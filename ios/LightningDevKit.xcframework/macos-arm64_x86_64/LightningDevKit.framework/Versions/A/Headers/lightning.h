#ifndef LDK_C_BINDINGS_H
#define LDK_C_BINDINGS_H

/* Generated with cbindgen:0.24.3 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include "ldk_rust_types.h"

/**
 * An error when accessing the chain via [`Access`].
 */
typedef enum LDKAccessError {
   /**
    * The requested chain is unknown.
    */
   LDKAccessError_UnknownChain,
   /**
    * The requested transaction doesn't exist or hasn't confirmed.
    */
   LDKAccessError_UnknownTx,
   /**
    * Must be last for serialization purposes
    */
   LDKAccessError_Sentinel,
} LDKAccessError;

/**
 * An enum which can either contain a  or not
 */
typedef enum LDKCOption_NoneZ {
   /**
    * When we're in this state, this COption_NoneZ contains a
    */
   LDKCOption_NoneZ_Some,
   /**
    * When we're in this state, this COption_NoneZ contains nothing
    */
   LDKCOption_NoneZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_NoneZ_Sentinel,
} LDKCOption_NoneZ;

/**
 * An enum representing the status of a channel monitor update persistence.
 */
typedef enum LDKChannelMonitorUpdateStatus {
   /**
    * The update has been durably persisted and all copies of the relevant [`ChannelMonitor`]
    * have been updated.
    *
    * This includes performing any `fsync()` calls required to ensure the update is guaranteed to
    * be available on restart even if the application crashes.
    */
   LDKChannelMonitorUpdateStatus_Completed,
   /**
    * Used to indicate a temporary failure (eg connection to a watchtower or remote backup of
    * our state failed, but is expected to succeed at some point in the future).
    *
    * Such a failure will \"freeze\" a channel, preventing us from revoking old states or
    * submitting new commitment transactions to the counterparty. Once the update(s) which failed
    * have been successfully applied, a [`MonitorEvent::Completed`] can be used to restore the
    * channel to an operational state.
    *
    * Note that a given [`ChannelManager`] will *never* re-generate a [`ChannelMonitorUpdate`].
    * If you return this error you must ensure that it is written to disk safely before writing
    * the latest [`ChannelManager`] state, or you should return [`PermanentFailure`] instead.
    *
    * Even when a channel has been \"frozen\", updates to the [`ChannelMonitor`] can continue to
    * occur (e.g. if an inbound HTLC which we forwarded was claimed upstream, resulting in us
    * attempting to claim it on this channel) and those updates must still be persisted.
    *
    * No updates to the channel will be made which could invalidate other [`ChannelMonitor`]s
    * until a [`MonitorEvent::Completed`] is provided, even if you return no error on a later
    * monitor update for the same channel.
    *
    * For deployments where a copy of ChannelMonitors and other local state are backed up in a
    * remote location (with local copies persisted immediately), it is anticipated that all
    * updates will return [`InProgress`] until the remote copies could be updated.
    *
    * [`PermanentFailure`]: ChannelMonitorUpdateStatus::PermanentFailure
    * [`InProgress`]: ChannelMonitorUpdateStatus::InProgress
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   LDKChannelMonitorUpdateStatus_InProgress,
   /**
    * Used to indicate no further channel monitor updates will be allowed (likely a disk failure
    * or a remote copy of this [`ChannelMonitor`] is no longer reachable and thus not updatable).
    *
    * When this is returned, [`ChannelManager`] will force-close the channel but *not* broadcast
    * our current commitment transaction. This avoids a dangerous case where a local disk failure
    * (e.g. the Linux-default remounting of the disk as read-only) causes [`PermanentFailure`]s
    * for all monitor updates. If we were to broadcast our latest commitment transaction and then
    * restart, we could end up reading a previous [`ChannelMonitor`] and [`ChannelManager`],
    * revoking our now-broadcasted state before seeing it confirm and losing all our funds.
    *
    * Note that this is somewhat of a tradeoff - if the disk is really gone and we may have lost
    * the data permanently, we really should broadcast immediately. If the data can be recovered
    * with manual intervention, we'd rather close the channel, rejecting future updates to it,
    * and broadcast the latest state only if we have HTLCs to claim which are timing out (which
    * we do as long as blocks are connected).
    *
    * In order to broadcast the latest local commitment transaction, you'll need to call
    * [`ChannelMonitor::get_latest_holder_commitment_txn`] and broadcast the resulting
    * transactions once you've safely ensured no further channel updates can be generated by your
    * [`ChannelManager`].
    *
    * Note that at least one final [`ChannelMonitorUpdate`] may still be provided, which must
    * still be processed by a running [`ChannelMonitor`]. This final update will mark the
    * [`ChannelMonitor`] as finalized, ensuring no further updates (e.g. revocation of the latest
    * commitment transaction) are allowed.
    *
    * Note that even if you return a [`PermanentFailure`] due to unavailability of secondary
    * [`ChannelMonitor`] copies, you should still make an attempt to store the update where
    * possible to ensure you can claim HTLC outputs on the latest commitment transaction
    * broadcasted later.
    *
    * In case of distributed watchtowers deployment, the new version must be written to disk, as
    * state may have been stored but rejected due to a block forcing a commitment broadcast. This
    * storage is used to claim outputs of rejected state confirmed onchain by another watchtower,
    * lagging behind on block processing.
    *
    * [`PermanentFailure`]: ChannelMonitorUpdateStatus::PermanentFailure
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   LDKChannelMonitorUpdateStatus_PermanentFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKChannelMonitorUpdateStatus_Sentinel,
} LDKChannelMonitorUpdateStatus;

/**
 * An enum that represents the speed at which we want a transaction to confirm used for feerate
 * estimation.
 */
typedef enum LDKConfirmationTarget {
   /**
    * We are happy with this transaction confirming slowly when feerate drops some.
    */
   LDKConfirmationTarget_Background,
   /**
    * We'd like this transaction to confirm without major delay, but 12-18 blocks is fine.
    */
   LDKConfirmationTarget_Normal,
   /**
    * We'd like this transaction to confirm in the next few blocks.
    */
   LDKConfirmationTarget_HighPriority,
   /**
    * Must be last for serialization purposes
    */
   LDKConfirmationTarget_Sentinel,
} LDKConfirmationTarget;

/**
 * Errors that may occur when constructing a new `RawInvoice` or `Invoice`
 */
typedef enum LDKCreationError {
   /**
    * The supplied description string was longer than 639 __bytes__ (see [`Description::new(â€¦)`](./struct.Description.html#method.new))
    */
   LDKCreationError_DescriptionTooLong,
   /**
    * The specified route has too many hops and can't be encoded
    */
   LDKCreationError_RouteTooLong,
   /**
    * The Unix timestamp of the supplied date is less than zero or greater than 35-bits
    */
   LDKCreationError_TimestampOutOfBounds,
   /**
    * The supplied millisatoshi amount was greater than the total bitcoin supply.
    */
   LDKCreationError_InvalidAmount,
   /**
    * Route hints were required for this invoice and were missing. Applies to
    * [phantom invoices].
    *
    * [phantom invoices]: crate::utils::create_phantom_invoice
    */
   LDKCreationError_MissingRouteHints,
   /**
    * Must be last for serialization purposes
    */
   LDKCreationError_Sentinel,
} LDKCreationError;

/**
 * Enum representing the crypto currencies (or networks) supported by this library
 */
typedef enum LDKCurrency {
   /**
    * Bitcoin mainnet
    */
   LDKCurrency_Bitcoin,
   /**
    * Bitcoin testnet
    */
   LDKCurrency_BitcoinTestnet,
   /**
    * Bitcoin regtest
    */
   LDKCurrency_Regtest,
   /**
    * Bitcoin simnet
    */
   LDKCurrency_Simnet,
   /**
    * Bitcoin signet
    */
   LDKCurrency_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKCurrency_Sentinel,
} LDKCurrency;

/**
 * Describes the type of HTLC claim as determined by analyzing the witness.
 */
typedef enum LDKHTLCClaim {
   /**
    * Claims an offered output on a commitment transaction through the timeout path.
    */
   LDKHTLCClaim_OfferedTimeout,
   /**
    * Claims an offered output on a commitment transaction through the success path.
    */
   LDKHTLCClaim_OfferedPreimage,
   /**
    * Claims an accepted output on a commitment transaction through the timeout path.
    */
   LDKHTLCClaim_AcceptedTimeout,
   /**
    * Claims an accepted output on a commitment transaction through the success path.
    */
   LDKHTLCClaim_AcceptedPreimage,
   /**
    * Claims an offered/accepted output on a commitment transaction through the revocation path.
    */
   LDKHTLCClaim_Revocation,
   /**
    * Must be last for serialization purposes
    */
   LDKHTLCClaim_Sentinel,
} LDKHTLCClaim;

/**
 * Represents an IO Error. Note that some information is lost in the conversion from Rust.
 */
typedef enum LDKIOError {
   LDKIOError_NotFound,
   LDKIOError_PermissionDenied,
   LDKIOError_ConnectionRefused,
   LDKIOError_ConnectionReset,
   LDKIOError_ConnectionAborted,
   LDKIOError_NotConnected,
   LDKIOError_AddrInUse,
   LDKIOError_AddrNotAvailable,
   LDKIOError_BrokenPipe,
   LDKIOError_AlreadyExists,
   LDKIOError_WouldBlock,
   LDKIOError_InvalidInput,
   LDKIOError_InvalidData,
   LDKIOError_TimedOut,
   LDKIOError_WriteZero,
   LDKIOError_Interrupted,
   LDKIOError_Other,
   LDKIOError_UnexpectedEof,
   /**
    * Must be last for serialization purposes
    */
   LDKIOError_Sentinel,
} LDKIOError;

/**
 * An enum representing the available verbosity levels of the logger.
 */
typedef enum LDKLevel {
   /**
    * Designates extremely verbose information, including gossip-induced messages
    */
   LDKLevel_Gossip,
   /**
    * Designates very low priority, often extremely verbose, information
    */
   LDKLevel_Trace,
   /**
    * Designates lower priority information
    */
   LDKLevel_Debug,
   /**
    * Designates useful information
    */
   LDKLevel_Info,
   /**
    * Designates hazardous situations
    */
   LDKLevel_Warn,
   /**
    * Designates very serious errors
    */
   LDKLevel_Error,
   /**
    * Must be last for serialization purposes
    */
   LDKLevel_Sentinel,
} LDKLevel;

/**
 * An enum representing the possible Bitcoin or test networks which we can run on
 */
typedef enum LDKNetwork {
   /**
    * The main Bitcoin blockchain.
    */
   LDKNetwork_Bitcoin,
   /**
    * The testnet3 blockchain.
    */
   LDKNetwork_Testnet,
   /**
    * A local test blockchain.
    */
   LDKNetwork_Regtest,
   /**
    * A blockchain on which blocks are signed instead of mined.
    */
   LDKNetwork_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKNetwork_Sentinel,
} LDKNetwork;

/**
 * Specifies the recipient of an invoice.
 *
 * This indicates to [`KeysInterface::sign_invoice`] what node secret key should be used to sign
 * the invoice.
 */
typedef enum LDKRecipient {
   /**
    * The invoice should be signed with the local node secret key.
    */
   LDKRecipient_Node,
   /**
    * The invoice should be signed with the phantom node secret key. This secret key must be the
    * same for all nodes participating in the [phantom node payment].
    *
    * [phantom node payment]: PhantomKeysManager
    */
   LDKRecipient_PhantomNode,
   /**
    * Must be last for serialization purposes
    */
   LDKRecipient_Sentinel,
} LDKRecipient;

/**
 * Represents an error returned from libsecp256k1 during validation of some secp256k1 data
 */
typedef enum LDKSecp256k1Error {
   /**
    * Signature failed verification
    */
   LDKSecp256k1Error_IncorrectSignature,
   /**
    * Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
    */
   LDKSecp256k1Error_InvalidMessage,
   /**
    * Bad public key
    */
   LDKSecp256k1Error_InvalidPublicKey,
   /**
    * Bad signature
    */
   LDKSecp256k1Error_InvalidSignature,
   /**
    * Bad secret key
    */
   LDKSecp256k1Error_InvalidSecretKey,
   /**
    * Bad shared secret.
    */
   LDKSecp256k1Error_InvalidSharedSecret,
   /**
    * Bad recovery id
    */
   LDKSecp256k1Error_InvalidRecoveryId,
   /**
    * Invalid tweak for add_assign or mul_assign
    */
   LDKSecp256k1Error_InvalidTweak,
   /**
    * Didn't pass enough memory to context creation with preallocated memory
    */
   LDKSecp256k1Error_NotEnoughMemory,
   /**
    * Bad set of public keys.
    */
   LDKSecp256k1Error_InvalidPublicKeySum,
   /**
    * The only valid parity values are 0 or 1.
    */
   LDKSecp256k1Error_InvalidParityValue,
   /**
    * Must be last for serialization purposes
    */
   LDKSecp256k1Error_Sentinel,
} LDKSecp256k1Error;

/**
 * Errors that may occur when converting a `RawInvoice` to an `Invoice`. They relate to the
 * requirements sections in BOLT #11
 */
typedef enum LDKSemanticError {
   /**
    * The invoice is missing the mandatory payment hash
    */
   LDKSemanticError_NoPaymentHash,
   /**
    * The invoice has multiple payment hashes which isn't allowed
    */
   LDKSemanticError_MultiplePaymentHashes,
   /**
    * No description or description hash are part of the invoice
    */
   LDKSemanticError_NoDescription,
   /**
    * The invoice contains multiple descriptions and/or description hashes which isn't allowed
    */
   LDKSemanticError_MultipleDescriptions,
   /**
    * The invoice is missing the mandatory payment secret, which all modern lightning nodes
    * should provide.
    */
   LDKSemanticError_NoPaymentSecret,
   /**
    * The invoice contains multiple payment secrets
    */
   LDKSemanticError_MultiplePaymentSecrets,
   /**
    * The invoice's features are invalid
    */
   LDKSemanticError_InvalidFeatures,
   /**
    * The recovery id doesn't fit the signature/pub key
    */
   LDKSemanticError_InvalidRecoveryId,
   /**
    * The invoice's signature is invalid
    */
   LDKSemanticError_InvalidSignature,
   /**
    * The invoice's amount was not a whole number of millisatoshis
    */
   LDKSemanticError_ImpreciseAmount,
   /**
    * Must be last for serialization purposes
    */
   LDKSemanticError_Sentinel,
} LDKSemanticError;

/**
 * SI prefixes for the human readable part
 */
typedef enum LDKSiPrefix {
   /**
    * 10^-3
    */
   LDKSiPrefix_Milli,
   /**
    * 10^-6
    */
   LDKSiPrefix_Micro,
   /**
    * 10^-9
    */
   LDKSiPrefix_Nano,
   /**
    * 10^-12
    */
   LDKSiPrefix_Pico,
   /**
    * Must be last for serialization purposes
    */
   LDKSiPrefix_Sentinel,
} LDKSiPrefix;

/**
 * A Rust str object, ie a reference to a UTF8-valid string.
 * This is *not* null-terminated so cannot be used directly as a C string!
 */
typedef struct LDKStr {
   /**
    * A pointer to the string's bytes, in UTF8 encoding
    */
   const uint8_t *chars;
   /**
    * The number of bytes (not characters!) pointed to by `chars`
    */
   uintptr_t len;
   /**
    * Whether the data pointed to by `chars` should be freed or not.
    */
   bool chars_is_owned;
} LDKStr;

/**
 * A 16-byte byte array.
 */
typedef struct LDKSixteenBytes {
   /**
    * The sixteen bytes
    */
   uint8_t data[16];
} LDKSixteenBytes;

/**
 * Unsigned, 128-bit integer.
 *
 * Because LLVM implements an incorrect ABI for 128-bit integers, a wrapper type is defined here.
 * See https://github.com/rust-lang/rust/issues/54341 for more details.
 */
typedef struct LDKU128 {
   /**
    * The 128-bit integer, as 16 little-endian bytes
    */
   uint8_t le_bytes[16];
} LDKU128;

/**
 * Represents a scalar value between zero and the secp256k1 curve order, in big endian.
 */
typedef struct LDKBigEndianScalar {
   /**
    * The bytes of the scalar value.
    */
   uint8_t big_endian_bytes[32];
} LDKBigEndianScalar;

/**
 * Arbitrary 32 bytes, which could represent one of a few different things. You probably want to
 * look up the corresponding function in rust-lightning's docs.
 */
typedef struct LDKThirtyTwoBytes {
   /**
    * The thirty-two bytes
    */
   uint8_t data[32];
} LDKThirtyTwoBytes;

/**
 * Represents an error returned from the bech32 library during validation of some bech32 data
 */
typedef enum LDKBech32Error_Tag {
   /**
    * String does not contain the separator character
    */
   LDKBech32Error_MissingSeparator,
   /**
    * The checksum does not match the rest of the data
    */
   LDKBech32Error_InvalidChecksum,
   /**
    * The data or human-readable part is too long or too short
    */
   LDKBech32Error_InvalidLength,
   /**
    * Some part of the string contains an invalid character
    */
   LDKBech32Error_InvalidChar,
   /**
    * Some part of the data has an invalid value
    */
   LDKBech32Error_InvalidData,
   /**
    * The bit conversion failed due to a padding issue
    */
   LDKBech32Error_InvalidPadding,
   /**
    * The whole string must be of one case
    */
   LDKBech32Error_MixedCase,
   /**
    * Must be last for serialization purposes
    */
   LDKBech32Error_Sentinel,
} LDKBech32Error_Tag;

typedef struct LDKBech32Error {
   LDKBech32Error_Tag tag;
   union {
      struct {
         uint32_t invalid_char;
      };
      struct {
         uint8_t invalid_data;
      };
   };
} LDKBech32Error;

/**
 * A serialized transaction, in (pointer, length) form.
 *
 * This type optionally owns its own memory, and thus the semantics around access change based on
 * the `data_is_owned` flag. If `data_is_owned` is set, you must call `Transaction_free` to free
 * the underlying buffer before the object goes out of scope. If `data_is_owned` is not set, any
 * access to the buffer after the scope in which the object was provided to you is invalid. eg,
 * access after you return from the call in which a `!data_is_owned` `Transaction` is provided to
 * you would be invalid.
 *
 * Note that, while it may change in the future, because transactions on the Rust side are stored
 * in a deserialized form, all `Transaction`s generated on the Rust side will have `data_is_owned`
 * set. Similarly, while it may change in the future, all `Transaction`s you pass to Rust may have
 * `data_is_owned` either set or unset at your discretion.
 */
typedef struct LDKTransaction {
   /**
    * The serialized transaction data.
    *
    * This is non-const for your convenience, an object passed to Rust is never written to.
    */
   uint8_t *data;
   /**
    * The length of the serialized transaction
    */
   uintptr_t datalen;
   /**
    * Whether the data pointed to by `data` should be freed or not.
    */
   bool data_is_owned;
} LDKTransaction;

/**
 * A serialized witness.
 */
typedef struct LDKWitness {
   /**
    * The serialized transaction data.
    *
    * This is non-const for your convenience, an object passed to Rust is never written to.
    */
   uint8_t *data;
   /**
    * The length of the serialized transaction
    */
   uintptr_t datalen;
   /**
    * Whether the data pointed to by `data` should be freed or not.
    */
   bool data_is_owned;
} LDKWitness;

/**
 * A dynamically-allocated array of u8s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u8Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   uint8_t *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u8Z;

/**
 * A transaction output including a scriptPubKey and value.
 * This type *does* own its own memory, so must be free'd appropriately.
 */
typedef struct LDKTxOut {
   /**
    * The script_pubkey in this output
    */
   struct LDKCVec_u8Z script_pubkey;
   /**
    * The value, in satoshis, of this output
    */
   uint64_t value;
} LDKTxOut;

/**
 * An enum which can either contain a crate::lightning::ln::chan_utils::HTLCClaim or not
 */
typedef enum LDKCOption_HTLCClaimZ_Tag {
   /**
    * When we're in this state, this COption_HTLCClaimZ contains a crate::lightning::ln::chan_utils::HTLCClaim
    */
   LDKCOption_HTLCClaimZ_Some,
   /**
    * When we're in this state, this COption_HTLCClaimZ contains nothing
    */
   LDKCOption_HTLCClaimZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_HTLCClaimZ_Sentinel,
} LDKCOption_HTLCClaimZ_Tag;

typedef struct LDKCOption_HTLCClaimZ {
   LDKCOption_HTLCClaimZ_Tag tag;
   union {
      struct {
         enum LDKHTLCClaim some;
      };
   };
} LDKCOption_HTLCClaimZ;

/**
 * The contents of CResult_NoneNoneZ
 */
typedef union LDKCResult_NoneNoneZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_NoneNoneZPtr;

/**
 * A CResult_NoneNoneZ represents the result of a fallible operation,
 * containing a () on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneNoneZ {
   /**
    * The contents of this CResult_NoneNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneNoneZPtr contents;
   /**
    * Whether this CResult_NoneNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneNoneZ;



/**
 * Implements the per-commitment secret storage scheme from
 * [BOLT 3](https://github.com/lightning/bolts/blob/dcbf8583976df087c79c3ce0b535311212e6812d/03-transactions.md#efficient-per-commitment-secret-storage).
 *
 * Allows us to keep track of all of the revocation secrets of our counterparty in just 50*32 bytes
 * or so.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyCommitmentSecrets {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyCommitmentSecrets *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyCommitmentSecrets;

/**
 * An error in decoding a message or struct.
 */
typedef enum LDKDecodeError_Tag {
   /**
    * A version byte specified something we don't know how to handle.
    * Includes unknown realm byte in an OnionHopData packet
    */
   LDKDecodeError_UnknownVersion,
   /**
    * Unknown feature mandating we fail to parse message (eg TLV with an even, unknown type)
    */
   LDKDecodeError_UnknownRequiredFeature,
   /**
    * Value was invalid, eg a byte which was supposed to be a bool was something other than a 0
    * or 1, a public key/private key/signature was invalid, text wasn't UTF-8, TLV was
    * syntactically incorrect, etc
    */
   LDKDecodeError_InvalidValue,
   /**
    * Buffer too short
    */
   LDKDecodeError_ShortRead,
   /**
    * A length descriptor in the packet didn't describe the later data correctly
    */
   LDKDecodeError_BadLengthDescriptor,
   /**
    * Error from std::io
    */
   LDKDecodeError_Io,
   /**
    * The message included zlib-compressed values, which we don't support.
    */
   LDKDecodeError_UnsupportedCompression,
   /**
    * Must be last for serialization purposes
    */
   LDKDecodeError_Sentinel,
} LDKDecodeError_Tag;

typedef struct MUST_USE_STRUCT LDKDecodeError {
   LDKDecodeError_Tag tag;
   union {
      struct {
         enum LDKIOError io;
      };
   };
} LDKDecodeError;

/**
 * The contents of CResult_CounterpartyCommitmentSecretsDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyCommitmentSecrets *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr;

/**
 * A CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyCommitmentSecretsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ;



/**
 * The set of public keys which are used in the creation of one commitment transaction.
 * These are derived from the channel base keys and per-commitment data.
 *
 * A broadcaster key is provided from potential broadcaster of the computed transaction.
 * A countersignatory key is coming from a protocol participant unable to broadcast the
 * transaction.
 *
 * These keys are assumed to be good, either because the code derived them from
 * channel basepoints via the new function, or they were obtained via
 * CommitmentTransaction.trust().keys() because we trusted the source of the
 * pre-calculated keys.
 */
typedef struct MUST_USE_STRUCT LDKTxCreationKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxCreationKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxCreationKeys;

/**
 * The contents of CResult_TxCreationKeysDecodeErrorZ
 */
typedef union LDKCResult_TxCreationKeysDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxCreationKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxCreationKeysDecodeErrorZPtr;

/**
 * A CResult_TxCreationKeysDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxCreationKeysDecodeErrorZ {
   /**
    * The contents of this CResult_TxCreationKeysDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxCreationKeysDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxCreationKeysDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxCreationKeysDecodeErrorZ;



/**
 * One counterparty's public keys which do not change over the life of a channel.
 */
typedef struct MUST_USE_STRUCT LDKChannelPublicKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelPublicKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelPublicKeys;

/**
 * The contents of CResult_ChannelPublicKeysDecodeErrorZ
 */
typedef union LDKCResult_ChannelPublicKeysDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelPublicKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelPublicKeysDecodeErrorZPtr;

/**
 * A CResult_ChannelPublicKeysDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::ChannelPublicKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelPublicKeysDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelPublicKeysDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelPublicKeysDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelPublicKeysDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelPublicKeysDecodeErrorZ;

/**
 * An enum which can either contain a u32 or not
 */
typedef enum LDKCOption_u32Z_Tag {
   /**
    * When we're in this state, this COption_u32Z contains a u32
    */
   LDKCOption_u32Z_Some,
   /**
    * When we're in this state, this COption_u32Z contains nothing
    */
   LDKCOption_u32Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u32Z_Sentinel,
} LDKCOption_u32Z_Tag;

typedef struct LDKCOption_u32Z {
   LDKCOption_u32Z_Tag tag;
   union {
      struct {
         uint32_t some;
      };
   };
} LDKCOption_u32Z;



/**
 * Information about an HTLC as it appears in a commitment transaction
 */
typedef struct MUST_USE_STRUCT LDKHTLCOutputInCommitment {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCOutputInCommitment *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCOutputInCommitment;

/**
 * The contents of CResult_HTLCOutputInCommitmentDecodeErrorZ
 */
typedef union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCOutputInCommitment *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr;

/**
 * A CResult_HTLCOutputInCommitmentDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::HTLCOutputInCommitment on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCOutputInCommitmentDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCOutputInCommitmentDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZ;



/**
 * Late-bound per-channel counterparty data used to build transactions.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyChannelTransactionParameters;

/**
 * The contents of CResult_CounterpartyChannelTransactionParametersDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyChannelTransactionParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr;

/**
 * A CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ;



/**
 * Per-channel data used to build transactions in conjunction with the per-commitment data (CommitmentTransaction).
 * The fields are organized by holder/counterparty.
 *
 * Normally, this is converted to the broadcaster/countersignatory-organized DirectedChannelTransactionParameters
 * before use, via the as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelTransactionParameters;

/**
 * The contents of CResult_ChannelTransactionParametersDecodeErrorZ
 */
typedef union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelTransactionParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelTransactionParametersDecodeErrorZPtr;

/**
 * A CResult_ChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::ChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelTransactionParametersDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelTransactionParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelTransactionParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelTransactionParametersDecodeErrorZ;

/**
 * Represents a secp256k1 signature serialized as two 32-byte numbers
 */
typedef struct LDKSignature {
   /**
    * The bytes of the signature in "compact" form
    */
   uint8_t compact_form[64];
} LDKSignature;

/**
 * A dynamically-allocated array of crate::c_types::Signatures of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_SignatureZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKSignature *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_SignatureZ;



/**
 * Information needed to build and sign a holder's commitment transaction.
 *
 * The transaction is only signed once we are ready to broadcast.
 */
typedef struct MUST_USE_STRUCT LDKHolderCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHolderCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHolderCommitmentTransaction;

/**
 * The contents of CResult_HolderCommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHolderCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_HolderCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::HolderCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_HolderCommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HolderCommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZ;



/**
 * A pre-built Bitcoin commitment transaction and its txid.
 */
typedef struct MUST_USE_STRUCT LDKBuiltCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBuiltCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBuiltCommitmentTransaction;

/**
 * The contents of CResult_BuiltCommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBuiltCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_BuiltCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::BuiltCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_BuiltCommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BuiltCommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZ;



/**
 * A wrapper on ClosingTransaction indicating that the built bitcoin
 * transaction is trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */
typedef struct MUST_USE_STRUCT LDKTrustedClosingTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTrustedClosingTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTrustedClosingTransaction;

/**
 * The contents of CResult_TrustedClosingTransactionNoneZ
 */
typedef union LDKCResult_TrustedClosingTransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTrustedClosingTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TrustedClosingTransactionNoneZPtr;

/**
 * A CResult_TrustedClosingTransactionNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TrustedClosingTransaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TrustedClosingTransactionNoneZ {
   /**
    * The contents of this CResult_TrustedClosingTransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TrustedClosingTransactionNoneZPtr contents;
   /**
    * Whether this CResult_TrustedClosingTransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TrustedClosingTransactionNoneZ;



/**
 * This class tracks the per-transaction information needed to build a commitment transaction and will
 * actually build it and sign.  It is used for holder transactions that we sign only when needed
 * and for transactions we sign for the counterparty.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentTransaction;

/**
 * The contents of CResult_CommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_CommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_CommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_CommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CommitmentTransactionDecodeErrorZ;



/**
 * A wrapper on CommitmentTransaction indicating that the derived fields (the built bitcoin
 * transaction and the transaction creation keys) are trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */
typedef struct MUST_USE_STRUCT LDKTrustedCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTrustedCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTrustedCommitmentTransaction;

/**
 * The contents of CResult_TrustedCommitmentTransactionNoneZ
 */
typedef union LDKCResult_TrustedCommitmentTransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTrustedCommitmentTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TrustedCommitmentTransactionNoneZPtr;

/**
 * A CResult_TrustedCommitmentTransactionNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TrustedCommitmentTransaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TrustedCommitmentTransactionNoneZ {
   /**
    * The contents of this CResult_TrustedCommitmentTransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TrustedCommitmentTransactionNoneZPtr contents;
   /**
    * Whether this CResult_TrustedCommitmentTransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TrustedCommitmentTransactionNoneZ;

/**
 * The contents of CResult_CVec_SignatureZNoneZ
 */
typedef union LDKCResult_CVec_SignatureZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_SignatureZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_SignatureZNoneZPtr;

/**
 * A CResult_CVec_SignatureZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_SignatureZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_SignatureZNoneZ {
   /**
    * The contents of this CResult_CVec_SignatureZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_SignatureZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_SignatureZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_SignatureZNoneZ;



/**
 * A script pubkey for shutting down a channel as defined by [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
 */
typedef struct MUST_USE_STRUCT LDKShutdownScript {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeShutdownScript *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKShutdownScript;

/**
 * The contents of CResult_ShutdownScriptDecodeErrorZ
 */
typedef union LDKCResult_ShutdownScriptDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdownScript *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ShutdownScriptDecodeErrorZPtr;

/**
 * A CResult_ShutdownScriptDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownScriptDecodeErrorZ {
   /**
    * The contents of this CResult_ShutdownScriptDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownScriptDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ShutdownScriptDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownScriptDecodeErrorZ;



/**
 * An error occurring when converting from [`Script`] to [`ShutdownScript`].
 */
typedef struct MUST_USE_STRUCT LDKInvalidShutdownScript {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvalidShutdownScript *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvalidShutdownScript;

/**
 * The contents of CResult_ShutdownScriptInvalidShutdownScriptZ
 */
typedef union LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdownScript *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKInvalidShutdownScript *err;
} LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr;

/**
 * A CResult_ShutdownScriptInvalidShutdownScriptZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::script::InvalidShutdownScript on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ {
   /**
    * The contents of this CResult_ShutdownScriptInvalidShutdownScriptZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr contents;
   /**
    * Whether this CResult_ShutdownScriptInvalidShutdownScriptZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownScriptInvalidShutdownScriptZ;

/**
 * Represents a valid secp256k1 public key serialized in "compressed form" as a 33 byte array.
 */
typedef struct LDKPublicKey {
   /**
    * The bytes of the public key
    */
   uint8_t compressed_form[33];
} LDKPublicKey;

/**
 * A dynamically-allocated array of crate::c_types::PublicKeys of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PublicKeyZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPublicKey *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PublicKeyZ;



/**
 * Onion messages can be sent and received to blinded paths, which serve to hide the identity of
 * the recipient.
 */
typedef struct MUST_USE_STRUCT LDKBlindedPath {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBlindedPath *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBlindedPath;

/**
 * The contents of CResult_BlindedPathNoneZ
 */
typedef union LDKCResult_BlindedPathNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedPath *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_BlindedPathNoneZPtr;

/**
 * A CResult_BlindedPathNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::onion_message::blinded_path::BlindedPath on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedPathNoneZ {
   /**
    * The contents of this CResult_BlindedPathNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedPathNoneZPtr contents;
   /**
    * Whether this CResult_BlindedPathNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedPathNoneZ;

/**
 * The contents of CResult_BlindedPathDecodeErrorZ
 */
typedef union LDKCResult_BlindedPathDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedPath *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BlindedPathDecodeErrorZPtr;

/**
 * A CResult_BlindedPathDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::onion_message::blinded_path::BlindedPath on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedPathDecodeErrorZ {
   /**
    * The contents of this CResult_BlindedPathDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedPathDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BlindedPathDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedPathDecodeErrorZ;



/**
 * Used to construct the blinded hops portion of a blinded path. These hops cannot be identified
 * by outside observers and thus can be used to hide the identity of the recipient.
 */
typedef struct MUST_USE_STRUCT LDKBlindedHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBlindedHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBlindedHop;

/**
 * The contents of CResult_BlindedHopDecodeErrorZ
 */
typedef union LDKCResult_BlindedHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BlindedHopDecodeErrorZPtr;

/**
 * A CResult_BlindedHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::onion_message::blinded_path::BlindedHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedHopDecodeErrorZ {
   /**
    * The contents of this CResult_BlindedHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BlindedHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedHopDecodeErrorZ;



/**
 * Represents the compressed public key of a node
 */
typedef struct MUST_USE_STRUCT LDKNodeId {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeId *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeId;



/**
 * Proposed use of a channel passed as a parameter to [`Score::channel_penalty_msat`].
 */
typedef struct MUST_USE_STRUCT LDKChannelUsage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUsage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUsage;



/**
 * A hop in a route
 */
typedef struct MUST_USE_STRUCT LDKRouteHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHop;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHops of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHopZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHop *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHopZ;

/**
 * An interface used to score payment channels for path finding.
 *
 *\tScoring is in terms of fees willing to be paid in order to avoid routing through a channel.
 */
typedef struct LDKScore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the fee in msats willing to be paid to avoid routing `send_amt_msat` through the
    * given channel in the direction from `source` to `target`.
    *
    * The channel's capacity (less any other MPP parts that are also being considered for use in
    * the same payment) is given by `capacity_msat`. It may be determined from various sources
    * such as a chain data, network gossip, or invoice hints. For invoice hints, a capacity near
    * [`u64::max_value`] is given to indicate sufficient capacity for the invoice's full amount.
    * Thus, implementations should be overflow-safe.
    */
   uint64_t (*channel_penalty_msat)(const void *this_arg, uint64_t short_channel_id, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target, struct LDKChannelUsage usage);
   /**
    * Handles updating channel penalties after failing to route through a channel.
    */
   void (*payment_path_failed)(void *this_arg, struct LDKCVec_RouteHopZ path, uint64_t short_channel_id);
   /**
    * Handles updating channel penalties after successfully routing along a path.
    */
   void (*payment_path_successful)(void *this_arg, struct LDKCVec_RouteHopZ path);
   /**
    * Handles updating channel penalties after a probe over the given path failed.
    */
   void (*probe_failed)(void *this_arg, struct LDKCVec_RouteHopZ path, uint64_t short_channel_id);
   /**
    * Handles updating channel penalties after a probe over the given path succeeded.
    */
   void (*probe_successful)(void *this_arg, struct LDKCVec_RouteHopZ path);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKScore;

/**
 * A scorer that is accessed under a lock.
 *
 * Needed so that calls to [`Score::channel_penalty_msat`] in [`find_route`] can be made while
 * having shared ownership of a scorer but without requiring internal locking in [`Score`]
 * implementations. Internal locking would be detrimental to route finding performance and could
 * result in [`Score::channel_penalty_msat`] returning a different value for the same channel.
 *
 * [`find_route`]: crate::routing::router::find_route
 */
typedef struct LDKLockableScore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the locked scorer.
    */
   struct LDKScore (*lock)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKLockableScore;

/**
 * Refers to a scorer that is accessible under lock and also writeable to disk
 *
 * We need this trait to be able to pass in a scorer to `lightning-background-processor` that will enable us to
 * use the Persister to persist it.
 */
typedef struct LDKWriteableScore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Implementation of LockableScore for this object.
    */
   struct LDKLockableScore LockableScore;
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWriteableScore;

/**
 * An enum which can either contain a crate::lightning::routing::scoring::WriteableScore or not
 */
typedef enum LDKCOption_WriteableScoreZ_Tag {
   /**
    * When we're in this state, this COption_WriteableScoreZ contains a crate::lightning::routing::scoring::WriteableScore
    */
   LDKCOption_WriteableScoreZ_Some,
   /**
    * When we're in this state, this COption_WriteableScoreZ contains nothing
    */
   LDKCOption_WriteableScoreZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_WriteableScoreZ_Sentinel,
} LDKCOption_WriteableScoreZ_Tag;

typedef struct LDKCOption_WriteableScoreZ {
   LDKCOption_WriteableScoreZ_Tag tag;
   union {
      struct {
         struct LDKWriteableScore some;
      };
   };
} LDKCOption_WriteableScoreZ;

/**
 * The contents of CResult_NoneErrorZ
 */
typedef union LDKCResult_NoneErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_NoneErrorZPtr;

/**
 * A CResult_NoneErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneErrorZ {
   /**
    * The contents of this CResult_NoneErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneErrorZPtr contents;
   /**
    * Whether this CResult_NoneErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneErrorZ;



/**
 * Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels
 */
typedef struct MUST_USE_STRUCT LDKChannelDetails {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelDetails *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelDetails;

/**
 * A dynamically-allocated array of crate::lightning::ln::channelmanager::ChannelDetailss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ChannelDetailsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKChannelDetails *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ChannelDetailsZ;



/**
 * A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,
 * it can take multiple paths. Each path is composed of one or more hops through the network.
 */
typedef struct MUST_USE_STRUCT LDKRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoute;



/**
 * An Err type for failure to process messages.
 */
typedef struct MUST_USE_STRUCT LDKLightningError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLightningError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLightningError;

/**
 * The contents of CResult_RouteLightningErrorZ
 */
typedef union LDKCResult_RouteLightningErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_RouteLightningErrorZPtr;

/**
 * A CResult_RouteLightningErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteLightningErrorZ {
   /**
    * The contents of this CResult_RouteLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteLightningErrorZPtr contents;
   /**
    * Whether this CResult_RouteLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteLightningErrorZ;

/**
 * An enum which can either contain a u64 or not
 */
typedef enum LDKCOption_u64Z_Tag {
   /**
    * When we're in this state, this COption_u64Z contains a u64
    */
   LDKCOption_u64Z_Some,
   /**
    * When we're in this state, this COption_u64Z contains nothing
    */
   LDKCOption_u64Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u64Z_Sentinel,
} LDKCOption_u64Z_Tag;

typedef struct LDKCOption_u64Z {
   LDKCOption_u64Z_Tag tag;
   union {
      struct {
         uint64_t some;
      };
   };
} LDKCOption_u64Z;



/**
 * A data structure for tracking in-flight HTLCs. May be used during pathfinding to account for
 * in-use channel liquidity.
 */
typedef struct MUST_USE_STRUCT LDKInFlightHtlcs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInFlightHtlcs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInFlightHtlcs;

/**
 * The contents of CResult_InFlightHtlcsDecodeErrorZ
 */
typedef union LDKCResult_InFlightHtlcsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInFlightHtlcs *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InFlightHtlcsDecodeErrorZPtr;

/**
 * A CResult_InFlightHtlcsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::InFlightHtlcs on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InFlightHtlcsDecodeErrorZ {
   /**
    * The contents of this CResult_InFlightHtlcsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InFlightHtlcsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InFlightHtlcsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InFlightHtlcsDecodeErrorZ;

/**
 * The contents of CResult_RouteHopDecodeErrorZ
 */
typedef union LDKCResult_RouteHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHopDecodeErrorZPtr;

/**
 * A CResult_RouteHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHopDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHopDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CVec_RouteHopZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CVec_RouteHopZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCVec_RouteHopZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CVec_RouteHopZZ;

/**
 * The contents of CResult_RouteDecodeErrorZ
 */
typedef union LDKCResult_RouteDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteDecodeErrorZPtr;

/**
 * A CResult_RouteDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteDecodeErrorZ {
   /**
    * The contents of this CResult_RouteDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteDecodeErrorZ;



/**
 * Parameters needed to find a [`Route`].
 *
 * Passed to [`find_route`] and [`build_route_from_hops`], but also provided in
 * [`Event::PaymentPathFailed`] for retrying a failed payment path.
 *
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 */
typedef struct MUST_USE_STRUCT LDKRouteParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteParameters;

/**
 * The contents of CResult_RouteParametersDecodeErrorZ
 */
typedef union LDKCResult_RouteParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteParametersDecodeErrorZPtr;

/**
 * A CResult_RouteParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteParametersDecodeErrorZ {
   /**
    * The contents of this CResult_RouteParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteParametersDecodeErrorZ;



/**
 * A list of hops along a payment path terminating with a channel to the recipient.
 */
typedef struct MUST_USE_STRUCT LDKRouteHint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHint;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHints of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHintZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHint *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHintZ;

/**
 * A dynamically-allocated array of u64s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u64Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   uint64_t *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u64Z;



/**
 * The recipient of a payment.
 */
typedef struct MUST_USE_STRUCT LDKPaymentParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePaymentParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPaymentParameters;

/**
 * The contents of CResult_PaymentParametersDecodeErrorZ
 */
typedef union LDKCResult_PaymentParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPaymentParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PaymentParametersDecodeErrorZPtr;

/**
 * A CResult_PaymentParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::PaymentParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentParametersDecodeErrorZ {
   /**
    * The contents of this CResult_PaymentParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PaymentParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentParametersDecodeErrorZ;



/**
 * A channel descriptor for a hop along a payment path.
 */
typedef struct MUST_USE_STRUCT LDKRouteHintHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHintHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHintHop;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHintHops of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHintHopZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHintHop *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHintHopZ;

/**
 * The contents of CResult_RouteHintDecodeErrorZ
 */
typedef union LDKCResult_RouteHintDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHint *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHintDecodeErrorZPtr;

/**
 * A CResult_RouteHintDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHint on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHintDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHintDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHintDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHintDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHintDecodeErrorZ;

/**
 * The contents of CResult_RouteHintHopDecodeErrorZ
 */
typedef union LDKCResult_RouteHintHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHintHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHintHopDecodeErrorZPtr;

/**
 * A CResult_RouteHintHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHintHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHintHopDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHintHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHintHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHintHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHintHopDecodeErrorZ;

/**
 * Some information provided on receipt of payment depends on whether the payment received is a
 * spontaneous payment or a \"conventional\" lightning payment that's paying an invoice.
 */
typedef enum LDKPaymentPurpose_Tag {
   /**
    * Information for receiving a payment that we generated an invoice for.
    */
   LDKPaymentPurpose_InvoicePayment,
   /**
    * Because this is a spontaneous payment, the payer generated their own preimage rather than us
    * (the payee) providing a preimage.
    */
   LDKPaymentPurpose_SpontaneousPayment,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentPurpose_Sentinel,
} LDKPaymentPurpose_Tag;

typedef struct LDKPaymentPurpose_LDKInvoicePayment_Body {
   /**
    * The preimage to the payment_hash, if the payment hash (and secret) were fetched via
    * [`ChannelManager::create_inbound_payment`]. If provided, this can be handed directly to
    * [`ChannelManager::claim_funds`].
    *
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes payment_preimage;
   /**
    * The \"payment secret\". This authenticates the sender to the recipient, preventing a
    * number of deanonymization attacks during the routing process.
    * It is provided here for your reference, however its accuracy is enforced directly by
    * [`ChannelManager`] using the values you previously provided to
    * [`ChannelManager::create_inbound_payment`] or
    * [`ChannelManager::create_inbound_payment_for_hash`].
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::create_inbound_payment_for_hash`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
    */
   struct LDKThirtyTwoBytes payment_secret;
} LDKPaymentPurpose_LDKInvoicePayment_Body;

typedef struct MUST_USE_STRUCT LDKPaymentPurpose {
   LDKPaymentPurpose_Tag tag;
   union {
      LDKPaymentPurpose_LDKInvoicePayment_Body invoice_payment;
      struct {
         struct LDKThirtyTwoBytes spontaneous_payment;
      };
   };
} LDKPaymentPurpose;

/**
 * The contents of CResult_PaymentPurposeDecodeErrorZ
 */
typedef union LDKCResult_PaymentPurposeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPaymentPurpose *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PaymentPurposeDecodeErrorZPtr;

/**
 * A CResult_PaymentPurposeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::events::PaymentPurpose on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentPurposeDecodeErrorZ {
   /**
    * The contents of this CResult_PaymentPurposeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentPurposeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PaymentPurposeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentPurposeDecodeErrorZ;

/**
 * The reason the channel was closed. See individual variants more details.
 */
typedef enum LDKClosureReason_Tag {
   /**
    * Closure generated from receiving a peer error message.
    *
    * Our counterparty may have broadcasted their latest commitment state, and we have
    * as well.
    */
   LDKClosureReason_CounterpartyForceClosed,
   /**
    * Closure generated from [`ChannelManager::force_close_channel`], called by the user.
    *
    * [`ChannelManager::force_close_channel`]: crate::ln::channelmanager::ChannelManager::force_close_channel.
    */
   LDKClosureReason_HolderForceClosed,
   /**
    * The channel was closed after negotiating a cooperative close and we've now broadcasted
    * the cooperative close transaction. Note the shutdown may have been initiated by us.
    */
   LDKClosureReason_CooperativeClosure,
   /**
    * A commitment transaction was confirmed on chain, closing the channel. Most likely this
    * commitment transaction came from our counterparty, but it may also have come from
    * a copy of our own `ChannelMonitor`.
    */
   LDKClosureReason_CommitmentTxConfirmed,
   /**
    * The funding transaction failed to confirm in a timely manner on an inbound channel.
    */
   LDKClosureReason_FundingTimedOut,
   /**
    * Closure generated from processing an event, likely a HTLC forward/relay/reception.
    */
   LDKClosureReason_ProcessingError,
   /**
    * The peer disconnected prior to funding completing. In this case the spec mandates that we
    * forget the channel entirely - we can attempt again if the peer reconnects.
    *
    * This includes cases where we restarted prior to funding completion, including prior to the
    * initial [`ChannelMonitor`] persistence completing.
    *
    * In LDK versions prior to 0.0.107 this could also occur if we were unable to connect to the
    * peer because of mutual incompatibility between us and our channel counterparty.
    *
    * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    */
   LDKClosureReason_DisconnectedPeer,
   /**
    * Closure generated from `ChannelManager::read` if the [`ChannelMonitor`] is newer than
    * the [`ChannelManager`] deserialized.
    *
    * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   LDKClosureReason_OutdatedChannelManager,
   /**
    * Must be last for serialization purposes
    */
   LDKClosureReason_Sentinel,
} LDKClosureReason_Tag;

typedef struct LDKClosureReason_LDKCounterpartyForceClosed_Body {
   /**
    * The error which the peer sent us.
    *
    * The string should be sanitized before it is used (e.g emitted to logs
    * or printed to stdout). Otherwise, a well crafted error message may exploit
    * a security vulnerability in the terminal emulator or the logging subsystem.
    */
   struct LDKStr peer_msg;
} LDKClosureReason_LDKCounterpartyForceClosed_Body;

typedef struct LDKClosureReason_LDKProcessingError_Body {
   /**
    * A developer-readable error message which we generated.
    */
   struct LDKStr err;
} LDKClosureReason_LDKProcessingError_Body;

typedef struct MUST_USE_STRUCT LDKClosureReason {
   LDKClosureReason_Tag tag;
   union {
      LDKClosureReason_LDKCounterpartyForceClosed_Body counterparty_force_closed;
      LDKClosureReason_LDKProcessingError_Body processing_error;
   };
} LDKClosureReason;

/**
 * An enum which can either contain a crate::lightning::util::events::ClosureReason or not
 */
typedef enum LDKCOption_ClosureReasonZ_Tag {
   /**
    * When we're in this state, this COption_ClosureReasonZ contains a crate::lightning::util::events::ClosureReason
    */
   LDKCOption_ClosureReasonZ_Some,
   /**
    * When we're in this state, this COption_ClosureReasonZ contains nothing
    */
   LDKCOption_ClosureReasonZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_ClosureReasonZ_Sentinel,
} LDKCOption_ClosureReasonZ_Tag;

typedef struct LDKCOption_ClosureReasonZ {
   LDKCOption_ClosureReasonZ_Tag tag;
   union {
      struct {
         struct LDKClosureReason some;
      };
   };
} LDKCOption_ClosureReasonZ;

/**
 * The contents of CResult_COption_ClosureReasonZDecodeErrorZ
 */
typedef union LDKCResult_COption_ClosureReasonZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_ClosureReasonZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_ClosureReasonZDecodeErrorZPtr;

/**
 * A CResult_COption_ClosureReasonZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_ClosureReasonZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_ClosureReasonZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_ClosureReasonZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_ClosureReasonZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_ClosureReasonZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_ClosureReasonZDecodeErrorZ;

/**
 * Intended destination of a failed HTLC as indicated in [`Event::HTLCHandlingFailed`].
 */
typedef enum LDKHTLCDestination_Tag {
   /**
    * We tried forwarding to a channel but failed to do so. An example of such an instance is when
    * there is insufficient capacity in our outbound channel.
    */
   LDKHTLCDestination_NextHopChannel,
   /**
    * Scenario where we are unsure of the next node to forward the HTLC to.
    */
   LDKHTLCDestination_UnknownNextHop,
   /**
    * We couldn't forward to the outgoing scid. An example would be attempting to send a duplicate
    * intercept HTLC.
    */
   LDKHTLCDestination_InvalidForward,
   /**
    * Failure scenario where an HTLC may have been forwarded to be intended for us,
    * but is invalid for some reason, so we reject it.
    *
    * Some of the reasons may include:
    * * HTLC Timeouts
    * * Expected MPP amount to claim does not equal HTLC total
    * * Claimable amount does not match expected amount
    */
   LDKHTLCDestination_FailedPayment,
   /**
    * Must be last for serialization purposes
    */
   LDKHTLCDestination_Sentinel,
} LDKHTLCDestination_Tag;

typedef struct LDKHTLCDestination_LDKNextHopChannel_Body {
   /**
    * The `node_id` of the next node. For backwards compatibility, this field is
    * marked as optional, versions prior to 0.0.110 may not always be able to provide
    * counterparty node information.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKPublicKey node_id;
   /**
    * The outgoing `channel_id` between us and the next node.
    */
   struct LDKThirtyTwoBytes channel_id;
} LDKHTLCDestination_LDKNextHopChannel_Body;

typedef struct LDKHTLCDestination_LDKUnknownNextHop_Body {
   /**
    * Short channel id we are requesting to forward an HTLC to.
    */
   uint64_t requested_forward_scid;
} LDKHTLCDestination_LDKUnknownNextHop_Body;

typedef struct LDKHTLCDestination_LDKInvalidForward_Body {
   /**
    * Short channel id we are requesting to forward an HTLC to.
    */
   uint64_t requested_forward_scid;
} LDKHTLCDestination_LDKInvalidForward_Body;

typedef struct LDKHTLCDestination_LDKFailedPayment_Body {
   /**
    * The payment hash of the payment we attempted to process.
    */
   struct LDKThirtyTwoBytes payment_hash;
} LDKHTLCDestination_LDKFailedPayment_Body;

typedef struct MUST_USE_STRUCT LDKHTLCDestination {
   LDKHTLCDestination_Tag tag;
   union {
      LDKHTLCDestination_LDKNextHopChannel_Body next_hop_channel;
      LDKHTLCDestination_LDKUnknownNextHop_Body unknown_next_hop;
      LDKHTLCDestination_LDKInvalidForward_Body invalid_forward;
      LDKHTLCDestination_LDKFailedPayment_Body failed_payment;
   };
} LDKHTLCDestination;

/**
 * An enum which can either contain a crate::lightning::util::events::HTLCDestination or not
 */
typedef enum LDKCOption_HTLCDestinationZ_Tag {
   /**
    * When we're in this state, this COption_HTLCDestinationZ contains a crate::lightning::util::events::HTLCDestination
    */
   LDKCOption_HTLCDestinationZ_Some,
   /**
    * When we're in this state, this COption_HTLCDestinationZ contains nothing
    */
   LDKCOption_HTLCDestinationZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_HTLCDestinationZ_Sentinel,
} LDKCOption_HTLCDestinationZ_Tag;

typedef struct LDKCOption_HTLCDestinationZ {
   LDKCOption_HTLCDestinationZ_Tag tag;
   union {
      struct {
         struct LDKHTLCDestination some;
      };
   };
} LDKCOption_HTLCDestinationZ;

/**
 * The contents of CResult_COption_HTLCDestinationZDecodeErrorZ
 */
typedef union LDKCResult_COption_HTLCDestinationZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_HTLCDestinationZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_HTLCDestinationZDecodeErrorZPtr;

/**
 * A CResult_COption_HTLCDestinationZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_HTLCDestinationZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_HTLCDestinationZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_HTLCDestinationZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_HTLCDestinationZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_HTLCDestinationZDecodeErrorZ;

/**
 * An enum which can either contain a crate::c_types::U128 or not
 */
typedef enum LDKCOption_u128Z_Tag {
   /**
    * When we're in this state, this COption_u128Z contains a crate::c_types::U128
    */
   LDKCOption_u128Z_Some,
   /**
    * When we're in this state, this COption_u128Z contains nothing
    */
   LDKCOption_u128Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u128Z_Sentinel,
} LDKCOption_u128Z_Tag;

typedef struct LDKCOption_u128Z {
   LDKCOption_u128Z_Tag tag;
   union {
      struct {
         struct LDKU128 some;
      };
   };
} LDKCOption_u128Z;



/**
 * A channel_update message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUpdate;

/**
 * Update to the [`NetworkGraph`] based on payment failure information conveyed via the Onion
 * return packet by a node along the route. See [BOLT #4] for details.
 *
 * [BOLT #4]: https://github.com/lightning/bolts/blob/master/04-onion-routing.md
 */
typedef enum LDKNetworkUpdate_Tag {
   /**
    * An error indicating a `channel_update` messages should be applied via
    * [`NetworkGraph::update_channel`].
    */
   LDKNetworkUpdate_ChannelUpdateMessage,
   /**
    * An error indicating that a channel failed to route a payment, which should be applied via
    * [`NetworkGraph::channel_failed`].
    */
   LDKNetworkUpdate_ChannelFailure,
   /**
    * An error indicating that a node failed to route a payment, which should be applied via
    * [`NetworkGraph::node_failed_permanent`] if permanent.
    */
   LDKNetworkUpdate_NodeFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKNetworkUpdate_Sentinel,
} LDKNetworkUpdate_Tag;

typedef struct LDKNetworkUpdate_LDKChannelUpdateMessage_Body {
   /**
    * The update to apply via [`NetworkGraph::update_channel`].
    */
   struct LDKChannelUpdate msg;
} LDKNetworkUpdate_LDKChannelUpdateMessage_Body;

typedef struct LDKNetworkUpdate_LDKChannelFailure_Body {
   /**
    * The short channel id of the closed channel.
    */
   uint64_t short_channel_id;
   /**
    * Whether the channel should be permanently removed or temporarily disabled until a new
    * `channel_update` message is received.
    */
   bool is_permanent;
} LDKNetworkUpdate_LDKChannelFailure_Body;

typedef struct LDKNetworkUpdate_LDKNodeFailure_Body {
   /**
    * The node id of the failed node.
    */
   struct LDKPublicKey node_id;
   /**
    * Whether the node should be permanently removed from consideration or can be restored
    * when a new `channel_update` message is received.
    */
   bool is_permanent;
} LDKNetworkUpdate_LDKNodeFailure_Body;

typedef struct MUST_USE_STRUCT LDKNetworkUpdate {
   LDKNetworkUpdate_Tag tag;
   union {
      LDKNetworkUpdate_LDKChannelUpdateMessage_Body channel_update_message;
      LDKNetworkUpdate_LDKChannelFailure_Body channel_failure;
      LDKNetworkUpdate_LDKNodeFailure_Body node_failure;
   };
} LDKNetworkUpdate;

/**
 * An enum which can either contain a crate::lightning::routing::gossip::NetworkUpdate or not
 */
typedef enum LDKCOption_NetworkUpdateZ_Tag {
   /**
    * When we're in this state, this COption_NetworkUpdateZ contains a crate::lightning::routing::gossip::NetworkUpdate
    */
   LDKCOption_NetworkUpdateZ_Some,
   /**
    * When we're in this state, this COption_NetworkUpdateZ contains nothing
    */
   LDKCOption_NetworkUpdateZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_NetworkUpdateZ_Sentinel,
} LDKCOption_NetworkUpdateZ_Tag;

typedef struct LDKCOption_NetworkUpdateZ {
   LDKCOption_NetworkUpdateZ_Tag tag;
   union {
      struct {
         struct LDKNetworkUpdate some;
      };
   };
} LDKCOption_NetworkUpdateZ;



/**
 * A reference to a transaction output.
 *
 * Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32
 * due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way.
 */
typedef struct MUST_USE_STRUCT LDKOutPoint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOutPoint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOutPoint;



/**
 * Information about a spendable output to a P2WSH script.
 *
 * See [`SpendableOutputDescriptor::DelayedPaymentOutput`] for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKDelayedPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDelayedPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDelayedPaymentOutputDescriptor;



/**
 * Information about a spendable output to our \"payment key\".
 *
 * See [`SpendableOutputDescriptor::StaticPaymentOutput`] for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKStaticPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeStaticPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKStaticPaymentOutputDescriptor;

/**
 * Describes the necessary information to spend a spendable output.
 *
 * When on-chain outputs are created by LDK (which our counterparty is not able to claim at any
 * point in the future) a [`SpendableOutputs`] event is generated which you must track and be able
 * to spend on-chain. The information needed to do this is provided in this enum, including the
 * outpoint describing which `txid` and output `index` is available, the full output which exists
 * at that `txid`/`index`, and any keys or other information required to sign.
 *
 * [`SpendableOutputs`]: crate::util::events::Event::SpendableOutputs
 */
typedef enum LDKSpendableOutputDescriptor_Tag {
   /**
    * An output to a script which was provided via [`KeysInterface`] directly, either from
    * [`get_destination_script`] or [`get_shutdown_scriptpubkey`], thus you should already
    * know how to spend it. No secret keys are provided as LDK was never given any key.
    * These may include outputs from a transaction punishing our counterparty or claiming an HTLC
    * on-chain using the payment preimage or after it has timed out.
    *
    * [`get_shutdown_scriptpubkey`]: KeysInterface::get_shutdown_scriptpubkey
    * [`get_destination_script`]: KeysInterface::get_shutdown_scriptpubkey
    */
   LDKSpendableOutputDescriptor_StaticOutput,
   /**
    * An output to a P2WSH script which can be spent with a single signature after an `OP_CSV`
    * delay.
    *
    * The witness in the spending input should be:
    * ```bitcoin
    * <BIP 143 signature> <empty vector> (MINIMALIF standard rule) <provided witnessScript>
    * ```
    *
    * Note that the `nSequence` field in the spending input must be set to
    * [`DelayedPaymentOutputDescriptor::to_self_delay`] (which means the transaction is not
    * broadcastable until at least [`DelayedPaymentOutputDescriptor::to_self_delay`] blocks after
    * the outpoint confirms, see [BIP
    * 68](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki)). Also note that LDK
    * won't generate a [`SpendableOutputDescriptor`] until the corresponding block height
    * is reached.
    *
    * These are generally the result of a \"revocable\" output to us, spendable only by us unless
    * it is an output from an old state which we broadcast (which should never happen).
    *
    * To derive the delayed payment key which is used to sign this input, you must pass the
    * holder [`InMemorySigner::delayed_payment_base_key`] (i.e., the private key which corresponds to the
    * [`ChannelPublicKeys::delayed_payment_basepoint`] in [`BaseSign::pubkeys`]) and the provided
    * [`DelayedPaymentOutputDescriptor::per_commitment_point`] to [`chan_utils::derive_private_key`]. The public key can be
    * generated without the secret key using [`chan_utils::derive_public_key`] and only the
    * [`ChannelPublicKeys::delayed_payment_basepoint`] which appears in [`BaseSign::pubkeys`].
    *
    * To derive the [`DelayedPaymentOutputDescriptor::revocation_pubkey`] provided here (which is
    * used in the witness script generation), you must pass the counterparty
    * [`ChannelPublicKeys::revocation_basepoint`] (which appears in the call to
    * [`BaseSign::provide_channel_parameters`]) and the provided
    * [`DelayedPaymentOutputDescriptor::per_commitment_point`] to
    * [`chan_utils::derive_public_revocation_key`].
    *
    * The witness script which is hashed and included in the output `script_pubkey` may be
    * regenerated by passing the [`DelayedPaymentOutputDescriptor::revocation_pubkey`] (derived
    * as explained above), our delayed payment pubkey (derived as explained above), and the
    * [`DelayedPaymentOutputDescriptor::to_self_delay`] contained here to
    * [`chan_utils::get_revokeable_redeemscript`].
    */
   LDKSpendableOutputDescriptor_DelayedPaymentOutput,
   /**
    * An output to a P2WPKH, spendable exclusively by our payment key (i.e., the private key
    * which corresponds to the `payment_point` in [`BaseSign::pubkeys`]). The witness
    * in the spending input is, thus, simply:
    * ```bitcoin
    * <BIP 143 signature> <payment key>
    * ```
    *
    * These are generally the result of our counterparty having broadcast the current state,
    * allowing us to claim the non-HTLC-encumbered outputs immediately.
    */
   LDKSpendableOutputDescriptor_StaticPaymentOutput,
   /**
    * Must be last for serialization purposes
    */
   LDKSpendableOutputDescriptor_Sentinel,
} LDKSpendableOutputDescriptor_Tag;

typedef struct LDKSpendableOutputDescriptor_LDKStaticOutput_Body {
   /**
    * The outpoint which is spendable.
    */
   struct LDKOutPoint outpoint;
   /**
    * The output which is referenced by the given outpoint.
    */
   struct LDKTxOut output;
} LDKSpendableOutputDescriptor_LDKStaticOutput_Body;

typedef struct MUST_USE_STRUCT LDKSpendableOutputDescriptor {
   LDKSpendableOutputDescriptor_Tag tag;
   union {
      LDKSpendableOutputDescriptor_LDKStaticOutput_Body static_output;
      struct {
         struct LDKDelayedPaymentOutputDescriptor delayed_payment_output;
      };
      struct {
         struct LDKStaticPaymentOutputDescriptor static_payment_output;
      };
   };
} LDKSpendableOutputDescriptor;

/**
 * A dynamically-allocated array of crate::lightning::chain::keysinterface::SpendableOutputDescriptors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_SpendableOutputDescriptorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKSpendableOutputDescriptor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_SpendableOutputDescriptorZ;



/**
 * Features used within the channel_type field in an OpenChannel message.
 *
 * A channel is always of some known \"type\", describing the transaction formats used and the exact
 * semantics of our interaction with our peer.
 *
 * Note that because a channel is a specific type which is proposed by the opener and accepted by
 * the counterparty, only required features are allowed here.
 *
 * This is serialized differently from other feature types - it is not prefixed by a length, and
 * thus must only appear inside a TLV where its length is known in advance.
 */
typedef struct MUST_USE_STRUCT LDKChannelTypeFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelTypeFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelTypeFeatures;

/**
 * An Event which you should probably take some action in response to.
 *
 * Note that while Writeable and Readable are implemented for Event, you probably shouldn't use
 * them directly as they don't round-trip exactly (for example FundingGenerationReady is never
 * written as it makes no sense to respond to it after reconnecting to peers).
 */
typedef enum LDKEvent_Tag {
   /**
    * Used to indicate that the client should generate a funding transaction with the given
    * parameters and then call [`ChannelManager::funding_transaction_generated`].
    * Generated in [`ChannelManager`] message handling.
    * Note that *all inputs* in the funding transaction must spend SegWit outputs or your
    * counterparty can steal your funds!
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
    */
   LDKEvent_FundingGenerationReady,
   /**
    * Indicates that we've been offered a payment and it needs to be claimed via calling
    * [`ChannelManager::claim_funds`] with the preimage given in [`PaymentPurpose`].
    *
    * Note that if the preimage is not known, you should call
    * [`ChannelManager::fail_htlc_backwards`] to free up resources for this HTLC and avoid
    * network congestion.
    * If you fail to call either [`ChannelManager::claim_funds`] or
    * [`ChannelManager::fail_htlc_backwards`] within the HTLC's timeout, the HTLC will be
    * automatically failed.
    *
    * # Note
    * LDK will not stop an inbound payment from being paid multiple times, so multiple
    * `PaymentClaimable` events may be generated for the same payment.
    *
    * # Note
    * This event used to be called `PaymentReceived` in LDK versions 0.0.112 and earlier.
    *
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    * [`ChannelManager::fail_htlc_backwards`]: crate::ln::channelmanager::ChannelManager::fail_htlc_backwards
    */
   LDKEvent_PaymentClaimable,
   /**
    * Indicates a payment has been claimed and we've received money!
    *
    * This most likely occurs when [`ChannelManager::claim_funds`] has been called in response
    * to an [`Event::PaymentClaimable`]. However, if we previously crashed during a
    * [`ChannelManager::claim_funds`] call you may see this event without a corresponding
    * [`Event::PaymentClaimable`] event.
    *
    * # Note
    * LDK will not stop an inbound payment from being paid multiple times, so multiple
    * `PaymentClaimable` events may be generated for the same payment. If you then call
    * [`ChannelManager::claim_funds`] twice for the same [`Event::PaymentClaimable`] you may get
    * multiple `PaymentClaimed` events.
    *
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    */
   LDKEvent_PaymentClaimed,
   /**
    * Indicates an outbound payment we made succeeded (i.e. it made it all the way to its target
    * and we got back the payment preimage for it).
    *
    * Note for MPP payments: in rare cases, this event may be preceded by a `PaymentPathFailed`
    * event. In this situation, you SHOULD treat this payment as having succeeded.
    */
   LDKEvent_PaymentSent,
   /**
    * Indicates an outbound payment failed. Individual [`Event::PaymentPathFailed`] events
    * provide failure information for each MPP part in the payment.
    *
    * This event is provided once there are no further pending HTLCs for the payment and the
    * payment is no longer retryable due to [`ChannelManager::abandon_payment`] having been
    * called for the corresponding payment.
    *
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   LDKEvent_PaymentFailed,
   /**
    * Indicates that a path for an outbound payment was successful.
    *
    * Always generated after [`Event::PaymentSent`] and thus useful for scoring channels. See
    * [`Event::PaymentSent`] for obtaining the payment preimage.
    */
   LDKEvent_PaymentPathSuccessful,
   /**
    * Indicates an outbound HTLC we sent failed. Probably some intermediary node dropped
    * something. You may wish to retry with a different route.
    *
    * If you have given up retrying this payment and wish to fail it, you MUST call
    * [`ChannelManager::abandon_payment`] at least once for a given [`PaymentId`] or memory
    * related to payment tracking will leak.
    *
    * Note that this does *not* indicate that all paths for an MPP payment have failed, see
    * [`Event::PaymentFailed`] and [`all_paths_failed`].
    *
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    * [`all_paths_failed`]: Self::PaymentPathFailed::all_paths_failed
    */
   LDKEvent_PaymentPathFailed,
   /**
    * Indicates that a probe payment we sent returned successful, i.e., only failed at the destination.
    */
   LDKEvent_ProbeSuccessful,
   /**
    * Indicates that a probe payment we sent failed at an intermediary node on the path.
    */
   LDKEvent_ProbeFailed,
   /**
    * Used to indicate that [`ChannelManager::process_pending_htlc_forwards`] should be called at
    * a time in the future.
    *
    * [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
    */
   LDKEvent_PendingHTLCsForwardable,
   /**
    * Used to indicate that we've intercepted an HTLC forward. This event will only be generated if
    * you've encoded an intercept scid in the receiver's invoice route hints using
    * [`ChannelManager::get_intercept_scid`] and have set [`UserConfig::accept_intercept_htlcs`].
    *
    * [`ChannelManager::forward_intercepted_htlc`] or
    * [`ChannelManager::fail_intercepted_htlc`] MUST be called in response to this event. See
    * their docs for more information.
    *
    * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
    * [`UserConfig::accept_intercept_htlcs`]: crate::util::config::UserConfig::accept_intercept_htlcs
    * [`ChannelManager::forward_intercepted_htlc`]: crate::ln::channelmanager::ChannelManager::forward_intercepted_htlc
    * [`ChannelManager::fail_intercepted_htlc`]: crate::ln::channelmanager::ChannelManager::fail_intercepted_htlc
    */
   LDKEvent_HTLCIntercepted,
   /**
    * Used to indicate that an output which you should know how to spend was confirmed on chain
    * and is now spendable.
    * Such an output will *not* ever be spent by rust-lightning, and are not at risk of your
    * counterparty spending them due to some kind of timeout. Thus, you need to store them
    * somewhere and spend them when you create on-chain transactions.
    */
   LDKEvent_SpendableOutputs,
   /**
    * This event is generated when a payment has been successfully forwarded through us and a
    * forwarding fee earned.
    */
   LDKEvent_PaymentForwarded,
   /**
    * Used to indicate that a channel with the given `channel_id` is ready to
    * be used. This event is emitted either when the funding transaction has been confirmed
    * on-chain, or, in case of a 0conf channel, when both parties have confirmed the channel
    * establishment.
    */
   LDKEvent_ChannelReady,
   /**
    * Used to indicate that a previously opened channel with the given `channel_id` is in the
    * process of closure.
    */
   LDKEvent_ChannelClosed,
   /**
    * Used to indicate to the user that they can abandon the funding transaction and recycle the
    * inputs for another purpose.
    */
   LDKEvent_DiscardFunding,
   /**
    * Indicates a request to open a new channel by a peer.
    *
    * To accept the request, call [`ChannelManager::accept_inbound_channel`]. To reject the
    * request, call [`ChannelManager::force_close_without_broadcasting_txn`].
    *
    * The event is only triggered when a new open channel request is received and the
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   LDKEvent_OpenChannelRequest,
   /**
    * Indicates that the HTLC was accepted, but could not be processed when or after attempting to
    * forward it.
    *
    * Some scenarios where this event may be sent include:
    * * Insufficient capacity in the outbound channel
    * * While waiting to forward the HTLC, the channel it is meant to be forwarded through closes
    * * When an unknown SCID is requested for forwarding a payment.
    * * Claiming an amount for an MPP payment that exceeds the HTLC total
    * * The HTLC has timed out
    *
    * This event, however, does not get generated if an HTLC fails to meet the forwarding
    * requirements (i.e. insufficient fees paid, or a CLTV that is too soon).
    */
   LDKEvent_HTLCHandlingFailed,
   /**
    * Must be last for serialization purposes
    */
   LDKEvent_Sentinel,
} LDKEvent_Tag;

typedef struct LDKEvent_LDKFundingGenerationReady_Body {
   /**
    * The random channel_id we picked which you'll need to pass into
    * [`ChannelManager::funding_transaction_generated`].
    *
    * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
    */
   struct LDKThirtyTwoBytes temporary_channel_id;
   /**
    * The counterparty's node_id, which you'll need to pass back into
    * [`ChannelManager::funding_transaction_generated`].
    *
    * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * The value, in satoshis, that the output should have.
    */
   uint64_t channel_value_satoshis;
   /**
    * The script which should be used in the transaction output.
    */
   struct LDKCVec_u8Z output_script;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`], or a
    * random value for an inbound channel. This may be zero for objects serialized with LDK
    * versions prior to 0.0.113.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    */
   struct LDKU128 user_channel_id;
} LDKEvent_LDKFundingGenerationReady_Body;

typedef struct LDKEvent_LDKPaymentClaimable_Body {
   /**
    * The node that will receive the payment after it has been claimed.
    * This is useful to identify payments received via [phantom nodes].
    * This field will always be filled in when the event was generated by LDK versions
    * 0.0.113 and above.
    *
    * [phantom nodes]: crate::chain::keysinterface::PhantomKeysManager
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKPublicKey receiver_node_id;
   /**
    * The hash for which the preimage should be handed to the ChannelManager. Note that LDK will
    * not stop you from registering duplicate payment hashes for inbound payments.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The value, in thousandths of a satoshi, that this payment is for.
    */
   uint64_t amount_msat;
   /**
    * Information for claiming this received payment, based on whether the purpose of the
    * payment is to pay an invoice or to send a spontaneous payment.
    */
   struct LDKPaymentPurpose purpose;
   /**
    * The `channel_id` indicating over which channel we received the payment.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes via_channel_id;
   /**
    * The `user_channel_id` indicating over which channel we received the payment.
    */
   struct LDKCOption_u128Z via_user_channel_id;
} LDKEvent_LDKPaymentClaimable_Body;

typedef struct LDKEvent_LDKPaymentClaimed_Body {
   /**
    * The node that received the payment.
    * This is useful to identify payments which were received via [phantom nodes].
    * This field will always be filled in when the event was generated by LDK versions
    * 0.0.113 and above.
    *
    * [phantom nodes]: crate::chain::keysinterface::PhantomKeysManager
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKPublicKey receiver_node_id;
   /**
    * The payment hash of the claimed payment. Note that LDK will not stop you from
    * registering duplicate payment hashes for inbound payments.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The value, in thousandths of a satoshi, that this payment is for.
    */
   uint64_t amount_msat;
   /**
    * The purpose of the claimed payment, i.e. whether the payment was for an invoice or a
    * spontaneous payment.
    */
   struct LDKPaymentPurpose purpose;
} LDKEvent_LDKPaymentClaimed_Body;

typedef struct LDKEvent_LDKPaymentSent_Body {
   /**
    * The id returned by [`ChannelManager::send_payment`] and used with
    * [`ChannelManager::retry_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The preimage to the hash given to ChannelManager::send_payment.
    * Note that this serves as a payment receipt, if you wish to have such a thing, you must
    * store it somehow!
    */
   struct LDKThirtyTwoBytes payment_preimage;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The total fee which was spent at intermediate hops in this payment, across all paths.
    *
    * Note that, like [`Route::get_total_fees`] this does *not* include any potential
    * overpayment to the recipient node.
    *
    * If the recipient or an intermediate node misbehaves and gives us free money, this may
    * overstate the amount paid, though this is unlikely.
    *
    * [`Route::get_total_fees`]: crate::routing::router::Route::get_total_fees
    */
   struct LDKCOption_u64Z fee_paid_msat;
} LDKEvent_LDKPaymentSent_Body;

typedef struct LDKEvent_LDKPaymentFailed_Body {
   /**
    * The id returned by [`ChannelManager::send_payment`] and used with
    * [`ChannelManager::retry_payment`] and [`ChannelManager::abandon_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
} LDKEvent_LDKPaymentFailed_Body;

typedef struct LDKEvent_LDKPaymentPathSuccessful_Body {
   /**
    * The id returned by [`ChannelManager::send_payment`] and used with
    * [`ChannelManager::retry_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The payment path that was successful.
    *
    * May contain a closed channel if the HTLC sent along the path was fulfilled on chain.
    */
   struct LDKCVec_RouteHopZ path;
} LDKEvent_LDKPaymentPathSuccessful_Body;

typedef struct LDKEvent_LDKPaymentPathFailed_Body {
   /**
    * The id returned by [`ChannelManager::send_payment`] and used with
    * [`ChannelManager::retry_payment`] and [`ChannelManager::abandon_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * Indicates the payment was rejected for some reason by the recipient. This implies that
    * the payment has failed, not just the route in question. If this is not set, you may
    * retry the payment via a different route.
    */
   bool payment_failed_permanently;
   /**
    * Any failure information conveyed via the Onion return packet by a node along the failed
    * payment route.
    *
    * Should be applied to the [`NetworkGraph`] so that routing decisions can take into
    * account the update.
    *
    * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
    */
   struct LDKCOption_NetworkUpdateZ network_update;
   /**
    * For both single-path and multi-path payments, this is set if all paths of the payment have
    * failed. This will be set to false if (1) this is an MPP payment and (2) other parts of the
    * larger MPP payment were still in flight when this event was generated.
    *
    * Note that if you are retrying individual MPP parts, using this value to determine if a
    * payment has fully failed is race-y. Because multiple failures can happen prior to events
    * being processed, you may retry in response to a first failure, with a second failure
    * (with `all_paths_failed` set) still pending. Then, when the second failure is processed
    * you will see `all_paths_failed` set even though the retry of the first failure still
    * has an associated in-flight HTLC. See (1) for an example of such a failure.
    *
    * If you wish to retry individual MPP parts and learn when a payment has failed, you must
    * call [`ChannelManager::abandon_payment`] and wait for a [`Event::PaymentFailed`] event.
    *
    * (1) <https://github.com/lightningdevkit/rust-lightning/issues/1164>
    *
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   bool all_paths_failed;
   /**
    * The payment path that failed.
    */
   struct LDKCVec_RouteHopZ path;
   /**
    * The channel responsible for the failed payment path.
    *
    * Note that for route hints or for the first hop in a path this may be an SCID alias and
    * may not refer to a channel in the public network graph. These aliases may also collide
    * with channels in the public network graph.
    *
    * If this is `Some`, then the corresponding channel should be avoided when the payment is
    * retried. May be `None` for older [`Event`] serializations.
    */
   struct LDKCOption_u64Z short_channel_id;
   /**
    * Parameters needed to compute a new [`Route`] when retrying the failed payment path.
    *
    * See [`find_route`] for details.
    *
    * [`Route`]: crate::routing::router::Route
    * [`find_route`]: crate::routing::router::find_route
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKRouteParameters retry;
} LDKEvent_LDKPaymentPathFailed_Body;

typedef struct LDKEvent_LDKProbeSuccessful_Body {
   /**
    * The id returned by [`ChannelManager::send_probe`].
    *
    * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash generated by [`ChannelManager::send_probe`].
    *
    * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The payment path that was successful.
    */
   struct LDKCVec_RouteHopZ path;
} LDKEvent_LDKProbeSuccessful_Body;

typedef struct LDKEvent_LDKProbeFailed_Body {
   /**
    * The id returned by [`ChannelManager::send_probe`].
    *
    * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash generated by [`ChannelManager::send_probe`].
    *
    * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The payment path that failed.
    */
   struct LDKCVec_RouteHopZ path;
   /**
    * The channel responsible for the failed probe.
    *
    * Note that for route hints or for the first hop in a path this may be an SCID alias and
    * may not refer to a channel in the public network graph. These aliases may also collide
    * with channels in the public network graph.
    */
   struct LDKCOption_u64Z short_channel_id;
} LDKEvent_LDKProbeFailed_Body;

typedef struct LDKEvent_LDKPendingHTLCsForwardable_Body {
   /**
    * The minimum amount of time that should be waited prior to calling
    * process_pending_htlc_forwards. To increase the effort required to correlate payments,
    * you should wait a random amount of time in roughly the range (now + time_forwardable,
    * now + 5*time_forwardable).
    */
   uint64_t time_forwardable;
} LDKEvent_LDKPendingHTLCsForwardable_Body;

typedef struct LDKEvent_LDKHTLCIntercepted_Body {
   /**
    * An id to help LDK identify which HTLC is being forwarded or failed.
    */
   struct LDKThirtyTwoBytes intercept_id;
   /**
    * The fake scid that was programmed as the next hop's scid, generated using
    * [`ChannelManager::get_intercept_scid`].
    *
    * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
    */
   uint64_t requested_next_hop_scid;
   /**
    * The payment hash used for this HTLC.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * How many msats were received on the inbound edge of this HTLC.
    */
   uint64_t inbound_amount_msat;
   /**
    * How many msats the payer intended to route to the next node. Depending on the reason you are
    * intercepting this payment, you might take a fee by forwarding less than this amount.
    *
    * Note that LDK will NOT check that expected fees were factored into this value. You MUST
    * check that whatever fee you want has been included here or subtract it as required. Further,
    * LDK will not stop you from forwarding more than you received.
    */
   uint64_t expected_outbound_amount_msat;
} LDKEvent_LDKHTLCIntercepted_Body;

typedef struct LDKEvent_LDKSpendableOutputs_Body {
   /**
    * The outputs which you should store as spendable by you.
    */
   struct LDKCVec_SpendableOutputDescriptorZ outputs;
} LDKEvent_LDKSpendableOutputs_Body;

typedef struct LDKEvent_LDKPaymentForwarded_Body {
   /**
    * The incoming channel between the previous node and us. This is only `None` for events
    * generated or serialized by versions prior to 0.0.107.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes prev_channel_id;
   /**
    * The outgoing channel between the next node and us. This is only `None` for events
    * generated or serialized by versions prior to 0.0.107.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes next_channel_id;
   /**
    * The fee, in milli-satoshis, which was earned as a result of the payment.
    *
    * Note that if we force-closed the channel over which we forwarded an HTLC while the HTLC
    * was pending, the amount the next hop claimed will have been rounded down to the nearest
    * whole satoshi. Thus, the fee calculated here may be higher than expected as we still
    * claimed the full value in millisatoshis from the source. In this case,
    * `claim_from_onchain_tx` will be set.
    *
    * If the channel which sent us the payment has been force-closed, we will claim the funds
    * via an on-chain transaction. In that case we do not yet know the on-chain transaction
    * fees which we will spend and will instead set this to `None`. It is possible duplicate
    * `PaymentForwarded` events are generated for the same payment iff `fee_earned_msat` is
    * `None`.
    */
   struct LDKCOption_u64Z fee_earned_msat;
   /**
    * If this is `true`, the forwarded HTLC was claimed by our counterparty via an on-chain
    * transaction.
    */
   bool claim_from_onchain_tx;
} LDKEvent_LDKPaymentForwarded_Body;

typedef struct LDKEvent_LDKChannelReady_Body {
   /**
    * The channel_id of the channel that is ready.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
    * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
    * `user_channel_id` will be randomized for an inbound channel.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   struct LDKU128 user_channel_id;
   /**
    * The node_id of the channel counterparty.
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * The features that this channel will operate with.
    */
   struct LDKChannelTypeFeatures channel_type;
} LDKEvent_LDKChannelReady_Body;

typedef struct LDKEvent_LDKChannelClosed_Body {
   /**
    * The channel_id of the channel which has been closed. Note that on-chain transactions
    * resolving the channel are likely still awaiting confirmation.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
    * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
    * `user_channel_id` will be randomized for inbound channels.
    * This may be zero for inbound channels serialized prior to 0.0.113 and will always be
    * zero for objects serialized with LDK versions prior to 0.0.102.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   struct LDKU128 user_channel_id;
   /**
    * The reason the channel was closed.
    */
   struct LDKClosureReason reason;
} LDKEvent_LDKChannelClosed_Body;

typedef struct LDKEvent_LDKDiscardFunding_Body {
   /**
    * The channel_id of the channel which has been closed.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The full transaction received from the user
    */
   struct LDKTransaction transaction;
} LDKEvent_LDKDiscardFunding_Body;

typedef struct LDKEvent_LDKOpenChannelRequest_Body {
   /**
    * The temporary channel ID of the channel requested to be opened.
    *
    * When responding to the request, the `temporary_channel_id` should be passed
    * back to the ChannelManager through [`ChannelManager::accept_inbound_channel`] to accept,
    * or through [`ChannelManager::force_close_without_broadcasting_txn`] to reject.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
    */
   struct LDKThirtyTwoBytes temporary_channel_id;
   /**
    * The node_id of the counterparty requesting to open the channel.
    *
    * When responding to the request, the `counterparty_node_id` should be passed
    * back to the `ChannelManager` through [`ChannelManager::accept_inbound_channel`] to
    * accept the request, or through [`ChannelManager::force_close_without_broadcasting_txn`] to reject the
    * request.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * The channel value of the requested channel.
    */
   uint64_t funding_satoshis;
   /**
    * Our starting balance in the channel if the request is accepted, in milli-satoshi.
    */
   uint64_t push_msat;
   /**
    * The features that this channel will operate with. If you reject the channel, a
    * well-behaved counterparty may automatically re-attempt the channel with a new set of
    * feature flags.
    *
    * Note that if [`ChannelTypeFeatures::supports_scid_privacy`] returns true on this type,
    * the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
    * 0.0.106.
    *
    * Furthermore, note that if [`ChannelTypeFeatures::supports_zero_conf`] returns true on this type,
    * the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
    * 0.0.107. Channels setting this type also need to get manually accepted via
    * [`crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`],
    * or will be rejected otherwise.
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   struct LDKChannelTypeFeatures channel_type;
} LDKEvent_LDKOpenChannelRequest_Body;

typedef struct LDKEvent_LDKHTLCHandlingFailed_Body {
   /**
    * The channel over which the HTLC was received.
    */
   struct LDKThirtyTwoBytes prev_channel_id;
   /**
    * Destination of the HTLC that failed to be processed.
    */
   struct LDKHTLCDestination failed_next_destination;
} LDKEvent_LDKHTLCHandlingFailed_Body;

typedef struct MUST_USE_STRUCT LDKEvent {
   LDKEvent_Tag tag;
   union {
      LDKEvent_LDKFundingGenerationReady_Body funding_generation_ready;
      LDKEvent_LDKPaymentClaimable_Body payment_claimable;
      LDKEvent_LDKPaymentClaimed_Body payment_claimed;
      LDKEvent_LDKPaymentSent_Body payment_sent;
      LDKEvent_LDKPaymentFailed_Body payment_failed;
      LDKEvent_LDKPaymentPathSuccessful_Body payment_path_successful;
      LDKEvent_LDKPaymentPathFailed_Body payment_path_failed;
      LDKEvent_LDKProbeSuccessful_Body probe_successful;
      LDKEvent_LDKProbeFailed_Body probe_failed;
      LDKEvent_LDKPendingHTLCsForwardable_Body pending_htl_cs_forwardable;
      LDKEvent_LDKHTLCIntercepted_Body htlc_intercepted;
      LDKEvent_LDKSpendableOutputs_Body spendable_outputs;
      LDKEvent_LDKPaymentForwarded_Body payment_forwarded;
      LDKEvent_LDKChannelReady_Body channel_ready;
      LDKEvent_LDKChannelClosed_Body channel_closed;
      LDKEvent_LDKDiscardFunding_Body discard_funding;
      LDKEvent_LDKOpenChannelRequest_Body open_channel_request;
      LDKEvent_LDKHTLCHandlingFailed_Body htlc_handling_failed;
   };
} LDKEvent;

/**
 * An enum which can either contain a crate::lightning::util::events::Event or not
 */
typedef enum LDKCOption_EventZ_Tag {
   /**
    * When we're in this state, this COption_EventZ contains a crate::lightning::util::events::Event
    */
   LDKCOption_EventZ_Some,
   /**
    * When we're in this state, this COption_EventZ contains nothing
    */
   LDKCOption_EventZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_EventZ_Sentinel,
} LDKCOption_EventZ_Tag;

typedef struct LDKCOption_EventZ {
   LDKCOption_EventZ_Tag tag;
   union {
      struct {
         struct LDKEvent some;
      };
   };
} LDKCOption_EventZ;

/**
 * The contents of CResult_COption_EventZDecodeErrorZ
 */
typedef union LDKCResult_COption_EventZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_EventZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_EventZDecodeErrorZPtr;

/**
 * A CResult_COption_EventZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_EventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_EventZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_EventZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_EventZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_EventZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_EventZDecodeErrorZ;



/**
 * An accept_channel message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKAcceptChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAcceptChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAcceptChannel;



/**
 * An open_channel message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKOpenChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOpenChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOpenChannel;



/**
 * A funding_created message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingCreated {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingCreated *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingCreated;



/**
 * A funding_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingSigned;



/**
 * A channel_ready message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelReady {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelReady *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelReady;



/**
 * An announcement_signatures message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKAnnouncementSignatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAnnouncementSignatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAnnouncementSignatures;



/**
 * Struct used to return values from revoke_and_ack messages, containing a bunch of commitment
 * transaction updates if they were pending.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentUpdate;



/**
 * A revoke_and_ack message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKRevokeAndACK {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRevokeAndACK *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRevokeAndACK;



/**
 * A closing_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKClosingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingSigned;



/**
 * A shutdown message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKShutdown {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeShutdown *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKShutdown;



/**
 * A channel_reestablish message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelReestablish {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelReestablish *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelReestablish;



/**
 * A channel_announcement message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelAnnouncement;



/**
 * An error message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKErrorMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErrorMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErrorMessage;



/**
 * A warning message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKWarningMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeWarningMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKWarningMessage;

/**
 * Used to put an error message in a LightningError
 */
typedef enum LDKErrorAction_Tag {
   /**
    * The peer took some action which made us think they were useless. Disconnect them.
    */
   LDKErrorAction_DisconnectPeer,
   /**
    * The peer did something harmless that we weren't able to process, just log and ignore
    */
   LDKErrorAction_IgnoreError,
   /**
    * The peer did something harmless that we weren't able to meaningfully process.
    * If the error is logged, log it at the given level.
    */
   LDKErrorAction_IgnoreAndLog,
   /**
    * The peer provided us with a gossip message which we'd already seen. In most cases this
    * should be ignored, but it may result in the message being forwarded if it is a duplicate of
    * our own channel announcements.
    */
   LDKErrorAction_IgnoreDuplicateGossip,
   /**
    * The peer did something incorrect. Tell them.
    */
   LDKErrorAction_SendErrorMessage,
   /**
    * The peer did something incorrect. Tell them without closing any channels.
    */
   LDKErrorAction_SendWarningMessage,
   /**
    * Must be last for serialization purposes
    */
   LDKErrorAction_Sentinel,
} LDKErrorAction_Tag;

typedef struct LDKErrorAction_LDKDisconnectPeer_Body {
   /**
    * An error message which we should make an effort to send before we disconnect.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKDisconnectPeer_Body;

typedef struct LDKErrorAction_LDKSendErrorMessage_Body {
   /**
    * The message to send.
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKSendErrorMessage_Body;

typedef struct LDKErrorAction_LDKSendWarningMessage_Body {
   /**
    * The message to send.
    */
   struct LDKWarningMessage msg;
   /**
    * The peer may have done something harmless that we weren't able to meaningfully process,
    * though we should still tell them about it.
    * If this event is logged, log it at the given level.
    */
   enum LDKLevel log_level;
} LDKErrorAction_LDKSendWarningMessage_Body;

typedef struct MUST_USE_STRUCT LDKErrorAction {
   LDKErrorAction_Tag tag;
   union {
      LDKErrorAction_LDKDisconnectPeer_Body disconnect_peer;
      struct {
         enum LDKLevel ignore_and_log;
      };
      LDKErrorAction_LDKSendErrorMessage_Body send_error_message;
      LDKErrorAction_LDKSendWarningMessage_Body send_warning_message;
   };
} LDKErrorAction;



/**
 * A query_channel_range message is used to query a peer for channel
 * UTXOs in a range of blocks. The recipient of a query makes a best
 * effort to reply to the query using one or more reply_channel_range
 * messages.
 */
typedef struct MUST_USE_STRUCT LDKQueryChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryChannelRange;



/**
 * A query_short_channel_ids message is used to query a peer for
 * routing gossip messages related to one or more short_channel_ids.
 * The query recipient will reply with the latest, if available,
 * channel_announcement, channel_update and node_announcement messages
 * it maintains for the requested short_channel_ids followed by a
 * reply_short_channel_ids_end message. The short_channel_ids sent in
 * this query are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */
typedef struct MUST_USE_STRUCT LDKQueryShortChannelIds {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryShortChannelIds *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryShortChannelIds;



/**
 * A reply_channel_range message is a reply to a query_channel_range
 * message. Multiple reply_channel_range messages can be sent in reply
 * to a single query_channel_range message. The query recipient makes a
 * best effort to respond based on their local network view which may
 * not be a perfect view of the network. The short_channel_ids in the
 * reply are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */
typedef struct MUST_USE_STRUCT LDKReplyChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyChannelRange;



/**
 * A gossip_timestamp_filter message is used by a node to request
 * gossip relay for messages in the requested time range when the
 * gossip_queries feature has been negotiated.
 */
typedef struct MUST_USE_STRUCT LDKGossipTimestampFilter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeGossipTimestampFilter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKGossipTimestampFilter;

/**
 * An event generated by ChannelManager which indicates a message should be sent to a peer (or
 * broadcast to most peers).
 * These events are handled by PeerManager::process_events if you are using a PeerManager.
 */
typedef enum LDKMessageSendEvent_Tag {
   /**
    * Used to indicate that we've accepted a channel open and should send the accept_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendAcceptChannel,
   /**
    * Used to indicate that we've initiated a channel open and should send the open_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendOpenChannel,
   /**
    * Used to indicate that a funding_created message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingCreated,
   /**
    * Used to indicate that a funding_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingSigned,
   /**
    * Used to indicate that a channel_ready message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendChannelReady,
   /**
    * Used to indicate that an announcement_signatures message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendAnnouncementSignatures,
   /**
    * Used to indicate that a series of HTLC update messages, as well as a commitment_signed
    * message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_UpdateHTLCs,
   /**
    * Used to indicate that a revoke_and_ack message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendRevokeAndACK,
   /**
    * Used to indicate that a closing_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendClosingSigned,
   /**
    * Used to indicate that a shutdown message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendShutdown,
   /**
    * Used to indicate that a channel_reestablish message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendChannelReestablish,
   /**
    * Used to send a channel_announcement and channel_update to a specific peer, likely on
    * initial connection to ensure our peers know about our channels.
    */
   LDKMessageSendEvent_SendChannelAnnouncement,
   /**
    * Used to indicate that a channel_announcement and channel_update should be broadcast to all
    * peers (except the peer with node_id either msg.contents.node_id_1 or msg.contents.node_id_2).
    *
    * Note that after doing so, you very likely (unless you did so very recently) want to
    * broadcast a node_announcement (e.g. via [`PeerManager::broadcast_node_announcement`]). This
    * ensures that any nodes which see our channel_announcement also have a relevant
    * node_announcement, including relevant feature flags which may be important for routing
    * through or to us.
    *
    * [`PeerManager::broadcast_node_announcement`]: crate::ln::peer_handler::PeerManager::broadcast_node_announcement
    */
   LDKMessageSendEvent_BroadcastChannelAnnouncement,
   /**
    * Used to indicate that a channel_update should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastChannelUpdate,
   /**
    * Used to indicate that a channel_update should be sent to a single peer.
    * In contrast to [`Self::BroadcastChannelUpdate`], this is used when the channel is a
    * private channel and we shouldn't be informing all of our peers of channel parameters.
    */
   LDKMessageSendEvent_SendChannelUpdate,
   /**
    * Broadcast an error downstream to be handled
    */
   LDKMessageSendEvent_HandleError,
   /**
    * Query a peer for channels with funding transaction UTXOs in a block range.
    */
   LDKMessageSendEvent_SendChannelRangeQuery,
   /**
    * Request routing gossip messages from a peer for a list of channels identified by
    * their short_channel_ids.
    */
   LDKMessageSendEvent_SendShortIdsQuery,
   /**
    * Sends a reply to a channel range query. This may be one of several SendReplyChannelRange events
    * emitted during processing of the query.
    */
   LDKMessageSendEvent_SendReplyChannelRange,
   /**
    * Sends a timestamp filter for inbound gossip. This should be sent on each new connection to
    * enable receiving gossip messages from the peer.
    */
   LDKMessageSendEvent_SendGossipTimestampFilter,
   /**
    * Must be last for serialization purposes
    */
   LDKMessageSendEvent_Sentinel,
} LDKMessageSendEvent_Tag;

typedef struct LDKMessageSendEvent_LDKSendAcceptChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKAcceptChannel msg;
} LDKMessageSendEvent_LDKSendAcceptChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendOpenChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKOpenChannel msg;
} LDKMessageSendEvent_LDKSendOpenChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingCreated_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingCreated msg;
} LDKMessageSendEvent_LDKSendFundingCreated_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingSigned msg;
} LDKMessageSendEvent_LDKSendFundingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelReady_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The channel_ready message which should be sent.
    */
   struct LDKChannelReady msg;
} LDKMessageSendEvent_LDKSendChannelReady_Body;

typedef struct LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The announcement_signatures message which should be sent.
    */
   struct LDKAnnouncementSignatures msg;
} LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body;

typedef struct LDKMessageSendEvent_LDKUpdateHTLCs_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The update messages which should be sent. ALL messages in the struct should be sent!
    */
   struct LDKCommitmentUpdate updates;
} LDKMessageSendEvent_LDKUpdateHTLCs_Body;

typedef struct LDKMessageSendEvent_LDKSendRevokeAndACK_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKRevokeAndACK msg;
} LDKMessageSendEvent_LDKSendRevokeAndACK_Body;

typedef struct LDKMessageSendEvent_LDKSendClosingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKClosingSigned msg;
} LDKMessageSendEvent_LDKSendClosingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendShutdown_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKShutdown msg;
} LDKMessageSendEvent_LDKSendShutdown_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelReestablish_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKChannelReestablish msg;
} LDKMessageSendEvent_LDKSendChannelReestablish_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelAnnouncement_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The channel_announcement which should be sent.
    */
   struct LDKChannelAnnouncement msg;
   /**
    * The followup channel_update which should be sent.
    */
   struct LDKChannelUpdate update_msg;
} LDKMessageSendEvent_LDKSendChannelAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body {
   /**
    * The channel_announcement which should be sent.
    */
   struct LDKChannelAnnouncement msg;
   /**
    * The followup channel_update which should be sent.
    */
   struct LDKChannelUpdate update_msg;
} LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body {
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelUpdate_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKSendChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKHandleError_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The action which should be taken.
    */
   struct LDKErrorAction action;
} LDKMessageSendEvent_LDKHandleError_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelRangeQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_channel_range which should be sent.
    */
   struct LDKQueryChannelRange msg;
} LDKMessageSendEvent_LDKSendChannelRangeQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendShortIdsQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_short_channel_ids which should be sent.
    */
   struct LDKQueryShortChannelIds msg;
} LDKMessageSendEvent_LDKSendShortIdsQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendReplyChannelRange_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The reply_channel_range which should be sent.
    */
   struct LDKReplyChannelRange msg;
} LDKMessageSendEvent_LDKSendReplyChannelRange_Body;

typedef struct LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The gossip_timestamp_filter which should be sent.
    */
   struct LDKGossipTimestampFilter msg;
} LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body;

typedef struct MUST_USE_STRUCT LDKMessageSendEvent {
   LDKMessageSendEvent_Tag tag;
   union {
      LDKMessageSendEvent_LDKSendAcceptChannel_Body send_accept_channel;
      LDKMessageSendEvent_LDKSendOpenChannel_Body send_open_channel;
      LDKMessageSendEvent_LDKSendFundingCreated_Body send_funding_created;
      LDKMessageSendEvent_LDKSendFundingSigned_Body send_funding_signed;
      LDKMessageSendEvent_LDKSendChannelReady_Body send_channel_ready;
      LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body send_announcement_signatures;
      LDKMessageSendEvent_LDKUpdateHTLCs_Body update_htl_cs;
      LDKMessageSendEvent_LDKSendRevokeAndACK_Body send_revoke_and_ack;
      LDKMessageSendEvent_LDKSendClosingSigned_Body send_closing_signed;
      LDKMessageSendEvent_LDKSendShutdown_Body send_shutdown;
      LDKMessageSendEvent_LDKSendChannelReestablish_Body send_channel_reestablish;
      LDKMessageSendEvent_LDKSendChannelAnnouncement_Body send_channel_announcement;
      LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body broadcast_channel_announcement;
      LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body broadcast_channel_update;
      LDKMessageSendEvent_LDKSendChannelUpdate_Body send_channel_update;
      LDKMessageSendEvent_LDKHandleError_Body handle_error;
      LDKMessageSendEvent_LDKSendChannelRangeQuery_Body send_channel_range_query;
      LDKMessageSendEvent_LDKSendShortIdsQuery_Body send_short_ids_query;
      LDKMessageSendEvent_LDKSendReplyChannelRange_Body send_reply_channel_range;
      LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body send_gossip_timestamp_filter;
   };
} LDKMessageSendEvent;

/**
 * A dynamically-allocated array of crate::lightning::util::events::MessageSendEvents of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MessageSendEventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMessageSendEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MessageSendEventZ;

/**
 * The contents of CResult_TxOutAccessErrorZ
 */
typedef union LDKCResult_TxOutAccessErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxOut *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKAccessError *err;
} LDKCResult_TxOutAccessErrorZPtr;

/**
 * A CResult_TxOutAccessErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::TxOut on success and a crate::lightning::chain::AccessError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxOutAccessErrorZ {
   /**
    * The contents of this CResult_TxOutAccessErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxOutAccessErrorZPtr contents;
   /**
    * Whether this CResult_TxOutAccessErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxOutAccessErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_usizeTransactionZ {
   /**
    * The element at position 0
    */
   uintptr_t a;
   /**
    * The element at position 1
    */
   struct LDKTransaction b;
} LDKC2Tuple_usizeTransactionZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_usizeTransactionZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_usizeTransactionZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_usizeTransactionZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_usizeTransactionZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_TxidBlockHashZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
} LDKC2Tuple_TxidBlockHashZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidBlockHashZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_TxidBlockHashZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_TxidBlockHashZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_TxidBlockHashZZ;



/**
 * Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
 * chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
 * preimage claim backward will lead to loss of funds.
 */
typedef struct MUST_USE_STRUCT LDKHTLCUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCUpdate;

/**
 * An event to be processed by the ChannelManager.
 */
typedef enum LDKMonitorEvent_Tag {
   /**
    * A monitor event containing an HTLCUpdate.
    */
   LDKMonitorEvent_HTLCEvent,
   /**
    * A monitor event that the Channel's commitment transaction was confirmed.
    */
   LDKMonitorEvent_CommitmentTxConfirmed,
   /**
    * Indicates a [`ChannelMonitor`] update has completed. See
    * [`ChannelMonitorUpdateStatus::InProgress`] for more information on how this is used.
    *
    * [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
    */
   LDKMonitorEvent_Completed,
   /**
    * Indicates a [`ChannelMonitor`] update has failed. See
    * [`ChannelMonitorUpdateStatus::PermanentFailure`] for more information on how this is used.
    *
    * [`ChannelMonitorUpdateStatus::PermanentFailure`]: super::ChannelMonitorUpdateStatus::PermanentFailure
    */
   LDKMonitorEvent_UpdateFailed,
   /**
    * Must be last for serialization purposes
    */
   LDKMonitorEvent_Sentinel,
} LDKMonitorEvent_Tag;

typedef struct LDKMonitorEvent_LDKCompleted_Body {
   /**
    * The funding outpoint of the [`ChannelMonitor`] that was updated
    */
   struct LDKOutPoint funding_txo;
   /**
    * The Update ID from [`ChannelMonitorUpdate::update_id`] which was applied or
    * [`ChannelMonitor::get_latest_update_id`].
    *
    * Note that this should only be set to a given update's ID if all previous updates for the
    * same [`ChannelMonitor`] have been applied and persisted.
    */
   uint64_t monitor_update_id;
} LDKMonitorEvent_LDKCompleted_Body;

typedef struct MUST_USE_STRUCT LDKMonitorEvent {
   LDKMonitorEvent_Tag tag;
   union {
      struct {
         struct LDKHTLCUpdate htlc_event;
      };
      struct {
         struct LDKOutPoint commitment_tx_confirmed;
      };
      LDKMonitorEvent_LDKCompleted_Body completed;
      struct {
         struct LDKOutPoint update_failed;
      };
   };
} LDKMonitorEvent;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::MonitorEvents of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MonitorEventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMonitorEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MonitorEventZ;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ {
   /**
    * The element at position 0
    */
   struct LDKOutPoint a;
   /**
    * The element at position 1
    */
   struct LDKCVec_MonitorEventZ b;
   /**
    * The element at position 2
    */
   struct LDKPublicKey c;
} LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ;



/**
 * [`Score`] implementation that uses a fixed penalty.
 */
typedef struct MUST_USE_STRUCT LDKFixedPenaltyScorer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFixedPenaltyScorer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFixedPenaltyScorer;

/**
 * The contents of CResult_FixedPenaltyScorerDecodeErrorZ
 */
typedef union LDKCResult_FixedPenaltyScorerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFixedPenaltyScorer *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FixedPenaltyScorerDecodeErrorZPtr;

/**
 * A CResult_FixedPenaltyScorerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::scoring::FixedPenaltyScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FixedPenaltyScorerDecodeErrorZ {
   /**
    * The contents of this CResult_FixedPenaltyScorerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FixedPenaltyScorerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FixedPenaltyScorerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FixedPenaltyScorerDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u64u64Z {
   /**
    * The element at position 0
    */
   uint64_t a;
   /**
    * The element at position 1
    */
   uint64_t b;
} LDKC2Tuple_u64u64Z;

/**
 * An enum which can either contain a crate::c_types::derived::C2Tuple_u64u64Z or not
 */
typedef enum LDKCOption_C2Tuple_u64u64ZZ_Tag {
   /**
    * When we're in this state, this COption_C2Tuple_u64u64ZZ contains a crate::c_types::derived::C2Tuple_u64u64Z
    */
   LDKCOption_C2Tuple_u64u64ZZ_Some,
   /**
    * When we're in this state, this COption_C2Tuple_u64u64ZZ contains nothing
    */
   LDKCOption_C2Tuple_u64u64ZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_C2Tuple_u64u64ZZ_Sentinel,
} LDKCOption_C2Tuple_u64u64ZZ_Tag;

typedef struct LDKCOption_C2Tuple_u64u64ZZ {
   LDKCOption_C2Tuple_u64u64ZZ_Tag tag;
   union {
      struct {
         struct LDKC2Tuple_u64u64Z some;
      };
   };
} LDKCOption_C2Tuple_u64u64ZZ;

/**
 * A dynamically-allocated array of crate::lightning::routing::gossip::NodeIds of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_NodeIdZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKNodeId *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_NodeIdZ;



/**
 * A Record, unit of logging output with Metadata to enable filtering
 * Module_path, file, line to inform on log's source
 */
typedef struct MUST_USE_STRUCT LDKRecord {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRecord *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRecord;

/**
 * A trait encapsulating the operations required of a logger
 */
typedef struct LDKLogger {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Logs the `Record`
    */
   void (*log)(const void *this_arg, const struct LDKRecord *NONNULL_PTR record);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKLogger;



/**
 * Represents the network as nodes and channels between them
 */
typedef struct MUST_USE_STRUCT LDKNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNetworkGraph;



/**
 * [`Score`] implementation using channel success probability distributions.
 *
 * Channels are tracked with upper and lower liquidity bounds - when an HTLC fails at a channel,
 * we learn that the upper-bound on the available liquidity is lower than the amount of the HTLC.
 * When a payment is forwarded through a channel (but fails later in the route), we learn the
 * lower-bound on the channel's available liquidity must be at least the value of the HTLC.
 *
 * These bounds are then used to determine a success probability using the formula from
 * *Optimally Reliable & Cheap Payment Flows on the Lightning Network* by Rene Pickhardt
 * and Stefan Richter [[1]] (i.e. `(upper_bound - payment_amount) / (upper_bound - lower_bound)`).
 *
 * This probability is combined with the [`liquidity_penalty_multiplier_msat`] and
 * [`liquidity_penalty_amount_multiplier_msat`] parameters to calculate a concrete penalty in
 * milli-satoshis. The penalties, when added across all hops, have the property of being linear in
 * terms of the entire path's success probability. This allows the router to directly compare
 * penalties for different paths. See the documentation of those parameters for the exact formulas.
 *
 * The liquidity bounds are decayed by halving them every [`liquidity_offset_half_life`].
 *
 * Further, we track the history of our upper and lower liquidity bounds for each channel,
 * allowing us to assign a second penalty (using [`historical_liquidity_penalty_multiplier_msat`]
 * and [`historical_liquidity_penalty_amount_multiplier_msat`]) based on the same probability
 * formula, but using the history of a channel rather than our latest estimates for the liquidity
 * bounds.
 *
 * # Note
 *
 * Mixing the `no-std` feature between serialization and deserialization results in undefined
 * behavior.
 *
 * [1]: https://arxiv.org/abs/2107.05322
 * [`liquidity_penalty_multiplier_msat`]: ProbabilisticScoringParameters::liquidity_penalty_multiplier_msat
 * [`liquidity_penalty_amount_multiplier_msat`]: ProbabilisticScoringParameters::liquidity_penalty_amount_multiplier_msat
 * [`liquidity_offset_half_life`]: ProbabilisticScoringParameters::liquidity_offset_half_life
 * [`historical_liquidity_penalty_multiplier_msat`]: ProbabilisticScoringParameters::historical_liquidity_penalty_multiplier_msat
 * [`historical_liquidity_penalty_amount_multiplier_msat`]: ProbabilisticScoringParameters::historical_liquidity_penalty_amount_multiplier_msat
 */
typedef struct MUST_USE_STRUCT LDKProbabilisticScorer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeProbabilisticScorer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKProbabilisticScorer;

/**
 * The contents of CResult_ProbabilisticScorerDecodeErrorZ
 */
typedef union LDKCResult_ProbabilisticScorerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKProbabilisticScorer *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ProbabilisticScorerDecodeErrorZPtr;

/**
 * A CResult_ProbabilisticScorerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::scoring::ProbabilisticScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ProbabilisticScorerDecodeErrorZ {
   /**
    * The contents of this CResult_ProbabilisticScorerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ProbabilisticScorerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ProbabilisticScorerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ProbabilisticScorerDecodeErrorZ;



/**
 * Features used within an `init` message.
 */
typedef struct MUST_USE_STRUCT LDKInitFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInitFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInitFeatures;

/**
 * The contents of CResult_InitFeaturesDecodeErrorZ
 */
typedef union LDKCResult_InitFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInitFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InitFeaturesDecodeErrorZPtr;

/**
 * A CResult_InitFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::InitFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InitFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_InitFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InitFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InitFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InitFeaturesDecodeErrorZ;



/**
 * Features used within a `channel_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKChannelFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelFeatures;

/**
 * The contents of CResult_ChannelFeaturesDecodeErrorZ
 */
typedef union LDKCResult_ChannelFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelFeaturesDecodeErrorZPtr;

/**
 * A CResult_ChannelFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::ChannelFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelFeaturesDecodeErrorZ;



/**
 * Features used within a `node_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKNodeFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeFeatures;

/**
 * The contents of CResult_NodeFeaturesDecodeErrorZ
 */
typedef union LDKCResult_NodeFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeFeaturesDecodeErrorZPtr;

/**
 * A CResult_NodeFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::NodeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_NodeFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeFeaturesDecodeErrorZ;



/**
 * Features used within an invoice.
 */
typedef struct MUST_USE_STRUCT LDKInvoiceFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceFeatures;

/**
 * The contents of CResult_InvoiceFeaturesDecodeErrorZ
 */
typedef union LDKCResult_InvoiceFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoiceFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InvoiceFeaturesDecodeErrorZPtr;

/**
 * A CResult_InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_InvoiceFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceFeaturesDecodeErrorZ;

/**
 * The contents of CResult_ChannelTypeFeaturesDecodeErrorZ
 */
typedef union LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelTypeFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr;

/**
 * A CResult_ChannelTypeFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::ChannelTypeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelTypeFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelTypeFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelTypeFeaturesDecodeErrorZ;



/**
 * Features used within an `offer`.
 */
typedef struct MUST_USE_STRUCT LDKOfferFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOfferFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOfferFeatures;

/**
 * The contents of CResult_OfferFeaturesDecodeErrorZ
 */
typedef union LDKCResult_OfferFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOfferFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OfferFeaturesDecodeErrorZPtr;

/**
 * A CResult_OfferFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::OfferFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OfferFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_OfferFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OfferFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OfferFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OfferFeaturesDecodeErrorZ;



/**
 * Features used within an `invoice_request`.
 */
typedef struct MUST_USE_STRUCT LDKInvoiceRequestFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceRequestFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceRequestFeatures;

/**
 * The contents of CResult_InvoiceRequestFeaturesDecodeErrorZ
 */
typedef union LDKCResult_InvoiceRequestFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoiceRequestFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InvoiceRequestFeaturesDecodeErrorZPtr;

/**
 * A CResult_InvoiceRequestFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::InvoiceRequestFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceRequestFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_InvoiceRequestFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceRequestFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceRequestFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceRequestFeaturesDecodeErrorZ;

/**
 * The contents of CResult_NodeIdDecodeErrorZ
 */
typedef union LDKCResult_NodeIdDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeId *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeIdDecodeErrorZPtr;

/**
 * A CResult_NodeIdDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NodeId on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeIdDecodeErrorZ {
   /**
    * The contents of this CResult_NodeIdDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeIdDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeIdDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeIdDecodeErrorZ;

/**
 * The contents of CResult_COption_NetworkUpdateZDecodeErrorZ
 */
typedef union LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_NetworkUpdateZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr;

/**
 * A CResult_COption_NetworkUpdateZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_NetworkUpdateZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_NetworkUpdateZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_NetworkUpdateZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_NetworkUpdateZDecodeErrorZ;

/**
 * The `Access` trait defines behavior for accessing chain data and state, such as blocks and
 * UTXOs.
 */
typedef struct LDKAccess {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the transaction output of a funding transaction encoded by [`short_channel_id`].
    * Returns an error if `genesis_hash` is for a different chain or if such a transaction output
    * is unknown.
    *
    * [`short_channel_id`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#definition-of-short_channel_id
    */
   struct LDKCResult_TxOutAccessErrorZ (*get_utxo)(const void *this_arg, const uint8_t (*genesis_hash)[32], uint64_t short_channel_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKAccess;

/**
 * An enum which can either contain a crate::lightning::chain::Access or not
 */
typedef enum LDKCOption_AccessZ_Tag {
   /**
    * When we're in this state, this COption_AccessZ contains a crate::lightning::chain::Access
    */
   LDKCOption_AccessZ_Some,
   /**
    * When we're in this state, this COption_AccessZ contains nothing
    */
   LDKCOption_AccessZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_AccessZ_Sentinel,
} LDKCOption_AccessZ_Tag;

typedef struct LDKCOption_AccessZ {
   LDKCOption_AccessZ_Tag tag;
   union {
      struct {
         struct LDKAccess some;
      };
   };
} LDKCOption_AccessZ;

/**
 * The contents of CResult_boolLightningErrorZ
 */
typedef union LDKCResult_boolLightningErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   bool *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_boolLightningErrorZPtr;

/**
 * A CResult_boolLightningErrorZ represents the result of a fallible operation,
 * containing a bool on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_boolLightningErrorZ {
   /**
    * The contents of this CResult_boolLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_boolLightningErrorZPtr contents;
   /**
    * Whether this CResult_boolLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_boolLightningErrorZ;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
   /**
    * The element at position 0
    */
   struct LDKChannelAnnouncement a;
   /**
    * The element at position 1
    */
   struct LDKChannelUpdate b;
   /**
    * The element at position 2
    */
   struct LDKChannelUpdate c;
} LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ;

/**
 * An enum which can either contain a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ or not
 */
typedef enum LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Tag {
   /**
    * When we're in this state, this COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ contains a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
    */
   LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Some,
   /**
    * When we're in this state, this COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ contains nothing
    */
   LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Sentinel,
} LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Tag;

typedef struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
   LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Tag tag;
   union {
      struct {
         struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ some;
      };
   };
} LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ;

/**
 * The contents of CResult_NoneLightningErrorZ
 */
typedef union LDKCResult_NoneLightningErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_NoneLightningErrorZPtr;

/**
 * A CResult_NoneLightningErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneLightningErrorZ {
   /**
    * The contents of this CResult_NoneLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneLightningErrorZPtr contents;
   /**
    * Whether this CResult_NoneLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneLightningErrorZ;



/**
 * Details about one direction of a channel as received within a [`ChannelUpdate`].
 */
typedef struct MUST_USE_STRUCT LDKChannelUpdateInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUpdateInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUpdateInfo;

/**
 * The contents of CResult_ChannelUpdateInfoDecodeErrorZ
 */
typedef union LDKCResult_ChannelUpdateInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelUpdateInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelUpdateInfoDecodeErrorZPtr;

/**
 * A CResult_ChannelUpdateInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::ChannelUpdateInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelUpdateInfoDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelUpdateInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelUpdateInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelUpdateInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelUpdateInfoDecodeErrorZ;



/**
 * Details about a channel (both directions).
 * Received within a channel announcement.
 */
typedef struct MUST_USE_STRUCT LDKChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelInfo;

/**
 * The contents of CResult_ChannelInfoDecodeErrorZ
 */
typedef union LDKCResult_ChannelInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelInfoDecodeErrorZPtr;

/**
 * A CResult_ChannelInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::ChannelInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelInfoDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelInfoDecodeErrorZ;



/**
 * Fees for routing via a given channel or a node
 */
typedef struct MUST_USE_STRUCT LDKRoutingFees {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoutingFees *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoutingFees;

/**
 * The contents of CResult_RoutingFeesDecodeErrorZ
 */
typedef union LDKCResult_RoutingFeesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoutingFees *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RoutingFeesDecodeErrorZPtr;

/**
 * A CResult_RoutingFeesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::RoutingFees on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RoutingFeesDecodeErrorZ {
   /**
    * The contents of this CResult_RoutingFeesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RoutingFeesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RoutingFeesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RoutingFeesDecodeErrorZ;

/**
 * A 4-byte byte array.
 */
typedef struct LDKFourBytes {
   /**
    * The four bytes
    */
   uint8_t data[4];
} LDKFourBytes;

/**
 * A 12-byte byte array.
 */
typedef struct LDKTwelveBytes {
   /**
    * The twelve bytes
    */
   uint8_t data[12];
} LDKTwelveBytes;



/**
 * Represents a hostname for serialization purposes.
 * Only the character set and length will be validated.
 * The character set consists of ASCII alphanumeric characters, hyphens, and periods.
 * Its length is guaranteed to be representable by a single byte.
 * This serialization is used by BOLT 7 hostnames.
 */
typedef struct MUST_USE_STRUCT LDKHostname {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHostname *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHostname;

/**
 * An address which can be used to connect to a remote peer
 */
typedef enum LDKNetAddress_Tag {
   /**
    * An IPv4 address/port on which the peer is listening.
    */
   LDKNetAddress_IPv4,
   /**
    * An IPv6 address/port on which the peer is listening.
    */
   LDKNetAddress_IPv6,
   /**
    * An old-style Tor onion address/port on which the peer is listening.
    *
    * This field is deprecated and the Tor network generally no longer supports V2 Onion
    * addresses. Thus, the details are not parsed here.
    */
   LDKNetAddress_OnionV2,
   /**
    * A new-style Tor onion address/port on which the peer is listening.
    * To create the human-readable \"hostname\", concatenate ed25519_pubkey, checksum, and version,
    * wrap as base32 and append \".onion\".
    */
   LDKNetAddress_OnionV3,
   /**
    * A hostname/port on which the peer is listening.
    */
   LDKNetAddress_Hostname,
   /**
    * Must be last for serialization purposes
    */
   LDKNetAddress_Sentinel,
} LDKNetAddress_Tag;

typedef struct LDKNetAddress_LDKIPv4_Body {
   /**
    * The 4-byte IPv4 address
    */
   struct LDKFourBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKIPv4_Body;

typedef struct LDKNetAddress_LDKIPv6_Body {
   /**
    * The 16-byte IPv6 address
    */
   struct LDKSixteenBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKIPv6_Body;

typedef struct LDKNetAddress_LDKOnionV3_Body {
   /**
    * The ed25519 long-term public key of the peer
    */
   struct LDKThirtyTwoBytes ed25519_pubkey;
   /**
    * The checksum of the pubkey and version, as included in the onion address
    */
   uint16_t checksum;
   /**
    * The version byte, as defined by the Tor Onion v3 spec.
    */
   uint8_t version;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKOnionV3_Body;

typedef struct LDKNetAddress_LDKHostname_Body {
   /**
    * The hostname on which the node is listening.
    */
   struct LDKHostname hostname;
   /**
    * The port on which the node is listening.
    */
   uint16_t port;
} LDKNetAddress_LDKHostname_Body;

typedef struct MUST_USE_STRUCT LDKNetAddress {
   LDKNetAddress_Tag tag;
   union {
      LDKNetAddress_LDKIPv4_Body i_pv4;
      LDKNetAddress_LDKIPv6_Body i_pv6;
      struct {
         struct LDKTwelveBytes onion_v2;
      };
      LDKNetAddress_LDKOnionV3_Body onion_v3;
      LDKNetAddress_LDKHostname_Body hostname;
   };
} LDKNetAddress;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::NetAddresss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_NetAddressZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKNetAddress *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_NetAddressZ;



/**
 * Information received in the latest node_announcement from this node.
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncementInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncementInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncementInfo;

/**
 * The contents of CResult_NodeAnnouncementInfoDecodeErrorZ
 */
typedef union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAnnouncementInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr;

/**
 * A CResult_NodeAnnouncementInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NodeAnnouncementInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAnnouncementInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAnnouncementInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZ;



/**
 * A user-defined name for a node, which may be used when displaying the node in a graph.
 *
 * Since node aliases are provided by third parties, they are a potential avenue for injection
 * attacks. Care must be taken when processing.
 */
typedef struct MUST_USE_STRUCT LDKNodeAlias {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAlias *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAlias;

/**
 * The contents of CResult_NodeAliasDecodeErrorZ
 */
typedef union LDKCResult_NodeAliasDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAlias *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAliasDecodeErrorZPtr;

/**
 * A CResult_NodeAliasDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NodeAlias on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAliasDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAliasDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAliasDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAliasDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAliasDecodeErrorZ;



/**
 * Details about a node in the network, known from the network announcement.
 */
typedef struct MUST_USE_STRUCT LDKNodeInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeInfo;

/**
 * The contents of CResult_NodeInfoDecodeErrorZ
 */
typedef union LDKCResult_NodeInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeInfoDecodeErrorZPtr;

/**
 * A CResult_NodeInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NodeInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeInfoDecodeErrorZ {
   /**
    * The contents of this CResult_NodeInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeInfoDecodeErrorZ;

/**
 * The contents of CResult_NetworkGraphDecodeErrorZ
 */
typedef union LDKCResult_NetworkGraphDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNetworkGraph *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NetworkGraphDecodeErrorZPtr;

/**
 * A CResult_NetworkGraphDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NetworkGraph on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NetworkGraphDecodeErrorZ {
   /**
    * The contents of this CResult_NetworkGraphDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NetworkGraphDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NetworkGraphDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NetworkGraphDecodeErrorZ;

/**
 * An enum which can either contain a crate::c_types::derived::CVec_NetAddressZ or not
 */
typedef enum LDKCOption_CVec_NetAddressZZ_Tag {
   /**
    * When we're in this state, this COption_CVec_NetAddressZZ contains a crate::c_types::derived::CVec_NetAddressZ
    */
   LDKCOption_CVec_NetAddressZZ_Some,
   /**
    * When we're in this state, this COption_CVec_NetAddressZZ contains nothing
    */
   LDKCOption_CVec_NetAddressZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_CVec_NetAddressZZ_Sentinel,
} LDKCOption_CVec_NetAddressZZ_Tag;

typedef struct LDKCOption_CVec_NetAddressZZ {
   LDKCOption_CVec_NetAddressZZ_Tag tag;
   union {
      struct {
         struct LDKCVec_NetAddressZ some;
      };
   };
} LDKCOption_CVec_NetAddressZZ;

/**
 * The contents of CResult_DelayedPaymentOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDelayedPaymentOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::DelayedPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ;

/**
 * The contents of CResult_StaticPaymentOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKStaticPaymentOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::StaticPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_StaticPaymentOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ;

/**
 * The contents of CResult_SpendableOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSpendableOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_SpendableOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::SpendableOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_SpendableOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_SpendableOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PaymentPreimageZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKThirtyTwoBytes *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PaymentPreimageZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_SignatureCVec_SignatureZZ {
   /**
    * The element at position 0
    */
   struct LDKSignature a;
   /**
    * The element at position 1
    */
   struct LDKCVec_SignatureZ b;
} LDKC2Tuple_SignatureCVec_SignatureZZ;

/**
 * The contents of CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ
 */
typedef union LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_SignatureCVec_SignatureZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr;

/**
 * A CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_SignatureCVec_SignatureZZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ;

/**
 * The contents of CResult_SignatureNoneZ
 */
typedef union LDKCResult_SignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SignatureNoneZPtr;

/**
 * A CResult_SignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::Signature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignatureNoneZ {
   /**
    * The contents of this CResult_SignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignatureNoneZPtr contents;
   /**
    * Whether this CResult_SignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignatureNoneZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_SignatureSignatureZ {
   /**
    * The element at position 0
    */
   struct LDKSignature a;
   /**
    * The element at position 1
    */
   struct LDKSignature b;
} LDKC2Tuple_SignatureSignatureZ;

/**
 * The contents of CResult_C2Tuple_SignatureSignatureZNoneZ
 */
typedef union LDKCResult_C2Tuple_SignatureSignatureZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_SignatureSignatureZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_SignatureSignatureZNoneZPtr;

/**
 * A CResult_C2Tuple_SignatureSignatureZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_SignatureSignatureZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_SignatureSignatureZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_SignatureSignatureZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_SignatureSignatureZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_SignatureSignatureZNoneZ;

/**
 * Represents a valid secp256k1 secret key serialized as a 32 byte array.
 */
typedef struct LDKSecretKey {
   /**
    * The bytes of the secret key
    */
   uint8_t bytes[32];
} LDKSecretKey;

/**
 * The contents of CResult_SecretKeyNoneZ
 */
typedef union LDKCResult_SecretKeyNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSecretKey *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SecretKeyNoneZPtr;

/**
 * A CResult_SecretKeyNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::SecretKey on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SecretKeyNoneZ {
   /**
    * The contents of this CResult_SecretKeyNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SecretKeyNoneZPtr contents;
   /**
    * Whether this CResult_SecretKeyNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SecretKeyNoneZ;

/**
 * The contents of CResult_PublicKeyNoneZ
 */
typedef union LDKCResult_PublicKeyNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPublicKey *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_PublicKeyNoneZPtr;

/**
 * A CResult_PublicKeyNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::PublicKey on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PublicKeyNoneZ {
   /**
    * The contents of this CResult_PublicKeyNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PublicKeyNoneZPtr contents;
   /**
    * Whether this CResult_PublicKeyNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PublicKeyNoneZ;

/**
 * An enum which can either contain a crate::c_types::BigEndianScalar or not
 */
typedef enum LDKCOption_ScalarZ_Tag {
   /**
    * When we're in this state, this COption_ScalarZ contains a crate::c_types::BigEndianScalar
    */
   LDKCOption_ScalarZ_Some,
   /**
    * When we're in this state, this COption_ScalarZ contains nothing
    */
   LDKCOption_ScalarZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_ScalarZ_Sentinel,
} LDKCOption_ScalarZ_Tag;

typedef struct LDKCOption_ScalarZ {
   LDKCOption_ScalarZ_Tag tag;
   union {
      struct {
         struct LDKBigEndianScalar some;
      };
   };
} LDKCOption_ScalarZ;

/**
 * The contents of CResult_SharedSecretNoneZ
 */
typedef union LDKCResult_SharedSecretNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SharedSecretNoneZPtr;

/**
 * A CResult_SharedSecretNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SharedSecretNoneZ {
   /**
    * The contents of this CResult_SharedSecretNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SharedSecretNoneZPtr contents;
   /**
    * Whether this CResult_SharedSecretNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SharedSecretNoneZ;



/**
 * This class tracks the per-transaction information needed to build a closing transaction and will
 * actually build it and sign.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */
typedef struct MUST_USE_STRUCT LDKClosingTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingTransaction;



/**
 * The unsigned part of a channel_announcement
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelAnnouncement;

/**
 * A trait to sign Lightning channel transactions as described in
 * [BOLT 3](https://github.com/lightning/bolts/blob/master/03-transactions.md).
 *
 * Signing services could be implemented on a hardware wallet and should implement signing
 * policies in order to be secure. Please refer to the [VLS Policy
 * Controls](https://gitlab.com/lightning-signer/validating-lightning-signer/-/blob/main/docs/policy-controls.md)
 * for an example of such policies.
 */
typedef struct LDKBaseSign {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the per-commitment point for a specific commitment number
    *
    * Note that the commitment number starts at `(1 << 48) - 1` and counts backwards.
    */
   struct LDKPublicKey (*get_per_commitment_point)(const void *this_arg, uint64_t idx);
   /**
    * Gets the commitment secret for a specific commitment number as part of the revocation process
    *
    * An external signer implementation should error here if the commitment was already signed
    * and should refuse to sign it in the future.
    *
    * May be called more than once for the same index.
    *
    * Note that the commitment number starts at `(1 << 48) - 1` and counts backwards.
    */
   struct LDKThirtyTwoBytes (*release_commitment_secret)(const void *this_arg, uint64_t idx);
   /**
    * Validate the counterparty's signatures on the holder commitment transaction and HTLCs.
    *
    * This is required in order for the signer to make sure that releasing a commitment
    * secret won't leave us without a broadcastable holder transaction.
    * Policy checks should be implemented in this function, including checking the amount
    * sent to us and checking the HTLCs.
    *
    * The preimages of outgoing HTLCs that were fulfilled since the last commitment are provided.
    * A validating signer should ensure that an HTLC output is removed only when the matching
    * preimage is provided, or when the value to holder is restored.
    *
    * Note that all the relevant preimages will be provided, but there may also be additional
    * irrelevant or duplicate preimages.
    */
   struct LDKCResult_NoneNoneZ (*validate_holder_commitment)(const void *this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR holder_tx, struct LDKCVec_PaymentPreimageZ preimages);
   /**
    * Returns the holder's channel public keys and basepoints.
    */
   struct LDKChannelPublicKeys pubkeys;
   /**
    * Fill in the pubkeys field as a reference to it will be given to Rust after this returns
    * Note that this takes a pointer to this object, not the this_ptr like other methods do
    * This function pointer may be NULL if pubkeys is filled in when this object is created and never needs updating.
    */
   void (*set_pubkeys)(const struct LDKBaseSign*NONNULL_PTR );
   /**
    * Returns an arbitrary identifier describing the set of keys which are provided back to you in
    * some [`SpendableOutputDescriptor`] types. This should be sufficient to identify this
    * [`BaseSign`] object uniquely and lookup or re-derive its keys.
    */
   struct LDKThirtyTwoBytes (*channel_keys_id)(const void *this_arg);
   /**
    * Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
    *
    * Note that if signing fails or is rejected, the channel will be force-closed.
    *
    * Policy checks should be implemented in this function, including checking the amount
    * sent to us and checking the HTLCs.
    *
    * The preimages of outgoing HTLCs that were fulfilled since the last commitment are provided.
    * A validating signer should ensure that an HTLC output is removed only when the matching
    * preimage is provided, or when the value to holder is restored.
    *
    * Note that all the relevant preimages will be provided, but there may also be additional
    * irrelevant or duplicate preimages.
    */
   struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ (*sign_counterparty_commitment)(const void *this_arg, const struct LDKCommitmentTransaction *NONNULL_PTR commitment_tx, struct LDKCVec_PaymentPreimageZ preimages);
   /**
    * Validate the counterparty's revocation.
    *
    * This is required in order for the signer to make sure that the state has moved
    * forward and it is safe to sign the next counterparty commitment.
    */
   struct LDKCResult_NoneNoneZ (*validate_counterparty_revocation)(const void *this_arg, uint64_t idx, const uint8_t (*secret)[32]);
   /**
    * Creates a signature for a holder's commitment transaction and its claiming HTLC transactions.
    *
    * This will be called
    * - with a non-revoked `commitment_tx`.
    * - with the latest `commitment_tx` when we initiate a force-close.
    * - with the previous `commitment_tx`, just to get claiming HTLC
    *   signatures, if we are reacting to a [`ChannelMonitor`]
    *   [replica](https://github.com/lightningdevkit/rust-lightning/blob/main/GLOSSARY.md#monitor-replicas)
    *   that decided to broadcast before it had been updated to the latest `commitment_tx`.
    *
    * This may be called multiple times for the same transaction.
    *
    * An external signer implementation should check that the commitment has not been revoked.
    *
    * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    */
   struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ (*sign_holder_commitment_and_htlcs)(const void *this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR commitment_tx);
   /**
    * Create a signature for the given input in a transaction spending an HTLC transaction output
    * or a commitment transaction `to_local` output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiple outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiple times for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * `per_commitment_key` is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder `revocation_secret` to do
    * so).
    */
   struct LDKCResult_SignatureNoneZ (*sign_justice_revoked_output)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32]);
   /**
    * Create a signature for the given input in a transaction spending a commitment transaction
    * HTLC output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiple outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiple times for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * `amount` is the value of the output spent by this input, committed to in the BIP 143
    * signature.
    *
    * `per_commitment_key` is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder revocation_secret to do
    * so).
    *
    * `htlc` holds HTLC elements (hash, timelock), thus changing the format of the witness script
    * (which is committed to in the BIP 143 signatures).
    */
   struct LDKCResult_SignatureNoneZ (*sign_justice_revoked_htlc)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32], const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
    * transaction, either offered or received.
    *
    * Such a transaction may claim multiples offered outputs at same time if we know the
    * preimage for each when we create it, but only the input at index `input` should be
    * signed for here. It may be called multiple times for same output(s) if a fee-bump is
    * needed with regards to an upcoming timelock expiration.
    *
    * `witness_script` is either an offered or received script as defined in BOLT3 for HTLC
    * outputs.
    *
    * `amount` is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * `per_commitment_point` is the dynamic point corresponding to the channel state
    * detected onchain. It has been generated by our counterparty and is used to derive
    * channel state keys, which are then included in the witness script and committed to in the
    * BIP 143 signature.
    */
   struct LDKCResult_SignatureNoneZ (*sign_counterparty_htlc_transaction)(const void *this_arg, struct LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, struct LDKPublicKey per_commitment_point, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a (proposed) closing transaction.
    *
    * Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
    * chosen to forgo their output as dust.
    */
   struct LDKCResult_SignatureNoneZ (*sign_closing_transaction)(const void *this_arg, const struct LDKClosingTransaction *NONNULL_PTR closing_tx);
   /**
    * Computes the signature for a commitment transaction's anchor output used as an
    * input within `anchor_tx`, which spends the commitment transaction, at index `input`.
    */
   struct LDKCResult_SignatureNoneZ (*sign_holder_anchor_input)(const void *this_arg, struct LDKTransaction anchor_tx, uintptr_t input);
   /**
    * Signs a channel announcement message with our funding key and our node secret key (aka
    * node_id or network_key), proving it comes from one of the channel participants.
    *
    * The first returned signature should be from our node secret key, the second from our
    * funding key.
    *
    * Note that if this fails or is rejected, the channel will not be publicly announced and
    * our counterparty may (though likely will not) close the channel on us for violating the
    * protocol.
    */
   struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ (*sign_channel_announcement)(const void *this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Set the counterparty static channel data, including basepoints,
    * `counterparty_selected`/`holder_selected_contest_delay` and funding outpoint. Since these
    * are static channel data, they MUST NOT be allowed to change to different values once set,
    * as LDK may call this method more than once.
    *
    * channel_parameters.is_populated() MUST be true.
    */
   void (*provide_channel_parameters)(void *this_arg, const struct LDKChannelTransactionParameters *NONNULL_PTR channel_parameters);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKBaseSign;

/**
 * A writeable signer.
 *
 * There will always be two instances of a signer per channel, one occupied by the
 * [`ChannelManager`] and another by the channel's [`ChannelMonitor`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
 */
typedef struct LDKSign {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Implementation of BaseSign for this object.
    */
   struct LDKBaseSign BaseSign;
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Called, if set, after this Sign has been cloned into a duplicate object.
    * The new Sign is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKSign *NONNULL_PTR new_Sign);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSign;

/**
 * The contents of CResult_SignDecodeErrorZ
 */
typedef union LDKCResult_SignDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSign *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_SignDecodeErrorZPtr;

/**
 * A CResult_SignDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::Sign on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignDecodeErrorZ {
   /**
    * The contents of this CResult_SignDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignDecodeErrorZPtr contents;
   /**
    * Whether this CResult_SignDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignDecodeErrorZ;

/**
 * Integer in the range `0..32`
 */
typedef struct LDKU5 {
   uint8_t _0;
} LDKU5;

/**
 * A dynamically-allocated array of crate::c_types::U5s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_U5Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKU5 *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_U5Z;

/**
 * Represents a secp256k1 signature serialized as two 32-byte numbers as well as a tag which
 * allows recovering the exact public key which created the signature given the message.
 */
typedef struct LDKRecoverableSignature {
   /**
    * The bytes of the signature in "compact" form plus a "Recovery ID" which allows for
    * recovery.
    */
   uint8_t serialized_form[68];
} LDKRecoverableSignature;

/**
 * The contents of CResult_RecoverableSignatureNoneZ
 */
typedef union LDKCResult_RecoverableSignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRecoverableSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_RecoverableSignatureNoneZPtr;

/**
 * A CResult_RecoverableSignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::RecoverableSignature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RecoverableSignatureNoneZ {
   /**
    * The contents of this CResult_RecoverableSignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RecoverableSignatureNoneZPtr contents;
   /**
    * Whether this CResult_RecoverableSignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RecoverableSignatureNoneZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CVec_u8Zs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CVec_u8ZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCVec_u8Z *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CVec_u8ZZ;

/**
 * The contents of CResult_CVec_CVec_u8ZZNoneZ
 */
typedef union LDKCResult_CVec_CVec_u8ZZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_CVec_u8ZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_CVec_u8ZZNoneZPtr;

/**
 * A CResult_CVec_CVec_u8ZZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_CVec_u8ZZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_CVec_u8ZZNoneZ {
   /**
    * The contents of this CResult_CVec_CVec_u8ZZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_CVec_u8ZZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_CVec_u8ZZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_CVec_u8ZZNoneZ;



/**
 * A simple implementation of [`Sign`] that just keeps the private keys in memory.
 *
 * This implementation performs no policy checks and is insufficient by itself as
 * a secure external signer.
 */
typedef struct MUST_USE_STRUCT LDKInMemorySigner {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInMemorySigner *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInMemorySigner;

/**
 * The contents of CResult_InMemorySignerDecodeErrorZ
 */
typedef union LDKCResult_InMemorySignerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInMemorySigner *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InMemorySignerDecodeErrorZPtr;

/**
 * A CResult_InMemorySignerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::InMemorySigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InMemorySignerDecodeErrorZ {
   /**
    * The contents of this CResult_InMemorySignerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InMemorySignerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InMemorySignerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InMemorySignerDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::TxOuts of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TxOutZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKTxOut *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TxOutZ;

/**
 * The contents of CResult_TransactionNoneZ
 */
typedef union LDKCResult_TransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TransactionNoneZPtr;

/**
 * A CResult_TransactionNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::Transaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TransactionNoneZ {
   /**
    * The contents of this CResult_TransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TransactionNoneZPtr contents;
   /**
    * Whether this CResult_TransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TransactionNoneZ;



/**
 * A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
 * on-chain transactions to ensure no loss of funds occurs.
 *
 * You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
 * information and are actively monitoring the chain.
 *
 * Pending Events or updated HTLCs which have not yet been read out by
 * get_and_clear_pending_monitor_events or get_and_clear_pending_events are serialized to disk and
 * reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events
 * gotten are fully handled before re-serializing the new state.
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
 * returned block hash and the the current chain and then reconnecting blocks to get to the
 * best chain) upon deserializing the object!
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitor;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_BlockHashChannelMonitorZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKChannelMonitor b;
} LDKC2Tuple_BlockHashChannelMonitorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_BlockHashChannelMonitorZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_BlockHashChannelMonitorZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_BlockHashChannelMonitorZZ;

/**
 * The contents of CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
 */
typedef union LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr;

/**
 * A CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_C2Tuple_BlockHashChannelMonitorZZ on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ {
   /**
    * The contents of this CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr contents;
   /**
    * Whether this CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ;

/**
 * An enum which can either contain a u16 or not
 */
typedef enum LDKCOption_u16Z_Tag {
   /**
    * When we're in this state, this COption_u16Z contains a u16
    */
   LDKCOption_u16Z_Some,
   /**
    * When we're in this state, this COption_u16Z contains nothing
    */
   LDKCOption_u16Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u16Z_Sentinel,
} LDKCOption_u16Z_Tag;

typedef struct LDKCOption_u16Z {
   LDKCOption_u16Z_Tag tag;
   union {
      struct {
         uint16_t some;
      };
   };
} LDKCOption_u16Z;

/**
 * Indicates an error on the client's part (usually some variant of attempting to use too-low or
 * too-high values)
 */
typedef enum LDKAPIError_Tag {
   /**
    * Indicates the API was wholly misused (see err for more). Cases where these can be returned
    * are documented, but generally indicates some precondition of a function was violated.
    */
   LDKAPIError_APIMisuseError,
   /**
    * Due to a high feerate, we were unable to complete the request.
    * For example, this may be returned if the feerate implies we cannot open a channel at the
    * requested value, but opening a larger channel would succeed.
    */
   LDKAPIError_FeeRateTooHigh,
   /**
    * A malformed Route was provided (eg overflowed value, node id mismatch, overly-looped route,
    * too-many-hops, etc).
    */
   LDKAPIError_InvalidRoute,
   /**
    * We were unable to complete the request as the Channel required to do so is unable to
    * complete the request (or was not found). This can take many forms, including disconnected
    * peer, channel at capacity, channel shutting down, etc.
    */
   LDKAPIError_ChannelUnavailable,
   /**
    * An attempt to call [`chain::Watch::watch_channel`]/[`chain::Watch::update_channel`]
    * returned a [`ChannelMonitorUpdateStatus::InProgress`] indicating the persistence of a
    * monitor update is awaiting async resolution. Once it resolves the attempted action should
    * complete automatically.
    *
    * [`chain::Watch::watch_channel`]: crate::chain::Watch::watch_channel
    * [`chain::Watch::update_channel`]: crate::chain::Watch::update_channel
    * [`ChannelMonitorUpdateStatus::InProgress`]: crate::chain::ChannelMonitorUpdateStatus::InProgress
    */
   LDKAPIError_MonitorUpdateInProgress,
   /**
    * [`KeysInterface::get_shutdown_scriptpubkey`] returned a shutdown scriptpubkey incompatible
    * with the channel counterparty as negotiated in [`InitFeatures`].
    *
    * Using a SegWit v0 script should resolve this issue. If you cannot, you won't be able to open
    * a channel or cooperatively close one with this peer (and will have to force-close instead).
    *
    * [`KeysInterface::get_shutdown_scriptpubkey`]: crate::chain::keysinterface::KeysInterface::get_shutdown_scriptpubkey
    * [`InitFeatures`]: crate::ln::features::InitFeatures
    */
   LDKAPIError_IncompatibleShutdownScript,
   /**
    * Must be last for serialization purposes
    */
   LDKAPIError_Sentinel,
} LDKAPIError_Tag;

typedef struct LDKAPIError_LDKAPIMisuseError_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKAPIMisuseError_Body;

typedef struct LDKAPIError_LDKFeeRateTooHigh_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
   /**
    * The feerate which was too high.
    */
   uint32_t feerate;
} LDKAPIError_LDKFeeRateTooHigh_Body;

typedef struct LDKAPIError_LDKInvalidRoute_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKInvalidRoute_Body;

typedef struct LDKAPIError_LDKChannelUnavailable_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKChannelUnavailable_Body;

typedef struct LDKAPIError_LDKIncompatibleShutdownScript_Body {
   /**
    * The incompatible shutdown script.
    */
   struct LDKShutdownScript script;
} LDKAPIError_LDKIncompatibleShutdownScript_Body;

typedef struct MUST_USE_STRUCT LDKAPIError {
   LDKAPIError_Tag tag;
   union {
      LDKAPIError_LDKAPIMisuseError_Body api_misuse_error;
      LDKAPIError_LDKFeeRateTooHigh_Body fee_rate_too_high;
      LDKAPIError_LDKInvalidRoute_Body invalid_route;
      LDKAPIError_LDKChannelUnavailable_Body channel_unavailable;
      LDKAPIError_LDKIncompatibleShutdownScript_Body incompatible_shutdown_script;
   };
} LDKAPIError;

/**
 * The contents of CResult_NoneAPIErrorZ
 */
typedef union LDKCResult_NoneAPIErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_NoneAPIErrorZPtr;

/**
 * A CResult_NoneAPIErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneAPIErrorZ {
   /**
    * The contents of this CResult_NoneAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneAPIErrorZPtr contents;
   /**
    * Whether this CResult_NoneAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneAPIErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CResult_NoneAPIErrorZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CResult_NoneAPIErrorZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCResult_NoneAPIErrorZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CResult_NoneAPIErrorZZ;

/**
 * A dynamically-allocated array of crate::lightning::util::errors::APIErrors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_APIErrorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKAPIError *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_APIErrorZ;

/**
 * The contents of CResult__u832APIErrorZ
 */
typedef union LDKCResult__u832APIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult__u832APIErrorZPtr;

/**
 * A CResult__u832APIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult__u832APIErrorZ {
   /**
    * The contents of this CResult__u832APIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult__u832APIErrorZPtr contents;
   /**
    * Whether this CResult__u832APIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult__u832APIErrorZ;

/**
 * If a payment fails to send, it can be in one of several states. This enum is returned as the
 * Err() type describing which state the payment is in, see the description of individual enum
 * states for more.
 */
typedef enum LDKPaymentSendFailure_Tag {
   /**
    * A parameter which was passed to send_payment was invalid, preventing us from attempting to
    * send the payment at all.
    *
    * You can freely resend the payment in full (with the parameter error fixed).
    *
    * Because the payment failed outright, no payment tracking is done, you do not need to call
    * [`ChannelManager::abandon_payment`] and [`ChannelManager::retry_payment`] will *not* work
    * for this payment.
    */
   LDKPaymentSendFailure_ParameterError,
   /**
    * A parameter in a single path which was passed to send_payment was invalid, preventing us
    * from attempting to send the payment at all.
    *
    * You can freely resend the payment in full (with the parameter error fixed).
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment.
    *
    * Because the payment failed outright, no payment tracking is done, you do not need to call
    * [`ChannelManager::abandon_payment`] and [`ChannelManager::retry_payment`] will *not* work
    * for this payment.
    */
   LDKPaymentSendFailure_PathParameterError,
   /**
    * All paths which were attempted failed to send, with no channel state change taking place.
    * You can freely resend the payment in full (though you probably want to do so over different
    * paths than the ones selected).
    *
    * Because the payment failed outright, no payment tracking is done, you do not need to call
    * [`ChannelManager::abandon_payment`] and [`ChannelManager::retry_payment`] will *not* work
    * for this payment.
    */
   LDKPaymentSendFailure_AllFailedResendSafe,
   /**
    * Indicates that a payment for the provided [`PaymentId`] is already in-flight and has not
    * yet completed (i.e. generated an [`Event::PaymentSent`]) or been abandoned (via
    * [`ChannelManager::abandon_payment`]).
    *
    * [`Event::PaymentSent`]: events::Event::PaymentSent
    */
   LDKPaymentSendFailure_DuplicatePayment,
   /**
    * Some paths which were attempted failed to send, though possibly not all. At least some
    * paths have irrevocably committed to the HTLC and retrying the payment in full would result
    * in over-/re-payment.
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment, and any `Err`s which are not [`APIError::MonitorUpdateInProgress`] can be
    * safely retried via [`ChannelManager::retry_payment`].
    *
    * Any entries which contain `Err(APIError::MonitorUpdateInprogress)` or `Ok(())` MUST NOT be
    * retried as they will result in over-/re-payment. These HTLCs all either successfully sent
    * (in the case of `Ok(())`) or will send once a [`MonitorEvent::Completed`] is provided for
    * the next-hop channel with the latest update_id.
    */
   LDKPaymentSendFailure_PartialFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentSendFailure_Sentinel,
} LDKPaymentSendFailure_Tag;

typedef struct LDKPaymentSendFailure_LDKPartialFailure_Body {
   /**
    * The errors themselves, in the same order as the route hops.
    */
   struct LDKCVec_CResult_NoneAPIErrorZZ results;
   /**
    * If some paths failed without irrevocably committing to the new HTLC(s), this will
    * contain a [`RouteParameters`] object which can be used to calculate a new route that
    * will pay all remaining unpaid balance.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKRouteParameters failed_paths_retry;
   /**
    * The payment id for the payment, which is now at least partially pending.
    */
   struct LDKThirtyTwoBytes payment_id;
} LDKPaymentSendFailure_LDKPartialFailure_Body;

typedef struct MUST_USE_STRUCT LDKPaymentSendFailure {
   LDKPaymentSendFailure_Tag tag;
   union {
      struct {
         struct LDKAPIError parameter_error;
      };
      struct {
         struct LDKCVec_CResult_NoneAPIErrorZZ path_parameter_error;
      };
      struct {
         struct LDKCVec_APIErrorZ all_failed_resend_safe;
      };
      LDKPaymentSendFailure_LDKPartialFailure_Body partial_failure;
   };
} LDKPaymentSendFailure;

/**
 * The contents of CResult_NonePaymentSendFailureZ
 */
typedef union LDKCResult_NonePaymentSendFailureZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_NonePaymentSendFailureZPtr;

/**
 * A CResult_NonePaymentSendFailureZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePaymentSendFailureZ {
   /**
    * The contents of this CResult_NonePaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_NonePaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePaymentSendFailureZ;

/**
 * The contents of CResult_PaymentHashPaymentSendFailureZ
 */
typedef union LDKCResult_PaymentHashPaymentSendFailureZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_PaymentHashPaymentSendFailureZPtr;

/**
 * A CResult_PaymentHashPaymentSendFailureZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentHashPaymentSendFailureZ {
   /**
    * The contents of this CResult_PaymentHashPaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentHashPaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_PaymentHashPaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentHashPaymentSendFailureZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PaymentHashPaymentIdZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
} LDKC2Tuple_PaymentHashPaymentIdZ;

/**
 * The contents of CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
 */
typedef union LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_PaymentHashPaymentIdZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZPtr;

/**
 * A CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentIdZ on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ {
   /**
    * The contents of this CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ;

/**
 * A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ThirtyTwoBytesZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKThirtyTwoBytes *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ThirtyTwoBytesZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PaymentHashPaymentSecretZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
} LDKC2Tuple_PaymentHashPaymentSecretZ;

/**
 * The contents of CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ
 */
typedef union LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_PaymentHashPaymentSecretZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZPtr;

/**
 * A CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentSecretZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ;

/**
 * The contents of CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
 */
typedef union LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_PaymentHashPaymentSecretZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZPtr;

/**
 * A CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentSecretZ on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ {
   /**
    * The contents of this CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ;

/**
 * The contents of CResult_PaymentSecretNoneZ
 */
typedef union LDKCResult_PaymentSecretNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_PaymentSecretNoneZPtr;

/**
 * A CResult_PaymentSecretNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentSecretNoneZ {
   /**
    * The contents of this CResult_PaymentSecretNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentSecretNoneZPtr contents;
   /**
    * Whether this CResult_PaymentSecretNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentSecretNoneZ;

/**
 * The contents of CResult_PaymentSecretAPIErrorZ
 */
typedef union LDKCResult_PaymentSecretAPIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_PaymentSecretAPIErrorZPtr;

/**
 * A CResult_PaymentSecretAPIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentSecretAPIErrorZ {
   /**
    * The contents of this CResult_PaymentSecretAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentSecretAPIErrorZPtr contents;
   /**
    * Whether this CResult_PaymentSecretAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentSecretAPIErrorZ;

/**
 * The contents of CResult_PaymentPreimageAPIErrorZ
 */
typedef union LDKCResult_PaymentPreimageAPIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_PaymentPreimageAPIErrorZPtr;

/**
 * A CResult_PaymentPreimageAPIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentPreimageAPIErrorZ {
   /**
    * The contents of this CResult_PaymentPreimageAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentPreimageAPIErrorZPtr contents;
   /**
    * Whether this CResult_PaymentPreimageAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentPreimageAPIErrorZ;



/**
 * Information needed for constructing an invoice route hint for this channel.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyForwardingInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyForwardingInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyForwardingInfo;

/**
 * The contents of CResult_CounterpartyForwardingInfoDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyForwardingInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr;

/**
 * A CResult_CounterpartyForwardingInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::CounterpartyForwardingInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyForwardingInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyForwardingInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyForwardingInfoDecodeErrorZ;



/**
 * Channel parameters which apply to our counterparty. These are split out from [`ChannelDetails`]
 * to better separate parameters.
 */
typedef struct MUST_USE_STRUCT LDKChannelCounterparty {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelCounterparty *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelCounterparty;

/**
 * The contents of CResult_ChannelCounterpartyDecodeErrorZ
 */
typedef union LDKCResult_ChannelCounterpartyDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelCounterparty *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelCounterpartyDecodeErrorZPtr;

/**
 * A CResult_ChannelCounterpartyDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::ChannelCounterparty on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelCounterpartyDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelCounterpartyDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelCounterpartyDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelCounterpartyDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelCounterpartyDecodeErrorZ;

/**
 * The contents of CResult_ChannelDetailsDecodeErrorZ
 */
typedef union LDKCResult_ChannelDetailsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelDetails *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelDetailsDecodeErrorZPtr;

/**
 * A CResult_ChannelDetailsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::ChannelDetails on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelDetailsDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelDetailsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelDetailsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelDetailsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelDetailsDecodeErrorZ;



/**
 * Route hints used in constructing invoices for [phantom node payents].
 *
 * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
 */
typedef struct MUST_USE_STRUCT LDKPhantomRouteHints {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePhantomRouteHints *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPhantomRouteHints;

/**
 * The contents of CResult_PhantomRouteHintsDecodeErrorZ
 */
typedef union LDKCResult_PhantomRouteHintsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPhantomRouteHints *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PhantomRouteHintsDecodeErrorZPtr;

/**
 * A CResult_PhantomRouteHintsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::PhantomRouteHints on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PhantomRouteHintsDecodeErrorZ {
   /**
    * The contents of this CResult_PhantomRouteHintsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PhantomRouteHintsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PhantomRouteHintsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PhantomRouteHintsDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::ChannelMonitors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ChannelMonitorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKChannelMonitor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ChannelMonitorZ;



/**
 * An update generated by the underlying channel itself which contains some new information the
 * [`ChannelMonitor`] should be made aware of.
 *
 * Because this represents only a small number of updates to the underlying state, it is generally
 * much smaller than a full [`ChannelMonitor`]. However, for large single commitment transaction
 * updates (e.g. ones during which there are hundreds of HTLCs pending on the commitment
 * transaction), a single update may reach upwards of 1 MiB in serialized size.
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitorUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitorUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitorUpdate;

/**
 * The `Watch` trait defines behavior for watching on-chain activity pertaining to channels as
 * blocks are connected and disconnected.
 *
 * Each channel is associated with a [`ChannelMonitor`]. Implementations of this trait are
 * responsible for maintaining a set of monitors such that they can be updated accordingly as
 * channel state changes and HTLCs are resolved. See method documentation for specific
 * requirements.
 *
 * Implementations **must** ensure that updates are successfully applied and persisted upon method
 * completion. If an update fails with a [`PermanentFailure`], then it must immediately shut down
 * without taking any further action such as persisting the current state.
 *
 * If an implementation maintains multiple instances of a channel's monitor (e.g., by storing
 * backup copies), then it must ensure that updates are applied across all instances. Otherwise, it
 * could result in a revoked transaction being broadcast, allowing the counterparty to claim all
 * funds in the channel. See [`ChannelMonitorUpdateStatus`] for more details about how to handle
 * multiple instances.
 *
 * [`PermanentFailure`]: ChannelMonitorUpdateStatus::PermanentFailure
 */
typedef struct LDKWatch {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Watches a channel identified by `funding_txo` using `monitor`.
    *
    * Implementations are responsible for watching the chain for the funding transaction along
    * with any spends of outputs returned by [`get_outputs_to_watch`]. In practice, this means
    * calling [`block_connected`] and [`block_disconnected`] on the monitor.
    *
    * Note: this interface MUST error with [`ChannelMonitorUpdateStatus::PermanentFailure`] if
    * the given `funding_txo` has previously been registered via `watch_channel`.
    *
    * [`get_outputs_to_watch`]: channelmonitor::ChannelMonitor::get_outputs_to_watch
    * [`block_connected`]: channelmonitor::ChannelMonitor::block_connected
    * [`block_disconnected`]: channelmonitor::ChannelMonitor::block_disconnected
    */
   enum LDKChannelMonitorUpdateStatus (*watch_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitor monitor);
   /**
    * Updates a channel identified by `funding_txo` by applying `update` to its monitor.
    *
    * Implementations must call [`update_monitor`] with the given update. See
    * [`ChannelMonitorUpdateStatus`] for invariants around returning an error.
    *
    * [`update_monitor`]: channelmonitor::ChannelMonitor::update_monitor
    */
   enum LDKChannelMonitorUpdateStatus (*update_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitorUpdate update);
   /**
    * Returns any monitor events since the last call. Subsequent calls must only return new
    * events.
    *
    * Note that after any block- or transaction-connection calls to a [`ChannelMonitor`], no
    * further events may be returned here until the [`ChannelMonitor`] has been fully persisted
    * to disk.
    *
    * For details on asynchronous [`ChannelMonitor`] updating and returning
    * [`MonitorEvent::Completed`] here, see [`ChannelMonitorUpdateStatus::InProgress`].
    */
   struct LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ (*release_pending_monitor_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWatch;

/**
 * An interface to send a transaction to the Bitcoin network.
 */
typedef struct LDKBroadcasterInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Sends a transaction out to (hopefully) be mined.
    */
   void (*broadcast_transaction)(const void *this_arg, struct LDKTransaction tx);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKBroadcasterInterface;

/**
 * A "slice" referencing some byte array. This is simply a length-tagged pointer which does not
 * own the memory pointed to by data.
 */
typedef struct LDKu8slice {
   /**
    * A pointer to the byte buffer
    */
   const uint8_t *data;
   /**
    * The number of bytes pointed to by `data`.
    */
   uintptr_t datalen;
} LDKu8slice;

/**
 * A trait to describe an object which can get user secrets and key material.
 */
typedef struct LDKKeysInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Get node secret key based on the provided [`Recipient`].
    *
    * The `node_id`/`network_key` is the public key that corresponds to this secret key.
    *
    * This method must return the same value each time it is called with a given [`Recipient`]
    * parameter.
    *
    * Errors if the [`Recipient`] variant is not supported by the implementation.
    */
   struct LDKCResult_SecretKeyNoneZ (*get_node_secret)(const void *this_arg, enum LDKRecipient recipient);
   /**
    * Get node id based on the provided [`Recipient`]. This public key corresponds to the secret in
    * [`get_node_secret`].
    *
    * This method must return the same value each time it is called with a given [`Recipient`]
    * parameter.
    *
    * Errors if the [`Recipient`] variant is not supported by the implementation.
    *
    * [`get_node_secret`]: Self::get_node_secret
    */
   struct LDKCResult_PublicKeyNoneZ (*get_node_id)(const void *this_arg, enum LDKRecipient recipient);
   /**
    * Gets the ECDH shared secret of our [`node secret`] and `other_key`, multiplying by `tweak` if
    * one is provided. Note that this tweak can be applied to `other_key` instead of our node
    * secret, though this is less efficient.
    *
    * Errors if the [`Recipient`] variant is not supported by the implementation.
    *
    * [`node secret`]: Self::get_node_secret
    */
   struct LDKCResult_SharedSecretNoneZ (*ecdh)(const void *this_arg, enum LDKRecipient recipient, struct LDKPublicKey other_key, struct LDKCOption_ScalarZ tweak);
   /**
    * Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKCVec_u8Z (*get_destination_script)(const void *this_arg);
   /**
    * Get a script pubkey which we will send funds to when closing a channel.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKShutdownScript (*get_shutdown_scriptpubkey)(const void *this_arg);
   /**
    * Get a new set of [`Sign`] for per-channel secrets. These MUST be unique even if you
    * restarted with some stale data!
    *
    * This method must return a different value each time it is called.
    */
   struct LDKThirtyTwoBytes (*generate_channel_keys_id)(const void *this_arg, bool inbound, uint64_t channel_value_satoshis, struct LDKU128 user_channel_id);
   /**
    * Derives the private key material backing a `Signer`.
    *
    * To derive a new `Signer`, a fresh `channel_keys_id` should be obtained through
    * [`KeysInterface::generate_channel_keys_id`]. Otherwise, an existing `Signer` can be
    * re-derived from its `channel_keys_id`, which can be obtained through its trait method
    * [`BaseSign::channel_keys_id`].
    */
   struct LDKSign (*derive_channel_signer)(const void *this_arg, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id);
   /**
    * Gets a unique, cryptographically-secure, random 32 byte value. This is used for encrypting
    * onion packets and for temporary channel IDs. There is no requirement that these be
    * persisted anywhere, though they must be unique across restarts.
    *
    * This method must return a different value each time it is called.
    */
   struct LDKThirtyTwoBytes (*get_secure_random_bytes)(const void *this_arg);
   /**
    * Reads a [`Signer`] for this [`KeysInterface`] from the given input stream.
    * This is only called during deserialization of other objects which contain
    * [`Sign`]-implementing objects (i.e., [`ChannelMonitor`]s and [`ChannelManager`]s).
    * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
    * contain no versioning scheme. You may wish to include your own version prefix and ensure
    * you've read all of the provided bytes to ensure no corruption occurred.
    *
    * This method is slowly being phased out -- it will only be called when reading objects
    * written by LDK versions prior to 0.0.113.
    *
    * [`Signer`]: Self::Signer
    * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   struct LDKCResult_SignDecodeErrorZ (*read_chan_signer)(const void *this_arg, struct LDKu8slice reader);
   /**
    * Sign an invoice.
    * By parameterizing by the raw invoice bytes instead of the hash, we allow implementors of
    * this trait to parse the invoice and make sure they're signing what they expect, rather than
    * blindly signing the hash.
    * The `hrp` is ASCII bytes, while the invoice data is base32-encoded.
    *
    * The secret key used to sign the invoice is dependent on the [`Recipient`].
    *
    * Errors if the [`Recipient`] variant is not supported by the implementation.
    */
   struct LDKCResult_RecoverableSignatureNoneZ (*sign_invoice)(const void *this_arg, struct LDKu8slice hrp_bytes, struct LDKCVec_U5Z invoice_data, enum LDKRecipient receipient);
   /**
    * Get secret key material as bytes for use in encrypting and decrypting inbound payment data.
    *
    * If the implementor of this trait supports [phantom node payments], then every node that is
    * intended to be included in the phantom invoice route hints must return the same value from
    * this method.
    *
    * This method must return the same value each time it is called.
    *
    * [phantom node payments]: PhantomKeysManager
    */
   struct LDKThirtyTwoBytes (*get_inbound_payment_key_material)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKKeysInterface;

/**
 * A trait which should be implemented to provide feerate information on a number of time
 * horizons.
 *
 * Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're
 * called from inside the library in response to chain events, P2P events, or timer events).
 */
typedef struct LDKFeeEstimator {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets estimated satoshis of fee required per 1000 Weight-Units.
    *
    * LDK will wrap this method and ensure that the value returned is no smaller than 253
    * (ie 1 satoshi-per-byte rounded up to ensure later round-downs don't put us below 1 satoshi-per-byte).
    *
    * The following unit conversions can be used to convert to sats/KW:
    *  * satoshis-per-byte * 250
    *  * satoshis-per-kbyte / 4
    */
   uint32_t (*get_est_sat_per_1000_weight)(const void *this_arg, enum LDKConfirmationTarget confirmation_target);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFeeEstimator;



/**
 * Manager which keeps track of a number of channels and sends messages to the appropriate
 * channel, also tracking HTLC preimages and forwarding onion packets appropriately.
 *
 * Implements ChannelMessageHandler, handling the multi-channel parts and passing things through
 * to individual Channels.
 *
 * Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for
 * all peers during write/read (though does not modify this instance, only the instance being
 * serialized). This will result in any channels which have not yet exchanged funding_created (ie
 * called funding_transaction_generated for outbound channels).
 *
 * Note that you can be a bit lazier about writing out ChannelManager than you can be with
 * ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before
 * returning from chain::Watch::watch_/update_channel, with ChannelManagers, writing updates
 * happens out-of-band (and will prevent any other ChannelManager operations from occurring during
 * the serialization process). If the deserialized version is out-of-date compared to the
 * ChannelMonitors passed by reference to read(), those channels will be force-closed based on the
 * ChannelMonitor state and no funds will be lost (mod on-chain transaction fees).
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelManager), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call
 * block_connected() to step towards your best block) upon deserialization before using the
 * object!
 *
 * Note that ChannelManager is responsible for tracking liveness of its channels and generating
 * ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid
 * spam due to quick disconnection/reconnection, updates are not sent until the channel has been
 * offline for a full minute. In order to track this, you must call
 * timer_tick_occurred roughly once per minute, though it doesn't have to be perfect.
 *
 * Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager
 * a SimpleRefChannelManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefChannelManager, and use a
 * SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 */
typedef struct MUST_USE_STRUCT LDKChannelManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManager;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_BlockHashChannelManagerZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKChannelManager b;
} LDKC2Tuple_BlockHashChannelManagerZ;

/**
 * The contents of CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
 */
typedef union LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_BlockHashChannelManagerZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr;

/**
 * A CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_BlockHashChannelManagerZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ {
   /**
    * The contents of this CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ;



/**
 * Options which apply on a per-channel basis and may change at runtime or based on negotiation
 * with our counterparty.
 */
typedef struct MUST_USE_STRUCT LDKChannelConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelConfig;

/**
 * The contents of CResult_ChannelConfigDecodeErrorZ
 */
typedef union LDKCResult_ChannelConfigDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelConfig *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelConfigDecodeErrorZPtr;

/**
 * A CResult_ChannelConfigDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::config::ChannelConfig on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelConfigDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelConfigDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelConfigDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelConfigDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelConfigDecodeErrorZ;

/**
 * The contents of CResult_OutPointDecodeErrorZ
 */
typedef union LDKCResult_OutPointDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOutPoint *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OutPointDecodeErrorZPtr;

/**
 * A CResult_OutPointDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::transaction::OutPoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OutPointDecodeErrorZ {
   /**
    * The contents of this CResult_OutPointDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OutPointDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OutPointDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OutPointDecodeErrorZ;

/**
 * Defines a type identifier for sending messages over the wire.
 *
 * Messages implementing this trait specify a type and must be [`Writeable`].
 */
typedef struct LDKType {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the type identifying the message payload.
    */
   uint16_t (*type_id)(const void *this_arg);
   /**
    * Return a human-readable "debug" string describing this object
    */
   struct LDKStr (*debug_str)(const void *this_arg);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Called, if set, after this Type has been cloned into a duplicate object.
    * The new Type is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKType *NONNULL_PTR new_Type);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKType;

/**
 * An enum which can either contain a crate::lightning::ln::wire::Type or not
 */
typedef enum LDKCOption_TypeZ_Tag {
   /**
    * When we're in this state, this COption_TypeZ contains a crate::lightning::ln::wire::Type
    */
   LDKCOption_TypeZ_Some,
   /**
    * When we're in this state, this COption_TypeZ contains nothing
    */
   LDKCOption_TypeZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_TypeZ_Sentinel,
} LDKCOption_TypeZ_Tag;

typedef struct LDKCOption_TypeZ {
   LDKCOption_TypeZ_Tag tag;
   union {
      struct {
         struct LDKType some;
      };
   };
} LDKCOption_TypeZ;

/**
 * The contents of CResult_COption_TypeZDecodeErrorZ
 */
typedef union LDKCResult_COption_TypeZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_TypeZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_TypeZDecodeErrorZPtr;

/**
 * A CResult_COption_TypeZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_TypeZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_TypeZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_TypeZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_TypeZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_TypeZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_TypeZDecodeErrorZ;

/**
 * An error that may occur when making a payment.
 */
typedef enum LDKPaymentError_Tag {
   /**
    * An error resulting from the provided [`Invoice`] or payment hash.
    */
   LDKPaymentError_Invoice,
   /**
    * An error occurring when finding a route.
    */
   LDKPaymentError_Routing,
   /**
    * An error occurring when sending a payment.
    */
   LDKPaymentError_Sending,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentError_Sentinel,
} LDKPaymentError_Tag;

typedef struct MUST_USE_STRUCT LDKPaymentError {
   LDKPaymentError_Tag tag;
   union {
      struct {
         struct LDKStr invoice;
      };
      struct {
         struct LDKLightningError routing;
      };
      struct {
         struct LDKPaymentSendFailure sending;
      };
   };
} LDKPaymentError;

/**
 * The contents of CResult_PaymentIdPaymentErrorZ
 */
typedef union LDKCResult_PaymentIdPaymentErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentError *err;
} LDKCResult_PaymentIdPaymentErrorZPtr;

/**
 * A CResult_PaymentIdPaymentErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning_invoice::payment::PaymentError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentIdPaymentErrorZ {
   /**
    * The contents of this CResult_PaymentIdPaymentErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentIdPaymentErrorZPtr contents;
   /**
    * Whether this CResult_PaymentIdPaymentErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentIdPaymentErrorZ;

/**
 * The contents of CResult_NonePaymentErrorZ
 */
typedef union LDKCResult_NonePaymentErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentError *err;
} LDKCResult_NonePaymentErrorZPtr;

/**
 * A CResult_NonePaymentErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning_invoice::payment::PaymentError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePaymentErrorZ {
   /**
    * The contents of this CResult_NonePaymentErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePaymentErrorZPtr contents;
   /**
    * Whether this CResult_NonePaymentErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePaymentErrorZ;

/**
 * The contents of CResult_StringErrorZ
 */
typedef union LDKCResult_StringErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKStr *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_StringErrorZPtr;

/**
 * A CResult_StringErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::Str on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_StringErrorZ {
   /**
    * The contents of this CResult_StringErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_StringErrorZPtr contents;
   /**
    * Whether this CResult_StringErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_StringErrorZ;

/**
 * The contents of CResult_PublicKeyErrorZ
 */
typedef union LDKCResult_PublicKeyErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPublicKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_PublicKeyErrorZPtr;

/**
 * A CResult_PublicKeyErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::PublicKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PublicKeyErrorZ {
   /**
    * The contents of this CResult_PublicKeyErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PublicKeyErrorZPtr contents;
   /**
    * Whether this CResult_PublicKeyErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PublicKeyErrorZ;

/**
 * The contents of CResult_ChannelMonitorUpdateDecodeErrorZ
 */
typedef union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelMonitorUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr;

/**
 * A CResult_ChannelMonitorUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::channelmonitor::ChannelMonitorUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelMonitorUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelMonitorUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZ;

/**
 * An enum which can either contain a crate::lightning::chain::channelmonitor::MonitorEvent or not
 */
typedef enum LDKCOption_MonitorEventZ_Tag {
   /**
    * When we're in this state, this COption_MonitorEventZ contains a crate::lightning::chain::channelmonitor::MonitorEvent
    */
   LDKCOption_MonitorEventZ_Some,
   /**
    * When we're in this state, this COption_MonitorEventZ contains nothing
    */
   LDKCOption_MonitorEventZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_MonitorEventZ_Sentinel,
} LDKCOption_MonitorEventZ_Tag;

typedef struct LDKCOption_MonitorEventZ {
   LDKCOption_MonitorEventZ_Tag tag;
   union {
      struct {
         struct LDKMonitorEvent some;
      };
   };
} LDKCOption_MonitorEventZ;

/**
 * The contents of CResult_COption_MonitorEventZDecodeErrorZ
 */
typedef union LDKCResult_COption_MonitorEventZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_MonitorEventZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_MonitorEventZDecodeErrorZPtr;

/**
 * A CResult_COption_MonitorEventZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_MonitorEventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_MonitorEventZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_MonitorEventZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_MonitorEventZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_MonitorEventZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_MonitorEventZDecodeErrorZ;

/**
 * The contents of CResult_HTLCUpdateDecodeErrorZ
 */
typedef union LDKCResult_HTLCUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCUpdateDecodeErrorZPtr;

/**
 * A CResult_HTLCUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::channelmonitor::HTLCUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCUpdateDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_OutPointScriptZ {
   /**
    * The element at position 0
    */
   struct LDKOutPoint a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_OutPointScriptZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u32ScriptZ {
   /**
    * The element at position 0
    */
   uint32_t a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_u32ScriptZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32ScriptZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u32ScriptZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u32ScriptZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32ScriptZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCVec_C2Tuple_u32ScriptZZ b;
} LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ;

/**
 * A dynamically-allocated array of crate::lightning::util::events::Events of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_EventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_EventZ;

/**
 * A dynamically-allocated array of crate::c_types::Transactions of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TransactionZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKTransaction *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TransactionZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u32TxOutZ {
   /**
    * The element at position 0
    */
   uint32_t a;
   /**
    * The element at position 1
    */
   struct LDKTxOut b;
} LDKC2Tuple_u32TxOutZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32TxOutZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u32TxOutZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u32TxOutZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32TxOutZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCVec_C2Tuple_u32TxOutZZ b;
} LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TransactionOutputsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TransactionOutputsZ;

/**
 * Details about the balance(s) available for spending once the channel appears on chain.
 *
 * See [`ChannelMonitor::get_claimable_balances`] for more details on when these will or will not
 * be provided.
 */
typedef enum LDKBalance_Tag {
   /**
    * The channel is not yet closed (or the commitment or closing transaction has not yet
    * appeared in a block). The given balance is claimable (less on-chain fees) if the channel is
    * force-closed now.
    */
   LDKBalance_ClaimableOnChannelClose,
   /**
    * The channel has been closed, and the given balance is ours but awaiting confirmations until
    * we consider it spendable.
    */
   LDKBalance_ClaimableAwaitingConfirmations,
   /**
    * The channel has been closed, and the given balance should be ours but awaiting spending
    * transaction confirmation. If the spending transaction does not confirm in time, it is
    * possible our counterparty can take the funds by broadcasting an HTLC timeout on-chain.
    *
    * Once the spending transaction confirms, before it has reached enough confirmations to be
    * considered safe from chain reorganizations, the balance will instead be provided via
    * [`Balance::ClaimableAwaitingConfirmations`].
    */
   LDKBalance_ContentiousClaimable,
   /**
    * HTLCs which we sent to our counterparty which are claimable after a timeout (less on-chain
    * fees) if the counterparty does not know the preimage for the HTLCs. These are somewhat
    * likely to be claimed by our counterparty before we do.
    */
   LDKBalance_MaybeTimeoutClaimableHTLC,
   /**
    * HTLCs which we received from our counterparty which are claimable with a preimage which we
    * do not currently have. This will only be claimable if we receive the preimage from the node
    * to which we forwarded this HTLC before the timeout.
    */
   LDKBalance_MaybePreimageClaimableHTLC,
   /**
    * The channel has been closed, and our counterparty broadcasted a revoked commitment
    * transaction.
    *
    * Thus, we're able to claim all outputs in the commitment transaction, one of which has the
    * following amount.
    */
   LDKBalance_CounterpartyRevokedOutputClaimable,
   /**
    * Must be last for serialization purposes
    */
   LDKBalance_Sentinel,
} LDKBalance_Tag;

typedef struct LDKBalance_LDKClaimableOnChannelClose_Body {
   /**
    * The amount available to claim, in satoshis, excluding the on-chain fees which will be
    * required to do so.
    */
   uint64_t claimable_amount_satoshis;
} LDKBalance_LDKClaimableOnChannelClose_Body;

typedef struct LDKBalance_LDKClaimableAwaitingConfirmations_Body {
   /**
    * The amount available to claim, in satoshis, possibly excluding the on-chain fees which
    * were spent in broadcasting the transaction.
    */
   uint64_t claimable_amount_satoshis;
   /**
    * The height at which an [`Event::SpendableOutputs`] event will be generated for this
    * amount.
    */
   uint32_t confirmation_height;
} LDKBalance_LDKClaimableAwaitingConfirmations_Body;

typedef struct LDKBalance_LDKContentiousClaimable_Body {
   /**
    * The amount available to claim, in satoshis, excluding the on-chain fees which will be
    * required to do so.
    */
   uint64_t claimable_amount_satoshis;
   /**
    * The height at which the counterparty may be able to claim the balance if we have not
    * done so.
    */
   uint32_t timeout_height;
} LDKBalance_LDKContentiousClaimable_Body;

typedef struct LDKBalance_LDKMaybeTimeoutClaimableHTLC_Body {
   /**
    * The amount potentially available to claim, in satoshis, excluding the on-chain fees
    * which will be required to do so.
    */
   uint64_t claimable_amount_satoshis;
   /**
    * The height at which we will be able to claim the balance if our counterparty has not
    * done so.
    */
   uint32_t claimable_height;
} LDKBalance_LDKMaybeTimeoutClaimableHTLC_Body;

typedef struct LDKBalance_LDKMaybePreimageClaimableHTLC_Body {
   /**
    * The amount potentially available to claim, in satoshis, excluding the on-chain fees
    * which will be required to do so.
    */
   uint64_t claimable_amount_satoshis;
   /**
    * The height at which our counterparty will be able to claim the balance if we have not
    * yet received the preimage and claimed it ourselves.
    */
   uint32_t expiry_height;
} LDKBalance_LDKMaybePreimageClaimableHTLC_Body;

typedef struct LDKBalance_LDKCounterpartyRevokedOutputClaimable_Body {
   /**
    * The amount, in satoshis, of the output which we can claim.
    *
    * Note that for outputs from HTLC balances this may be excluding some on-chain fees that
    * were already spent.
    */
   uint64_t claimable_amount_satoshis;
} LDKBalance_LDKCounterpartyRevokedOutputClaimable_Body;

typedef struct MUST_USE_STRUCT LDKBalance {
   LDKBalance_Tag tag;
   union {
      LDKBalance_LDKClaimableOnChannelClose_Body claimable_on_channel_close;
      LDKBalance_LDKClaimableAwaitingConfirmations_Body claimable_awaiting_confirmations;
      LDKBalance_LDKContentiousClaimable_Body contentious_claimable;
      LDKBalance_LDKMaybeTimeoutClaimableHTLC_Body maybe_timeout_claimable_htlc;
      LDKBalance_LDKMaybePreimageClaimableHTLC_Body maybe_preimage_claimable_htlc;
      LDKBalance_LDKCounterpartyRevokedOutputClaimable_Body counterparty_revoked_output_claimable;
   };
} LDKBalance;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::Balances of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_BalanceZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKBalance *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_BalanceZ;

/**
 * The contents of CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
 */
typedef union LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_BlockHashChannelMonitorZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr;

/**
 * A CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_BlockHashChannelMonitorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ {
   /**
    * The contents of this CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PublicKeyTypeZ {
   /**
    * The element at position 0
    */
   struct LDKPublicKey a;
   /**
    * The element at position 1
    */
   struct LDKType b;
} LDKC2Tuple_PublicKeyTypeZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyTypeZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_PublicKeyTypeZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_PublicKeyTypeZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_PublicKeyTypeZZ;

/**
 * The contents of a custom onion message.
 */
typedef struct LDKCustomOnionMessageContents {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the TLV type identifying the message contents. MUST be >= 64.
    */
   uint64_t (*tlv_type)(const void *this_arg);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Called, if set, after this CustomOnionMessageContents has been cloned into a duplicate object.
    * The new CustomOnionMessageContents is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKCustomOnionMessageContents *NONNULL_PTR new_CustomOnionMessageContents);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomOnionMessageContents;

/**
 * An enum which can either contain a crate::lightning::onion_message::packet::CustomOnionMessageContents or not
 */
typedef enum LDKCOption_CustomOnionMessageContentsZ_Tag {
   /**
    * When we're in this state, this COption_CustomOnionMessageContentsZ contains a crate::lightning::onion_message::packet::CustomOnionMessageContents
    */
   LDKCOption_CustomOnionMessageContentsZ_Some,
   /**
    * When we're in this state, this COption_CustomOnionMessageContentsZ contains nothing
    */
   LDKCOption_CustomOnionMessageContentsZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_CustomOnionMessageContentsZ_Sentinel,
} LDKCOption_CustomOnionMessageContentsZ_Tag;

typedef struct LDKCOption_CustomOnionMessageContentsZ {
   LDKCOption_CustomOnionMessageContentsZ_Tag tag;
   union {
      struct {
         struct LDKCustomOnionMessageContents some;
      };
   };
} LDKCOption_CustomOnionMessageContentsZ;

/**
 * The contents of CResult_COption_CustomOnionMessageContentsZDecodeErrorZ
 */
typedef union LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_CustomOnionMessageContentsZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZPtr;

/**
 * A CResult_COption_CustomOnionMessageContentsZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_CustomOnionMessageContentsZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_CustomOnionMessageContentsZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_CustomOnionMessageContentsZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ;

/**
 * An enum which can either contain a crate::lightning::ln::msgs::NetAddress or not
 */
typedef enum LDKCOption_NetAddressZ_Tag {
   /**
    * When we're in this state, this COption_NetAddressZ contains a crate::lightning::ln::msgs::NetAddress
    */
   LDKCOption_NetAddressZ_Some,
   /**
    * When we're in this state, this COption_NetAddressZ contains nothing
    */
   LDKCOption_NetAddressZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_NetAddressZ_Sentinel,
} LDKCOption_NetAddressZ_Tag;

typedef struct LDKCOption_NetAddressZ {
   LDKCOption_NetAddressZ_Tag tag;
   union {
      struct {
         struct LDKNetAddress some;
      };
   };
} LDKCOption_NetAddressZ;



/**
 * Error for PeerManager errors. If you get one of these, you must disconnect the socket and
 * generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
 * descriptor.
 */
typedef struct MUST_USE_STRUCT LDKPeerHandleError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerHandleError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerHandleError;

/**
 * The contents of CResult_CVec_u8ZPeerHandleErrorZ
 */
typedef union LDKCResult_CVec_u8ZPeerHandleErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_u8Z *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_CVec_u8ZPeerHandleErrorZPtr;

/**
 * A CResult_CVec_u8ZPeerHandleErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_u8Z on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_u8ZPeerHandleErrorZ {
   /**
    * The contents of this CResult_CVec_u8ZPeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_u8ZPeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_CVec_u8ZPeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_u8ZPeerHandleErrorZ;

/**
 * The contents of CResult_NonePeerHandleErrorZ
 */
typedef union LDKCResult_NonePeerHandleErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_NonePeerHandleErrorZPtr;

/**
 * A CResult_NonePeerHandleErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePeerHandleErrorZ {
   /**
    * The contents of this CResult_NonePeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_NonePeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePeerHandleErrorZ;

/**
 * The contents of CResult_boolPeerHandleErrorZ
 */
typedef union LDKCResult_boolPeerHandleErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   bool *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_boolPeerHandleErrorZPtr;

/**
 * A CResult_boolPeerHandleErrorZ represents the result of a fallible operation,
 * containing a bool on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_boolPeerHandleErrorZ {
   /**
    * The contents of this CResult_boolPeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_boolPeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_boolPeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_boolPeerHandleErrorZ;

/**
 * Errors that may occur when [sending an onion message].
 *
 * [sending an onion message]: OnionMessenger::send_onion_message
 */
typedef enum LDKSendError_Tag {
   /**
    * Errored computing onion message packet keys.
    */
   LDKSendError_Secp256k1,
   /**
    * Because implementations such as Eclair will drop onion messages where the message packet
    * exceeds 32834 bytes, we refuse to send messages where the packet exceeds this size.
    */
   LDKSendError_TooBigPacket,
   /**
    * The provided [`Destination`] was an invalid [`BlindedPath`], due to having fewer than two
    * blinded hops.
    */
   LDKSendError_TooFewBlindedHops,
   /**
    * Our next-hop peer was offline or does not support onion message forwarding.
    */
   LDKSendError_InvalidFirstHop,
   /**
    * Onion message contents must have a TLV type >= 64.
    */
   LDKSendError_InvalidMessage,
   /**
    * Our next-hop peer's buffer was full or our total outbound buffer was full.
    */
   LDKSendError_BufferFull,
   /**
    * Failed to retrieve our node id from the provided [`KeysInterface`].
    *
    * [`KeysInterface`]: crate::chain::keysinterface::KeysInterface
    */
   LDKSendError_GetNodeIdFailed,
   /**
    * We attempted to send to a blinded path where we are the introduction node, and failed to
    * advance the blinded path to make the second hop the new introduction node. Either
    * [`KeysInterface::ecdh`] failed, we failed to tweak the current blinding point to get the
    * new blinding point, or we were attempting to send to ourselves.
    */
   LDKSendError_BlindedPathAdvanceFailed,
   /**
    * Must be last for serialization purposes
    */
   LDKSendError_Sentinel,
} LDKSendError_Tag;

typedef struct MUST_USE_STRUCT LDKSendError {
   LDKSendError_Tag tag;
   union {
      struct {
         enum LDKSecp256k1Error secp256k1;
      };
   };
} LDKSendError;

/**
 * The contents of CResult_NoneSendErrorZ
 */
typedef union LDKCResult_NoneSendErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKSendError *err;
} LDKCResult_NoneSendErrorZPtr;

/**
 * A CResult_NoneSendErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::onion_message::messenger::SendError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneSendErrorZ {
   /**
    * The contents of this CResult_NoneSendErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneSendErrorZPtr contents;
   /**
    * Whether this CResult_NoneSendErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneSendErrorZ;

/**
 * Sub-errors which don't have specific information in them use this type.
 */
typedef struct LDKError {
   /**
    * Zero-Sized_types aren't consistent across Rust/C/C++, so we add some size here
    */
   uint8_t _dummy;
} LDKError;

/**
 * Errors that indicate what is wrong with the invoice. They have some granularity for debug
 * reasons, but should generally result in an \"invalid BOLT11 invoice\" message for the user.
 */
typedef enum LDKParseError_Tag {
   LDKParseError_Bech32Error,
   LDKParseError_ParseAmountError,
   LDKParseError_MalformedSignature,
   LDKParseError_BadPrefix,
   LDKParseError_UnknownCurrency,
   LDKParseError_UnknownSiPrefix,
   LDKParseError_MalformedHRP,
   LDKParseError_TooShortDataPart,
   LDKParseError_UnexpectedEndOfTaggedFields,
   LDKParseError_DescriptionDecodeError,
   LDKParseError_PaddingError,
   LDKParseError_IntegerOverflowError,
   LDKParseError_InvalidSegWitProgramLength,
   LDKParseError_InvalidPubKeyHashLength,
   LDKParseError_InvalidScriptHashLength,
   LDKParseError_InvalidRecoveryId,
   LDKParseError_InvalidSliceLength,
   /**
    * Not an error, but used internally to signal that a part of the invoice should be ignored
    * according to BOLT11
    */
   LDKParseError_Skip,
   /**
    * Must be last for serialization purposes
    */
   LDKParseError_Sentinel,
} LDKParseError_Tag;

typedef struct MUST_USE_STRUCT LDKParseError {
   LDKParseError_Tag tag;
   union {
      struct {
         struct LDKBech32Error bech32_error;
      };
      struct {
         struct LDKError parse_amount_error;
      };
      struct {
         enum LDKSecp256k1Error malformed_signature;
      };
      struct {
         struct LDKError description_decode_error;
      };
      struct {
         struct LDKStr invalid_slice_length;
      };
   };
} LDKParseError;

/**
 * The contents of CResult_SiPrefixParseErrorZ
 */
typedef union LDKCResult_SiPrefixParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   enum LDKSiPrefix *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKParseError *err;
} LDKCResult_SiPrefixParseErrorZPtr;

/**
 * A CResult_SiPrefixParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::SiPrefix on success and a crate::lightning_invoice::ParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SiPrefixParseErrorZ {
   /**
    * The contents of this CResult_SiPrefixParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SiPrefixParseErrorZPtr contents;
   /**
    * Whether this CResult_SiPrefixParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SiPrefixParseErrorZ;



/**
 * Represents a syntactically and semantically correct lightning BOLT11 invoice.
 *
 * There are three ways to construct an `Invoice`:
 *  1. using `InvoiceBuilder`
 *  2. using `Invoice::from_signed(SignedRawInvoice)`
 *  3. using `str::parse::<Invoice>(&str)`
 */
typedef struct MUST_USE_STRUCT LDKInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoice;

/**
 * Indicates that something went wrong while parsing or validating the invoice. Parsing errors
 * should be mostly seen as opaque and are only there for debugging reasons. Semantic errors
 * like wrong signatures, missing fields etc. could mean that someone tampered with the invoice.
 */
typedef enum LDKParseOrSemanticError_Tag {
   /**
    * The invoice couldn't be decoded
    */
   LDKParseOrSemanticError_ParseError,
   /**
    * The invoice could be decoded but violates the BOLT11 standard
    */
   LDKParseOrSemanticError_SemanticError,
   /**
    * Must be last for serialization purposes
    */
   LDKParseOrSemanticError_Sentinel,
} LDKParseOrSemanticError_Tag;

typedef struct MUST_USE_STRUCT LDKParseOrSemanticError {
   LDKParseOrSemanticError_Tag tag;
   union {
      struct {
         struct LDKParseError parse_error;
      };
      struct {
         enum LDKSemanticError semantic_error;
      };
   };
} LDKParseOrSemanticError;

/**
 * The contents of CResult_InvoiceParseOrSemanticErrorZ
 */
typedef union LDKCResult_InvoiceParseOrSemanticErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKParseOrSemanticError *err;
} LDKCResult_InvoiceParseOrSemanticErrorZPtr;

/**
 * A CResult_InvoiceParseOrSemanticErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::ParseOrSemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceParseOrSemanticErrorZ {
   /**
    * The contents of this CResult_InvoiceParseOrSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceParseOrSemanticErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceParseOrSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceParseOrSemanticErrorZ;



/**
 * Represents a signed `RawInvoice` with cached hash. The signature is not checked and may be
 * invalid.
 *
 * # Invariants
 * The hash has to be either from the deserialized invoice or from the serialized `raw_invoice`.
 */
typedef struct MUST_USE_STRUCT LDKSignedRawInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSignedRawInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSignedRawInvoice;

/**
 * The contents of CResult_SignedRawInvoiceParseErrorZ
 */
typedef union LDKCResult_SignedRawInvoiceParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSignedRawInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKParseError *err;
} LDKCResult_SignedRawInvoiceParseErrorZPtr;

/**
 * A CResult_SignedRawInvoiceParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::SignedRawInvoice on success and a crate::lightning_invoice::ParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignedRawInvoiceParseErrorZ {
   /**
    * The contents of this CResult_SignedRawInvoiceParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignedRawInvoiceParseErrorZPtr contents;
   /**
    * Whether this CResult_SignedRawInvoiceParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignedRawInvoiceParseErrorZ;



/**
 * Represents an syntactically correct Invoice for a payment on the lightning network,
 * but without the signature information.
 * De- and encoding should not lead to information loss but may lead to different hashes.
 *
 * For methods without docs see the corresponding methods in `Invoice`.
 */
typedef struct MUST_USE_STRUCT LDKRawInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRawInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRawInvoice;



/**
 * Recoverable signature
 */
typedef struct MUST_USE_STRUCT LDKInvoiceSignature {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceSignature *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceSignature;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ {
   /**
    * The element at position 0
    */
   struct LDKRawInvoice a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
   /**
    * The element at position 2
    */
   struct LDKInvoiceSignature c;
} LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ;



/**
 * Payee public key
 */
typedef struct MUST_USE_STRUCT LDKPayeePubKey {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePayeePubKey *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPayeePubKey;

/**
 * The contents of CResult_PayeePubKeyErrorZ
 */
typedef union LDKCResult_PayeePubKeyErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPayeePubKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_PayeePubKeyErrorZPtr;

/**
 * A CResult_PayeePubKeyErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PayeePubKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PayeePubKeyErrorZ {
   /**
    * The contents of this CResult_PayeePubKeyErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PayeePubKeyErrorZPtr contents;
   /**
    * Whether this CResult_PayeePubKeyErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PayeePubKeyErrorZ;



/**
 * Private routing information
 *
 * # Invariants
 * The encoded route has to be <1024 5bit characters long (<=639 bytes or <=12 hops)
 *
 */
typedef struct MUST_USE_STRUCT LDKPrivateRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePrivateRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPrivateRoute;

/**
 * A dynamically-allocated array of crate::lightning_invoice::PrivateRoutes of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PrivateRouteZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPrivateRoute *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PrivateRouteZ;



/**
 * A timestamp that refers to a date after 1 January 1970.
 *
 * # Invariants
 *
 * The Unix timestamp representing the stored time has to be positive and no greater than
 * [`MAX_TIMESTAMP`].
 */
typedef struct MUST_USE_STRUCT LDKPositiveTimestamp {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePositiveTimestamp *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPositiveTimestamp;

/**
 * The contents of CResult_PositiveTimestampCreationErrorZ
 */
typedef union LDKCResult_PositiveTimestampCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPositiveTimestamp *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_PositiveTimestampCreationErrorZPtr;

/**
 * A CResult_PositiveTimestampCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PositiveTimestamp on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PositiveTimestampCreationErrorZ {
   /**
    * The contents of this CResult_PositiveTimestampCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PositiveTimestampCreationErrorZPtr contents;
   /**
    * Whether this CResult_PositiveTimestampCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PositiveTimestampCreationErrorZ;

/**
 * The contents of CResult_NoneSemanticErrorZ
 */
typedef union LDKCResult_NoneSemanticErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSemanticError *err;
} LDKCResult_NoneSemanticErrorZPtr;

/**
 * A CResult_NoneSemanticErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning_invoice::SemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneSemanticErrorZ {
   /**
    * The contents of this CResult_NoneSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneSemanticErrorZPtr contents;
   /**
    * Whether this CResult_NoneSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneSemanticErrorZ;

/**
 * The contents of CResult_InvoiceSemanticErrorZ
 */
typedef union LDKCResult_InvoiceSemanticErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSemanticError *err;
} LDKCResult_InvoiceSemanticErrorZPtr;

/**
 * A CResult_InvoiceSemanticErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::SemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceSemanticErrorZ {
   /**
    * The contents of this CResult_InvoiceSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceSemanticErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceSemanticErrorZ;



/**
 * Description string
 *
 * # Invariants
 * The description can be at most 639 __bytes__ long
 */
typedef struct MUST_USE_STRUCT LDKDescription {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDescription *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDescription;

/**
 * The contents of CResult_DescriptionCreationErrorZ
 */
typedef union LDKCResult_DescriptionCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDescription *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_DescriptionCreationErrorZPtr;

/**
 * A CResult_DescriptionCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Description on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DescriptionCreationErrorZ {
   /**
    * The contents of this CResult_DescriptionCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DescriptionCreationErrorZPtr contents;
   /**
    * Whether this CResult_DescriptionCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DescriptionCreationErrorZ;

/**
 * The contents of CResult_PrivateRouteCreationErrorZ
 */
typedef union LDKCResult_PrivateRouteCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPrivateRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_PrivateRouteCreationErrorZPtr;

/**
 * A CResult_PrivateRouteCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PrivateRoute on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PrivateRouteCreationErrorZ {
   /**
    * The contents of this CResult_PrivateRouteCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PrivateRouteCreationErrorZPtr contents;
   /**
    * Whether this CResult_PrivateRouteCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PrivateRouteCreationErrorZ;

/**
 * All-encompassing standard error type that processing can return
 */
typedef enum LDKGraphSyncError_Tag {
   /**
    * Error trying to read the update data, typically due to an erroneous data length indication
    * that is greater than the actual amount of data provided
    */
   LDKGraphSyncError_DecodeError,
   /**
    * Error applying the patch to the network graph, usually the result of updates that are too
    * old or missing prerequisite data to the application of updates out of order
    */
   LDKGraphSyncError_LightningError,
   /**
    * Must be last for serialization purposes
    */
   LDKGraphSyncError_Sentinel,
} LDKGraphSyncError_Tag;

typedef struct MUST_USE_STRUCT LDKGraphSyncError {
   LDKGraphSyncError_Tag tag;
   union {
      struct {
         struct LDKDecodeError decode_error;
      };
      struct {
         struct LDKLightningError lightning_error;
      };
   };
} LDKGraphSyncError;

/**
 * The contents of CResult_u32GraphSyncErrorZ
 */
typedef union LDKCResult_u32GraphSyncErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   uint32_t *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKGraphSyncError *err;
} LDKCResult_u32GraphSyncErrorZPtr;

/**
 * A CResult_u32GraphSyncErrorZ represents the result of a fallible operation,
 * containing a u32 on success and a crate::lightning_rapid_gossip_sync::error::GraphSyncError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_u32GraphSyncErrorZ {
   /**
    * The contents of this CResult_u32GraphSyncErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_u32GraphSyncErrorZPtr contents;
   /**
    * Whether this CResult_u32GraphSyncErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_u32GraphSyncErrorZ;

/**
 * The contents of CResult_NetAddressDecodeErrorZ
 */
typedef union LDKCResult_NetAddressDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNetAddress *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NetAddressDecodeErrorZPtr;

/**
 * A CResult_NetAddressDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::NetAddress on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NetAddressDecodeErrorZ {
   /**
    * The contents of this CResult_NetAddressDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NetAddressDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NetAddressDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NetAddressDecodeErrorZ;



/**
 * An update_add_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateAddHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateAddHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateAddHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateAddHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateAddHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateAddHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateAddHTLCZ;



/**
 * An update_fulfill_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFulfillHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFulfillHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFulfillHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFulfillHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFulfillHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFulfillHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFulfillHTLCZ;



/**
 * An update_fail_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFailHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFailHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFailHTLCZ;



/**
 * An update_fail_malformed_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailMalformedHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailMalformedHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailMalformedHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailMalformedHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFailMalformedHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFailMalformedHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFailMalformedHTLCZ;

/**
 * The contents of CResult_AcceptChannelDecodeErrorZ
 */
typedef union LDKCResult_AcceptChannelDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAcceptChannel *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AcceptChannelDecodeErrorZPtr;

/**
 * A CResult_AcceptChannelDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AcceptChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AcceptChannelDecodeErrorZ {
   /**
    * The contents of this CResult_AcceptChannelDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AcceptChannelDecodeErrorZPtr contents;
   /**
    * Whether this CResult_AcceptChannelDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AcceptChannelDecodeErrorZ;

/**
 * The contents of CResult_AnnouncementSignaturesDecodeErrorZ
 */
typedef union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAnnouncementSignatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AnnouncementSignaturesDecodeErrorZPtr;

/**
 * A CResult_AnnouncementSignaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AnnouncementSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AnnouncementSignaturesDecodeErrorZ {
   /**
    * The contents of this CResult_AnnouncementSignaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_AnnouncementSignaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AnnouncementSignaturesDecodeErrorZ;

/**
 * The contents of CResult_ChannelReestablishDecodeErrorZ
 */
typedef union LDKCResult_ChannelReestablishDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelReestablish *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelReestablishDecodeErrorZPtr;

/**
 * A CResult_ChannelReestablishDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelReestablish on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelReestablishDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelReestablishDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelReestablishDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelReestablishDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelReestablishDecodeErrorZ;

/**
 * The contents of CResult_ClosingSignedDecodeErrorZ
 */
typedef union LDKCResult_ClosingSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKClosingSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ClosingSignedDecodeErrorZPtr;

/**
 * A CResult_ClosingSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ClosingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ClosingSignedDecodeErrorZ {
   /**
    * The contents of this CResult_ClosingSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ClosingSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ClosingSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ClosingSignedDecodeErrorZ;



/**
 * The minimum and maximum fees which the sender is willing to place on the closing transaction.
 * This is provided in [`ClosingSigned`] by both sides to indicate the fee range they are willing
 * to use.
 */
typedef struct MUST_USE_STRUCT LDKClosingSignedFeeRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingSignedFeeRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingSignedFeeRange;

/**
 * The contents of CResult_ClosingSignedFeeRangeDecodeErrorZ
 */
typedef union LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKClosingSignedFeeRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr;

/**
 * A CResult_ClosingSignedFeeRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ClosingSignedFeeRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ {
   /**
    * The contents of this CResult_ClosingSignedFeeRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ClosingSignedFeeRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ClosingSignedFeeRangeDecodeErrorZ;



/**
 * A commitment_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKCommitmentSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentSigned;

/**
 * The contents of CResult_CommitmentSignedDecodeErrorZ
 */
typedef union LDKCResult_CommitmentSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCommitmentSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CommitmentSignedDecodeErrorZPtr;

/**
 * A CResult_CommitmentSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::CommitmentSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CommitmentSignedDecodeErrorZ {
   /**
    * The contents of this CResult_CommitmentSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CommitmentSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CommitmentSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CommitmentSignedDecodeErrorZ;

/**
 * The contents of CResult_FundingCreatedDecodeErrorZ
 */
typedef union LDKCResult_FundingCreatedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingCreated *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingCreatedDecodeErrorZPtr;

/**
 * A CResult_FundingCreatedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingCreated on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingCreatedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingCreatedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingCreatedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingCreatedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingCreatedDecodeErrorZ;

/**
 * The contents of CResult_FundingSignedDecodeErrorZ
 */
typedef union LDKCResult_FundingSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingSignedDecodeErrorZPtr;

/**
 * A CResult_FundingSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingSignedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingSignedDecodeErrorZ;

/**
 * The contents of CResult_ChannelReadyDecodeErrorZ
 */
typedef union LDKCResult_ChannelReadyDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelReady *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelReadyDecodeErrorZPtr;

/**
 * A CResult_ChannelReadyDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelReady on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelReadyDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelReadyDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelReadyDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelReadyDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelReadyDecodeErrorZ;



/**
 * An init message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKInit {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInit *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInit;

/**
 * The contents of CResult_InitDecodeErrorZ
 */
typedef union LDKCResult_InitDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInit *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InitDecodeErrorZPtr;

/**
 * A CResult_InitDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Init on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InitDecodeErrorZ {
   /**
    * The contents of this CResult_InitDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InitDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InitDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InitDecodeErrorZ;

/**
 * The contents of CResult_OpenChannelDecodeErrorZ
 */
typedef union LDKCResult_OpenChannelDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOpenChannel *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OpenChannelDecodeErrorZPtr;

/**
 * A CResult_OpenChannelDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::OpenChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OpenChannelDecodeErrorZ {
   /**
    * The contents of this CResult_OpenChannelDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OpenChannelDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OpenChannelDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OpenChannelDecodeErrorZ;

/**
 * The contents of CResult_RevokeAndACKDecodeErrorZ
 */
typedef union LDKCResult_RevokeAndACKDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRevokeAndACK *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RevokeAndACKDecodeErrorZPtr;

/**
 * A CResult_RevokeAndACKDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::RevokeAndACK on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RevokeAndACKDecodeErrorZ {
   /**
    * The contents of this CResult_RevokeAndACKDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RevokeAndACKDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RevokeAndACKDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RevokeAndACKDecodeErrorZ;

/**
 * The contents of CResult_ShutdownDecodeErrorZ
 */
typedef union LDKCResult_ShutdownDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdown *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ShutdownDecodeErrorZPtr;

/**
 * A CResult_ShutdownDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Shutdown on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownDecodeErrorZ {
   /**
    * The contents of this CResult_ShutdownDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ShutdownDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownDecodeErrorZ;

/**
 * The contents of CResult_UpdateFailHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFailHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFailHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFailHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFailHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFailHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFailHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFailHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFailHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFailHTLCDecodeErrorZ;

/**
 * The contents of CResult_UpdateFailMalformedHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFailMalformedHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFailMalformedHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFailMalformedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFailMalformedHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFailMalformedHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ;



/**
 * An update_fee message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFee {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFee *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFee;

/**
 * The contents of CResult_UpdateFeeDecodeErrorZ
 */
typedef union LDKCResult_UpdateFeeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFee *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFeeDecodeErrorZPtr;

/**
 * A CResult_UpdateFeeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFee on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFeeDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFeeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFeeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFeeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFeeDecodeErrorZ;

/**
 * The contents of CResult_UpdateFulfillHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFulfillHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFulfillHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFulfillHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFulfillHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFulfillHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZ;

/**
 * The contents of CResult_UpdateAddHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateAddHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateAddHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateAddHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateAddHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateAddHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateAddHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateAddHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateAddHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateAddHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateAddHTLCDecodeErrorZ;



/**
 * An onion message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKOnionMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOnionMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOnionMessage;

/**
 * The contents of CResult_OnionMessageDecodeErrorZ
 */
typedef union LDKCResult_OnionMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOnionMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OnionMessageDecodeErrorZPtr;

/**
 * A CResult_OnionMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::OnionMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OnionMessageDecodeErrorZ {
   /**
    * The contents of this CResult_OnionMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OnionMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OnionMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OnionMessageDecodeErrorZ;



/**
 * A ping message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKPing {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePing *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPing;

/**
 * The contents of CResult_PingDecodeErrorZ
 */
typedef union LDKCResult_PingDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPing *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PingDecodeErrorZPtr;

/**
 * A CResult_PingDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Ping on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PingDecodeErrorZ {
   /**
    * The contents of this CResult_PingDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PingDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PingDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PingDecodeErrorZ;



/**
 * A pong message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKPong {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePong *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPong;

/**
 * The contents of CResult_PongDecodeErrorZ
 */
typedef union LDKCResult_PongDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPong *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PongDecodeErrorZPtr;

/**
 * A CResult_PongDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Pong on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PongDecodeErrorZ {
   /**
    * The contents of this CResult_PongDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PongDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PongDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PongDecodeErrorZ;

/**
 * The contents of CResult_UnsignedChannelAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedChannelAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr;

/**
 * A CResult_UnsignedChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedChannelAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedChannelAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_ChannelAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_ChannelAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelAnnouncementDecodeErrorZPtr;

/**
 * A CResult_ChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelAnnouncementDecodeErrorZ;



/**
 * The unsigned part of a channel_update
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelUpdate;

/**
 * The contents of CResult_UnsignedChannelUpdateDecodeErrorZ
 */
typedef union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedChannelUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr;

/**
 * A CResult_UnsignedChannelUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedChannelUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedChannelUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZ;

/**
 * The contents of CResult_ChannelUpdateDecodeErrorZ
 */
typedef union LDKCResult_ChannelUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelUpdateDecodeErrorZPtr;

/**
 * A CResult_ChannelUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelUpdateDecodeErrorZ;

/**
 * The contents of CResult_ErrorMessageDecodeErrorZ
 */
typedef union LDKCResult_ErrorMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKErrorMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ErrorMessageDecodeErrorZPtr;

/**
 * A CResult_ErrorMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ErrorMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ErrorMessageDecodeErrorZ {
   /**
    * The contents of this CResult_ErrorMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ErrorMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ErrorMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ErrorMessageDecodeErrorZ;

/**
 * The contents of CResult_WarningMessageDecodeErrorZ
 */
typedef union LDKCResult_WarningMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKWarningMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_WarningMessageDecodeErrorZPtr;

/**
 * A CResult_WarningMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::WarningMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_WarningMessageDecodeErrorZ {
   /**
    * The contents of this CResult_WarningMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_WarningMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_WarningMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_WarningMessageDecodeErrorZ;



/**
 * The unsigned part of a node_announcement
 */
typedef struct MUST_USE_STRUCT LDKUnsignedNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedNodeAnnouncement;

/**
 * The contents of CResult_UnsignedNodeAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedNodeAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr;

/**
 * A CResult_UnsignedNodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedNodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedNodeAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedNodeAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ;



/**
 * A node_announcement message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncement;

/**
 * The contents of CResult_NodeAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_NodeAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementDecodeErrorZPtr;

/**
 * A CResult_NodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::NodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_QueryShortChannelIdsDecodeErrorZ
 */
typedef union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKQueryShortChannelIds *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_QueryShortChannelIdsDecodeErrorZPtr;

/**
 * A CResult_QueryShortChannelIdsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::QueryShortChannelIds on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_QueryShortChannelIdsDecodeErrorZ {
   /**
    * The contents of this CResult_QueryShortChannelIdsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_QueryShortChannelIdsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_QueryShortChannelIdsDecodeErrorZ;



/**
 * A reply_short_channel_ids_end message is sent as a reply to a
 * query_short_channel_ids message. The query recipient makes a best
 * effort to respond based on their local network view which may not be
 * a perfect view of the network.
 */
typedef struct MUST_USE_STRUCT LDKReplyShortChannelIdsEnd {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyShortChannelIdsEnd *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyShortChannelIdsEnd;

/**
 * The contents of CResult_ReplyShortChannelIdsEndDecodeErrorZ
 */
typedef union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReplyShortChannelIdsEnd *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr;

/**
 * A CResult_ReplyShortChannelIdsEndDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ReplyShortChannelIdsEnd on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ {
   /**
    * The contents of this CResult_ReplyShortChannelIdsEndDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReplyShortChannelIdsEndDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ;

/**
 * The contents of CResult_QueryChannelRangeDecodeErrorZ
 */
typedef union LDKCResult_QueryChannelRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKQueryChannelRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_QueryChannelRangeDecodeErrorZPtr;

/**
 * A CResult_QueryChannelRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::QueryChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_QueryChannelRangeDecodeErrorZ {
   /**
    * The contents of this CResult_QueryChannelRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_QueryChannelRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_QueryChannelRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_QueryChannelRangeDecodeErrorZ;

/**
 * The contents of CResult_ReplyChannelRangeDecodeErrorZ
 */
typedef union LDKCResult_ReplyChannelRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReplyChannelRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReplyChannelRangeDecodeErrorZPtr;

/**
 * A CResult_ReplyChannelRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ReplyChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReplyChannelRangeDecodeErrorZ {
   /**
    * The contents of this CResult_ReplyChannelRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReplyChannelRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReplyChannelRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReplyChannelRangeDecodeErrorZ;

/**
 * The contents of CResult_GossipTimestampFilterDecodeErrorZ
 */
typedef union LDKCResult_GossipTimestampFilterDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKGossipTimestampFilter *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_GossipTimestampFilterDecodeErrorZPtr;

/**
 * A CResult_GossipTimestampFilterDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::GossipTimestampFilter on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_GossipTimestampFilterDecodeErrorZ {
   /**
    * The contents of this CResult_GossipTimestampFilterDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_GossipTimestampFilterDecodeErrorZPtr contents;
   /**
    * Whether this CResult_GossipTimestampFilterDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_GossipTimestampFilterDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::ln::channelmanager::PhantomRouteHintss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PhantomRouteHintsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPhantomRouteHints *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PhantomRouteHintsZ;

/**
 * When signing using a fallible method either an user-supplied `SignError` or a `CreationError`
 * may occur.
 */
typedef enum LDKSignOrCreationError_Tag {
   /**
    * An error occurred during signing
    */
   LDKSignOrCreationError_SignError,
   /**
    * An error occurred while building the transaction
    */
   LDKSignOrCreationError_CreationError,
   /**
    * Must be last for serialization purposes
    */
   LDKSignOrCreationError_Sentinel,
} LDKSignOrCreationError_Tag;

typedef struct MUST_USE_STRUCT LDKSignOrCreationError {
   LDKSignOrCreationError_Tag tag;
   union {
      struct {
         enum LDKCreationError creation_error;
      };
   };
} LDKSignOrCreationError;

/**
 * The contents of CResult_InvoiceSignOrCreationErrorZ
 */
typedef union LDKCResult_InvoiceSignOrCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKSignOrCreationError *err;
} LDKCResult_InvoiceSignOrCreationErrorZPtr;

/**
 * A CResult_InvoiceSignOrCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::SignOrCreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceSignOrCreationErrorZ {
   /**
    * The contents of this CResult_InvoiceSignOrCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceSignOrCreationErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceSignOrCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceSignOrCreationErrorZ;



/**
 * A transaction output watched by a [`ChannelMonitor`] for spends on-chain.
 *
 * Used to convey to a [`Filter`] such an output with a given spending condition. Any transaction
 * spending the output must be given to [`ChannelMonitor::block_connected`] either directly or via
 * [`Confirm::transactions_confirmed`].
 *
 * If `block_hash` is `Some`, this indicates the output was created in the corresponding block and
 * may have been spent there. See [`Filter::register_output`] for details.
 *
 * [`ChannelMonitor`]: channelmonitor::ChannelMonitor
 * [`ChannelMonitor::block_connected`]: channelmonitor::ChannelMonitor::block_connected
 */
typedef struct MUST_USE_STRUCT LDKWatchedOutput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeWatchedOutput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKWatchedOutput;

/**
 * The `Filter` trait defines behavior for indicating chain activity of interest pertaining to
 * channels.
 *
 * This is useful in order to have a [`Watch`] implementation convey to a chain source which
 * transactions to be notified of. Notification may take the form of pre-filtering blocks or, in
 * the case of [BIP 157]/[BIP 158], only fetching a block if the compact filter matches. If
 * receiving full blocks from a chain source, any further filtering is unnecessary.
 *
 * After an output has been registered, subsequent block retrievals from the chain source must not
 * exclude any transactions matching the new criteria nor any in-block descendants of such
 * transactions.
 *
 * Note that use as part of a [`Watch`] implementation involves reentrancy. Therefore, the `Filter`
 * should not block on I/O. Implementations should instead queue the newly monitored data to be
 * processed later. Then, in order to block until the data has been processed, any [`Watch`]
 * invocation that has called the `Filter` must return [`InProgress`].
 *
 * [`InProgress`]: ChannelMonitorUpdateStatus::InProgress
 * [BIP 157]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
 * [BIP 158]: https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
 */
typedef struct LDKFilter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Registers interest in a transaction with `txid` and having an output with `script_pubkey` as
    * a spending condition.
    */
   void (*register_tx)(const void *this_arg, const uint8_t (*txid)[32], struct LDKu8slice script_pubkey);
   /**
    * Registers interest in spends of a transaction output.
    *
    * Note that this method might be called during processing of a new block. You therefore need
    * to ensure that also dependent output spents within an already connected block are correctly
    * handled, e.g., by re-scanning the block in question whenever new outputs have been
    * registered mid-processing.
    */
   void (*register_output)(const void *this_arg, struct LDKWatchedOutput output);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFilter;

/**
 * An enum which can either contain a crate::lightning::chain::Filter or not
 */
typedef enum LDKCOption_FilterZ_Tag {
   /**
    * When we're in this state, this COption_FilterZ contains a crate::lightning::chain::Filter
    */
   LDKCOption_FilterZ_Some,
   /**
    * When we're in this state, this COption_FilterZ contains nothing
    */
   LDKCOption_FilterZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_FilterZ_Sentinel,
} LDKCOption_FilterZ_Tag;

typedef struct LDKCOption_FilterZ {
   LDKCOption_FilterZ_Tag tag;
   union {
      struct {
         struct LDKFilter some;
      };
   };
} LDKCOption_FilterZ;



/**
 * A read-only reference to a current ChannelMonitor.
 *
 * Note that this holds a mutex in [`ChainMonitor`] and may block other events until it is
 * released.
 */
typedef struct MUST_USE_STRUCT LDKLockedChannelMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLockedChannelMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLockedChannelMonitor;

/**
 * The contents of CResult_LockedChannelMonitorNoneZ
 */
typedef union LDKCResult_LockedChannelMonitorNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKLockedChannelMonitor *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_LockedChannelMonitorNoneZPtr;

/**
 * A CResult_LockedChannelMonitorNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::chainmonitor::LockedChannelMonitor on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_LockedChannelMonitorNoneZ {
   /**
    * The contents of this CResult_LockedChannelMonitorNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_LockedChannelMonitorNoneZPtr contents;
   /**
    * Whether this CResult_LockedChannelMonitorNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_LockedChannelMonitorNoneZ;

/**
 * A dynamically-allocated array of crate::lightning::chain::transaction::OutPoints of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_OutPointZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKOutPoint *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_OutPointZ;



/**
 * An opaque identifier describing a specific [`Persist`] method call.
 */
typedef struct MUST_USE_STRUCT LDKMonitorUpdateId {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMonitorUpdateId *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMonitorUpdateId;

/**
 * A dynamically-allocated array of crate::lightning::chain::chainmonitor::MonitorUpdateIds of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MonitorUpdateIdZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMonitorUpdateId *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MonitorUpdateIdZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ {
   /**
    * The element at position 0
    */
   struct LDKOutPoint a;
   /**
    * The element at position 1
    */
   struct LDKCVec_MonitorUpdateIdZ b;
} LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_OutPointCVec_MonitorUpdateIdZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ;

/**
 * A trait indicating an object may generate message send events
 */
typedef struct LDKMessageSendEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the list of pending events which were generated by previous actions, clearing the list
    * in the process.
    */
   struct LDKCVec_MessageSendEventZ (*get_and_clear_pending_msg_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKMessageSendEventsProvider;

/**
 * A trait indicating an object may generate onion messages to send
 */
typedef struct LDKOnionMessageProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the next pending onion message for the peer with the given node id.
    *
    * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKOnionMessage (*next_onion_message_for_peer)(const void *this_arg, struct LDKPublicKey peer_node_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKOnionMessageProvider;

/**
 * A trait implemented for objects handling events from [`EventsProvider`].
 *
 * An async variation also exists for implementations of [`EventsProvider`] that support async
 * event handling. The async event handler should satisfy the generic bounds: `F:
 * core::future::Future, H: Fn(Event) -> F`.
 */
typedef struct LDKEventHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handles the given [`Event`].
    *
    * See [`EventsProvider`] for details that must be considered when implementing this method.
    */
   void (*handle_event)(const void *this_arg, struct LDKEvent event);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventHandler;

/**
 * A trait indicating an object may generate events.
 *
 * Events are processed by passing an [`EventHandler`] to [`process_pending_events`].
 *
 * Implementations of this trait may also feature an async version of event handling, as shown with
 * [`ChannelManager::process_pending_events_async`] and
 * [`ChainMonitor::process_pending_events_async`].
 *
 * # Requirements
 *
 * When using this trait, [`process_pending_events`] will call [`handle_event`] for each pending
 * event since the last invocation.
 *
 * In order to ensure no [`Event`]s are lost, implementors of this trait will persist [`Event`]s
 * and replay any unhandled events on startup. An [`Event`] is considered handled when
 * [`process_pending_events`] returns, thus handlers MUST fully handle [`Event`]s and persist any
 * relevant changes to disk *before* returning.
 *
 * Further, because an application may crash between an [`Event`] being handled and the
 * implementor of this trait being re-serialized, [`Event`] handling must be idempotent - in
 * effect, [`Event`]s may be replayed.
 *
 * Note, handlers may call back into the provider and thus deadlocking must be avoided. Be sure to
 * consult the provider's documentation on the implication of processing events and how a handler
 * may safely use the provider (e.g., see [`ChannelManager::process_pending_events`] and
 * [`ChainMonitor::process_pending_events`]).
 *
 * (C-not implementable) As there is likely no reason for a user to implement this trait on their
 * own type(s).
 *
 * [`process_pending_events`]: Self::process_pending_events
 * [`handle_event`]: EventHandler::handle_event
 * [`ChannelManager::process_pending_events`]: crate::ln::channelmanager::ChannelManager#method.process_pending_events
 * [`ChainMonitor::process_pending_events`]: crate::chain::chainmonitor::ChainMonitor#method.process_pending_events
 * [`ChannelManager::process_pending_events_async`]: crate::ln::channelmanager::ChannelManager::process_pending_events_async
 * [`ChainMonitor::process_pending_events_async`]: crate::chain::chainmonitor::ChainMonitor::process_pending_events_async
 */
typedef struct LDKEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Processes any events generated since the last call using the given event handler.
    *
    * See the trait-level documentation for requirements.
    */
   void (*process_pending_events)(const void *this_arg, struct LDKEventHandler handler);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventsProvider;



/**
 * Lightning TLV uses a custom variable-length integer called BigSize. It is similar to Bitcoin's
 * variable-length integers except that it is serialized in big-endian instead of little-endian.
 *
 * Like Bitcoin's variable-length integer, it exhibits ambiguity in that certain values can be
 * encoded in several different ways, which we must check for at deserialization-time. Thus, if
 * you're looking for an example of a variable-length integer to use for your own project, move
 * along, this is a rather poor design.
 */
typedef struct MUST_USE_STRUCT LDKBigSize {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBigSize *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBigSize;

/**
 * Trait that handles persisting a [`ChannelManager`], [`NetworkGraph`], and [`WriteableScore`] to disk.
 */
typedef struct LDKPersister {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist the given ['ChannelManager'] to disk, returning an error if persistence failed.
    */
   struct LDKCResult_NoneErrorZ (*persist_manager)(const void *this_arg, const struct LDKChannelManager *NONNULL_PTR channel_manager);
   /**
    * Persist the given [`NetworkGraph`] to disk, returning an error if persistence failed.
    */
   struct LDKCResult_NoneErrorZ (*persist_graph)(const void *this_arg, const struct LDKNetworkGraph *NONNULL_PTR network_graph);
   /**
    * Persist the given [`WriteableScore`] to disk, returning an error if persistence failed.
    */
   struct LDKCResult_NoneErrorZ (*persist_scorer)(const void *this_arg, const struct LDKWriteableScore *NONNULL_PTR scorer);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPersister;



/**
 * A string that displays only printable characters, replacing control characters with
 * [`core::char::REPLACEMENT_CHARACTER`].
 */
typedef struct MUST_USE_STRUCT LDKPrintableString {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePrintableString *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPrintableString;

/**
 * A callback which is called when a [`Future`] completes.
 *
 * Note that this MUST NOT call back into LDK directly, it must instead schedule actions to be
 * taken later. Rust users should use the [`std::future::Future`] implementation for [`Future`]
 * instead.
 *
 * Note that the [`std::future::Future`] implementation may only work for runtimes which schedule
 * futures when they receive a wake, rather than immediately executing them.
 */
typedef struct LDKFutureCallback {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * The method which is called.
    */
   void (*call)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFutureCallback;



/**
 * A simple future which can complete once, and calls some callback(s) when it does so.
 */
typedef struct MUST_USE_STRUCT LDKFuture {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFuture *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFuture;



/**
 * Configuration we set when applicable.
 *
 * Default::default() provides sane defaults.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeConfig;



/**
 * Optional channel limits which are applied during channel creation.
 *
 * These limits are only applied to our counterparty's limits, not our own.
 *
 * Use 0/<type>::max_value() as appropriate to skip checking.
 *
 * Provides sane defaults for most configurations.
 *
 * Most additional limits are disabled except those with which specify a default in individual
 * field documentation. Note that this may result in barely-usable channels, but since they
 * are applied mostly only to incoming channels that's not much of a problem.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeLimits {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeLimits *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeLimits;



/**
 * Top-level config which holds ChannelHandshakeLimits and ChannelConfig.
 *
 * Default::default() provides sane defaults for most configurations
 * (but currently with 0 relay fees!)
 */
typedef struct MUST_USE_STRUCT LDKUserConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUserConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUserConfig;



/**
 * The best known block as identified by its hash and height.
 */
typedef struct MUST_USE_STRUCT LDKBestBlock {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBestBlock *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBestBlock;

/**
 * The `Listen` trait is used to notify when blocks have been connected or disconnected from the
 * chain.
 *
 * Useful when needing to replay chain data upon startup or as new chain events occur. Clients
 * sourcing chain data using a block-oriented API should prefer this interface over [`Confirm`].
 * Such clients fetch the entire header chain whereas clients using [`Confirm`] only fetch headers
 * when needed.
 *
 * By using [`Listen::filtered_block_connected`] this interface supports clients fetching the
 * entire header chain and only blocks with matching transaction data using BIP 157 filters or
 * other similar filtering.
 */
typedef struct LDKListen {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Notifies the listener that a block was added at the given height, with the transaction data
    * possibly filtered.
    */
   void (*filtered_block_connected)(const void *this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height);
   /**
    * Notifies the listener that a block was added at the given height.
    */
   void (*block_connected)(const void *this_arg, struct LDKu8slice block, uint32_t height);
   /**
    * Notifies the listener that a block was removed at the given height.
    */
   void (*block_disconnected)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKListen;

/**
 * The `Confirm` trait is used to notify LDK when relevant transactions have been confirmed on
 * chain or unconfirmed during a chain reorganization.
 *
 * Clients sourcing chain data using a transaction-oriented API should prefer this interface over
 * [`Listen`]. For instance, an Electrum-based transaction sync implementation may implement
 * [`Filter`] to subscribe to relevant transactions and unspent outputs it should monitor for
 * on-chain activity. Then, it needs to notify LDK via this interface upon observing any changes
 * with reference to the confirmation status of the monitored objects.
 *
 * # Use
 * The intended use is as follows:
 * - Call [`transactions_confirmed`] to notify LDK whenever any of the registered transactions or
 *   outputs are, respectively, confirmed or spent on chain.
 * - Call [`transaction_unconfirmed`] to notify LDK whenever any transaction returned by
 *   [`get_relevant_txids`] is no longer confirmed in the block with the given block hash.
 * - Call [`best_block_updated`] to notify LDK whenever a new chain tip becomes available.
 *
 * # Order
 *
 * Clients must call these methods in chain order. Specifically:
 * - Transactions which are confirmed in a particular block must be given before transactions
 *   confirmed in a later block.
 * - Dependent transactions within the same block must be given in topological order, possibly in
 *   separate calls.
 * - All unconfirmed transactions must be given after the original confirmations and before *any*
 *   reconfirmations, i.e., [`transactions_confirmed`] and [`transaction_unconfirmed`] calls should
 *   never be interleaved, but always conduced *en bloc*.
 * - Any reconfirmed transactions need to be explicitly unconfirmed before they are reconfirmed
 *   in regard to the new block.
 *
 * See individual method documentation for further details.
 *
 * [`transactions_confirmed`]: Self::transactions_confirmed
 * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
 * [`best_block_updated`]: Self::best_block_updated
 * [`get_relevant_txids`]: Self::get_relevant_txids
 */
typedef struct LDKConfirm {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Notifies LDK of transactions confirmed in a block with a given header and height.
    *
    * Must be called for any transactions registered by [`Filter::register_tx`] or any
    * transactions spending an output registered by [`Filter::register_output`]. Such transactions
    * appearing in the same block do not need to be included in the same call; instead, multiple
    * calls with additional transactions may be made so long as they are made in [chain order].
    *
    * May be called before or after [`best_block_updated`] for the corresponding block. However,
    * in the event of a chain reorganization, it must not be called with a `header` that is no
    * longer in the chain as of the last call to [`best_block_updated`].
    *
    * [chain order]: Confirm#order
    * [`best_block_updated`]: Self::best_block_updated
    */
   void (*transactions_confirmed)(const void *this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height);
   /**
    * Notifies LDK of a transaction that is no longer confirmed as result of a chain reorganization.
    *
    * Must be called for any transaction returned by [`get_relevant_txids`] if it has been
    * reorganized out of the best chain or if it is no longer confirmed in the block with the
    * given block hash. Once called, the given transaction will not be returned
    * by [`get_relevant_txids`], unless it has been reconfirmed via [`transactions_confirmed`].
    *
    * [`get_relevant_txids`]: Self::get_relevant_txids
    * [`transactions_confirmed`]: Self::transactions_confirmed
    */
   void (*transaction_unconfirmed)(const void *this_arg, const uint8_t (*txid)[32]);
   /**
    * Notifies LDK of an update to the best header connected at the given height.
    *
    * Must be called whenever a new chain tip becomes available. May be skipped for intermediary
    * blocks.
    */
   void (*best_block_updated)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Returns transactions that must be monitored for reorganization out of the chain along
    * with the hash of the block as part of which it had been previously confirmed.
    *
    * Will include any transactions passed to [`transactions_confirmed`] that have insufficient
    * confirmations to be safe from a chain reorganization. Will not include any transactions
    * passed to [`transaction_unconfirmed`], unless later reconfirmed.
    *
    * Must be called to determine the subset of transactions that must be monitored for
    * reorganization. Will be idempotent between calls but may change as a result of calls to the
    * other interface methods. Thus, this is useful to determine which transactions must be
    * given to [`transaction_unconfirmed`].
    *
    * If any of the returned transactions are confirmed in a block other than the one with the
    * given hash, they need to be unconfirmed and reconfirmed via [`transaction_unconfirmed`] and
    * [`transactions_confirmed`], respectively.
    *
    * [`transactions_confirmed`]: Self::transactions_confirmed
    * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
    */
   struct LDKCVec_C2Tuple_TxidBlockHashZZ (*get_relevant_txids)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKConfirm;

/**
 * `Persist` defines behavior for persisting channel monitors: this could mean
 * writing once to disk, and/or uploading to one or more backup services.
 *
 * Each method can return three possible values:
 *  * If persistence (including any relevant `fsync()` calls) happens immediately, the
 *    implementation should return [`ChannelMonitorUpdateStatus::Completed`], indicating normal
 *    channel operation should continue.
 *  * If persistence happens asynchronously, implementations should first ensure the
 *    [`ChannelMonitor`] or [`ChannelMonitorUpdate`] are written durably to disk, and then return
 *    [`ChannelMonitorUpdateStatus::InProgress`] while the update continues in the background.
 *    Once the update completes, [`ChainMonitor::channel_monitor_updated`] should be called with
 *    the corresponding [`MonitorUpdateId`].
 *
 *    Note that unlike the direct [`chain::Watch`] interface,
 *    [`ChainMonitor::channel_monitor_updated`] must be called once for *each* update which occurs.
 *
 *  * If persistence fails for some reason, implementations should return
 *    [`ChannelMonitorUpdateStatus::PermanentFailure`], in which case the channel will likely be
 *    closed without broadcasting the latest state. See
 *    [`ChannelMonitorUpdateStatus::PermanentFailure`] for more details.
 */
typedef struct LDKPersist {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist a new channel's data in response to a [`chain::Watch::watch_channel`] call. This is
    * called by [`ChannelManager`] for new channels, or may be called directly, e.g. on startup.
    *
    * The data can be stored any way you want, but the identifier provided by LDK is the
    * channel's outpoint (and it is up to you to maintain a correct mapping between the outpoint
    * and the stored channel data). Note that you **must** persist every new monitor to disk.
    *
    * The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
    * if you return [`ChannelMonitorUpdateStatus::InProgress`].
    *
    * See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`
    * and [`ChannelMonitorUpdateStatus`] for requirements when returning errors.
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`Writeable::write`]: crate::util::ser::Writeable::write
    */
   enum LDKChannelMonitorUpdateStatus (*persist_new_channel)(const void *this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id);
   /**
    * Update one channel's data. The provided [`ChannelMonitor`] has already applied the given
    * update.
    *
    * Note that on every update, you **must** persist either the [`ChannelMonitorUpdate`] or the
    * updated monitor itself to disk/backups. See the [`Persist`] trait documentation for more
    * details.
    *
    * During blockchain synchronization operations, this may be called with no
    * [`ChannelMonitorUpdate`], in which case the full [`ChannelMonitor`] needs to be persisted.
    * Note that after the full [`ChannelMonitor`] is persisted any previous
    * [`ChannelMonitorUpdate`]s which were persisted should be discarded - they can no longer be
    * applied to the persisted [`ChannelMonitor`] as they were already applied.
    *
    * If an implementer chooses to persist the updates only, they need to make
    * sure that all the updates are applied to the `ChannelMonitors` *before*
    * the set of channel monitors is given to the `ChannelManager`
    * deserialization routine. See [`ChannelMonitor::update_monitor`] for
    * applying a monitor update to a monitor. If full `ChannelMonitors` are
    * persisted, then there is no need to persist individual updates.
    *
    * Note that there could be a performance tradeoff between persisting complete
    * channel monitors on every update vs. persisting only updates and applying
    * them in batches. The size of each monitor grows `O(number of state updates)`
    * whereas updates are small and `O(1)`.
    *
    * The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
    * if you return [`ChannelMonitorUpdateStatus::InProgress`].
    *
    * See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`,
    * [`Writeable::write`] on [`ChannelMonitorUpdate`] for writing out an update, and
    * [`ChannelMonitorUpdateStatus`] for requirements when returning errors.
    *
    * [`Writeable::write`]: crate::util::ser::Writeable::write
    *
    * Note that update (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   enum LDKChannelMonitorUpdateStatus (*update_persisted_channel)(const void *this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitorUpdate *NONNULL_PTR update, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPersist;



/**
 * An implementation of [`chain::Watch`] for monitoring channels.
 *
 * Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
 * [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
 * or used independently to monitor channels remotely. See the [module-level documentation] for
 * details.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [module-level documentation]: crate::chain::chainmonitor
 */
typedef struct MUST_USE_STRUCT LDKChainMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainMonitor;



/**
 * Simple [`KeysInterface`] implementation that takes a 32-byte seed for use as a BIP 32 extended
 * key and derives keys from that.
 *
 * Your `node_id` is seed/0'.
 * Unilateral closes may use seed/1'.
 * Cooperative closes may use seed/2'.
 * The two close keys may be needed to claim on-chain funds!
 *
 * This struct cannot be used for nodes that wish to support receiving phantom payments;
 * [`PhantomKeysManager`] must be used instead.
 *
 * Note that switching between this struct and [`PhantomKeysManager`] will invalidate any
 * previously issued invoices and attempts to pay previous invoices will fail.
 */
typedef struct MUST_USE_STRUCT LDKKeysManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeKeysManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKKeysManager;



/**
 * Similar to [`KeysManager`], but allows the node using this struct to receive phantom node
 * payments.
 *
 * A phantom node payment is a payment made to a phantom invoice, which is an invoice that can be
 * paid to one of multiple nodes. This works because we encode the invoice route hints such that
 * LDK will recognize an incoming payment as destined for a phantom node, and collect the payment
 * itself without ever needing to forward to this fake node.
 *
 * Phantom node payments are useful for load balancing between multiple LDK nodes. They also
 * provide some fault tolerance, because payers will automatically retry paying other provided
 * nodes in the case that one node goes down.
 *
 * Note that multi-path payments are not supported in phantom invoices for security reasons.
 * Switching between this struct and [`KeysManager`] will invalidate any previously issued
 * invoices and attempts to pay previous invoices will fail.
 */
typedef struct MUST_USE_STRUCT LDKPhantomKeysManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePhantomKeysManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPhantomKeysManager;



/**
 * Chain-related parameters used to construct a new `ChannelManager`.
 *
 * Typically, the block-specific parameters are derived from the best block hash for the network,
 * as a newly constructed `ChannelManager` will not have created any channels yet. These parameters
 * are not needed when deserializing a previously constructed `ChannelManager`.
 */
typedef struct MUST_USE_STRUCT LDKChainParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainParameters;

/**
 * A trait to describe an object which can receive channel messages.
 *
 * Messages MAY be called in parallel when they originate from different their_node_ids, however
 * they MUST NOT be called in parallel when the two calls have the same their_node_id.
 */
typedef struct LDKChannelMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming open_channel message from the given peer.
    */
   void (*handle_open_channel)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKOpenChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming accept_channel message from the given peer.
    */
   void (*handle_accept_channel)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKAcceptChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_created message from the given peer.
    */
   void (*handle_funding_created)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingCreated *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_signed message from the given peer.
    */
   void (*handle_funding_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_ready message from the given peer.
    */
   void (*handle_channel_ready)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReady *NONNULL_PTR msg);
   /**
    * Handle an incoming shutdown message from the given peer.
    */
   void (*handle_shutdown)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInitFeatures *NONNULL_PTR their_features, const struct LDKShutdown *NONNULL_PTR msg);
   /**
    * Handle an incoming closing_signed message from the given peer.
    */
   void (*handle_closing_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKClosingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming update_add_htlc message from the given peer.
    */
   void (*handle_update_add_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateAddHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fulfill_htlc message from the given peer.
    */
   void (*handle_update_fulfill_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFulfillHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fail_htlc message from the given peer.
    */
   void (*handle_update_fail_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fail_malformed_htlc message from the given peer.
    */
   void (*handle_update_fail_malformed_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming commitment_signed message from the given peer.
    */
   void (*handle_commitment_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKCommitmentSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming revoke_and_ack message from the given peer.
    */
   void (*handle_revoke_and_ack)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKRevokeAndACK *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fee message from the given peer.
    */
   void (*handle_update_fee)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFee *NONNULL_PTR msg);
   /**
    * Handle an incoming announcement_signatures message from the given peer.
    */
   void (*handle_announcement_signatures)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKAnnouncementSignatures *NONNULL_PTR msg);
   /**
    * Indicates a connection to the peer failed/an existing connection was lost. If no connection
    * is believed to be possible in the future (eg they're sending us messages we don't
    * understand or indicate they require unknown feature bits), no_connection_possible is set
    * and any outstanding channels should be failed.
    *
    * Note that in some rare cases this may be called without a corresponding
    * [`Self::peer_connected`].
    */
   void (*peer_disconnected)(const void *this_arg, struct LDKPublicKey their_node_id, bool no_connection_possible);
   /**
    * Handle a peer reconnecting, possibly generating channel_reestablish message(s).
    *
    * May return an `Err(())` if the features the peer supports are not sufficient to communicate
    * with us. Implementors should be somewhat conservative about doing so, however, as other
    * message handlers may still wish to communicate with this peer.
    */
   struct LDKCResult_NoneNoneZ (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_reestablish message from the given peer.
    */
   void (*handle_channel_reestablish)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReestablish *NONNULL_PTR msg);
   /**
    * Handle an incoming channel update from the given peer.
    */
   void (*handle_channel_update)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Handle an incoming error message from the given peer.
    */
   void (*handle_error)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKErrorMessage *NONNULL_PTR msg);
   /**
    * Gets the node feature flags which this handler itself supports. All available handlers are
    * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
    * which are broadcasted in our [`NodeAnnouncement`] message.
    */
   struct LDKNodeFeatures (*provided_node_features)(const void *this_arg);
   /**
    * Gets the init feature flags which should be sent to the given peer. All available handlers
    * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
    * which are sent in our [`Init`] message.
    *
    * Note that this method is called before [`Self::peer_connected`].
    */
   struct LDKInitFeatures (*provided_init_features)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKChannelMessageHandler;



/**
 * Arguments for the creation of a ChannelManager that are not deserialized.
 *
 * At a high-level, the process for deserializing a ChannelManager and resuming normal operation
 * is:
 * 1) Deserialize all stored [`ChannelMonitor`]s.
 * 2) Deserialize the [`ChannelManager`] by filling in this struct and calling:
 *    `<(BlockHash, ChannelManager)>::read(reader, args)`
 *    This may result in closing some channels if the [`ChannelMonitor`] is newer than the stored
 *    [`ChannelManager`] state to ensure no loss of funds. Thus, transactions may be broadcasted.
 * 3) If you are not fetching full blocks, register all relevant [`ChannelMonitor`] outpoints the
 *    same way you would handle a [`chain::Filter`] call using
 *    [`ChannelMonitor::get_outputs_to_watch`] and [`ChannelMonitor::get_funding_txo`].
 * 4) Reconnect blocks on your [`ChannelMonitor`]s.
 * 5) Disconnect/connect blocks on the [`ChannelManager`].
 * 6) Re-persist the [`ChannelMonitor`]s to ensure the latest state is on disk.
 *    Note that if you're using a [`ChainMonitor`] for your [`chain::Watch`] implementation, you
 *    will likely accomplish this as a side-effect of calling [`chain::Watch::watch_channel`] in
 *    the next step.
 * 7) Move the [`ChannelMonitor`]s into your local [`chain::Watch`]. If you're using a
 *    [`ChainMonitor`], this is done by calling [`chain::Watch::watch_channel`].
 *
 * Note that the ordering of #4-7 is not of importance, however all four must occur before you
 * call any other methods on the newly-deserialized [`ChannelManager`].
 *
 * Note that because some channels may be closed during deserialization, it is critical that you
 * always deserialize only the latest version of a ChannelManager and ChannelMonitors available to
 * you. If you deserialize an old ChannelManager (during which force-closure transactions may be
 * broadcast), and then later deserialize a newer version of the same ChannelManager (which will
 * not force-close the same channels but consider them live), you may end up revoking a state for
 * which you've already broadcasted the transaction.
 *
 * [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
 */
typedef struct MUST_USE_STRUCT LDKChannelManagerReadArgs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManagerReadArgs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManagerReadArgs;



/**
 * A set of keys that were HKDF-expanded from an initial call to
 * [`KeysInterface::get_inbound_payment_key_material`].
 *
 * [`KeysInterface::get_inbound_payment_key_material`]: crate::chain::keysinterface::KeysInterface::get_inbound_payment_key_material
 */
typedef struct MUST_USE_STRUCT LDKExpandedKey {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeExpandedKey *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKExpandedKey;



/**
 * Proof that the sender knows the per-commitment secret of the previous commitment transaction.
 * This is used to convince the recipient that the channel is at a certain commitment
 * number even if they lost that data due to a local failure.  Of course, the peer may lie
 * and even later commitments may have been revoked.
 */
typedef struct MUST_USE_STRUCT LDKDataLossProtect {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDataLossProtect *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDataLossProtect;

/**
 * A 3-byte byte array.
 */
typedef struct LDKThreeBytes {
   /**
    * The three bytes
    */
   uint8_t data[3];
} LDKThreeBytes;

/**
 * A trait to describe an object which can receive routing messages.
 *
 * # Implementor DoS Warnings
 *
 * For `gossip_queries` messages there are potential DoS vectors when handling
 * inbound queries. Implementors using an on-disk network graph should be aware of
 * repeated disk I/O for queries accessing different parts of the network graph.
 */
typedef struct LDKRoutingMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming node_announcement message, returning true if it should be forwarded on,
    * false or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_node_announcement)(const void *this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);
   /**
    * Handle a channel_announcement message, returning true if it should be forwarded on, false
    * or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_announcement)(const void *this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_update message, returning true if it should be forwarded on,
    * false or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_update)(const void *this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Gets channel announcements and updates required to dump our routing table to a remote node,
    * starting at the short_channel_id indicated by starting_point and including announcements
    * for a single channel.
    */
   struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ (*get_next_channel_announcement)(const void *this_arg, uint64_t starting_point);
   /**
    * Gets a node announcement required to dump our routing table to a remote node, starting at
    * the node *after* the provided pubkey and including up to one announcement immediately
    * higher (as defined by <PublicKey as Ord>::cmp) than starting_point.
    * If None is provided for starting_point, we start at the first node.
    *
    * Note that starting_point (or a relevant inner pointer) may be NULL or all-0s to represent None
    * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKNodeAnnouncement (*get_next_node_announcement)(const void *this_arg, struct LDKPublicKey starting_point);
   /**
    * Called when a connection is established with a peer. This can be used to
    * perform routing table synchronization using a strategy defined by the
    * implementor.
    *
    * May return an `Err(())` if the features the peer supports are not sufficient to communicate
    * with us. Implementors should be somewhat conservative about doing so, however, as other
    * message handlers may still wish to communicate with this peer.
    */
   struct LDKCResult_NoneNoneZ (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init);
   /**
    * Handles the reply of a query we initiated to learn about channels
    * for a given range of blocks. We can expect to receive one or more
    * replies to a single query.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyChannelRange msg);
   /**
    * Handles the reply of a query we initiated asking for routing gossip
    * messages for a list of channels. We should receive this message when
    * a node has completed its best effort to send us the pertaining routing
    * gossip messages.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_short_channel_ids_end)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyShortChannelIdsEnd msg);
   /**
    * Handles when a peer asks us to send a list of short_channel_ids
    * for the requested range of blocks.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryChannelRange msg);
   /**
    * Handles when a peer asks us to send routing gossip messages for a
    * list of short_channel_ids.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_short_channel_ids)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryShortChannelIds msg);
   /**
    * Gets the node feature flags which this handler itself supports. All available handlers are
    * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
    * which are broadcasted in our [`NodeAnnouncement`] message.
    */
   struct LDKNodeFeatures (*provided_node_features)(const void *this_arg);
   /**
    * Gets the init feature flags which should be sent to the given peer. All available handlers
    * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
    * which are sent in our [`Init`] message.
    *
    * Note that this method is called before [`Self::peer_connected`].
    */
   struct LDKInitFeatures (*provided_init_features)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKRoutingMessageHandler;

/**
 * A trait to describe an object that can receive onion messages.
 */
typedef struct LDKOnionMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming onion_message message from the given peer.
    */
   void (*handle_onion_message)(const void *this_arg, struct LDKPublicKey peer_node_id, const struct LDKOnionMessage *NONNULL_PTR msg);
   /**
    * Called when a connection is established with a peer. Can be used to track which peers
    * advertise onion message support and are online.
    *
    * May return an `Err(())` if the features the peer supports are not sufficient to communicate
    * with us. Implementors should be somewhat conservative about doing so, however, as other
    * message handlers may still wish to communicate with this peer.
    */
   struct LDKCResult_NoneNoneZ (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init);
   /**
    * Indicates a connection to the peer failed/an existing connection was lost. Allows handlers to
    * drop and refuse to forward onion messages to this peer.
    *
    * Note that in some rare cases this may be called without a corresponding
    * [`Self::peer_connected`].
    */
   void (*peer_disconnected)(const void *this_arg, struct LDKPublicKey their_node_id, bool no_connection_possible);
   /**
    * Gets the node feature flags which this handler itself supports. All available handlers are
    * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
    * which are broadcasted in our [`NodeAnnouncement`] message.
    */
   struct LDKNodeFeatures (*provided_node_features)(const void *this_arg);
   /**
    * Gets the init feature flags which should be sent to the given peer. All available handlers
    * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
    * which are sent in our [`Init`] message.
    *
    * Note that this method is called before [`Self::peer_connected`].
    */
   struct LDKInitFeatures (*provided_init_features)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Implementation of OnionMessageProvider for this object.
    */
   struct LDKOnionMessageProvider OnionMessageProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKOnionMessageHandler;

/**
 * Trait to be implemented by custom message (unrelated to the channel/gossip LN layers)
 * decoders.
 */
typedef struct LDKCustomMessageReader {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Decodes a custom message to `CustomMessageType`. If the given message type is known to the
    * implementation and the message could be decoded, must return `Ok(Some(message))`. If the
    * message type is unknown to the implementation, must return `Ok(None)`. If a decoding error
    * occur, must return `Err(DecodeError::X)` where `X` details the encountered error.
    */
   struct LDKCResult_COption_TypeZDecodeErrorZ (*read)(const void *this_arg, uint16_t message_type, struct LDKu8slice buffer);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomMessageReader;

/**
 * Handler for BOLT1-compliant messages.
 */
typedef struct LDKCustomMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Called with the message type that was received and the buffer to be read.
    * Can return a `MessageHandlingError` if the message could not be handled.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_custom_message)(const void *this_arg, struct LDKType msg, struct LDKPublicKey sender_node_id);
   /**
    * Gets the list of pending messages which were generated by the custom message
    * handler, clearing the list in the process. The first tuple element must
    * correspond to the intended recipients node ids. If no connection to one of the
    * specified node does not exist, the message is simply not sent to it.
    */
   struct LDKCVec_C2Tuple_PublicKeyTypeZZ (*get_and_clear_pending_msg)(const void *this_arg);
   /**
    * Implementation of CustomMessageReader for this object.
    */
   struct LDKCustomMessageReader CustomMessageReader;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomMessageHandler;



/**
 * A dummy struct which implements `RoutingMessageHandler` without storing any routing information
 * or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKIgnoringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeIgnoringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKIgnoringMessageHandler;

/**
 * Handler for custom onion messages. If you are using [`SimpleArcOnionMessenger`],
 * [`SimpleRefOnionMessenger`], or prefer to ignore inbound custom onion messages,
 * [`IgnoringMessageHandler`] must be provided to [`OnionMessenger::new`]. Otherwise, a custom
 * implementation of this trait must be provided, with [`CustomMessage`] specifying the supported
 * message types.
 *
 * See [`OnionMessenger`] for example usage.
 *
 * [`IgnoringMessageHandler`]: crate::ln::peer_handler::IgnoringMessageHandler
 * [`CustomMessage`]: Self::CustomMessage
 */
typedef struct LDKCustomOnionMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Called with the custom message that was received.
    */
   void (*handle_custom_message)(const void *this_arg, struct LDKCustomOnionMessageContents msg);
   /**
    * Read a custom message of type `message_type` from `buffer`, returning `Ok(None)` if the
    * message type is unknown.
    */
   struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ (*read_custom_message)(const void *this_arg, uint64_t message_type, struct LDKu8slice buffer);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomOnionMessageHandler;



/**
 * A dummy struct which implements `ChannelMessageHandler` without having any channels.
 * You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKErroringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErroringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErroringMessageHandler;



/**
 * Provides references to trait impls which handle different types of messages.
 */
typedef struct MUST_USE_STRUCT LDKMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMessageHandler;

/**
 * Provides an object which can be used to send data to and which uniquely identifies a connection
 * to a remote host. You will need to be able to generate multiple of these which meet Eq and
 * implement Hash to meet the PeerManager API.
 *
 * For efficiency, Clone should be relatively cheap for this type.
 *
 * Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
 * has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
 * having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
 * further calls to the [`PeerManager`] related to the original socket occur. This allows you to
 * use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
 * to simply use another value which is guaranteed to be globally unique instead.
 */
typedef struct LDKSocketDescriptor {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Attempts to send some data from the given slice to the peer.
    *
    * Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
    * Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
    * called and further write attempts may occur until that time.
    *
    * If the returned size is smaller than `data.len()`, a
    * [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
    * written. Additionally, until a `send_data` event completes fully, no further
    * [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
    * prevent denial-of-service issues, you should not read or buffer any data from the socket
    * until then.
    *
    * If a [`PeerManager::read_event`] call on this descriptor had previously returned true
    * (indicating that read events should be paused to prevent DoS in the send buffer),
    * `resume_read` may be set indicating that read events on this descriptor should resume. A
    * `resume_read` of false carries no meaning, and should not cause any action.
    */
   uintptr_t (*send_data)(void *this_arg, struct LDKu8slice data, bool resume_read);
   /**
    * Disconnect the socket pointed to by this SocketDescriptor.
    *
    * You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
    * call (doing so is a noop).
    */
   void (*disconnect_socket)(void *this_arg);
   /**
    * Checks if two objects are equal given this object's this_arg pointer and another object.
    */
   bool (*eq)(const void *this_arg, const struct LDKSocketDescriptor *NONNULL_PTR other_arg);
   /**
    * Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
    * This is used, for example, for inclusion of this object in a hash map.
    */
   uint64_t (*hash)(const void *this_arg);
   /**
    * Called, if set, after this SocketDescriptor has been cloned into a duplicate object.
    * The new SocketDescriptor is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKSocketDescriptor *NONNULL_PTR new_SocketDescriptor);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSocketDescriptor;



/**
 * A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
 * socket events into messages which it passes on to its [`MessageHandler`].
 *
 * Locks are taken internally, so you must never assume that reentrancy from a
 * [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
 *
 * Calls to [`read_event`] will decode relevant messages and pass them to the
 * [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
 * parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
 * [`PeerManager`] functions related to the same connection must occur only in serial, making new
 * calls only after previous ones have returned.
 *
 * Rather than using a plain PeerManager, it is preferable to use either a SimpleArcPeerManager
 * a SimpleRefPeerManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefPeerManager, and use a
 * SimpleArcPeerManager when you require a PeerManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 *
 * [`read_event`]: PeerManager::read_event
 */
typedef struct MUST_USE_STRUCT LDKPeerManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerManager;



/**
 * Static channel fields used to build transactions given per-commitment fields, organized by
 * broadcaster/countersignatory.
 *
 * This is derived from the holder/counterparty-organized ChannelTransactionParameters via the
 * as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKDirectedChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectedChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectedChannelTransactionParameters;

/**
 * Integer in the range `0..=16`
 */
typedef struct LDKWitnessVersion {
   uint8_t _0;
} LDKWitnessVersion;



/**
 * A read-only view of [`NetworkGraph`].
 */
typedef struct MUST_USE_STRUCT LDKReadOnlyNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReadOnlyNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReadOnlyNetworkGraph;



/**
 * Receives and validates network updates from peers,
 * stores authentic and relevant data as a network graph.
 * This network graph is then used for routing payments.
 * Provides interface to help with initial routing sync by
 * serving historical announcements.
 */
typedef struct MUST_USE_STRUCT LDKP2PGossipSync {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeP2PGossipSync *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKP2PGossipSync;



/**
 * A wrapper around [`ChannelInfo`] representing information about the channel as directed from a
 * source node to a target node.
 */
typedef struct MUST_USE_STRUCT LDKDirectedChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectedChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectedChannelInfo;

/**
 * The effective capacity of a channel for routing purposes.
 *
 * While this may be smaller than the actual channel capacity, amounts greater than
 * [`Self::as_msat`] should not be routed through the channel.
 */
typedef enum LDKEffectiveCapacity_Tag {
   /**
    * The available liquidity in the channel known from being a channel counterparty, and thus a
    * direct hop.
    */
   LDKEffectiveCapacity_ExactLiquidity,
   /**
    * The maximum HTLC amount in one direction as advertised on the gossip network.
    */
   LDKEffectiveCapacity_MaximumHTLC,
   /**
    * The total capacity of the channel as determined by the funding transaction.
    */
   LDKEffectiveCapacity_Total,
   /**
    * A capacity sufficient to route any payment, typically used for private channels provided by
    * an invoice.
    */
   LDKEffectiveCapacity_Infinite,
   /**
    * A capacity that is unknown possibly because either the chain state is unavailable to know
    * the total capacity or the `htlc_maximum_msat` was not advertised on the gossip network.
    */
   LDKEffectiveCapacity_Unknown,
   /**
    * Must be last for serialization purposes
    */
   LDKEffectiveCapacity_Sentinel,
} LDKEffectiveCapacity_Tag;

typedef struct LDKEffectiveCapacity_LDKExactLiquidity_Body {
   /**
    * Either the inbound or outbound liquidity depending on the direction, denominated in
    * millisatoshi.
    */
   uint64_t liquidity_msat;
} LDKEffectiveCapacity_LDKExactLiquidity_Body;

typedef struct LDKEffectiveCapacity_LDKMaximumHTLC_Body {
   /**
    * The maximum HTLC amount denominated in millisatoshi.
    */
   uint64_t amount_msat;
} LDKEffectiveCapacity_LDKMaximumHTLC_Body;

typedef struct LDKEffectiveCapacity_LDKTotal_Body {
   /**
    * The funding amount denominated in millisatoshi.
    */
   uint64_t capacity_msat;
   /**
    * The maximum HTLC amount denominated in millisatoshi.
    */
   uint64_t htlc_maximum_msat;
} LDKEffectiveCapacity_LDKTotal_Body;

typedef struct MUST_USE_STRUCT LDKEffectiveCapacity {
   LDKEffectiveCapacity_Tag tag;
   union {
      LDKEffectiveCapacity_LDKExactLiquidity_Body exact_liquidity;
      LDKEffectiveCapacity_LDKMaximumHTLC_Body maximum_htlc;
      LDKEffectiveCapacity_LDKTotal_Body total;
   };
} LDKEffectiveCapacity;



/**
 * A [`Router`] implemented using [`find_route`].
 */
typedef struct MUST_USE_STRUCT LDKDefaultRouter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDefaultRouter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDefaultRouter;

/**
 * A trait defining behavior for routing a payment.
 */
typedef struct LDKRouter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Finds a [`Route`] between `payer` and `payee` for a payment with the given values.
    *
    * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCResult_RouteLightningErrorZ (*find_route)(const void *this_arg, struct LDKPublicKey payer, const struct LDKRouteParameters *NONNULL_PTR route_params, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKInFlightHtlcs inflight_htlcs);
   /**
    * Finds a [`Route`] between `payer` and `payee` for a payment with the given values. Includes
    * `PaymentHash` and `PaymentId` to be able to correlate the request with a specific payment.
    *
    * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCResult_RouteLightningErrorZ (*find_route_with_id)(const void *this_arg, struct LDKPublicKey payer, const struct LDKRouteParameters *NONNULL_PTR route_params, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKInFlightHtlcs inflight_htlcs, struct LDKThirtyTwoBytes _payment_hash, struct LDKThirtyTwoBytes _payment_id);
   /**
    * Lets the router know that payment through a specific path has failed.
    */
   void (*notify_payment_path_failed)(const void *this_arg, struct LDKCVec_RouteHopZ path, uint64_t short_channel_id);
   /**
    * Lets the router know that payment through a specific path was successful.
    */
   void (*notify_payment_path_successful)(const void *this_arg, struct LDKCVec_RouteHopZ path);
   /**
    * Lets the router know that a payment probe was successful.
    */
   void (*notify_payment_probe_successful)(const void *this_arg, struct LDKCVec_RouteHopZ path);
   /**
    * Lets the router know that a payment probe failed.
    */
   void (*notify_payment_probe_failed)(const void *this_arg, struct LDKCVec_RouteHopZ path, uint64_t short_channel_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKRouter;



/**
 * [`Score`] implementation that factors in in-flight HTLC liquidity.
 *
 * Useful for custom [`Router`] implementations to wrap their [`Score`] on-the-fly when calling
 * [`find_route`].
 *
 * [`Score`]: crate::routing::scoring::Score
 */
typedef struct MUST_USE_STRUCT LDKScorerAccountingForInFlightHtlcs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeScorerAccountingForInFlightHtlcs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKScorerAccountingForInFlightHtlcs;



/**
 * A concrete implementation of [`LockableScore`] which supports multi-threading.
 */
typedef struct MUST_USE_STRUCT LDKMultiThreadedLockableScore {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMultiThreadedLockableScore *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMultiThreadedLockableScore;



/**
 * A locked `MultiThreadedLockableScore`.
 */
typedef struct MUST_USE_STRUCT LDKMultiThreadedScoreLock {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMultiThreadedScoreLock *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMultiThreadedScoreLock;



/**
 * Parameters for configuring [`ProbabilisticScorer`].
 *
 * Used to configure base, liquidity, and amount penalties, the sum of which comprises the channel
 * penalty (i.e., the amount in msats willing to be paid to avoid routing through the channel).
 *
 * The penalty applied to any channel by the [`ProbabilisticScorer`] is the sum of each of the
 * parameters here.
 */
typedef struct MUST_USE_STRUCT LDKProbabilisticScoringParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeProbabilisticScoringParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKProbabilisticScoringParameters;



/**
 * A sender, receiver and forwarder of onion messages. In upcoming releases, this object will be
 * used to retrieve invoices and fulfill invoice requests from [offers]. Currently, only sending
 * and receiving custom onion messages is supported.
 *
 * # Example
 *
 * ```
 * # extern crate bitcoin;
 * # use bitcoin::hashes::_export::_core::time::Duration;
 * # use bitcoin::secp256k1::{PublicKey, Secp256k1, SecretKey};
 * # use lightning::chain::keysinterface::{InMemorySigner, KeysManager, KeysInterface};
 * # use lightning::ln::msgs::DecodeError;
 * # use lightning::ln::peer_handler::IgnoringMessageHandler;
 * # use lightning::onion_message::blinded_path::BlindedPath;
 * # use lightning::onion_message::messenger::{CustomOnionMessageContents, Destination, OnionMessageContents, OnionMessenger};
 * # use lightning::util::logger::{Logger, Record};
 * # use lightning::util::ser::{Writeable, Writer};
 * # use lightning::io;
 * # use std::sync::Arc;
 * # struct FakeLogger {};
 * # impl Logger for FakeLogger {
 * #     fn log(&self, record: &Record) { unimplemented!() }
 * # }
 * # let seed = [42u8; 32];
 * # let time = Duration::from_secs(123456);
 * # let keys_manager = KeysManager::new(&seed, time.as_secs(), time.subsec_nanos());
 * # let logger = Arc::new(FakeLogger {});
 * # let node_secret = SecretKey::from_slice(&hex::decode(\"0101010101010101010101010101010101010101010101010101010101010101\").unwrap()[..]).unwrap();
 * # let secp_ctx = Secp256k1::new();
 * # let hop_node_id1 = PublicKey::from_secret_key(&secp_ctx, &node_secret);
 * # let (hop_node_id2, hop_node_id3, hop_node_id4) = (hop_node_id1, hop_node_id1, hop_node_id1);
 * # let destination_node_id = hop_node_id1;
 * # let your_custom_message_handler = IgnoringMessageHandler {};
 * // Create the onion messenger. This must use the same `keys_manager` as is passed to your
 * // ChannelManager.
 * let onion_messenger = OnionMessenger::new(&keys_manager, logger, your_custom_message_handler);
 *
 * # #[derive(Clone)]
 * # struct YourCustomMessage {}
 * impl Writeable for YourCustomMessage {
 * \tfn write<W: Writer>(&self, w: &mut W) -> Result<(), io::Error> {
 * \t\t# Ok(())
 * \t\t// Write your custom onion message to `w`
 * \t}
 * }
 * impl CustomOnionMessageContents for YourCustomMessage {
 * \tfn tlv_type(&self) -> u64 {
 * \t\t# let your_custom_message_type = 42;
 * \t\tyour_custom_message_type
 * \t}
 * }
 * // Send a custom onion message to a node id.
 * let intermediate_hops = [hop_node_id1, hop_node_id2];
 * let reply_path = None;
 * # let your_custom_message = YourCustomMessage {};
 * let message = OnionMessageContents::Custom(your_custom_message);
 * onion_messenger.send_onion_message(&intermediate_hops, Destination::Node(destination_node_id), message, reply_path);
 *
 * // Create a blinded path to yourself, for someone to send an onion message to.
 * # let your_node_id = hop_node_id1;
 * let hops = [hop_node_id3, hop_node_id4, your_node_id];
 * let blinded_path = BlindedPath::new(&hops, &keys_manager, &secp_ctx).unwrap();
 *
 * // Send a custom onion message to a blinded path.
 * # let intermediate_hops = [hop_node_id1, hop_node_id2];
 * let reply_path = None;
 * # let your_custom_message = YourCustomMessage {};
 * let message = OnionMessageContents::Custom(your_custom_message);
 * onion_messenger.send_onion_message(&intermediate_hops, Destination::BlindedPath(blinded_path), message, reply_path);
 * ```
 *
 * [offers]: <https://github.com/lightning/bolts/pull/798>
 * [`OnionMessenger`]: crate::onion_message::OnionMessenger
 */
typedef struct MUST_USE_STRUCT LDKOnionMessenger {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOnionMessenger *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOnionMessenger;

/**
 * The destination of an onion message.
 */
typedef enum LDKDestination_Tag {
   /**
    * We're sending this onion message to a node.
    */
   LDKDestination_Node,
   /**
    * We're sending this onion message to a blinded path.
    */
   LDKDestination_BlindedPath,
   /**
    * Must be last for serialization purposes
    */
   LDKDestination_Sentinel,
} LDKDestination_Tag;

typedef struct MUST_USE_STRUCT LDKDestination {
   LDKDestination_Tag tag;
   union {
      struct {
         struct LDKPublicKey node;
      };
      struct {
         struct LDKBlindedPath blinded_path;
      };
   };
} LDKDestination;

/**
 * The contents of an onion message. In the context of offers, this would be the invoice, invoice
 * request, or invoice error.
 */
typedef enum LDKOnionMessageContents_Tag {
   /**
    * A custom onion message specified by the user.
    */
   LDKOnionMessageContents_Custom,
   /**
    * Must be last for serialization purposes
    */
   LDKOnionMessageContents_Sentinel,
} LDKOnionMessageContents_Tag;

typedef struct MUST_USE_STRUCT LDKOnionMessageContents {
   LDKOnionMessageContents_Tag tag;
   union {
      struct {
         struct LDKCustomOnionMessageContents custom;
      };
   };
} LDKOnionMessageContents;



/**
 * FilesystemPersister persists channel data on disk, where each channel's
 * data is stored in a file named after its funding outpoint.
 *
 * Warning: this module does the best it can with calls to persist data, but it
 * can only guarantee that the data is passed to the drive. It is up to the
 * drive manufacturers to do the actual persistence properly, which they often
 * don't (especially on consumer-grade hardware). Therefore, it is up to the
 * user to validate their entire storage stack, to ensure the writes are
 * persistent.
 * Corollary: especially when dealing with larger amounts of money, it is best
 * practice to have multiple channel data backups and not rely only on one
 * FilesystemPersister.
 */
typedef struct MUST_USE_STRUCT LDKFilesystemPersister {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFilesystemPersister *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFilesystemPersister;



/**
 * `BackgroundProcessor` takes care of tasks that (1) need to happen periodically to keep
 * Rust-Lightning running properly, and (2) either can or should be run in the background. Its
 * responsibilities are:
 * * Processing [`Event`]s with a user-provided [`EventHandler`].
 * * Monitoring whether the [`ChannelManager`] needs to be re-persisted to disk, and if so,
 *   writing it to disk/backups by invoking the callback given to it at startup.
 *   [`ChannelManager`] persistence should be done in the background.
 * * Calling [`ChannelManager::timer_tick_occurred`] and [`PeerManager::timer_tick_occurred`]
 *   at the appropriate intervals.
 * * Calling [`NetworkGraph::remove_stale_channels_and_tracking`] (if a [`GossipSync`] with a
 *   [`NetworkGraph`] is provided to [`BackgroundProcessor::start`]).
 *
 * It will also call [`PeerManager::process_events`] periodically though this shouldn't be relied
 * upon as doing so may result in high latency.
 *
 * # Note
 *
 * If [`ChannelManager`] persistence fails and the persisted manager becomes out-of-date, then
 * there is a risk of channels force-closing on startup when the manager realizes it's outdated.
 * However, as long as [`ChannelMonitor`] backups are sound, no funds besides those used for
 * unilateral chain closure fees are at risk.
 *
 * [`ChannelMonitor`]: lightning::chain::channelmonitor::ChannelMonitor
 * [`Event`]: lightning::util::events::Event
 *BackgroundProcessor will immediately stop on drop. It should be stored until shutdown.
 */
typedef struct MUST_USE_STRUCT LDKBackgroundProcessor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBackgroundProcessor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBackgroundProcessor;



/**
 * The main Rapid Gossip Sync object.
 *
 * See [crate-level documentation] for usage.
 *
 * [crate-level documentation]: crate
 */
typedef struct MUST_USE_STRUCT LDKRapidGossipSync {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRapidGossipSync *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRapidGossipSync;

/**
 * Either [`P2PGossipSync`] or [`RapidGossipSync`].
 */
typedef enum LDKGossipSync_Tag {
   /**
    * Gossip sync via the lightning peer-to-peer network as defined by BOLT 7.
    */
   LDKGossipSync_P2P,
   /**
    * Rapid gossip sync from a trusted server.
    */
   LDKGossipSync_Rapid,
   /**
    * No gossip sync.
    */
   LDKGossipSync_None,
   /**
    * Must be last for serialization purposes
    */
   LDKGossipSync_Sentinel,
} LDKGossipSync_Tag;

typedef struct MUST_USE_STRUCT LDKGossipSync {
   LDKGossipSync_Tag tag;
   union {
      struct {
         /**
          * Note that this field is expected to be a reference.
          */
         struct LDKP2PGossipSync p2p;
      };
      struct {
         /**
          * Note that this field is expected to be a reference.
          */
         struct LDKRapidGossipSync rapid;
      };
   };
} LDKGossipSync;



/**
 * Data of the `RawInvoice` that is encoded in the data part
 */
typedef struct MUST_USE_STRUCT LDKRawDataPart {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRawDataPart *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRawDataPart;



/**
 * SHA-256 hash
 */
typedef struct MUST_USE_STRUCT LDKSha256 {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSha256 *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSha256;



/**
 * Positive duration that defines when (relatively to the timestamp) in the future the invoice
 * expires
 */
typedef struct MUST_USE_STRUCT LDKExpiryTime {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeExpiryTime *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKExpiryTime;



/**
 * `min_final_cltv_expiry` to use for the last HTLC in the route
 */
typedef struct MUST_USE_STRUCT LDKMinFinalCltvExpiry {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMinFinalCltvExpiry *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMinFinalCltvExpiry;

/**
 * A 20-byte byte array.
 */
typedef struct LDKTwentyBytes {
   /**
    * The twenty bytes
    */
   uint8_t data[20];
} LDKTwentyBytes;

/**
 * Fallback address in case no LN payment is possible
 */
typedef enum LDKFallback_Tag {
   LDKFallback_SegWitProgram,
   LDKFallback_PubKeyHash,
   LDKFallback_ScriptHash,
   /**
    * Must be last for serialization purposes
    */
   LDKFallback_Sentinel,
} LDKFallback_Tag;

typedef struct LDKFallback_LDKSegWitProgram_Body {
   struct LDKU5 version;
   struct LDKCVec_u8Z program;
} LDKFallback_LDKSegWitProgram_Body;

typedef struct MUST_USE_STRUCT LDKFallback {
   LDKFallback_Tag tag;
   union {
      LDKFallback_LDKSegWitProgram_Body seg_wit_program;
      struct {
         struct LDKTwentyBytes pub_key_hash;
      };
      struct {
         struct LDKTwentyBytes script_hash;
      };
   };
} LDKFallback;

/**
 * A trait defining behavior of an [`Invoice`] payer.
 *
 * While the behavior of [`InvoicePayer`] provides idempotency of duplicate `send_*payment` calls
 * with the same [`PaymentHash`], it is up to the `Payer` to provide idempotency across restarts.
 *
 * [`ChannelManager`] provides idempotency for duplicate payments with the same [`PaymentId`].
 *
 * In order to trivially ensure idempotency for payments, the default `Payer` implementation
 * reuses the [`PaymentHash`] bytes as the [`PaymentId`]. Custom implementations wishing to
 * provide payment idempotency with a different idempotency key (i.e. [`PaymentId`]) should map
 * the [`Invoice`] or spontaneous payment target pubkey to their own idempotency key.
 *
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 */
typedef struct LDKPayer {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the payer's node id.
    */
   struct LDKPublicKey (*node_id)(const void *this_arg);
   /**
    * Returns the payer's channels.
    */
   struct LDKCVec_ChannelDetailsZ (*first_hops)(const void *this_arg);
   /**
    * Sends a payment over the Lightning Network using the given [`Route`].
    *
    * Note that payment_secret (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCResult_NonePaymentSendFailureZ (*send_payment)(const void *this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret, struct LDKThirtyTwoBytes payment_id);
   /**
    * Sends a spontaneous payment over the Lightning Network using the given [`Route`].
    */
   struct LDKCResult_NonePaymentSendFailureZ (*send_spontaneous_payment)(const void *this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_id);
   /**
    * Retries a failed payment path for the [`PaymentId`] using the given [`Route`].
    */
   struct LDKCResult_NonePaymentSendFailureZ (*retry_payment)(const void *this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_id);
   /**
    * Signals that no further retries for the given payment will occur.
    */
   void (*abandon_payment)(const void *this_arg, struct LDKThirtyTwoBytes payment_id);
   /**
    * Construct an [`InFlightHtlcs`] containing information about currently used up liquidity
    * across payments.
    */
   struct LDKInFlightHtlcs (*inflight_htlcs)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPayer;



/**
 * A utility for paying [`Invoice`]s and sending spontaneous payments.
 *
 * See [module-level documentation] for details.
 *
 * [module-level documentation]: crate::payment
 */
typedef struct MUST_USE_STRUCT LDKInvoicePayer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoicePayer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoicePayer;

/**
 * Strategies available to retry payment path failures for an [`Invoice`].
 *
 */
typedef enum LDKRetry_Tag {
   /**
    * Max number of attempts to retry payment.
    *
    * Note that this is the number of *path* failures, not full payment retries. For multi-path
    * payments, if this is less than the total number of paths, we will never even retry all of the
    * payment's paths.
    */
   LDKRetry_Attempts,
   /**
    * Time elapsed before abandoning retries for a payment.
    */
   LDKRetry_Timeout,
   /**
    * Must be last for serialization purposes
    */
   LDKRetry_Sentinel,
} LDKRetry_Tag;

typedef struct MUST_USE_STRUCT LDKRetry {
   LDKRetry_Tag tag;
   union {
      struct {
         uintptr_t attempts;
      };
      struct {
         uint64_t timeout;
      };
   };
} LDKRetry;

extern const uintptr_t MAX_BUF_SIZE;

extern const uint64_t MIN_RELAY_FEE_SAT_PER_1000_WEIGHT;

extern const uint32_t FEERATE_FLOOR_SATS_PER_KW;

extern const uint64_t CLOSED_CHANNEL_UPDATE_ID;

extern const uint32_t ANTI_REORG_DELAY;

extern const uint16_t BREAKDOWN_TIMEOUT;

extern const uint16_t MIN_CLTV_EXPIRY_DELTA;

extern const uint32_t MIN_FINAL_CLTV_EXPIRY;

extern const uint16_t MAX_HTLCS;

extern const uintptr_t OFFERED_HTLC_SCRIPT_WEIGHT;

extern const uintptr_t OFFERED_HTLC_SCRIPT_WEIGHT_ANCHORS;

extern const uintptr_t MAX_ACCEPTED_HTLC_SCRIPT_WEIGHT;

extern const uintptr_t REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH;

extern const uint64_t UNKNOWN_CHANNEL_CAPACITY_MSAT;

extern const uint32_t DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA;

extern const uint8_t DEFAULT_MAX_PATH_COUNT;

extern const uint64_t MAX_TIMESTAMP;

extern const uint64_t DEFAULT_EXPIRY_TIME;

extern const uint64_t DEFAULT_MIN_FINAL_CLTV_EXPIRY;

extern const uint8_t TAG_PAYMENT_HASH;

extern const uint8_t TAG_DESCRIPTION;

extern const uint8_t TAG_PAYEE_PUB_KEY;

extern const uint8_t TAG_DESCRIPTION_HASH;

extern const uint8_t TAG_EXPIRY_TIME;

extern const uint8_t TAG_MIN_FINAL_CLTV_EXPIRY;

extern const uint8_t TAG_FALLBACK;

extern const uint8_t TAG_PRIVATE_ROUTE;

extern const uint8_t TAG_PAYMENT_SECRET;

extern const uint8_t TAG_FEATURES;

struct LDKStr _ldk_get_compiled_version(void);

struct LDKStr _ldk_c_bindings_get_compiled_version(void);

/**
 * Gets the 128-bit integer, as 16 little-endian bytes
 */
struct LDKSixteenBytes U128_le_bytes(struct LDKU128 val);

/**
 * Constructs a new U128 from 16 little-endian bytes
 */
struct LDKU128 U128_new(struct LDKSixteenBytes le_bytes);

/**
 * Convenience function for constructing a new BigEndianScalar
 */
struct LDKBigEndianScalar BigEndianScalar_new(struct LDKThirtyTwoBytes big_endian_bytes);

/**
 * Creates a new Bech32Error which has the same data as `orig`
 */
struct LDKBech32Error Bech32Error_clone(const struct LDKBech32Error *NONNULL_PTR orig);

/**
 * Releases any memory held by the given `Bech32Error` (which is currently none)
 */
void Bech32Error_free(struct LDKBech32Error o);

/**
 * Frees the data buffer, if data_is_owned is set and datalen > 0.
 */
void Transaction_free(struct LDKTransaction _res);

/**
 * Frees the data pointed to by data
 */
void Witness_free(struct LDKWitness _res);

/**
 * Convenience function for constructing a new TxOut
 */
struct LDKTxOut TxOut_new(struct LDKCVec_u8Z script_pubkey, uint64_t value);

/**
 * Frees the data pointed to by script_pubkey.
 */
void TxOut_free(struct LDKTxOut _res);

/**
 * Creates a new TxOut which has the same data as `orig` but with a new script buffer.
 */
struct LDKTxOut TxOut_clone(const struct LDKTxOut *NONNULL_PTR orig);

/**
 * Frees the data buffer, if chars_is_owned is set and len > 0.
 */
void Str_free(struct LDKStr _res);

#if defined(LDK_DEBUG_BUILD)
/**
 * This function exists for memory safety testing purposes. It should never be used in production
 * code
 */
const void *__unmangle_inner_ptr(const void *ptr);
#endif

/**
 * Constructs a new COption_HTLCClaimZ containing a crate::lightning::ln::chan_utils::HTLCClaim
 */
struct LDKCOption_HTLCClaimZ COption_HTLCClaimZ_some(enum LDKHTLCClaim o);

/**
 * Constructs a new COption_HTLCClaimZ containing nothing
 */
struct LDKCOption_HTLCClaimZ COption_HTLCClaimZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::chan_utils::HTLCClaim, if we are in the Some state
 */
void COption_HTLCClaimZ_free(struct LDKCOption_HTLCClaimZ _res);

/**
 * Creates a new CResult_NoneNoneZ in the success state.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_ok(void);

/**
 * Creates a new CResult_NoneNoneZ in the error state.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneNoneZ_is_ok(const struct LDKCResult_NoneNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneNoneZ.
 */
void CResult_NoneNoneZ_free(struct LDKCResult_NoneNoneZ _res);

/**
 * Creates a new CResult_NoneNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_clone(const struct LDKCResult_NoneNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(struct LDKCounterpartyCommitmentSecrets o);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyCommitmentSecretsDecodeErrorZ.
 */
void CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ in the success state.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(struct LDKTxCreationKeys o);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ in the error state.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxCreationKeysDecodeErrorZ_is_ok(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxCreationKeysDecodeErrorZ.
 */
void CResult_TxCreationKeysDecodeErrorZ_free(struct LDKCResult_TxCreationKeysDecodeErrorZ _res);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_clone(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_ok(struct LDKChannelPublicKeys o);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelPublicKeysDecodeErrorZ_is_ok(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelPublicKeysDecodeErrorZ.
 */
void CResult_ChannelPublicKeysDecodeErrorZ_free(struct LDKCResult_ChannelPublicKeysDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_clone(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_u32Z containing a u32
 */
struct LDKCOption_u32Z COption_u32Z_some(uint32_t o);

/**
 * Constructs a new COption_u32Z containing nothing
 */
struct LDKCOption_u32Z COption_u32Z_none(void);

/**
 * Frees any resources associated with the u32, if we are in the Some state
 */
void COption_u32Z_free(struct LDKCOption_u32Z _res);

/**
 * Creates a new COption_u32Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u32Z COption_u32Z_clone(const struct LDKCOption_u32Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(struct LDKHTLCOutputInCommitment o);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HTLCOutputInCommitmentDecodeErrorZ.
 */
void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_NoneZ containing a
 */
enum LDKCOption_NoneZ COption_NoneZ_some(void);

/**
 * Constructs a new COption_NoneZ containing nothing
 */
enum LDKCOption_NoneZ COption_NoneZ_none(void);

/**
 * Frees any resources associated with the , if we are in the Some state
 */
void COption_NoneZ_free(enum LDKCOption_NoneZ _res);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(struct LDKCounterpartyChannelTransactionParameters o);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyChannelTransactionParametersDecodeErrorZ.
 */
void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_ok(struct LDKChannelTransactionParameters o);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelTransactionParametersDecodeErrorZ.
 */
void CResult_ChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_ChannelTransactionParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_SignatureZ_free(struct LDKCVec_SignatureZ _res);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_ok(struct LDKHolderCommitmentTransaction o);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HolderCommitmentTransactionDecodeErrorZ.
 */
void CResult_HolderCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(struct LDKBuiltCommitmentTransaction o);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BuiltCommitmentTransactionDecodeErrorZ.
 */
void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TrustedClosingTransactionNoneZ in the success state.
 */
struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_ok(struct LDKTrustedClosingTransaction o);

/**
 * Creates a new CResult_TrustedClosingTransactionNoneZ in the error state.
 */
struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TrustedClosingTransactionNoneZ_is_ok(const struct LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TrustedClosingTransactionNoneZ.
 */
void CResult_TrustedClosingTransactionNoneZ_free(struct LDKCResult_TrustedClosingTransactionNoneZ _res);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_ok(struct LDKCommitmentTransaction o);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CommitmentTransactionDecodeErrorZ.
 */
void CResult_CommitmentTransactionDecodeErrorZ_free(struct LDKCResult_CommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the success state.
 */
struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_ok(struct LDKTrustedCommitmentTransaction o);

/**
 * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the error state.
 */
struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TrustedCommitmentTransactionNoneZ_is_ok(const struct LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TrustedCommitmentTransactionNoneZ.
 */
void CResult_TrustedCommitmentTransactionNoneZ_free(struct LDKCResult_TrustedCommitmentTransactionNoneZ _res);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ in the success state.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_ok(struct LDKCVec_SignatureZ o);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ in the error state.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_SignatureZNoneZ_is_ok(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_SignatureZNoneZ.
 */
void CResult_CVec_SignatureZNoneZ_free(struct LDKCResult_CVec_SignatureZNoneZ _res);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_clone(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ in the success state.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_ok(struct LDKShutdownScript o);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ in the error state.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownScriptDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownScriptDecodeErrorZ.
 */
void CResult_ShutdownScriptDecodeErrorZ_free(struct LDKCResult_ShutdownScriptDecodeErrorZ _res);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_clone(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the success state.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_ok(struct LDKShutdownScript o);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the error state.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_err(struct LDKInvalidShutdownScript e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownScriptInvalidShutdownScriptZ.
 */
void CResult_ShutdownScriptInvalidShutdownScriptZ_free(struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ _res);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_clone(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PublicKeyZ_free(struct LDKCVec_PublicKeyZ _res);

/**
 * Creates a new CResult_BlindedPathNoneZ in the success state.
 */
struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_ok(struct LDKBlindedPath o);

/**
 * Creates a new CResult_BlindedPathNoneZ in the error state.
 */
struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedPathNoneZ_is_ok(const struct LDKCResult_BlindedPathNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedPathNoneZ.
 */
void CResult_BlindedPathNoneZ_free(struct LDKCResult_BlindedPathNoneZ _res);

/**
 * Creates a new CResult_BlindedPathNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_clone(const struct LDKCResult_BlindedPathNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BlindedPathDecodeErrorZ in the success state.
 */
struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_ok(struct LDKBlindedPath o);

/**
 * Creates a new CResult_BlindedPathDecodeErrorZ in the error state.
 */
struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedPathDecodeErrorZ_is_ok(const struct LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedPathDecodeErrorZ.
 */
void CResult_BlindedPathDecodeErrorZ_free(struct LDKCResult_BlindedPathDecodeErrorZ _res);

/**
 * Creates a new CResult_BlindedPathDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_clone(const struct LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BlindedHopDecodeErrorZ in the success state.
 */
struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_ok(struct LDKBlindedHop o);

/**
 * Creates a new CResult_BlindedHopDecodeErrorZ in the error state.
 */
struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedHopDecodeErrorZ_is_ok(const struct LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedHopDecodeErrorZ.
 */
void CResult_BlindedHopDecodeErrorZ_free(struct LDKCResult_BlindedHopDecodeErrorZ _res);

/**
 * Creates a new CResult_BlindedHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_clone(const struct LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_WriteableScoreZ containing a crate::lightning::routing::scoring::WriteableScore
 */
struct LDKCOption_WriteableScoreZ COption_WriteableScoreZ_some(struct LDKWriteableScore o);

/**
 * Constructs a new COption_WriteableScoreZ containing nothing
 */
struct LDKCOption_WriteableScoreZ COption_WriteableScoreZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::routing::scoring::WriteableScore, if we are in the Some state
 */
void COption_WriteableScoreZ_free(struct LDKCOption_WriteableScoreZ _res);

/**
 * Creates a new CResult_NoneErrorZ in the success state.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_ok(void);

/**
 * Creates a new CResult_NoneErrorZ in the error state.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneErrorZ_is_ok(const struct LDKCResult_NoneErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneErrorZ.
 */
void CResult_NoneErrorZ_free(struct LDKCResult_NoneErrorZ _res);

/**
 * Creates a new CResult_NoneErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_clone(const struct LDKCResult_NoneErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ChannelDetailsZ_free(struct LDKCVec_ChannelDetailsZ _res);

/**
 * Creates a new CResult_RouteLightningErrorZ in the success state.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(struct LDKRoute o);

/**
 * Creates a new CResult_RouteLightningErrorZ in the error state.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteLightningErrorZ_is_ok(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteLightningErrorZ.
 */
void CResult_RouteLightningErrorZ_free(struct LDKCResult_RouteLightningErrorZ _res);

/**
 * Creates a new CResult_RouteLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHopZ_free(struct LDKCVec_RouteHopZ _res);

/**
 * Constructs a new COption_u64Z containing a u64
 */
struct LDKCOption_u64Z COption_u64Z_some(uint64_t o);

/**
 * Constructs a new COption_u64Z containing nothing
 */
struct LDKCOption_u64Z COption_u64Z_none(void);

/**
 * Frees any resources associated with the u64, if we are in the Some state
 */
void COption_u64Z_free(struct LDKCOption_u64Z _res);

/**
 * Creates a new COption_u64Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u64Z COption_u64Z_clone(const struct LDKCOption_u64Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_InFlightHtlcsDecodeErrorZ in the success state.
 */
struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_ok(struct LDKInFlightHtlcs o);

/**
 * Creates a new CResult_InFlightHtlcsDecodeErrorZ in the error state.
 */
struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InFlightHtlcsDecodeErrorZ_is_ok(const struct LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InFlightHtlcsDecodeErrorZ.
 */
void CResult_InFlightHtlcsDecodeErrorZ_free(struct LDKCResult_InFlightHtlcsDecodeErrorZ _res);

/**
 * Creates a new CResult_InFlightHtlcsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_clone(const struct LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_ok(struct LDKRouteHop o);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHopDecodeErrorZ.
 */
void CResult_RouteHopDecodeErrorZ_free(struct LDKCResult_RouteHopDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_clone(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CVec_RouteHopZZ_free(struct LDKCVec_CVec_RouteHopZZ _res);

/**
 * Creates a new CResult_RouteDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(struct LDKRoute o);

/**
 * Creates a new CResult_RouteDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteDecodeErrorZ_is_ok(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteDecodeErrorZ.
 */
void CResult_RouteDecodeErrorZ_free(struct LDKCResult_RouteDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_ok(struct LDKRouteParameters o);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteParametersDecodeErrorZ_is_ok(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteParametersDecodeErrorZ.
 */
void CResult_RouteParametersDecodeErrorZ_free(struct LDKCResult_RouteParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_clone(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHintZ_free(struct LDKCVec_RouteHintZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u64Z_free(struct LDKCVec_u64Z _res);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_ok(struct LDKPaymentParameters o);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentParametersDecodeErrorZ_is_ok(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentParametersDecodeErrorZ.
 */
void CResult_PaymentParametersDecodeErrorZ_free(struct LDKCResult_PaymentParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_clone(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHintHopZ_free(struct LDKCVec_RouteHintHopZ _res);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_ok(struct LDKRouteHint o);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHintDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHintDecodeErrorZ.
 */
void CResult_RouteHintDecodeErrorZ_free(struct LDKCResult_RouteHintDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_clone(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_ok(struct LDKRouteHintHop o);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHintHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHintHopDecodeErrorZ.
 */
void CResult_RouteHintHopDecodeErrorZ_free(struct LDKCResult_RouteHintHopDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_clone(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentPurposeDecodeErrorZ in the success state.
 */
struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_ok(struct LDKPaymentPurpose o);

/**
 * Creates a new CResult_PaymentPurposeDecodeErrorZ in the error state.
 */
struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentPurposeDecodeErrorZ_is_ok(const struct LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentPurposeDecodeErrorZ.
 */
void CResult_PaymentPurposeDecodeErrorZ_free(struct LDKCResult_PaymentPurposeDecodeErrorZ _res);

/**
 * Creates a new CResult_PaymentPurposeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_clone(const struct LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_ClosureReasonZ containing a crate::lightning::util::events::ClosureReason
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_some(struct LDKClosureReason o);

/**
 * Constructs a new COption_ClosureReasonZ containing nothing
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::util::events::ClosureReason, if we are in the Some state
 */
void COption_ClosureReasonZ_free(struct LDKCOption_ClosureReasonZ _res);

/**
 * Creates a new COption_ClosureReasonZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_clone(const struct LDKCOption_ClosureReasonZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_ok(struct LDKCOption_ClosureReasonZ o);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_ClosureReasonZDecodeErrorZ.
 */
void CResult_COption_ClosureReasonZDecodeErrorZ_free(struct LDKCResult_COption_ClosureReasonZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_clone(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_HTLCDestinationZ containing a crate::lightning::util::events::HTLCDestination
 */
struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_some(struct LDKHTLCDestination o);

/**
 * Constructs a new COption_HTLCDestinationZ containing nothing
 */
struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::util::events::HTLCDestination, if we are in the Some state
 */
void COption_HTLCDestinationZ_free(struct LDKCOption_HTLCDestinationZ _res);

/**
 * Creates a new COption_HTLCDestinationZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_clone(const struct LDKCOption_HTLCDestinationZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_ok(struct LDKCOption_HTLCDestinationZ o);

/**
 * Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(const struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_HTLCDestinationZDecodeErrorZ.
 */
void CResult_COption_HTLCDestinationZDecodeErrorZ_free(struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_clone(const struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_u128Z containing a crate::c_types::U128
 */
struct LDKCOption_u128Z COption_u128Z_some(struct LDKU128 o);

/**
 * Constructs a new COption_u128Z containing nothing
 */
struct LDKCOption_u128Z COption_u128Z_none(void);

/**
 * Frees any resources associated with the crate::c_types::U128, if we are in the Some state
 */
void COption_u128Z_free(struct LDKCOption_u128Z _res);

/**
 * Creates a new COption_u128Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u128Z COption_u128Z_clone(const struct LDKCOption_u128Z *NONNULL_PTR orig);

/**
 * Constructs a new COption_NetworkUpdateZ containing a crate::lightning::routing::gossip::NetworkUpdate
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_some(struct LDKNetworkUpdate o);

/**
 * Constructs a new COption_NetworkUpdateZ containing nothing
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::routing::gossip::NetworkUpdate, if we are in the Some state
 */
void COption_NetworkUpdateZ_free(struct LDKCOption_NetworkUpdateZ _res);

/**
 * Creates a new COption_NetworkUpdateZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_clone(const struct LDKCOption_NetworkUpdateZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_SpendableOutputDescriptorZ_free(struct LDKCVec_SpendableOutputDescriptorZ _res);

/**
 * Constructs a new COption_EventZ containing a crate::lightning::util::events::Event
 */
struct LDKCOption_EventZ COption_EventZ_some(struct LDKEvent o);

/**
 * Constructs a new COption_EventZ containing nothing
 */
struct LDKCOption_EventZ COption_EventZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::util::events::Event, if we are in the Some state
 */
void COption_EventZ_free(struct LDKCOption_EventZ _res);

/**
 * Creates a new COption_EventZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_EventZ COption_EventZ_clone(const struct LDKCOption_EventZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_ok(struct LDKCOption_EventZ o);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_EventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_EventZDecodeErrorZ.
 */
void CResult_COption_EventZDecodeErrorZ_free(struct LDKCResult_COption_EventZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_clone(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MessageSendEventZ_free(struct LDKCVec_MessageSendEventZ _res);

/**
 * Creates a new CResult_TxOutAccessErrorZ in the success state.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_ok(struct LDKTxOut o);

/**
 * Creates a new CResult_TxOutAccessErrorZ in the error state.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_err(enum LDKAccessError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxOutAccessErrorZ_is_ok(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxOutAccessErrorZ.
 */
void CResult_TxOutAccessErrorZ_free(struct LDKCResult_TxOutAccessErrorZ _res);

/**
 * Creates a new CResult_TxOutAccessErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_clone(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_clone(const struct LDKC2Tuple_usizeTransactionZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_usizeTransactionZ from the contained elements.
 */
struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(uintptr_t a, struct LDKTransaction b);

/**
 * Frees any resources used by the C2Tuple_usizeTransactionZ.
 */
void C2Tuple_usizeTransactionZ_free(struct LDKC2Tuple_usizeTransactionZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_usizeTransactionZZ_free(struct LDKCVec_C2Tuple_usizeTransactionZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_TxidBlockHashZ C2Tuple_TxidBlockHashZ_clone(const struct LDKC2Tuple_TxidBlockHashZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_TxidBlockHashZ from the contained elements.
 */
struct LDKC2Tuple_TxidBlockHashZ C2Tuple_TxidBlockHashZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);

/**
 * Frees any resources used by the C2Tuple_TxidBlockHashZ.
 */
void C2Tuple_TxidBlockHashZ_free(struct LDKC2Tuple_TxidBlockHashZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_TxidBlockHashZZ_free(struct LDKCVec_C2Tuple_TxidBlockHashZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MonitorEventZ_free(struct LDKCVec_MonitorEventZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone(const struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ from the contained elements.
 */
struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new(struct LDKOutPoint a, struct LDKCVec_MonitorEventZ b, struct LDKPublicKey c);

/**
 * Frees any resources used by the C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ.
 */
void C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free(struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free(struct LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ _res);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the success state.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_ok(struct LDKFixedPenaltyScorer o);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the error state.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FixedPenaltyScorerDecodeErrorZ.
 */
void CResult_FixedPenaltyScorerDecodeErrorZ_free(struct LDKCResult_FixedPenaltyScorerDecodeErrorZ _res);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_clone(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u64u64Z C2Tuple_u64u64Z_clone(const struct LDKC2Tuple_u64u64Z *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u64u64Z from the contained elements.
 */
struct LDKC2Tuple_u64u64Z C2Tuple_u64u64Z_new(uint64_t a, uint64_t b);

/**
 * Frees any resources used by the C2Tuple_u64u64Z.
 */
void C2Tuple_u64u64Z_free(struct LDKC2Tuple_u64u64Z _res);

/**
 * Constructs a new COption_C2Tuple_u64u64ZZ containing a crate::c_types::derived::C2Tuple_u64u64Z
 */
struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_some(struct LDKC2Tuple_u64u64Z o);

/**
 * Constructs a new COption_C2Tuple_u64u64ZZ containing nothing
 */
struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::C2Tuple_u64u64Z, if we are in the Some state
 */
void COption_C2Tuple_u64u64ZZ_free(struct LDKCOption_C2Tuple_u64u64ZZ _res);

/**
 * Creates a new COption_C2Tuple_u64u64ZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_clone(const struct LDKCOption_C2Tuple_u64u64ZZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_NodeIdZ_free(struct LDKCVec_NodeIdZ _res);

/**
 * Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the success state.
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_ok(struct LDKProbabilisticScorer o);

/**
 * Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the error state.
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ProbabilisticScorerDecodeErrorZ_is_ok(const struct LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ProbabilisticScorerDecodeErrorZ.
 */
void CResult_ProbabilisticScorerDecodeErrorZ_free(struct LDKCResult_ProbabilisticScorerDecodeErrorZ _res);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(struct LDKInitFeatures o);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InitFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InitFeaturesDecodeErrorZ.
 */
void CResult_InitFeaturesDecodeErrorZ_free(struct LDKCResult_InitFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_clone(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(struct LDKChannelFeatures o);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelFeaturesDecodeErrorZ.
 */
void CResult_ChannelFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_clone(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(struct LDKNodeFeatures o);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeFeaturesDecodeErrorZ.
 */
void CResult_NodeFeaturesDecodeErrorZ_free(struct LDKCResult_NodeFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_clone(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_ok(struct LDKInvoiceFeatures o);

/**
 * Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceFeaturesDecodeErrorZ.
 */
void CResult_InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_InvoiceFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_InvoiceFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_clone(const struct LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_ok(struct LDKChannelTypeFeatures o);

/**
 * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelTypeFeaturesDecodeErrorZ.
 */
void CResult_ChannelTypeFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_clone(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OfferFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_OfferFeaturesDecodeErrorZ CResult_OfferFeaturesDecodeErrorZ_ok(struct LDKOfferFeatures o);

/**
 * Creates a new CResult_OfferFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_OfferFeaturesDecodeErrorZ CResult_OfferFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OfferFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_OfferFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OfferFeaturesDecodeErrorZ.
 */
void CResult_OfferFeaturesDecodeErrorZ_free(struct LDKCResult_OfferFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_OfferFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OfferFeaturesDecodeErrorZ CResult_OfferFeaturesDecodeErrorZ_clone(const struct LDKCResult_OfferFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceRequestFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_InvoiceRequestFeaturesDecodeErrorZ CResult_InvoiceRequestFeaturesDecodeErrorZ_ok(struct LDKInvoiceRequestFeatures o);

/**
 * Creates a new CResult_InvoiceRequestFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_InvoiceRequestFeaturesDecodeErrorZ CResult_InvoiceRequestFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceRequestFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InvoiceRequestFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceRequestFeaturesDecodeErrorZ.
 */
void CResult_InvoiceRequestFeaturesDecodeErrorZ_free(struct LDKCResult_InvoiceRequestFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_InvoiceRequestFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceRequestFeaturesDecodeErrorZ CResult_InvoiceRequestFeaturesDecodeErrorZ_clone(const struct LDKCResult_InvoiceRequestFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_ok(struct LDKNodeId o);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeIdDecodeErrorZ_is_ok(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeIdDecodeErrorZ.
 */
void CResult_NodeIdDecodeErrorZ_free(struct LDKCResult_NodeIdDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_clone(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_ok(struct LDKCOption_NetworkUpdateZ o);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_NetworkUpdateZDecodeErrorZ.
 */
void CResult_COption_NetworkUpdateZDecodeErrorZ_free(struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_clone(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_AccessZ containing a crate::lightning::chain::Access
 */
struct LDKCOption_AccessZ COption_AccessZ_some(struct LDKAccess o);

/**
 * Constructs a new COption_AccessZ containing nothing
 */
struct LDKCOption_AccessZ COption_AccessZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::chain::Access, if we are in the Some state
 */
void COption_AccessZ_free(struct LDKCOption_AccessZ _res);

/**
 * Creates a new CResult_boolLightningErrorZ in the success state.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(bool o);

/**
 * Creates a new CResult_boolLightningErrorZ in the error state.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_boolLightningErrorZ_is_ok(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_boolLightningErrorZ.
 */
void CResult_boolLightningErrorZ_free(struct LDKCResult_boolLightningErrorZ _res);

/**
 * Creates a new CResult_boolLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(const struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ from the contained elements.
 */
struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(struct LDKChannelAnnouncement a, struct LDKChannelUpdate b, struct LDKChannelUpdate c);

/**
 * Frees any resources used by the C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.
 */
void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res);

/**
 * Constructs a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ containing a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
 */
struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_some(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ o);

/**
 * Constructs a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ containing nothing
 */
struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ, if we are in the Some state
 */
void COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res);

/**
 * Creates a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone(const struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneLightningErrorZ in the success state.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok(void);

/**
 * Creates a new CResult_NoneLightningErrorZ in the error state.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneLightningErrorZ_is_ok(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneLightningErrorZ.
 */
void CResult_NoneLightningErrorZ_free(struct LDKCResult_NoneLightningErrorZ _res);

/**
 * Creates a new CResult_NoneLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_ok(struct LDKChannelUpdateInfo o);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelUpdateInfoDecodeErrorZ.
 */
void CResult_ChannelUpdateInfoDecodeErrorZ_free(struct LDKCResult_ChannelUpdateInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(struct LDKChannelInfo o);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelInfoDecodeErrorZ.
 */
void CResult_ChannelInfoDecodeErrorZ_free(struct LDKCResult_ChannelInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ in the success state.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(struct LDKRoutingFees o);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ in the error state.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RoutingFeesDecodeErrorZ_is_ok(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RoutingFeesDecodeErrorZ.
 */
void CResult_RoutingFeesDecodeErrorZ_free(struct LDKCResult_RoutingFeesDecodeErrorZ _res);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_NetAddressZ_free(struct LDKCVec_NetAddressZ _res);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_ok(struct LDKNodeAnnouncementInfo o);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeAnnouncementInfoDecodeErrorZ.
 */
void CResult_NodeAnnouncementInfoDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeAliasDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_ok(struct LDKNodeAlias o);

/**
 * Creates a new CResult_NodeAliasDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeAliasDecodeErrorZ_is_ok(const struct LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeAliasDecodeErrorZ.
 */
void CResult_NodeAliasDecodeErrorZ_free(struct LDKCResult_NodeAliasDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAliasDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_clone(const struct LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(struct LDKNodeInfo o);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeInfoDecodeErrorZ.
 */
void CResult_NodeInfoDecodeErrorZ_free(struct LDKCResult_NodeInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ in the success state.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(struct LDKNetworkGraph o);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ in the error state.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NetworkGraphDecodeErrorZ_is_ok(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NetworkGraphDecodeErrorZ.
 */
void CResult_NetworkGraphDecodeErrorZ_free(struct LDKCResult_NetworkGraphDecodeErrorZ _res);

/**
 * Constructs a new COption_CVec_NetAddressZZ containing a crate::c_types::derived::CVec_NetAddressZ
 */
struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_some(struct LDKCVec_NetAddressZ o);

/**
 * Constructs a new COption_CVec_NetAddressZZ containing nothing
 */
struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::CVec_NetAddressZ, if we are in the Some state
 */
void COption_CVec_NetAddressZZ_free(struct LDKCOption_CVec_NetAddressZZ _res);

/**
 * Creates a new COption_CVec_NetAddressZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_clone(const struct LDKCOption_CVec_NetAddressZZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKDelayedPaymentOutputDescriptor o);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_DelayedPaymentOutputDescriptorDecodeErrorZ.
 */
void CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKStaticPaymentOutputDescriptor o);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_StaticPaymentOutputDescriptorDecodeErrorZ.
 */
void CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_ok(struct LDKSpendableOutputDescriptor o);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SpendableOutputDescriptorDecodeErrorZ.
 */
void CResult_SpendableOutputDescriptorDecodeErrorZ_free(struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PaymentPreimageZ_free(struct LDKCVec_PaymentPreimageZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_clone(const struct LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_SignatureCVec_SignatureZZ from the contained elements.
 */
struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_new(struct LDKSignature a, struct LDKCVec_SignatureZ b);

/**
 * Frees any resources used by the C2Tuple_SignatureCVec_SignatureZZ.
 */
void C2Tuple_SignatureCVec_SignatureZZ_free(struct LDKC2Tuple_SignatureCVec_SignatureZZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(struct LDKC2Tuple_SignatureCVec_SignatureZZ o);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ.
 */
void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignatureNoneZ in the success state.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_ok(struct LDKSignature o);

/**
 * Creates a new CResult_SignatureNoneZ in the error state.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SignatureNoneZ_is_ok(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SignatureNoneZ.
 */
void CResult_SignatureNoneZ_free(struct LDKCResult_SignatureNoneZ _res);

/**
 * Creates a new CResult_SignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_clone(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_SignatureSignatureZ C2Tuple_SignatureSignatureZ_clone(const struct LDKC2Tuple_SignatureSignatureZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_SignatureSignatureZ from the contained elements.
 */
struct LDKC2Tuple_SignatureSignatureZ C2Tuple_SignatureSignatureZ_new(struct LDKSignature a, struct LDKSignature b);

/**
 * Frees any resources used by the C2Tuple_SignatureSignatureZ.
 */
void C2Tuple_SignatureSignatureZ_free(struct LDKC2Tuple_SignatureSignatureZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_ok(struct LDKC2Tuple_SignatureSignatureZ o);

/**
 * Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok(const struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_SignatureSignatureZNoneZ.
 */
void CResult_C2Tuple_SignatureSignatureZNoneZ_free(struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SecretKeyNoneZ in the success state.
 */
struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_ok(struct LDKSecretKey o);

/**
 * Creates a new CResult_SecretKeyNoneZ in the error state.
 */
struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SecretKeyNoneZ_is_ok(const struct LDKCResult_SecretKeyNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SecretKeyNoneZ.
 */
void CResult_SecretKeyNoneZ_free(struct LDKCResult_SecretKeyNoneZ _res);

/**
 * Creates a new CResult_SecretKeyNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_clone(const struct LDKCResult_SecretKeyNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PublicKeyNoneZ in the success state.
 */
struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_ok(struct LDKPublicKey o);

/**
 * Creates a new CResult_PublicKeyNoneZ in the error state.
 */
struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PublicKeyNoneZ_is_ok(const struct LDKCResult_PublicKeyNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PublicKeyNoneZ.
 */
void CResult_PublicKeyNoneZ_free(struct LDKCResult_PublicKeyNoneZ _res);

/**
 * Creates a new CResult_PublicKeyNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_clone(const struct LDKCResult_PublicKeyNoneZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_ScalarZ containing a crate::c_types::BigEndianScalar
 */
struct LDKCOption_ScalarZ COption_ScalarZ_some(struct LDKBigEndianScalar o);

/**
 * Constructs a new COption_ScalarZ containing nothing
 */
struct LDKCOption_ScalarZ COption_ScalarZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::BigEndianScalar, if we are in the Some state
 */
void COption_ScalarZ_free(struct LDKCOption_ScalarZ _res);

/**
 * Creates a new CResult_SharedSecretNoneZ in the success state.
 */
struct LDKCResult_SharedSecretNoneZ CResult_SharedSecretNoneZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_SharedSecretNoneZ in the error state.
 */
struct LDKCResult_SharedSecretNoneZ CResult_SharedSecretNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SharedSecretNoneZ_is_ok(const struct LDKCResult_SharedSecretNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SharedSecretNoneZ.
 */
void CResult_SharedSecretNoneZ_free(struct LDKCResult_SharedSecretNoneZ _res);

/**
 * Creates a new CResult_SharedSecretNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SharedSecretNoneZ CResult_SharedSecretNoneZ_clone(const struct LDKCResult_SharedSecretNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignDecodeErrorZ in the success state.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_ok(struct LDKSign o);

/**
 * Creates a new CResult_SignDecodeErrorZ in the error state.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SignDecodeErrorZ_is_ok(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SignDecodeErrorZ.
 */
void CResult_SignDecodeErrorZ_free(struct LDKCResult_SignDecodeErrorZ _res);

/**
 * Creates a new CResult_SignDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_clone(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_U5Z_free(struct LDKCVec_U5Z _res);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ in the success state.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_ok(struct LDKRecoverableSignature o);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ in the error state.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RecoverableSignatureNoneZ_is_ok(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RecoverableSignatureNoneZ.
 */
void CResult_RecoverableSignatureNoneZ_free(struct LDKCResult_RecoverableSignatureNoneZ _res);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_clone(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u8Z_free(struct LDKCVec_u8Z _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CVec_u8ZZ_free(struct LDKCVec_CVec_u8ZZ _res);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the success state.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(struct LDKCVec_CVec_u8ZZ o);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the error state.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_CVec_u8ZZNoneZ_is_ok(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_CVec_u8ZZNoneZ.
 */
void CResult_CVec_CVec_u8ZZNoneZ_free(struct LDKCResult_CVec_CVec_u8ZZNoneZ _res);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ in the success state.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(struct LDKInMemorySigner o);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ in the error state.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InMemorySignerDecodeErrorZ_is_ok(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InMemorySignerDecodeErrorZ.
 */
void CResult_InMemorySignerDecodeErrorZ_free(struct LDKCResult_InMemorySignerDecodeErrorZ _res);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_clone(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TxOutZ_free(struct LDKCVec_TxOutZ _res);

/**
 * Creates a new CResult_TransactionNoneZ in the success state.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(struct LDKTransaction o);

/**
 * Creates a new CResult_TransactionNoneZ in the error state.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TransactionNoneZ_is_ok(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TransactionNoneZ.
 */
void CResult_TransactionNoneZ_free(struct LDKCResult_TransactionNoneZ _res);

/**
 * Creates a new CResult_TransactionNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_clone(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_clone(const struct LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_BlockHashChannelMonitorZ from the contained elements.
 */
struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelMonitor b);

/**
 * Frees any resources used by the C2Tuple_BlockHashChannelMonitorZ.
 */
void C2Tuple_BlockHashChannelMonitorZ_free(struct LDKC2Tuple_BlockHashChannelMonitorZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_BlockHashChannelMonitorZZ_free(struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ in the success state.
 */
struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_ok(struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ o);

/**
 * Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ in the error state.
 */
struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_is_ok(const struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ.
 */
void CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_free(struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clone(const struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_u16Z containing a u16
 */
struct LDKCOption_u16Z COption_u16Z_some(uint16_t o);

/**
 * Constructs a new COption_u16Z containing nothing
 */
struct LDKCOption_u16Z COption_u16Z_none(void);

/**
 * Frees any resources associated with the u16, if we are in the Some state
 */
void COption_u16Z_free(struct LDKCOption_u16Z _res);

/**
 * Creates a new COption_u16Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u16Z COption_u16Z_clone(const struct LDKCOption_u16Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneAPIErrorZ in the success state.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok(void);

/**
 * Creates a new CResult_NoneAPIErrorZ in the error state.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneAPIErrorZ_is_ok(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneAPIErrorZ.
 */
void CResult_NoneAPIErrorZ_free(struct LDKCResult_NoneAPIErrorZ _res);

/**
 * Creates a new CResult_NoneAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CResult_NoneAPIErrorZZ_free(struct LDKCVec_CResult_NoneAPIErrorZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_APIErrorZ_free(struct LDKCVec_APIErrorZ _res);

/**
 * Creates a new CResult__u832APIErrorZ in the success state.
 */
struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult__u832APIErrorZ in the error state.
 */
struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult__u832APIErrorZ_is_ok(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult__u832APIErrorZ.
 */
void CResult__u832APIErrorZ_free(struct LDKCResult__u832APIErrorZ _res);

/**
 * Creates a new CResult__u832APIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_clone(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NonePaymentSendFailureZ in the success state.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok(void);

/**
 * Creates a new CResult_NonePaymentSendFailureZ in the error state.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NonePaymentSendFailureZ_is_ok(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NonePaymentSendFailureZ.
 */
void CResult_NonePaymentSendFailureZ_free(struct LDKCResult_NonePaymentSendFailureZ _res);

/**
 * Creates a new CResult_NonePaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentHashPaymentSendFailureZ in the success state.
 */
struct LDKCResult_PaymentHashPaymentSendFailureZ CResult_PaymentHashPaymentSendFailureZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentHashPaymentSendFailureZ in the error state.
 */
struct LDKCResult_PaymentHashPaymentSendFailureZ CResult_PaymentHashPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentHashPaymentSendFailureZ_is_ok(const struct LDKCResult_PaymentHashPaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentHashPaymentSendFailureZ.
 */
void CResult_PaymentHashPaymentSendFailureZ_free(struct LDKCResult_PaymentHashPaymentSendFailureZ _res);

/**
 * Creates a new CResult_PaymentHashPaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentHashPaymentSendFailureZ CResult_PaymentHashPaymentSendFailureZ_clone(const struct LDKCResult_PaymentHashPaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_clone(const struct LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PaymentHashPaymentIdZ from the contained elements.
 */
struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);

/**
 * Frees any resources used by the C2Tuple_PaymentHashPaymentIdZ.
 */
void C2Tuple_PaymentHashPaymentIdZ_free(struct LDKC2Tuple_PaymentHashPaymentIdZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ in the success state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(struct LDKC2Tuple_PaymentHashPaymentIdZ o);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ in the error state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.
 */
void CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ThirtyTwoBytesZ_free(struct LDKCVec_ThirtyTwoBytesZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_clone(const struct LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PaymentHashPaymentSecretZ from the contained elements.
 */
struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);

/**
 * Frees any resources used by the C2Tuple_PaymentHashPaymentSecretZ.
 */
void C2Tuple_PaymentHashPaymentSecretZ_free(struct LDKC2Tuple_PaymentHashPaymentSecretZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ.
 */
void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.
 */
void CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentSecretNoneZ in the success state.
 */
struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentSecretNoneZ in the error state.
 */
struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentSecretNoneZ_is_ok(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentSecretNoneZ.
 */
void CResult_PaymentSecretNoneZ_free(struct LDKCResult_PaymentSecretNoneZ _res);

/**
 * Creates a new CResult_PaymentSecretNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_clone(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ in the success state.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ in the error state.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentSecretAPIErrorZ_is_ok(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentSecretAPIErrorZ.
 */
void CResult_PaymentSecretAPIErrorZ_free(struct LDKCResult_PaymentSecretAPIErrorZ _res);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_clone(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentPreimageAPIErrorZ in the success state.
 */
struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentPreimageAPIErrorZ in the error state.
 */
struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentPreimageAPIErrorZ_is_ok(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentPreimageAPIErrorZ.
 */
void CResult_PaymentPreimageAPIErrorZ_free(struct LDKCResult_PaymentPreimageAPIErrorZ _res);

/**
 * Creates a new CResult_PaymentPreimageAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_clone(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(struct LDKCounterpartyForwardingInfo o);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyForwardingInfoDecodeErrorZ.
 */
void CResult_CounterpartyForwardingInfoDecodeErrorZ_free(struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_ok(struct LDKChannelCounterparty o);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelCounterpartyDecodeErrorZ_is_ok(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelCounterpartyDecodeErrorZ.
 */
void CResult_ChannelCounterpartyDecodeErrorZ_free(struct LDKCResult_ChannelCounterpartyDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_clone(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_ok(struct LDKChannelDetails o);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelDetailsDecodeErrorZ_is_ok(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelDetailsDecodeErrorZ.
 */
void CResult_ChannelDetailsDecodeErrorZ_free(struct LDKCResult_ChannelDetailsDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_clone(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the success state.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_ok(struct LDKPhantomRouteHints o);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the error state.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PhantomRouteHintsDecodeErrorZ_is_ok(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PhantomRouteHintsDecodeErrorZ.
 */
void CResult_PhantomRouteHintsDecodeErrorZ_free(struct LDKCResult_PhantomRouteHintsDecodeErrorZ _res);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_clone(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ChannelMonitorZ_free(struct LDKCVec_ChannelMonitorZ _res);

/**
 * Creates a new C2Tuple_BlockHashChannelManagerZ from the contained elements.
 */
struct LDKC2Tuple_BlockHashChannelManagerZ C2Tuple_BlockHashChannelManagerZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelManager b);

/**
 * Frees any resources used by the C2Tuple_BlockHashChannelManagerZ.
 */
void C2Tuple_BlockHashChannelManagerZ_free(struct LDKC2Tuple_BlockHashChannelManagerZ _res);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelManagerZ o);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.
 */
void CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(struct LDKChannelConfig o);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelConfigDecodeErrorZ_is_ok(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelConfigDecodeErrorZ.
 */
void CResult_ChannelConfigDecodeErrorZ_free(struct LDKCResult_ChannelConfigDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OutPointDecodeErrorZ in the success state.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(struct LDKOutPoint o);

/**
 * Creates a new CResult_OutPointDecodeErrorZ in the error state.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OutPointDecodeErrorZ_is_ok(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OutPointDecodeErrorZ.
 */
void CResult_OutPointDecodeErrorZ_free(struct LDKCResult_OutPointDecodeErrorZ _res);

/**
 * Creates a new CResult_OutPointDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_TypeZ containing a crate::lightning::ln::wire::Type
 */
struct LDKCOption_TypeZ COption_TypeZ_some(struct LDKType o);

/**
 * Constructs a new COption_TypeZ containing nothing
 */
struct LDKCOption_TypeZ COption_TypeZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::wire::Type, if we are in the Some state
 */
void COption_TypeZ_free(struct LDKCOption_TypeZ _res);

/**
 * Creates a new COption_TypeZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_TypeZ COption_TypeZ_clone(const struct LDKCOption_TypeZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_ok(struct LDKCOption_TypeZ o);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_TypeZDecodeErrorZ_is_ok(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_TypeZDecodeErrorZ.
 */
void CResult_COption_TypeZDecodeErrorZ_free(struct LDKCResult_COption_TypeZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_clone(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentIdPaymentErrorZ in the success state.
 */
struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentIdPaymentErrorZ in the error state.
 */
struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_err(struct LDKPaymentError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentIdPaymentErrorZ_is_ok(const struct LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentIdPaymentErrorZ.
 */
void CResult_PaymentIdPaymentErrorZ_free(struct LDKCResult_PaymentIdPaymentErrorZ _res);

/**
 * Creates a new CResult_PaymentIdPaymentErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_clone(const struct LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NonePaymentErrorZ in the success state.
 */
struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_ok(void);

/**
 * Creates a new CResult_NonePaymentErrorZ in the error state.
 */
struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_err(struct LDKPaymentError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NonePaymentErrorZ_is_ok(const struct LDKCResult_NonePaymentErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NonePaymentErrorZ.
 */
void CResult_NonePaymentErrorZ_free(struct LDKCResult_NonePaymentErrorZ _res);

/**
 * Creates a new CResult_NonePaymentErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_clone(const struct LDKCResult_NonePaymentErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_StringErrorZ in the success state.
 */
struct LDKCResult_StringErrorZ CResult_StringErrorZ_ok(struct LDKStr o);

/**
 * Creates a new CResult_StringErrorZ in the error state.
 */
struct LDKCResult_StringErrorZ CResult_StringErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_StringErrorZ_is_ok(const struct LDKCResult_StringErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_StringErrorZ.
 */
void CResult_StringErrorZ_free(struct LDKCResult_StringErrorZ _res);

/**
 * Creates a new CResult_StringErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_StringErrorZ CResult_StringErrorZ_clone(const struct LDKCResult_StringErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PublicKeyErrorZ in the success state.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_ok(struct LDKPublicKey o);

/**
 * Creates a new CResult_PublicKeyErrorZ in the error state.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PublicKeyErrorZ_is_ok(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PublicKeyErrorZ.
 */
void CResult_PublicKeyErrorZ_free(struct LDKCResult_PublicKeyErrorZ _res);

/**
 * Creates a new CResult_PublicKeyErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_clone(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_ok(struct LDKChannelMonitorUpdate o);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelMonitorUpdateDecodeErrorZ.
 */
void CResult_ChannelMonitorUpdateDecodeErrorZ_free(struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_MonitorEventZ containing a crate::lightning::chain::channelmonitor::MonitorEvent
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_some(struct LDKMonitorEvent o);

/**
 * Constructs a new COption_MonitorEventZ containing nothing
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::chain::channelmonitor::MonitorEvent, if we are in the Some state
 */
void COption_MonitorEventZ_free(struct LDKCOption_MonitorEventZ _res);

/**
 * Creates a new COption_MonitorEventZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_clone(const struct LDKCOption_MonitorEventZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_ok(struct LDKCOption_MonitorEventZ o);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_MonitorEventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_MonitorEventZDecodeErrorZ.
 */
void CResult_COption_MonitorEventZDecodeErrorZ_free(struct LDKCResult_COption_MonitorEventZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_clone(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(struct LDKHTLCUpdate o);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HTLCUpdateDecodeErrorZ_is_ok(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HTLCUpdateDecodeErrorZ.
 */
void CResult_HTLCUpdateDecodeErrorZ_free(struct LDKCResult_HTLCUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_clone(const struct LDKC2Tuple_OutPointScriptZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_OutPointScriptZ from the contained elements.
 */
struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_new(struct LDKOutPoint a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_OutPointScriptZ.
 */
void C2Tuple_OutPointScriptZ_free(struct LDKC2Tuple_OutPointScriptZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_clone(const struct LDKC2Tuple_u32ScriptZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u32ScriptZ from the contained elements.
 */
struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_new(uint32_t a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_u32ScriptZ.
 */
void C2Tuple_u32ScriptZ_free(struct LDKC2Tuple_u32ScriptZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u32ScriptZZ_free(struct LDKCVec_C2Tuple_u32ScriptZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ from the contained elements.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32ScriptZZ b);

/**
 * Frees any resources used by the C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ.
 */
void C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_EventZ_free(struct LDKCVec_EventZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TransactionZ_free(struct LDKCVec_TransactionZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(const struct LDKC2Tuple_u32TxOutZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u32TxOutZ from the contained elements.
 */
struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(uint32_t a, struct LDKTxOut b);

/**
 * Frees any resources used by the C2Tuple_u32TxOutZ.
 */
void C2Tuple_u32TxOutZ_free(struct LDKC2Tuple_u32TxOutZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u32TxOutZZ_free(struct LDKCVec_C2Tuple_u32TxOutZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ from the contained elements.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32TxOutZZ b);

/**
 * Frees any resources used by the C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ.
 */
void C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TransactionOutputsZ_free(struct LDKCVec_TransactionOutputsZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_BalanceZ_free(struct LDKCVec_BalanceZ _res);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelMonitorZ o);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.
 */
void CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_clone(const struct LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PublicKeyTypeZ from the contained elements.
 */
struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_new(struct LDKPublicKey a, struct LDKType b);

/**
 * Frees any resources used by the C2Tuple_PublicKeyTypeZ.
 */
void C2Tuple_PublicKeyTypeZ_free(struct LDKC2Tuple_PublicKeyTypeZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_PublicKeyTypeZZ_free(struct LDKCVec_C2Tuple_PublicKeyTypeZZ _res);

/**
 * Constructs a new COption_CustomOnionMessageContentsZ containing a crate::lightning::onion_message::packet::CustomOnionMessageContents
 */
struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_some(struct LDKCustomOnionMessageContents o);

/**
 * Constructs a new COption_CustomOnionMessageContentsZ containing nothing
 */
struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::onion_message::packet::CustomOnionMessageContents, if we are in the Some state
 */
void COption_CustomOnionMessageContentsZ_free(struct LDKCOption_CustomOnionMessageContentsZ _res);

/**
 * Creates a new COption_CustomOnionMessageContentsZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_clone(const struct LDKCOption_CustomOnionMessageContentsZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_CustomOnionMessageContentsZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_ok(struct LDKCOption_CustomOnionMessageContentsZ o);

/**
 * Creates a new CResult_COption_CustomOnionMessageContentsZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_is_ok(const struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_CustomOnionMessageContentsZDecodeErrorZ.
 */
void CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_free(struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_CustomOnionMessageContentsZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_clone(const struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_NetAddressZ containing a crate::lightning::ln::msgs::NetAddress
 */
struct LDKCOption_NetAddressZ COption_NetAddressZ_some(struct LDKNetAddress o);

/**
 * Constructs a new COption_NetAddressZ containing nothing
 */
struct LDKCOption_NetAddressZ COption_NetAddressZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::msgs::NetAddress, if we are in the Some state
 */
void COption_NetAddressZ_free(struct LDKCOption_NetAddressZ _res);

/**
 * Creates a new COption_NetAddressZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_NetAddressZ COption_NetAddressZ_clone(const struct LDKCOption_NetAddressZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the success state.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(struct LDKCVec_u8Z o);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the error state.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_u8ZPeerHandleErrorZ_is_ok(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_u8ZPeerHandleErrorZ.
 */
void CResult_CVec_u8ZPeerHandleErrorZ_free(struct LDKCResult_CVec_u8ZPeerHandleErrorZ _res);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NonePeerHandleErrorZ in the success state.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok(void);

/**
 * Creates a new CResult_NonePeerHandleErrorZ in the error state.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NonePeerHandleErrorZ_is_ok(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NonePeerHandleErrorZ.
 */
void CResult_NonePeerHandleErrorZ_free(struct LDKCResult_NonePeerHandleErrorZ _res);

/**
 * Creates a new CResult_NonePeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_boolPeerHandleErrorZ in the success state.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(bool o);

/**
 * Creates a new CResult_boolPeerHandleErrorZ in the error state.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_boolPeerHandleErrorZ_is_ok(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_boolPeerHandleErrorZ.
 */
void CResult_boolPeerHandleErrorZ_free(struct LDKCResult_boolPeerHandleErrorZ _res);

/**
 * Creates a new CResult_boolPeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneSendErrorZ in the success state.
 */
struct LDKCResult_NoneSendErrorZ CResult_NoneSendErrorZ_ok(void);

/**
 * Creates a new CResult_NoneSendErrorZ in the error state.
 */
struct LDKCResult_NoneSendErrorZ CResult_NoneSendErrorZ_err(struct LDKSendError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneSendErrorZ_is_ok(const struct LDKCResult_NoneSendErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneSendErrorZ.
 */
void CResult_NoneSendErrorZ_free(struct LDKCResult_NoneSendErrorZ _res);

/**
 * Creates a new CResult_SiPrefixParseErrorZ in the success state.
 */
struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_ok(enum LDKSiPrefix o);

/**
 * Creates a new CResult_SiPrefixParseErrorZ in the error state.
 */
struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_err(struct LDKParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SiPrefixParseErrorZ_is_ok(const struct LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SiPrefixParseErrorZ.
 */
void CResult_SiPrefixParseErrorZ_free(struct LDKCResult_SiPrefixParseErrorZ _res);

/**
 * Creates a new CResult_SiPrefixParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_clone(const struct LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceParseOrSemanticErrorZ in the success state.
 */
struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceParseOrSemanticErrorZ in the error state.
 */
struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_err(struct LDKParseOrSemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceParseOrSemanticErrorZ_is_ok(const struct LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceParseOrSemanticErrorZ.
 */
void CResult_InvoiceParseOrSemanticErrorZ_free(struct LDKCResult_InvoiceParseOrSemanticErrorZ _res);

/**
 * Creates a new CResult_InvoiceParseOrSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_clone(const struct LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignedRawInvoiceParseErrorZ in the success state.
 */
struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_ok(struct LDKSignedRawInvoice o);

/**
 * Creates a new CResult_SignedRawInvoiceParseErrorZ in the error state.
 */
struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_err(struct LDKParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SignedRawInvoiceParseErrorZ_is_ok(const struct LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SignedRawInvoiceParseErrorZ.
 */
void CResult_SignedRawInvoiceParseErrorZ_free(struct LDKCResult_SignedRawInvoiceParseErrorZ _res);

/**
 * Creates a new CResult_SignedRawInvoiceParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_clone(const struct LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(const struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_RawInvoice_u832InvoiceSignatureZ from the contained elements.
 */
struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(struct LDKRawInvoice a, struct LDKThirtyTwoBytes b, struct LDKInvoiceSignature c);

/**
 * Frees any resources used by the C3Tuple_RawInvoice_u832InvoiceSignatureZ.
 */
void C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ _res);

/**
 * Creates a new CResult_PayeePubKeyErrorZ in the success state.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_ok(struct LDKPayeePubKey o);

/**
 * Creates a new CResult_PayeePubKeyErrorZ in the error state.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PayeePubKeyErrorZ_is_ok(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PayeePubKeyErrorZ.
 */
void CResult_PayeePubKeyErrorZ_free(struct LDKCResult_PayeePubKeyErrorZ _res);

/**
 * Creates a new CResult_PayeePubKeyErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_clone(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PrivateRouteZ_free(struct LDKCVec_PrivateRouteZ _res);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ in the success state.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_ok(struct LDKPositiveTimestamp o);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ in the error state.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PositiveTimestampCreationErrorZ_is_ok(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PositiveTimestampCreationErrorZ.
 */
void CResult_PositiveTimestampCreationErrorZ_free(struct LDKCResult_PositiveTimestampCreationErrorZ _res);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_clone(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneSemanticErrorZ in the success state.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_ok(void);

/**
 * Creates a new CResult_NoneSemanticErrorZ in the error state.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_err(enum LDKSemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneSemanticErrorZ_is_ok(const struct LDKCResult_NoneSemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneSemanticErrorZ.
 */
void CResult_NoneSemanticErrorZ_free(struct LDKCResult_NoneSemanticErrorZ _res);

/**
 * Creates a new CResult_NoneSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_clone(const struct LDKCResult_NoneSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ in the success state.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ in the error state.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_err(enum LDKSemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceSemanticErrorZ_is_ok(const struct LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceSemanticErrorZ.
 */
void CResult_InvoiceSemanticErrorZ_free(struct LDKCResult_InvoiceSemanticErrorZ _res);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_clone(const struct LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_DescriptionCreationErrorZ in the success state.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_ok(struct LDKDescription o);

/**
 * Creates a new CResult_DescriptionCreationErrorZ in the error state.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_DescriptionCreationErrorZ_is_ok(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_DescriptionCreationErrorZ.
 */
void CResult_DescriptionCreationErrorZ_free(struct LDKCResult_DescriptionCreationErrorZ _res);

/**
 * Creates a new CResult_DescriptionCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_clone(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ in the success state.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_ok(struct LDKPrivateRoute o);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ in the error state.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PrivateRouteCreationErrorZ_is_ok(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PrivateRouteCreationErrorZ.
 */
void CResult_PrivateRouteCreationErrorZ_free(struct LDKCResult_PrivateRouteCreationErrorZ _res);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_clone(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_u32GraphSyncErrorZ in the success state.
 */
struct LDKCResult_u32GraphSyncErrorZ CResult_u32GraphSyncErrorZ_ok(uint32_t o);

/**
 * Creates a new CResult_u32GraphSyncErrorZ in the error state.
 */
struct LDKCResult_u32GraphSyncErrorZ CResult_u32GraphSyncErrorZ_err(struct LDKGraphSyncError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_u32GraphSyncErrorZ_is_ok(const struct LDKCResult_u32GraphSyncErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_u32GraphSyncErrorZ.
 */
void CResult_u32GraphSyncErrorZ_free(struct LDKCResult_u32GraphSyncErrorZ _res);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ in the success state.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_ok(struct LDKNetAddress o);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ in the error state.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NetAddressDecodeErrorZ_is_ok(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NetAddressDecodeErrorZ.
 */
void CResult_NetAddressDecodeErrorZ_free(struct LDKCResult_NetAddressDecodeErrorZ _res);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_clone(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateAddHTLCZ_free(struct LDKCVec_UpdateAddHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFulfillHTLCZ_free(struct LDKCVec_UpdateFulfillHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFailHTLCZ_free(struct LDKCVec_UpdateFailHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFailMalformedHTLCZ_free(struct LDKCVec_UpdateFailMalformedHTLCZ _res);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ in the success state.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(struct LDKAcceptChannel o);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ in the error state.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_AcceptChannelDecodeErrorZ_is_ok(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_AcceptChannelDecodeErrorZ.
 */
void CResult_AcceptChannelDecodeErrorZ_free(struct LDKCResult_AcceptChannelDecodeErrorZ _res);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_ok(struct LDKAnnouncementSignatures o);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_AnnouncementSignaturesDecodeErrorZ.
 */
void CResult_AnnouncementSignaturesDecodeErrorZ_free(struct LDKCResult_AnnouncementSignaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_clone(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_ok(struct LDKChannelReestablish o);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelReestablishDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelReestablishDecodeErrorZ.
 */
void CResult_ChannelReestablishDecodeErrorZ_free(struct LDKCResult_ChannelReestablishDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_clone(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(struct LDKClosingSigned o);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ClosingSignedDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ClosingSignedDecodeErrorZ.
 */
void CResult_ClosingSignedDecodeErrorZ_free(struct LDKCResult_ClosingSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(struct LDKClosingSignedFeeRange o);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ClosingSignedFeeRangeDecodeErrorZ.
 */
void CResult_ClosingSignedFeeRangeDecodeErrorZ_free(struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_ok(struct LDKCommitmentSigned o);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CommitmentSignedDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CommitmentSignedDecodeErrorZ.
 */
void CResult_CommitmentSignedDecodeErrorZ_free(struct LDKCResult_CommitmentSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_clone(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(struct LDKFundingCreated o);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FundingCreatedDecodeErrorZ_is_ok(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FundingCreatedDecodeErrorZ.
 */
void CResult_FundingCreatedDecodeErrorZ_free(struct LDKCResult_FundingCreatedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_clone(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(struct LDKFundingSigned o);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FundingSignedDecodeErrorZ_is_ok(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FundingSignedDecodeErrorZ.
 */
void CResult_FundingSignedDecodeErrorZ_free(struct LDKCResult_FundingSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelReadyDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_ok(struct LDKChannelReady o);

/**
 * Creates a new CResult_ChannelReadyDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelReadyDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelReadyDecodeErrorZ.
 */
void CResult_ChannelReadyDecodeErrorZ_free(struct LDKCResult_ChannelReadyDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelReadyDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_clone(const struct LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InitDecodeErrorZ in the success state.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(struct LDKInit o);

/**
 * Creates a new CResult_InitDecodeErrorZ in the error state.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InitDecodeErrorZ_is_ok(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InitDecodeErrorZ.
 */
void CResult_InitDecodeErrorZ_free(struct LDKCResult_InitDecodeErrorZ _res);

/**
 * Creates a new CResult_InitDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ in the success state.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(struct LDKOpenChannel o);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ in the error state.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OpenChannelDecodeErrorZ_is_ok(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OpenChannelDecodeErrorZ.
 */
void CResult_OpenChannelDecodeErrorZ_free(struct LDKCResult_OpenChannelDecodeErrorZ _res);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ in the success state.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(struct LDKRevokeAndACK o);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ in the error state.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RevokeAndACKDecodeErrorZ_is_ok(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RevokeAndACKDecodeErrorZ.
 */
void CResult_RevokeAndACKDecodeErrorZ_free(struct LDKCResult_RevokeAndACKDecodeErrorZ _res);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ in the success state.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(struct LDKShutdown o);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ in the error state.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownDecodeErrorZ.
 */
void CResult_ShutdownDecodeErrorZ_free(struct LDKCResult_ShutdownDecodeErrorZ _res);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(struct LDKUpdateFailHTLC o);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFailHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFailHTLCDecodeErrorZ.
 */
void CResult_UpdateFailHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(struct LDKUpdateFailMalformedHTLC o);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFailMalformedHTLCDecodeErrorZ.
 */
void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(struct LDKUpdateFee o);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFeeDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFeeDecodeErrorZ.
 */
void CResult_UpdateFeeDecodeErrorZ_free(struct LDKCResult_UpdateFeeDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_ok(struct LDKUpdateFulfillHTLC o);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFulfillHTLCDecodeErrorZ.
 */
void CResult_UpdateFulfillHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(struct LDKUpdateAddHTLC o);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateAddHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateAddHTLCDecodeErrorZ.
 */
void CResult_UpdateAddHTLCDecodeErrorZ_free(struct LDKCResult_UpdateAddHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OnionMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_ok(struct LDKOnionMessage o);

/**
 * Creates a new CResult_OnionMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OnionMessageDecodeErrorZ_is_ok(const struct LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OnionMessageDecodeErrorZ.
 */
void CResult_OnionMessageDecodeErrorZ_free(struct LDKCResult_OnionMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_OnionMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_clone(const struct LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PingDecodeErrorZ in the success state.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(struct LDKPing o);

/**
 * Creates a new CResult_PingDecodeErrorZ in the error state.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PingDecodeErrorZ_is_ok(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PingDecodeErrorZ.
 */
void CResult_PingDecodeErrorZ_free(struct LDKCResult_PingDecodeErrorZ _res);

/**
 * Creates a new CResult_PingDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PongDecodeErrorZ in the success state.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(struct LDKPong o);

/**
 * Creates a new CResult_PongDecodeErrorZ in the error state.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PongDecodeErrorZ_is_ok(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PongDecodeErrorZ.
 */
void CResult_PongDecodeErrorZ_free(struct LDKCResult_PongDecodeErrorZ _res);

/**
 * Creates a new CResult_PongDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(struct LDKUnsignedChannelAnnouncement o);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedChannelAnnouncementDecodeErrorZ.
 */
void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_ok(struct LDKChannelAnnouncement o);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelAnnouncementDecodeErrorZ.
 */
void CResult_ChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_ChannelAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_ok(struct LDKUnsignedChannelUpdate o);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedChannelUpdateDecodeErrorZ.
 */
void CResult_UnsignedChannelUpdateDecodeErrorZ_free(struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(struct LDKChannelUpdate o);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelUpdateDecodeErrorZ.
 */
void CResult_ChannelUpdateDecodeErrorZ_free(struct LDKCResult_ChannelUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(struct LDKErrorMessage o);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ErrorMessageDecodeErrorZ_is_ok(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ErrorMessageDecodeErrorZ.
 */
void CResult_ErrorMessageDecodeErrorZ_free(struct LDKCResult_ErrorMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_ok(struct LDKWarningMessage o);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_WarningMessageDecodeErrorZ_is_ok(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_WarningMessageDecodeErrorZ.
 */
void CResult_WarningMessageDecodeErrorZ_free(struct LDKCResult_WarningMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_clone(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(struct LDKUnsignedNodeAnnouncement o);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedNodeAnnouncementDecodeErrorZ.
 */
void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_ok(struct LDKNodeAnnouncement o);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeAnnouncementDecodeErrorZ.
 */
void CResult_NodeAnnouncementDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the success state.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_ok(struct LDKQueryShortChannelIds o);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the error state.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_QueryShortChannelIdsDecodeErrorZ.
 */
void CResult_QueryShortChannelIdsDecodeErrorZ_free(struct LDKCResult_QueryShortChannelIdsDecodeErrorZ _res);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_clone(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the success state.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(struct LDKReplyShortChannelIdsEnd o);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the error state.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ReplyShortChannelIdsEndDecodeErrorZ.
 */
void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_ok(struct LDKQueryChannelRange o);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_QueryChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_QueryChannelRangeDecodeErrorZ.
 */
void CResult_QueryChannelRangeDecodeErrorZ_free(struct LDKCResult_QueryChannelRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_clone(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_ok(struct LDKReplyChannelRange o);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ReplyChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ReplyChannelRangeDecodeErrorZ.
 */
void CResult_ReplyChannelRangeDecodeErrorZ_free(struct LDKCResult_ReplyChannelRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_clone(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the success state.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_ok(struct LDKGossipTimestampFilter o);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the error state.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_GossipTimestampFilterDecodeErrorZ_is_ok(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_GossipTimestampFilterDecodeErrorZ.
 */
void CResult_GossipTimestampFilterDecodeErrorZ_free(struct LDKCResult_GossipTimestampFilterDecodeErrorZ _res);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_clone(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PhantomRouteHintsZ_free(struct LDKCVec_PhantomRouteHintsZ _res);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ in the success state.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ in the error state.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_err(struct LDKSignOrCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceSignOrCreationErrorZ_is_ok(const struct LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceSignOrCreationErrorZ.
 */
void CResult_InvoiceSignOrCreationErrorZ_free(struct LDKCResult_InvoiceSignOrCreationErrorZ _res);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_clone(const struct LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_FilterZ containing a crate::lightning::chain::Filter
 */
struct LDKCOption_FilterZ COption_FilterZ_some(struct LDKFilter o);

/**
 * Constructs a new COption_FilterZ containing nothing
 */
struct LDKCOption_FilterZ COption_FilterZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::chain::Filter, if we are in the Some state
 */
void COption_FilterZ_free(struct LDKCOption_FilterZ _res);

/**
 * Creates a new CResult_LockedChannelMonitorNoneZ in the success state.
 */
struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_ok(struct LDKLockedChannelMonitor o);

/**
 * Creates a new CResult_LockedChannelMonitorNoneZ in the error state.
 */
struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_LockedChannelMonitorNoneZ_is_ok(const struct LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_LockedChannelMonitorNoneZ.
 */
void CResult_LockedChannelMonitorNoneZ_free(struct LDKCResult_LockedChannelMonitorNoneZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_OutPointZ_free(struct LDKCVec_OutPointZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MonitorUpdateIdZ_free(struct LDKCVec_MonitorUpdateIdZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone(const struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_OutPointCVec_MonitorUpdateIdZZ from the contained elements.
 */
struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ C2Tuple_OutPointCVec_MonitorUpdateIdZZ_new(struct LDKOutPoint a, struct LDKCVec_MonitorUpdateIdZ b);

/**
 * Frees any resources used by the C2Tuple_OutPointCVec_MonitorUpdateIdZZ.
 */
void C2Tuple_OutPointCVec_MonitorUpdateIdZZ_free(struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ_free(struct LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ _res);

/**
 * Frees any resources used by the PaymentPurpose
 */
void PaymentPurpose_free(struct LDKPaymentPurpose this_ptr);

/**
 * Creates a copy of the PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_clone(const struct LDKPaymentPurpose *NONNULL_PTR orig);

/**
 * Utility method to constructs a new InvoicePayment-variant PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_invoice_payment(struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_secret);

/**
 * Utility method to constructs a new SpontaneousPayment-variant PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_spontaneous_payment(struct LDKThirtyTwoBytes a);

/**
 * Serialize the PaymentPurpose object into a byte array which can be read by PaymentPurpose_read
 */
struct LDKCVec_u8Z PaymentPurpose_write(const struct LDKPaymentPurpose *NONNULL_PTR obj);

/**
 * Read a PaymentPurpose from a byte array, created by PaymentPurpose_write
 */
struct LDKCResult_PaymentPurposeDecodeErrorZ PaymentPurpose_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ClosureReason
 */
void ClosureReason_free(struct LDKClosureReason this_ptr);

/**
 * Creates a copy of the ClosureReason
 */
struct LDKClosureReason ClosureReason_clone(const struct LDKClosureReason *NONNULL_PTR orig);

/**
 * Utility method to constructs a new CounterpartyForceClosed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_counterparty_force_closed(struct LDKStr peer_msg);

/**
 * Utility method to constructs a new HolderForceClosed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_holder_force_closed(void);

/**
 * Utility method to constructs a new CooperativeClosure-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_cooperative_closure(void);

/**
 * Utility method to constructs a new CommitmentTxConfirmed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_commitment_tx_confirmed(void);

/**
 * Utility method to constructs a new FundingTimedOut-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_funding_timed_out(void);

/**
 * Utility method to constructs a new ProcessingError-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_processing_error(struct LDKStr err);

/**
 * Utility method to constructs a new DisconnectedPeer-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_disconnected_peer(void);

/**
 * Utility method to constructs a new OutdatedChannelManager-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_outdated_channel_manager(void);

/**
 * Checks if two ClosureReasons contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ClosureReason_eq(const struct LDKClosureReason *NONNULL_PTR a, const struct LDKClosureReason *NONNULL_PTR b);

/**
 * Serialize the ClosureReason object into a byte array which can be read by ClosureReason_read
 */
struct LDKCVec_u8Z ClosureReason_write(const struct LDKClosureReason *NONNULL_PTR obj);

/**
 * Read a ClosureReason from a byte array, created by ClosureReason_write
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ ClosureReason_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the HTLCDestination
 */
void HTLCDestination_free(struct LDKHTLCDestination this_ptr);

/**
 * Creates a copy of the HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_clone(const struct LDKHTLCDestination *NONNULL_PTR orig);

/**
 * Utility method to constructs a new NextHopChannel-variant HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_next_hop_channel(struct LDKPublicKey node_id, struct LDKThirtyTwoBytes channel_id);

/**
 * Utility method to constructs a new UnknownNextHop-variant HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_unknown_next_hop(uint64_t requested_forward_scid);

/**
 * Utility method to constructs a new InvalidForward-variant HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_invalid_forward(uint64_t requested_forward_scid);

/**
 * Utility method to constructs a new FailedPayment-variant HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_failed_payment(struct LDKThirtyTwoBytes payment_hash);

/**
 * Checks if two HTLCDestinations contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool HTLCDestination_eq(const struct LDKHTLCDestination *NONNULL_PTR a, const struct LDKHTLCDestination *NONNULL_PTR b);

/**
 * Serialize the HTLCDestination object into a byte array which can be read by HTLCDestination_read
 */
struct LDKCVec_u8Z HTLCDestination_write(const struct LDKHTLCDestination *NONNULL_PTR obj);

/**
 * Read a HTLCDestination from a byte array, created by HTLCDestination_write
 */
struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ HTLCDestination_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Event
 */
void Event_free(struct LDKEvent this_ptr);

/**
 * Creates a copy of the Event
 */
struct LDKEvent Event_clone(const struct LDKEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new FundingGenerationReady-variant Event
 */
struct LDKEvent Event_funding_generation_ready(struct LDKThirtyTwoBytes temporary_channel_id, struct LDKPublicKey counterparty_node_id, uint64_t channel_value_satoshis, struct LDKCVec_u8Z output_script, struct LDKU128 user_channel_id);

/**
 * Utility method to constructs a new PaymentClaimable-variant Event
 */
struct LDKEvent Event_payment_claimable(struct LDKPublicKey receiver_node_id, struct LDKThirtyTwoBytes payment_hash, uint64_t amount_msat, struct LDKPaymentPurpose purpose, struct LDKThirtyTwoBytes via_channel_id, struct LDKCOption_u128Z via_user_channel_id);

/**
 * Utility method to constructs a new PaymentClaimed-variant Event
 */
struct LDKEvent Event_payment_claimed(struct LDKPublicKey receiver_node_id, struct LDKThirtyTwoBytes payment_hash, uint64_t amount_msat, struct LDKPaymentPurpose purpose);

/**
 * Utility method to constructs a new PaymentSent-variant Event
 */
struct LDKEvent Event_payment_sent(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z fee_paid_msat);

/**
 * Utility method to constructs a new PaymentFailed-variant Event
 */
struct LDKEvent Event_payment_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash);

/**
 * Utility method to constructs a new PaymentPathSuccessful-variant Event
 */
struct LDKEvent Event_payment_path_successful(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKCVec_RouteHopZ path);

/**
 * Utility method to constructs a new PaymentPathFailed-variant Event
 */
struct LDKEvent Event_payment_path_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, bool payment_failed_permanently, struct LDKCOption_NetworkUpdateZ network_update, bool all_paths_failed, struct LDKCVec_RouteHopZ path, struct LDKCOption_u64Z short_channel_id, struct LDKRouteParameters retry);

/**
 * Utility method to constructs a new ProbeSuccessful-variant Event
 */
struct LDKEvent Event_probe_successful(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKCVec_RouteHopZ path);

/**
 * Utility method to constructs a new ProbeFailed-variant Event
 */
struct LDKEvent Event_probe_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKCVec_RouteHopZ path, struct LDKCOption_u64Z short_channel_id);

/**
 * Utility method to constructs a new PendingHTLCsForwardable-variant Event
 */
struct LDKEvent Event_pending_htlcs_forwardable(uint64_t time_forwardable);

/**
 * Utility method to constructs a new HTLCIntercepted-variant Event
 */
struct LDKEvent Event_htlcintercepted(struct LDKThirtyTwoBytes intercept_id, uint64_t requested_next_hop_scid, struct LDKThirtyTwoBytes payment_hash, uint64_t inbound_amount_msat, uint64_t expected_outbound_amount_msat);

/**
 * Utility method to constructs a new SpendableOutputs-variant Event
 */
struct LDKEvent Event_spendable_outputs(struct LDKCVec_SpendableOutputDescriptorZ outputs);

/**
 * Utility method to constructs a new PaymentForwarded-variant Event
 */
struct LDKEvent Event_payment_forwarded(struct LDKThirtyTwoBytes prev_channel_id, struct LDKThirtyTwoBytes next_channel_id, struct LDKCOption_u64Z fee_earned_msat, bool claim_from_onchain_tx);

/**
 * Utility method to constructs a new ChannelReady-variant Event
 */
struct LDKEvent Event_channel_ready(struct LDKThirtyTwoBytes channel_id, struct LDKU128 user_channel_id, struct LDKPublicKey counterparty_node_id, struct LDKChannelTypeFeatures channel_type);

/**
 * Utility method to constructs a new ChannelClosed-variant Event
 */
struct LDKEvent Event_channel_closed(struct LDKThirtyTwoBytes channel_id, struct LDKU128 user_channel_id, struct LDKClosureReason reason);

/**
 * Utility method to constructs a new DiscardFunding-variant Event
 */
struct LDKEvent Event_discard_funding(struct LDKThirtyTwoBytes channel_id, struct LDKTransaction transaction);

/**
 * Utility method to constructs a new OpenChannelRequest-variant Event
 */
struct LDKEvent Event_open_channel_request(struct LDKThirtyTwoBytes temporary_channel_id, struct LDKPublicKey counterparty_node_id, uint64_t funding_satoshis, uint64_t push_msat, struct LDKChannelTypeFeatures channel_type);

/**
 * Utility method to constructs a new HTLCHandlingFailed-variant Event
 */
struct LDKEvent Event_htlchandling_failed(struct LDKThirtyTwoBytes prev_channel_id, struct LDKHTLCDestination failed_next_destination);

/**
 * Serialize the Event object into a byte array which can be read by Event_read
 */
struct LDKCVec_u8Z Event_write(const struct LDKEvent *NONNULL_PTR obj);

/**
 * Read a Event from a byte array, created by Event_write
 */
struct LDKCResult_COption_EventZDecodeErrorZ Event_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the MessageSendEvent
 */
void MessageSendEvent_free(struct LDKMessageSendEvent this_ptr);

/**
 * Creates a copy of the MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_clone(const struct LDKMessageSendEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SendAcceptChannel-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_accept_channel(struct LDKPublicKey node_id, struct LDKAcceptChannel msg);

/**
 * Utility method to constructs a new SendOpenChannel-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_open_channel(struct LDKPublicKey node_id, struct LDKOpenChannel msg);

/**
 * Utility method to constructs a new SendFundingCreated-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_funding_created(struct LDKPublicKey node_id, struct LDKFundingCreated msg);

/**
 * Utility method to constructs a new SendFundingSigned-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_funding_signed(struct LDKPublicKey node_id, struct LDKFundingSigned msg);

/**
 * Utility method to constructs a new SendChannelReady-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_ready(struct LDKPublicKey node_id, struct LDKChannelReady msg);

/**
 * Utility method to constructs a new SendAnnouncementSignatures-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_announcement_signatures(struct LDKPublicKey node_id, struct LDKAnnouncementSignatures msg);

/**
 * Utility method to constructs a new UpdateHTLCs-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_update_htlcs(struct LDKPublicKey node_id, struct LDKCommitmentUpdate updates);

/**
 * Utility method to constructs a new SendRevokeAndACK-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_revoke_and_ack(struct LDKPublicKey node_id, struct LDKRevokeAndACK msg);

/**
 * Utility method to constructs a new SendClosingSigned-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_closing_signed(struct LDKPublicKey node_id, struct LDKClosingSigned msg);

/**
 * Utility method to constructs a new SendShutdown-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_shutdown(struct LDKPublicKey node_id, struct LDKShutdown msg);

/**
 * Utility method to constructs a new SendChannelReestablish-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_reestablish(struct LDKPublicKey node_id, struct LDKChannelReestablish msg);

/**
 * Utility method to constructs a new SendChannelAnnouncement-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_announcement(struct LDKPublicKey node_id, struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);

/**
 * Utility method to constructs a new BroadcastChannelAnnouncement-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_announcement(struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);

/**
 * Utility method to constructs a new BroadcastChannelUpdate-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_update(struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new SendChannelUpdate-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_update(struct LDKPublicKey node_id, struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new HandleError-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_handle_error(struct LDKPublicKey node_id, struct LDKErrorAction action);

/**
 * Utility method to constructs a new SendChannelRangeQuery-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_range_query(struct LDKPublicKey node_id, struct LDKQueryChannelRange msg);

/**
 * Utility method to constructs a new SendShortIdsQuery-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_short_ids_query(struct LDKPublicKey node_id, struct LDKQueryShortChannelIds msg);

/**
 * Utility method to constructs a new SendReplyChannelRange-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_reply_channel_range(struct LDKPublicKey node_id, struct LDKReplyChannelRange msg);

/**
 * Utility method to constructs a new SendGossipTimestampFilter-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_gossip_timestamp_filter(struct LDKPublicKey node_id, struct LDKGossipTimestampFilter msg);

/**
 * Calls the free function if one is set
 */
void MessageSendEventsProvider_free(struct LDKMessageSendEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void OnionMessageProvider_free(struct LDKOnionMessageProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventsProvider_free(struct LDKEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventHandler_free(struct LDKEventHandler this_ptr);

/**
 * Frees any resources used by the APIError
 */
void APIError_free(struct LDKAPIError this_ptr);

/**
 * Creates a copy of the APIError
 */
struct LDKAPIError APIError_clone(const struct LDKAPIError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new APIMisuseError-variant APIError
 */
struct LDKAPIError APIError_apimisuse_error(struct LDKStr err);

/**
 * Utility method to constructs a new FeeRateTooHigh-variant APIError
 */
struct LDKAPIError APIError_fee_rate_too_high(struct LDKStr err, uint32_t feerate);

/**
 * Utility method to constructs a new InvalidRoute-variant APIError
 */
struct LDKAPIError APIError_invalid_route(struct LDKStr err);

/**
 * Utility method to constructs a new ChannelUnavailable-variant APIError
 */
struct LDKAPIError APIError_channel_unavailable(struct LDKStr err);

/**
 * Utility method to constructs a new MonitorUpdateInProgress-variant APIError
 */
struct LDKAPIError APIError_monitor_update_in_progress(void);

/**
 * Utility method to constructs a new IncompatibleShutdownScript-variant APIError
 */
struct LDKAPIError APIError_incompatible_shutdown_script(struct LDKShutdownScript script);

/**
 * Checks if two APIErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool APIError_eq(const struct LDKAPIError *NONNULL_PTR a, const struct LDKAPIError *NONNULL_PTR b);

/**
 * Frees any resources used by the BigSize, if is_owned is set and inner is non-NULL.
 */
void BigSize_free(struct LDKBigSize this_obj);

uint64_t BigSize_get_a(const struct LDKBigSize *NONNULL_PTR this_ptr);

void BigSize_set_a(struct LDKBigSize *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new BigSize given each field
 */
MUST_USE_RES struct LDKBigSize BigSize_new(uint64_t a_arg);

/**
 * Frees any resources used by the Hostname, if is_owned is set and inner is non-NULL.
 */
void Hostname_free(struct LDKHostname this_obj);

/**
 * Creates a copy of the Hostname
 */
struct LDKHostname Hostname_clone(const struct LDKHostname *NONNULL_PTR orig);

/**
 * Checks if two Hostnames contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Hostname_eq(const struct LDKHostname *NONNULL_PTR a, const struct LDKHostname *NONNULL_PTR b);

/**
 * Returns the length of the hostname.
 */
MUST_USE_RES uint8_t Hostname_len(const struct LDKHostname *NONNULL_PTR this_arg);

/**
 * Creates a digital signature of a message given a SecretKey, like the node's secret.
 * A receiver knowing the PublicKey (e.g. the node's id) and the message can be sure that the signature was generated by the caller.
 * Signatures are EC recoverable, meaning that given the message and the signature the PublicKey of the signer can be extracted.
 */
struct LDKCResult_StringErrorZ sign(struct LDKu8slice msg, const uint8_t (*sk)[32]);

/**
 * Recovers the PublicKey of the signer of the message given the message and the signature.
 */
struct LDKCResult_PublicKeyErrorZ recover_pk(struct LDKu8slice msg, struct LDKStr sig);

/**
 * Verifies a message was signed by a PrivateKey that derives to a given PublicKey, given a message, a signature,
 * and the PublicKey.
 */
bool verify(struct LDKu8slice msg, struct LDKStr sig, struct LDKPublicKey pk);

/**
 * Construct the invoice's HRP and signatureless data into a preimage to be hashed.
 */
struct LDKCVec_u8Z construct_invoice_preimage(struct LDKu8slice hrp_bytes, struct LDKCVec_U5Z data_without_signature);

/**
 * Calls the free function if one is set
 */
void Persister_free(struct LDKPersister this_ptr);

/**
 * Frees any resources used by the PrintableString, if is_owned is set and inner is non-NULL.
 */
void PrintableString_free(struct LDKPrintableString this_obj);

struct LDKStr PrintableString_get_a(const struct LDKPrintableString *NONNULL_PTR this_ptr);

void PrintableString_set_a(struct LDKPrintableString *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new PrintableString given each field
 */
MUST_USE_RES struct LDKPrintableString PrintableString_new(struct LDKStr a_arg);

/**
 * Calls the free function if one is set
 */
void FutureCallback_free(struct LDKFutureCallback this_ptr);

/**
 * Frees any resources used by the Future, if is_owned is set and inner is non-NULL.
 */
void Future_free(struct LDKFuture this_obj);

/**
 * Registers a callback to be called upon completion of this future. If the future has already
 * completed, the callback will be called immediately.
 */
void Future_register_callback_fn(const struct LDKFuture *NONNULL_PTR this_arg, struct LDKFutureCallback callback);

/**
 * Creates a copy of the Level
 */
enum LDKLevel Level_clone(const enum LDKLevel *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Gossip-variant Level
 */
enum LDKLevel Level_gossip(void);

/**
 * Utility method to constructs a new Trace-variant Level
 */
enum LDKLevel Level_trace(void);

/**
 * Utility method to constructs a new Debug-variant Level
 */
enum LDKLevel Level_debug(void);

/**
 * Utility method to constructs a new Info-variant Level
 */
enum LDKLevel Level_info(void);

/**
 * Utility method to constructs a new Warn-variant Level
 */
enum LDKLevel Level_warn(void);

/**
 * Utility method to constructs a new Error-variant Level
 */
enum LDKLevel Level_error(void);

/**
 * Checks if two Levels contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Level_eq(const enum LDKLevel *NONNULL_PTR a, const enum LDKLevel *NONNULL_PTR b);

/**
 * Checks if two Levels contain equal inner contents.
 */
uint64_t Level_hash(const enum LDKLevel *NONNULL_PTR o);

/**
 * Returns the most verbose logging level.
 */
MUST_USE_RES enum LDKLevel Level_max(void);

/**
 * Frees any resources used by the Record, if is_owned is set and inner is non-NULL.
 */
void Record_free(struct LDKRecord this_obj);

/**
 * The verbosity level of the message.
 */
enum LDKLevel Record_get_level(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The verbosity level of the message.
 */
void Record_set_level(struct LDKRecord *NONNULL_PTR this_ptr, enum LDKLevel val);

/**
 * The message body.
 */
struct LDKStr Record_get_args(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The message body.
 */
void Record_set_args(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The module path of the message.
 */
struct LDKStr Record_get_module_path(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The module path of the message.
 */
void Record_set_module_path(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The source file containing the message.
 */
struct LDKStr Record_get_file(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The source file containing the message.
 */
void Record_set_file(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The line containing the message.
 */
uint32_t Record_get_line(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The line containing the message.
 */
void Record_set_line(struct LDKRecord *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the Record
 */
struct LDKRecord Record_clone(const struct LDKRecord *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Logger_free(struct LDKLogger this_ptr);

/**
 * Frees any resources used by the ChannelHandshakeConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeConfig_free(struct LDKChannelHandshakeConfig this_obj);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * A lower-bound of 1 is applied, requiring all channels to have a confirmed commitment
 * transaction before operation. If you wish to accept channels with zero confirmations, see
 * [`UserConfig::manually_accept_inbound_channels`] and
 * [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`].
 *
 * Default value: 6.
 *
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf
 */
uint32_t ChannelHandshakeConfig_get_minimum_depth(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * A lower-bound of 1 is applied, requiring all channels to have a confirmed commitment
 * transaction before operation. If you wish to accept channels with zero confirmations, see
 * [`UserConfig::manually_accept_inbound_channels`] and
 * [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`].
 *
 * Default value: 6.
 *
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf
 */
void ChannelHandshakeConfig_set_minimum_depth(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to the number of blocks we require our counterparty to wait to claim their money (ie
 * the number of blocks we have to punish our counterparty if they broadcast a revoked
 * transaction).
 *
 * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
 * be online to check for revoked transactions on-chain at least once every our_to_self_delay
 * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
 * possibly with time in between to RBF the spending transaction).
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
 * can tweak config to ask for more security, not less.
 */
uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the number of blocks we require our counterparty to wait to claim their money (ie
 * the number of blocks we have to punish our counterparty if they broadcast a revoked
 * transaction).
 *
 * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
 * be online to check for revoked transactions on-chain at least once every our_to_self_delay
 * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
 * possibly with time in between to RBF the spending transaction).
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
 * can tweak config to ask for more security, not less.
 */
void ChannelHandshakeConfig_set_our_to_self_delay(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
void ChannelHandshakeConfig_set_our_htlc_minimum_msat(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Sets the percentage of the channel value we will cap the total value of outstanding inbound
 * HTLCs to.
 *
 * This can be set to a value between 1-100, where the value corresponds to the percent of the
 * channel value in whole percentages.
 *
 * Note that:
 * * If configured to another value than the default value 10, any new channels created with
 * the non default value will cause versions of LDK prior to 0.0.104 to refuse to read the
 * `ChannelManager`.
 *
 * * This caps the total value for inbound HTLCs in-flight only, and there's currently
 * no way to configure the cap for the total value of outbound HTLCs in-flight.
 *
 * * The requirements for your node being online to ensure the safety of HTLC-encumbered funds
 * are different from the non-HTLC-encumbered funds. This makes this an important knob to
 * restrict exposure to loss due to being offline for too long.
 * See [`ChannelHandshakeConfig::our_to_self_delay`] and [`ChannelConfig::cltv_expiry_delta`]
 * for more information.
 *
 * Default value: 10.
 * Minimum value: 1, any values less than 1 will be treated as 1 instead.
 * Maximum value: 100, any values larger than 100 will be treated as 100 instead.
 */
uint8_t ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Sets the percentage of the channel value we will cap the total value of outstanding inbound
 * HTLCs to.
 *
 * This can be set to a value between 1-100, where the value corresponds to the percent of the
 * channel value in whole percentages.
 *
 * Note that:
 * * If configured to another value than the default value 10, any new channels created with
 * the non default value will cause versions of LDK prior to 0.0.104 to refuse to read the
 * `ChannelManager`.
 *
 * * This caps the total value for inbound HTLCs in-flight only, and there's currently
 * no way to configure the cap for the total value of outbound HTLCs in-flight.
 *
 * * The requirements for your node being online to ensure the safety of HTLC-encumbered funds
 * are different from the non-HTLC-encumbered funds. This makes this an important knob to
 * restrict exposure to loss due to being offline for too long.
 * See [`ChannelHandshakeConfig::our_to_self_delay`] and [`ChannelConfig::cltv_expiry_delta`]
 * for more information.
 *
 * Default value: 10.
 * Minimum value: 1, any values less than 1 will be treated as 1 instead.
 * Maximum value: 100, any values larger than 100 will be treated as 100 instead.
 */
void ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint8_t val);

/**
 * If set, we attempt to negotiate the `scid_privacy` (referred to as `scid_alias` in the
 * BOLTs) option for outbound private channels. This provides better privacy by not including
 * our real on-chain channel UTXO in each invoice and requiring that our counterparty only
 * relay HTLCs to us using the channel's SCID alias.
 *
 * If this option is set, channels may be created that will not be readable by LDK versions
 * prior to 0.0.106, causing [`ChannelManager`]'s read method to return a
 * [`DecodeError::InvalidValue`].
 *
 * Note that setting this to true does *not* prevent us from opening channels with
 * counterparties that do not support the `scid_alias` option; we will simply fall back to a
 * private channel without that option.
 *
 * Ignored if the channel is negotiated to be announced, see
 * [`ChannelHandshakeConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`] for more.
 *
 * Default value: false. This value is likely to change to true in the future.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`DecodeError::InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
 */
bool ChannelHandshakeConfig_get_negotiate_scid_privacy(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * If set, we attempt to negotiate the `scid_privacy` (referred to as `scid_alias` in the
 * BOLTs) option for outbound private channels. This provides better privacy by not including
 * our real on-chain channel UTXO in each invoice and requiring that our counterparty only
 * relay HTLCs to us using the channel's SCID alias.
 *
 * If this option is set, channels may be created that will not be readable by LDK versions
 * prior to 0.0.106, causing [`ChannelManager`]'s read method to return a
 * [`DecodeError::InvalidValue`].
 *
 * Note that setting this to true does *not* prevent us from opening channels with
 * counterparties that do not support the `scid_alias` option; we will simply fall back to a
 * private channel without that option.
 *
 * Ignored if the channel is negotiated to be announced, see
 * [`ChannelHandshakeConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`] for more.
 *
 * Default value: false. This value is likely to change to true in the future.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`DecodeError::InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
 */
void ChannelHandshakeConfig_set_negotiate_scid_privacy(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
 *
 * Default value: false.
 */
bool ChannelHandshakeConfig_get_announced_channel(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
 *
 * Default value: false.
 */
void ChannelHandshakeConfig_set_announced_channel(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * The upfront key committed is provided from [`KeysInterface::get_shutdown_scriptpubkey`].
 *
 * Default value: true.
 *
 * [`KeysInterface::get_shutdown_scriptpubkey`]: crate::chain::keysinterface::KeysInterface::get_shutdown_scriptpubkey
 */
bool ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * The upfront key committed is provided from [`KeysInterface::get_shutdown_scriptpubkey`].
 *
 * Default value: true.
 *
 * [`KeysInterface::get_shutdown_scriptpubkey`]: crate::chain::keysinterface::KeysInterface::get_shutdown_scriptpubkey
 */
void ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);

/**
 * The Proportion of the channel value to configure as counterparty's channel reserve,
 * i.e., `their_channel_reserve_satoshis` for both outbound and inbound channels.
 *
 * `their_channel_reserve_satoshis` is the minimum balance that the other node has to maintain
 * on their side, at all times.
 * This ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * Channel reserve values greater than 30% could be considered highly unreasonable, since that
 * amount can never be used for payments.
 * Also, if our selected channel reserve for counterparty and counterparty's selected
 * channel reserve for us sum up to equal or greater than channel value, channel negotiations
 * will fail.
 *
 * Note: Versions of LDK earlier than v0.0.104 will fail to read channels with any channel reserve
 * other than the default value.
 *
 * Default value: 1% of channel value, i.e., configured as 10,000 millionths.
 * Minimum value: If the calculated proportional value is less than 1000 sats, it will be treated
 *                as 1000 sats instead, which is a safe implementation-specific lower bound.
 * Maximum value: 1,000,000, any values larger than 1 Million will be treated as 1 Million (or 100%)
 *                instead, although channel negotiations will fail in that case.
 */
uint32_t ChannelHandshakeConfig_get_their_channel_reserve_proportional_millionths(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * The Proportion of the channel value to configure as counterparty's channel reserve,
 * i.e., `their_channel_reserve_satoshis` for both outbound and inbound channels.
 *
 * `their_channel_reserve_satoshis` is the minimum balance that the other node has to maintain
 * on their side, at all times.
 * This ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * Channel reserve values greater than 30% could be considered highly unreasonable, since that
 * amount can never be used for payments.
 * Also, if our selected channel reserve for counterparty and counterparty's selected
 * channel reserve for us sum up to equal or greater than channel value, channel negotiations
 * will fail.
 *
 * Note: Versions of LDK earlier than v0.0.104 will fail to read channels with any channel reserve
 * other than the default value.
 *
 * Default value: 1% of channel value, i.e., configured as 10,000 millionths.
 * Minimum value: If the calculated proportional value is less than 1000 sats, it will be treated
 *                as 1000 sats instead, which is a safe implementation-specific lower bound.
 * Maximum value: 1,000,000, any values larger than 1 Million will be treated as 1 Million (or 100%)
 *                instead, although channel negotiations will fail in that case.
 */
void ChannelHandshakeConfig_set_their_channel_reserve_proportional_millionths(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new ChannelHandshakeConfig given each field
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg, uint8_t max_inbound_htlc_value_in_flight_percent_of_channel_arg, bool negotiate_scid_privacy_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg, uint32_t their_channel_reserve_proportional_millionths_arg);

/**
 * Creates a copy of the ChannelHandshakeConfig
 */
struct LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(const struct LDKChannelHandshakeConfig *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);

/**
 * Frees any resources used by the ChannelHandshakeLimits, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeLimits_free(struct LDKChannelHandshakeLimits this_obj);

/**
 * Minimum allowed satoshis when a channel is funded. This is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Minimum allowed satoshis when a channel is funded. This is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Maximum allowed satoshis when a channel is funded. This is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 2^24 - 1.
 */
uint64_t ChannelHandshakeLimits_get_max_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Maximum allowed satoshis when a channel is funded. This is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 2^24 - 1.
 */
void ChannelHandshakeLimits_set_max_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_htlc_minimum_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_accepted_htlcs(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
void ChannelHandshakeLimits_set_max_minimum_depth(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Whether we implicitly trust funding transactions generated by us for our own outbound
 * channels to not be double-spent.
 *
 * If this is set, we assume that our own funding transactions are *never* double-spent, and
 * thus we can trust them without any confirmations. This is generally a reasonable
 * assumption, given we're the only ones who could ever double-spend it (assuming we have sole
 * control of the signing keys).
 *
 * You may wish to un-set this if you allow the user to (or do in an automated fashion)
 * double-spend the funding transaction to RBF with an alternative channel open.
 *
 * This only applies if our counterparty set their confirmations-required value to 0, and we
 * always trust our own funding transaction at 1 confirmation irrespective of this value.
 * Thus, this effectively acts as a `min_minimum_depth`, with the only possible values being
 * `true` (0) and `false` (1).
 *
 * Default value: true
 */
bool ChannelHandshakeLimits_get_trust_own_funding_0conf(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Whether we implicitly trust funding transactions generated by us for our own outbound
 * channels to not be double-spent.
 *
 * If this is set, we assume that our own funding transactions are *never* double-spent, and
 * thus we can trust them without any confirmations. This is generally a reasonable
 * assumption, given we're the only ones who could ever double-spend it (assuming we have sole
 * control of the signing keys).
 *
 * You may wish to un-set this if you allow the user to (or do in an automated fashion)
 * double-spend the funding transaction to RBF with an alternative channel open.
 *
 * This only applies if our counterparty set their confirmations-required value to 0, and we
 * always trust our own funding transaction at 1 confirmation irrespective of this value.
 * Thus, this effectively acts as a `min_minimum_depth`, with the only possible values being
 * `true` (0) and `false` (1).
 *
 * Default value: true
 */
void ChannelHandshakeLimits_set_trust_own_funding_0conf(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);

/**
 * Set to force an incoming channel to match our announced channel preference in
 * [`ChannelHandshakeConfig::announced_channel`].
 *
 * For a node which is not online reliably, this should be set to true and
 * [`ChannelHandshakeConfig::announced_channel`] set to false, ensuring that no announced (aka public)
 * channels will ever be opened.
 *
 * Default value: true.
 */
bool ChannelHandshakeLimits_get_force_announced_channel_preference(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to force an incoming channel to match our announced channel preference in
 * [`ChannelHandshakeConfig::announced_channel`].
 *
 * For a node which is not online reliably, this should be set to true and
 * [`ChannelHandshakeConfig::announced_channel`] set to false, ensuring that no announced (aka public)
 * channels will ever be opened.
 *
 * Default value: true.
 */
void ChannelHandshakeLimits_set_force_announced_channel_preference(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
void ChannelHandshakeLimits_set_their_to_self_delay(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new ChannelHandshakeLimits given each field
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint32_t max_minimum_depth_arg, bool trust_own_funding_0conf_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);

/**
 * Creates a copy of the ChannelHandshakeLimits
 */
struct LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(const struct LDKChannelHandshakeLimits *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeLimits. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);

/**
 * Frees any resources used by the ChannelConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelConfig_free(struct LDKChannelConfig this_obj);

/**
 * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
 * over the channel.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
uint32_t ChannelConfig_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
 * over the channel.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
void ChannelConfig_set_forwarding_fee_proportional_millionths(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
 * excess of [`forwarding_fee_proportional_millionths`].
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * The default value of a single satoshi roughly matches the market rate on many routing nodes
 * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
 * this node.
 *
 * Default value: 1000.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 */
uint32_t ChannelConfig_get_forwarding_fee_base_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
 * excess of [`forwarding_fee_proportional_millionths`].
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * The default value of a single satoshi roughly matches the market rate on many routing nodes
 * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
 * this node.
 *
 * Default value: 1000.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 */
void ChannelConfig_set_forwarding_fee_base_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
 * the channel this config applies to.
 *
 * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
 * HTLC balance when a channel appears on-chain whereas
 * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
 * (non-HTLC-encumbered) balance.
 *
 * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
 * we (or one of our watchtowers) MUST be online to check for broadcast of the current
 * commitment transaction at least once per this many blocks (minus some margin to allow us
 * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
 * the spending transaction).
 *
 * Default value: 72 (12 hours at an average of 6 blocks/hour).
 * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
 *                [`MIN_CLTV_EXPIRY_DELTA`] instead.
 *
 * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
 */
uint16_t ChannelConfig_get_cltv_expiry_delta(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
 * the channel this config applies to.
 *
 * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
 * HTLC balance when a channel appears on-chain whereas
 * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
 * (non-HTLC-encumbered) balance.
 *
 * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
 * we (or one of our watchtowers) MUST be online to check for broadcast of the current
 * commitment transaction at least once per this many blocks (minus some margin to allow us
 * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
 * the spending transaction).
 *
 * Default value: 72 (12 hours at an average of 6 blocks/hour).
 * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
 *                [`MIN_CLTV_EXPIRY_DELTA`] instead.
 *
 * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
 */
void ChannelConfig_set_cltv_expiry_delta(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
 * small to claim on-chain.
 *
 * When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
 * not be claimable on-chain, instead being turned into additional miner fees if either
 * party force-closes the channel. Because the threshold is per-HTLC, our total exposure
 * to such payments may be sustantial if there are many dust HTLCs present when the
 * channel is force-closed.
 *
 * The dust threshold for each HTLC is based on the `dust_limit_satoshis` for each party in a
 * channel negotiated throughout the channel open process, along with the fees required to have
 * a broadcastable HTLC spending transaction. When a channel supports anchor outputs
 * (specifically the zero fee HTLC transaction variant), this threshold no longer takes into
 * account the HTLC transaction fee as it is zero.
 *
 * This limit is applied for sent, forwarded, and received HTLCs and limits the total
 * exposure across all three types per-channel. Setting this too low may prevent the
 * sending or receipt of low-value HTLCs on high-traffic nodes, and this limit is very
 * important to prevent stealing of dust HTLCs by miners.
 *
 * Default value: 5_000_000 msat.
 */
uint64_t ChannelConfig_get_max_dust_htlc_exposure_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
 * small to claim on-chain.
 *
 * When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
 * not be claimable on-chain, instead being turned into additional miner fees if either
 * party force-closes the channel. Because the threshold is per-HTLC, our total exposure
 * to such payments may be sustantial if there are many dust HTLCs present when the
 * channel is force-closed.
 *
 * The dust threshold for each HTLC is based on the `dust_limit_satoshis` for each party in a
 * channel negotiated throughout the channel open process, along with the fees required to have
 * a broadcastable HTLC spending transaction. When a channel supports anchor outputs
 * (specifically the zero fee HTLC transaction variant), this threshold no longer takes into
 * account the HTLC transaction fee as it is zero.
 *
 * This limit is applied for sent, forwarded, and received HTLCs and limits the total
 * exposure across all three types per-channel. Setting this too low may prevent the
 * sending or receipt of low-value HTLCs on high-traffic nodes, and this limit is very
 * important to prevent stealing of dust HTLCs by miners.
 *
 * Default value: 5_000_000 msat.
 */
void ChannelConfig_set_max_dust_htlc_exposure_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The additional fee we're willing to pay to avoid waiting for the counterparty's
 * `to_self_delay` to reclaim funds.
 *
 * When we close a channel cooperatively with our counterparty, we negotiate a fee for the
 * closing transaction which both sides find acceptable, ultimately paid by the channel
 * funder/initiator.
 *
 * When we are the funder, because we have to pay the channel closing fee, we bound the
 * acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
 * this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
 * [`Normal`] feerate during normal operation, this value represents the additional fee we're
 * willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
 * funds.
 *
 * When we are not the funder, we require the closing transaction fee pay at least our
 * [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
 * Thus, this value is ignored when we are not the funder.
 *
 * Default value: 1000 satoshis.
 *
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 */
uint64_t ChannelConfig_get_force_close_avoidance_max_fee_satoshis(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * The additional fee we're willing to pay to avoid waiting for the counterparty's
 * `to_self_delay` to reclaim funds.
 *
 * When we close a channel cooperatively with our counterparty, we negotiate a fee for the
 * closing transaction which both sides find acceptable, ultimately paid by the channel
 * funder/initiator.
 *
 * When we are the funder, because we have to pay the channel closing fee, we bound the
 * acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
 * this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
 * [`Normal`] feerate during normal operation, this value represents the additional fee we're
 * willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
 * funds.
 *
 * When we are not the funder, we require the closing transaction fee pay at least our
 * [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
 * Thus, this value is ignored when we are not the funder.
 *
 * Default value: 1000 satoshis.
 *
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 */
void ChannelConfig_set_force_close_avoidance_max_fee_satoshis(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ChannelConfig given each field
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_new(uint32_t forwarding_fee_proportional_millionths_arg, uint32_t forwarding_fee_base_msat_arg, uint16_t cltv_expiry_delta_arg, uint64_t max_dust_htlc_exposure_msat_arg, uint64_t force_close_avoidance_max_fee_satoshis_arg);

/**
 * Creates a copy of the ChannelConfig
 */
struct LDKChannelConfig ChannelConfig_clone(const struct LDKChannelConfig *NONNULL_PTR orig);

/**
 * Checks if two ChannelConfigs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelConfig_eq(const struct LDKChannelConfig *NONNULL_PTR a, const struct LDKChannelConfig *NONNULL_PTR b);

/**
 * Creates a "default" ChannelConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_default(void);

/**
 * Serialize the ChannelConfig object into a byte array which can be read by ChannelConfig_read
 */
struct LDKCVec_u8Z ChannelConfig_write(const struct LDKChannelConfig *NONNULL_PTR obj);

/**
 * Read a ChannelConfig from a byte array, created by ChannelConfig_write
 */
struct LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UserConfig, if is_owned is set and inner is non-NULL.
 */
void UserConfig_free(struct LDKUserConfig this_obj);

/**
 * Channel handshake config that we propose to our counterparty.
 */
struct LDKChannelHandshakeConfig UserConfig_get_channel_handshake_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel handshake config that we propose to our counterparty.
 */
void UserConfig_set_channel_handshake_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeConfig val);

/**
 * Limits applied to our counterparty's proposed channel handshake config settings.
 */
struct LDKChannelHandshakeLimits UserConfig_get_channel_handshake_limits(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Limits applied to our counterparty's proposed channel handshake config settings.
 */
void UserConfig_set_channel_handshake_limits(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeLimits val);

/**
 * Channel config which affects behavior during channel lifetime.
 */
struct LDKChannelConfig UserConfig_get_channel_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel config which affects behavior during channel lifetime.
 */
void UserConfig_set_channel_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelConfig val);

/**
 * If this is set to false, we will reject any HTLCs which were to be forwarded over private
 * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
 * node which is not online reliably.
 *
 * For nodes which are not online reliably, you should set all channels to *not* be announced
 * (using [`ChannelHandshakeConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
 * ensure you are not exposed to any forwarding risk.
 *
 * Note that because you cannot change a channel's announced state after creation, there is no
 * way to disable forwarding on public channels retroactively. Thus, in order to change a node
 * from a publicly-announced forwarding node to a private non-forwarding node you must close
 * all your channels and open new ones. For privacy, you should also change your node_id
 * (swapping all private and public key material for new ones) at that time.
 *
 * Default value: false.
 */
bool UserConfig_get_accept_forwards_to_priv_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to false, we will reject any HTLCs which were to be forwarded over private
 * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
 * node which is not online reliably.
 *
 * For nodes which are not online reliably, you should set all channels to *not* be announced
 * (using [`ChannelHandshakeConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
 * ensure you are not exposed to any forwarding risk.
 *
 * Note that because you cannot change a channel's announced state after creation, there is no
 * way to disable forwarding on public channels retroactively. Thus, in order to change a node
 * from a publicly-announced forwarding node to a private non-forwarding node you must close
 * all your channels and open new ones. For privacy, you should also change your node_id
 * (swapping all private and public key material for new ones) at that time.
 *
 * Default value: false.
 */
void UserConfig_set_accept_forwards_to_priv_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * If this is set to false, we do not accept inbound requests to open a new channel.
 * Default value: true.
 */
bool UserConfig_get_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to false, we do not accept inbound requests to open a new channel.
 * Default value: true.
 */
void UserConfig_set_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * If this is set to true, the user needs to manually accept inbound requests to open a new
 * channel.
 *
 * When set to true, [`Event::OpenChannelRequest`] will be triggered once a request to open a
 * new inbound channel is received through a [`msgs::OpenChannel`] message. In that case, a
 * [`msgs::AcceptChannel`] message will not be sent back to the counterparty node unless the
 * user explicitly chooses to accept the request.
 *
 * Default value: false.
 *
 * [`Event::OpenChannelRequest`]: crate::util::events::Event::OpenChannelRequest
 * [`msgs::OpenChannel`]: crate::ln::msgs::OpenChannel
 * [`msgs::AcceptChannel`]: crate::ln::msgs::AcceptChannel
 */
bool UserConfig_get_manually_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to true, the user needs to manually accept inbound requests to open a new
 * channel.
 *
 * When set to true, [`Event::OpenChannelRequest`] will be triggered once a request to open a
 * new inbound channel is received through a [`msgs::OpenChannel`] message. In that case, a
 * [`msgs::AcceptChannel`] message will not be sent back to the counterparty node unless the
 * user explicitly chooses to accept the request.
 *
 * Default value: false.
 *
 * [`Event::OpenChannelRequest`]: crate::util::events::Event::OpenChannelRequest
 * [`msgs::OpenChannel`]: crate::ln::msgs::OpenChannel
 * [`msgs::AcceptChannel`]: crate::ln::msgs::AcceptChannel
 */
void UserConfig_set_manually_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 *  If this is set to true, LDK will intercept HTLCs that are attempting to be forwarded over
 *  fake short channel ids generated via [`ChannelManager::get_intercept_scid`]. Upon HTLC
 *  intercept, LDK will generate an [`Event::HTLCIntercepted`] which MUST be handled by the user.
 *
 *  Setting this to true may break backwards compatibility with LDK versions < 0.0.113.
 *
 *  Default value: false.
 *
 * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
 * [`Event::HTLCIntercepted`]: crate::util::events::Event::HTLCIntercepted
 */
bool UserConfig_get_accept_intercept_htlcs(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 *  If this is set to true, LDK will intercept HTLCs that are attempting to be forwarded over
 *  fake short channel ids generated via [`ChannelManager::get_intercept_scid`]. Upon HTLC
 *  intercept, LDK will generate an [`Event::HTLCIntercepted`] which MUST be handled by the user.
 *
 *  Setting this to true may break backwards compatibility with LDK versions < 0.0.113.
 *
 *  Default value: false.
 *
 * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
 * [`Event::HTLCIntercepted`]: crate::util::events::Event::HTLCIntercepted
 */
void UserConfig_set_accept_intercept_htlcs(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new UserConfig given each field
 */
MUST_USE_RES struct LDKUserConfig UserConfig_new(struct LDKChannelHandshakeConfig channel_handshake_config_arg, struct LDKChannelHandshakeLimits channel_handshake_limits_arg, struct LDKChannelConfig channel_config_arg, bool accept_forwards_to_priv_channels_arg, bool accept_inbound_channels_arg, bool manually_accept_inbound_channels_arg, bool accept_intercept_htlcs_arg);

/**
 * Creates a copy of the UserConfig
 */
struct LDKUserConfig UserConfig_clone(const struct LDKUserConfig *NONNULL_PTR orig);

/**
 * Creates a "default" UserConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKUserConfig UserConfig_default(void);

/**
 * Frees any resources used by the BestBlock, if is_owned is set and inner is non-NULL.
 */
void BestBlock_free(struct LDKBestBlock this_obj);

/**
 * Creates a copy of the BestBlock
 */
struct LDKBestBlock BestBlock_clone(const struct LDKBestBlock *NONNULL_PTR orig);

/**
 * Checks if two BestBlocks contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool BestBlock_eq(const struct LDKBestBlock *NONNULL_PTR a, const struct LDKBestBlock *NONNULL_PTR b);

/**
 * Constructs a `BestBlock` that represents the genesis block at height 0 of the given
 * network.
 */
MUST_USE_RES struct LDKBestBlock BestBlock_from_genesis(enum LDKNetwork network);

/**
 * Returns a `BestBlock` as identified by the given block hash and height.
 */
MUST_USE_RES struct LDKBestBlock BestBlock_new(struct LDKThirtyTwoBytes block_hash, uint32_t height);

/**
 * Returns the best block hash.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BestBlock_block_hash(const struct LDKBestBlock *NONNULL_PTR this_arg);

/**
 * Returns the best block height.
 */
MUST_USE_RES uint32_t BestBlock_height(const struct LDKBestBlock *NONNULL_PTR this_arg);

/**
 * Creates a copy of the AccessError
 */
enum LDKAccessError AccessError_clone(const enum LDKAccessError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new UnknownChain-variant AccessError
 */
enum LDKAccessError AccessError_unknown_chain(void);

/**
 * Utility method to constructs a new UnknownTx-variant AccessError
 */
enum LDKAccessError AccessError_unknown_tx(void);

/**
 * Calls the free function if one is set
 */
void Access_free(struct LDKAccess this_ptr);

/**
 * Calls the free function if one is set
 */
void Listen_free(struct LDKListen this_ptr);

/**
 * Calls the free function if one is set
 */
void Confirm_free(struct LDKConfirm this_ptr);

/**
 * Creates a copy of the ChannelMonitorUpdateStatus
 */
enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_clone(const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Completed-variant ChannelMonitorUpdateStatus
 */
enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_completed(void);

/**
 * Utility method to constructs a new InProgress-variant ChannelMonitorUpdateStatus
 */
enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_in_progress(void);

/**
 * Utility method to constructs a new PermanentFailure-variant ChannelMonitorUpdateStatus
 */
enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_permanent_failure(void);

/**
 * Checks if two ChannelMonitorUpdateStatuss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ChannelMonitorUpdateStatus_eq(const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR a, const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void Watch_free(struct LDKWatch this_ptr);

/**
 * Calls the free function if one is set
 */
void Filter_free(struct LDKFilter this_ptr);

/**
 * Frees any resources used by the WatchedOutput, if is_owned is set and inner is non-NULL.
 */
void WatchedOutput_free(struct LDKWatchedOutput this_obj);

/**
 * First block where the transaction output may have been spent.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKThirtyTwoBytes WatchedOutput_get_block_hash(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * First block where the transaction output may have been spent.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void WatchedOutput_set_block_hash(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Outpoint identifying the transaction output.
 */
struct LDKOutPoint WatchedOutput_get_outpoint(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * Outpoint identifying the transaction output.
 */
void WatchedOutput_set_outpoint(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Spending condition of the transaction output.
 */
struct LDKu8slice WatchedOutput_get_script_pubkey(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * Spending condition of the transaction output.
 */
void WatchedOutput_set_script_pubkey(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new WatchedOutput given each field
 */
MUST_USE_RES struct LDKWatchedOutput WatchedOutput_new(struct LDKThirtyTwoBytes block_hash_arg, struct LDKOutPoint outpoint_arg, struct LDKCVec_u8Z script_pubkey_arg);

/**
 * Creates a copy of the WatchedOutput
 */
struct LDKWatchedOutput WatchedOutput_clone(const struct LDKWatchedOutput *NONNULL_PTR orig);

/**
 * Checks if two WatchedOutputs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool WatchedOutput_eq(const struct LDKWatchedOutput *NONNULL_PTR a, const struct LDKWatchedOutput *NONNULL_PTR b);

/**
 * Checks if two WatchedOutputs contain equal inner contents.
 */
uint64_t WatchedOutput_hash(const struct LDKWatchedOutput *NONNULL_PTR o);

/**
 * Calls the free function if one is set
 */
void BroadcasterInterface_free(struct LDKBroadcasterInterface this_ptr);

/**
 * Creates a copy of the ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_clone(const enum LDKConfirmationTarget *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Background-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_background(void);

/**
 * Utility method to constructs a new Normal-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_normal(void);

/**
 * Utility method to constructs a new HighPriority-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_high_priority(void);

/**
 * Checks if two ConfirmationTargets contain equal inner contents.
 */
uint64_t ConfirmationTarget_hash(const enum LDKConfirmationTarget *NONNULL_PTR o);

/**
 * Checks if two ConfirmationTargets contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ConfirmationTarget_eq(const enum LDKConfirmationTarget *NONNULL_PTR a, const enum LDKConfirmationTarget *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void FeeEstimator_free(struct LDKFeeEstimator this_ptr);

/**
 * Frees any resources used by the MonitorUpdateId, if is_owned is set and inner is non-NULL.
 */
void MonitorUpdateId_free(struct LDKMonitorUpdateId this_obj);

/**
 * Creates a copy of the MonitorUpdateId
 */
struct LDKMonitorUpdateId MonitorUpdateId_clone(const struct LDKMonitorUpdateId *NONNULL_PTR orig);

/**
 * Checks if two MonitorUpdateIds contain equal inner contents.
 */
uint64_t MonitorUpdateId_hash(const struct LDKMonitorUpdateId *NONNULL_PTR o);

/**
 * Checks if two MonitorUpdateIds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool MonitorUpdateId_eq(const struct LDKMonitorUpdateId *NONNULL_PTR a, const struct LDKMonitorUpdateId *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void Persist_free(struct LDKPersist this_ptr);

/**
 * Frees any resources used by the LockedChannelMonitor, if is_owned is set and inner is non-NULL.
 */
void LockedChannelMonitor_free(struct LDKLockedChannelMonitor this_obj);

/**
 * Frees any resources used by the ChainMonitor, if is_owned is set and inner is non-NULL.
 */
void ChainMonitor_free(struct LDKChainMonitor this_obj);

/**
 * Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
 *
 * When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
 * will call back to it indicating transactions and outputs of interest. This allows clients to
 * pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
 * always need to fetch full blocks absent another means for determining which blocks contain
 * transactions relevant to the watched channels.
 */
MUST_USE_RES struct LDKChainMonitor ChainMonitor_new(struct LDKCOption_FilterZ chain_source, struct LDKBroadcasterInterface broadcaster, struct LDKLogger logger, struct LDKFeeEstimator feeest, struct LDKPersist persister);

/**
 * Gets the balances in the contained [`ChannelMonitor`]s which are claimable on-chain or
 * claims which are awaiting confirmation.
 *
 * Includes the balances from each [`ChannelMonitor`] *except* those included in
 * `ignored_channels`, allowing you to filter out balances from channels which are still open
 * (and whose balance should likely be pulled from the [`ChannelDetails`]).
 *
 * See [`ChannelMonitor::get_claimable_balances`] for more details on the exact criteria for
 * inclusion in the return value.
 */
MUST_USE_RES struct LDKCVec_BalanceZ ChainMonitor_get_claimable_balances(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKCVec_ChannelDetailsZ ignored_channels);

/**
 * Gets the [`LockedChannelMonitor`] for a given funding outpoint, returning an `Err` if no
 * such [`ChannelMonitor`] is currently being monitored for.
 *
 * Note that the result holds a mutex over our monitor set, and should not be held
 * indefinitely.
 */
MUST_USE_RES struct LDKCResult_LockedChannelMonitorNoneZ ChainMonitor_get_monitor(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo);

/**
 * Lists the funding outpoint of each [`ChannelMonitor`] being monitored.
 *
 * Note that [`ChannelMonitor`]s are not removed when a channel is closed as they are always
 * monitoring for on-chain state resolutions.
 */
MUST_USE_RES struct LDKCVec_OutPointZ ChainMonitor_list_monitors(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Lists the pending updates for each [`ChannelMonitor`] (by `OutPoint` being monitored).
 */
MUST_USE_RES struct LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ ChainMonitor_list_pending_monitor_updates(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Indicates the persistence of a [`ChannelMonitor`] has completed after
 * [`ChannelMonitorUpdateStatus::InProgress`] was returned from an update operation.
 *
 * Thus, the anticipated use is, at a high level:
 *  1) This [`ChainMonitor`] calls [`Persist::update_persisted_channel`] which stores the
 *     update to disk and begins updating any remote (e.g. watchtower/backup) copies,
 *     returning [`ChannelMonitorUpdateStatus::InProgress`],
 *  2) once all remote copies are updated, you call this function with the
 *     `completed_update_id` that completed, and once all pending updates have completed the
 *     channel will be re-enabled.
 *
 * Returns an [`APIError::APIMisuseError`] if `funding_txo` does not match any currently
 * registered [`ChannelMonitor`]s.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChainMonitor_channel_monitor_updated(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKMonitorUpdateId completed_update_id);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChainMonitor_as_Listen(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Confirm which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
 */
struct LDKConfirm ChainMonitor_as_Confirm(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Watch which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
 */
struct LDKWatch ChainMonitor_as_Watch(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChainMonitor_as_EventsProvider(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelMonitorUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitorUpdate_free(struct LDKChannelMonitorUpdate this_obj);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with one exception specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * [`ChannelMonitorUpdateStatus::InProgress`] have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instance where update_id values are not strictly increasing is the case where we
 * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
 * its docs for more details.
 *
 * [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
 */
uint64_t ChannelMonitorUpdate_get_update_id(const struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with one exception specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * [`ChannelMonitorUpdateStatus::InProgress`] have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instance where update_id values are not strictly increasing is the case where we
 * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
 * its docs for more details.
 *
 * [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
 */
void ChannelMonitorUpdate_set_update_id(struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelMonitorUpdate
 */
struct LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(const struct LDKChannelMonitorUpdate *NONNULL_PTR orig);

/**
 * Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
 */
struct LDKCVec_u8Z ChannelMonitorUpdate_write(const struct LDKChannelMonitorUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the MonitorEvent
 */
void MonitorEvent_free(struct LDKMonitorEvent this_ptr);

/**
 * Creates a copy of the MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_clone(const struct LDKMonitorEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new HTLCEvent-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_htlcevent(struct LDKHTLCUpdate a);

/**
 * Utility method to constructs a new CommitmentTxConfirmed-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_commitment_tx_confirmed(struct LDKOutPoint a);

/**
 * Utility method to constructs a new Completed-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_completed(struct LDKOutPoint funding_txo, uint64_t monitor_update_id);

/**
 * Utility method to constructs a new UpdateFailed-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_update_failed(struct LDKOutPoint a);

/**
 * Checks if two MonitorEvents contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool MonitorEvent_eq(const struct LDKMonitorEvent *NONNULL_PTR a, const struct LDKMonitorEvent *NONNULL_PTR b);

/**
 * Serialize the MonitorEvent object into a byte array which can be read by MonitorEvent_read
 */
struct LDKCVec_u8Z MonitorEvent_write(const struct LDKMonitorEvent *NONNULL_PTR obj);

/**
 * Read a MonitorEvent from a byte array, created by MonitorEvent_write
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ MonitorEvent_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the HTLCUpdate, if is_owned is set and inner is non-NULL.
 */
void HTLCUpdate_free(struct LDKHTLCUpdate this_obj);

/**
 * Creates a copy of the HTLCUpdate
 */
struct LDKHTLCUpdate HTLCUpdate_clone(const struct LDKHTLCUpdate *NONNULL_PTR orig);

/**
 * Checks if two HTLCUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool HTLCUpdate_eq(const struct LDKHTLCUpdate *NONNULL_PTR a, const struct LDKHTLCUpdate *NONNULL_PTR b);

/**
 * Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
 */
struct LDKCVec_u8Z HTLCUpdate_write(const struct LDKHTLCUpdate *NONNULL_PTR obj);

/**
 * Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Balance
 */
void Balance_free(struct LDKBalance this_ptr);

/**
 * Creates a copy of the Balance
 */
struct LDKBalance Balance_clone(const struct LDKBalance *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ClaimableOnChannelClose-variant Balance
 */
struct LDKBalance Balance_claimable_on_channel_close(uint64_t claimable_amount_satoshis);

/**
 * Utility method to constructs a new ClaimableAwaitingConfirmations-variant Balance
 */
struct LDKBalance Balance_claimable_awaiting_confirmations(uint64_t claimable_amount_satoshis, uint32_t confirmation_height);

/**
 * Utility method to constructs a new ContentiousClaimable-variant Balance
 */
struct LDKBalance Balance_contentious_claimable(uint64_t claimable_amount_satoshis, uint32_t timeout_height);

/**
 * Utility method to constructs a new MaybeTimeoutClaimableHTLC-variant Balance
 */
struct LDKBalance Balance_maybe_timeout_claimable_htlc(uint64_t claimable_amount_satoshis, uint32_t claimable_height);

/**
 * Utility method to constructs a new MaybePreimageClaimableHTLC-variant Balance
 */
struct LDKBalance Balance_maybe_preimage_claimable_htlc(uint64_t claimable_amount_satoshis, uint32_t expiry_height);

/**
 * Utility method to constructs a new CounterpartyRevokedOutputClaimable-variant Balance
 */
struct LDKBalance Balance_counterparty_revoked_output_claimable(uint64_t claimable_amount_satoshis);

/**
 * Checks if two Balances contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Balance_eq(const struct LDKBalance *NONNULL_PTR a, const struct LDKBalance *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelMonitor, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitor_free(struct LDKChannelMonitor this_obj);

/**
 * Creates a copy of the ChannelMonitor
 */
struct LDKChannelMonitor ChannelMonitor_clone(const struct LDKChannelMonitor *NONNULL_PTR orig);

/**
 * Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
 */
struct LDKCVec_u8Z ChannelMonitor_write(const struct LDKChannelMonitor *NONNULL_PTR obj);

/**
 * Updates a ChannelMonitor on the basis of some new information provided by the Channel
 * itself.
 *
 * panics if the given update is not the next update by update_id.
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelMonitor_update_monitor(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR updates, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, struct LDKFeeEstimator fee_estimator, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
 * ChannelMonitor.
 */
MUST_USE_RES uint64_t ChannelMonitor_get_latest_update_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
 */
MUST_USE_RES struct LDKC2Tuple_OutPointScriptZ ChannelMonitor_get_funding_txo(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets a list of txids, with their output scripts (in the order they appear in the
 * transaction), which we must learn about spends of via block_connected().
 */
MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ChannelMonitor_get_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
 * calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
 * have been registered.
 */
void ChannelMonitor_load_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKFilter *NONNULL_PTR filter);

/**
 * Get the list of HTLCs who's status has been updated on chain. This should be called by
 * ChannelManager via [`chain::Watch::release_pending_monitor_events`].
 */
MUST_USE_RES struct LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the list of pending events which were generated by previous actions, clearing the list
 * in the process.
 *
 * This is called by the [`EventsProvider::process_pending_events`] implementation for
 * [`ChainMonitor`].
 *
 * [`EventsProvider::process_pending_events`]: crate::util::events::EventsProvider::process_pending_events
 * [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
 */
MUST_USE_RES struct LDKCVec_EventZ ChannelMonitor_get_and_clear_pending_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the `node_id` of the counterparty for this channel.
 *
 * Will be `None` for channels constructed on LDK versions prior to 0.0.110 and always `Some`
 * otherwise.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPublicKey ChannelMonitor_get_counterparty_node_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Used by ChannelManager deserialization to broadcast the latest holder state if its copy of
 * the Channel was out-of-date.
 *
 * You may also use this to broadcast the latest local commitment transaction, either because
 * a monitor update failed with [`ChannelMonitorUpdateStatus::PermanentFailure`] or because we've
 * fallen behind (i.e. we've received proof that our counterparty side knows a revocation
 * secret we gave them that they shouldn't know).
 *
 * Broadcasting these transactions in the second case is UNSAFE, as they allow counterparty
 * side to punish you. Nevertheless you may want to broadcast them if counterparty doesn't
 * close channel with their commitment transaction after a substantial amount of time. Best
 * may be to contact the other node operator out-of-band to coordinate other options available
 * to you. In any-case, the choice is up to you.
 *
 * [`ChannelMonitorUpdateStatus::PermanentFailure`]: super::ChannelMonitorUpdateStatus::PermanentFailure
 */
MUST_USE_RES struct LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Processes transactions in a newly connected block, which may result in any of the following:
 * - update the monitor's state against resolved HTLCs
 * - punish the counterparty in the case of seeing a revoked commitment transaction
 * - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
 * - detect settled outputs for later spending
 * - schedule and bump any in-flight claims
 *
 * Returns any new outputs to watch from `txdata`; after called, these are also included in
 * [`get_outputs_to_watch`].
 *
 * [`get_outputs_to_watch`]: #method.get_outputs_to_watch
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_block_connected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Determines if the disconnected block contained any transactions of interest and updates
 * appropriately.
 */
void ChannelMonitor_block_disconnected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Processes transactions confirmed in a block with the given header and height, returning new
 * outputs to watch. See [`block_connected`] for details.
 *
 * Used instead of [`block_connected`] by clients that are notified of transactions rather than
 * blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_connected`]: Self::block_connected
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_transactions_confirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Processes a transaction that was reorganized out of the chain.
 *
 * Used instead of [`block_disconnected`] by clients that are notified of transactions rather
 * than blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_disconnected`]: Self::block_disconnected
 */
void ChannelMonitor_transaction_unconfirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Updates the monitor with the current best chain tip, returning new outputs to watch. See
 * [`block_connected`] for details.
 *
 * Used instead of [`block_connected`] by clients that are notified of transactions rather than
 * blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_connected`]: Self::block_connected
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_best_block_updated(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Returns the set of txids that should be monitored for re-organization out of the chain.
 */
MUST_USE_RES struct LDKCVec_C2Tuple_TxidBlockHashZZ ChannelMonitor_get_relevant_txids(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the latest best block which was connected either via the [`chain::Listen`] or
 * [`chain::Confirm`] interfaces.
 */
MUST_USE_RES struct LDKBestBlock ChannelMonitor_current_best_block(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the balances in this channel which are either claimable by us if we were to
 * force-close the channel now or which are claimable on-chain (possibly awaiting
 * confirmation).
 *
 * Any balances in the channel which are available on-chain (excluding on-chain fees) are
 * included here until an [`Event::SpendableOutputs`] event has been generated for the
 * balance, or until our counterparty has claimed the balance and accrued several
 * confirmations on the claim transaction.
 *
 * Note that for `ChannelMonitors` which track a channel which went on-chain with versions of
 * LDK prior to 0.0.111, balances may not be fully captured if our counterparty broadcasted
 * a revoked state.
 *
 * See [`Balance`] for additional details on the types of claimable balances which
 * may be returned here and their meanings.
 */
MUST_USE_RES struct LDKCVec_BalanceZ ChannelMonitor_get_claimable_balances(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Read a C2Tuple_BlockHashChannelMonitorZ from a byte array, created by C2Tuple_BlockHashChannelMonitorZ_write
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ C2Tuple_BlockHashChannelMonitorZ_read(struct LDKu8slice ser, const struct LDKKeysInterface *NONNULL_PTR arg);

/**
 * Frees any resources used by the OutPoint, if is_owned is set and inner is non-NULL.
 */
void OutPoint_free(struct LDKOutPoint this_obj);

/**
 * The referenced transaction's txid.
 */
const uint8_t (*OutPoint_get_txid(const struct LDKOutPoint *NONNULL_PTR this_ptr))[32];

/**
 * The referenced transaction's txid.
 */
void OutPoint_set_txid(struct LDKOutPoint *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The index of the referenced output in its transaction's vout.
 */
uint16_t OutPoint_get_index(const struct LDKOutPoint *NONNULL_PTR this_ptr);

/**
 * The index of the referenced output in its transaction's vout.
 */
void OutPoint_set_index(struct LDKOutPoint *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new OutPoint given each field
 */
MUST_USE_RES struct LDKOutPoint OutPoint_new(struct LDKThirtyTwoBytes txid_arg, uint16_t index_arg);

/**
 * Creates a copy of the OutPoint
 */
struct LDKOutPoint OutPoint_clone(const struct LDKOutPoint *NONNULL_PTR orig);

/**
 * Checks if two OutPoints contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OutPoint_eq(const struct LDKOutPoint *NONNULL_PTR a, const struct LDKOutPoint *NONNULL_PTR b);

/**
 * Checks if two OutPoints contain equal inner contents.
 */
uint64_t OutPoint_hash(const struct LDKOutPoint *NONNULL_PTR o);

/**
 * Convert an `OutPoint` to a lightning channel id.
 */
MUST_USE_RES struct LDKThirtyTwoBytes OutPoint_to_channel_id(const struct LDKOutPoint *NONNULL_PTR this_arg);

/**
 * Serialize the OutPoint object into a byte array which can be read by OutPoint_read
 */
struct LDKCVec_u8Z OutPoint_write(const struct LDKOutPoint *NONNULL_PTR obj);

/**
 * Read a OutPoint from a byte array, created by OutPoint_write
 */
struct LDKCResult_OutPointDecodeErrorZ OutPoint_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DelayedPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void DelayedPaymentOutputDescriptor_free(struct LDKDelayedPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable.
 */
struct LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable.
 */
void DelayedPaymentOutputDescriptor_set_outpoint(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Per commitment point to derive the delayed payment key by key holder.
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * Per commitment point to derive the delayed payment key by key holder.
 */
void DelayedPaymentOutputDescriptor_set_per_commitment_point(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The `nSequence` value which must be set in the spending input to satisfy the `OP_CSV` in
 * the witness_script.
 */
uint16_t DelayedPaymentOutputDescriptor_get_to_self_delay(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The `nSequence` value which must be set in the spending input to satisfy the `OP_CSV` in
 * the witness_script.
 */
void DelayedPaymentOutputDescriptor_set_to_self_delay(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The output which is referenced by the given outpoint.
 *
 * Returns a copy of the field.
 */
struct LDKTxOut DelayedPaymentOutputDescriptor_get_output(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The output which is referenced by the given outpoint.
 */
void DelayedPaymentOutputDescriptor_set_output(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
void DelayedPaymentOutputDescriptor_set_revocation_pubkey(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Arbitrary identification information returned by a call to [`BaseSign::channel_keys_id`].
 * This may be useful in re-deriving keys used in the channel to spend the output.
 */
const uint8_t (*DelayedPaymentOutputDescriptor_get_channel_keys_id(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to [`BaseSign::channel_keys_id`].
 * This may be useful in re-deriving keys used in the channel to spend the output.
 */
void DelayedPaymentOutputDescriptor_set_channel_keys_id(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
uint64_t DelayedPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new DelayedPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKPublicKey per_commitment_point_arg, uint16_t to_self_delay_arg, struct LDKTxOut output_arg, struct LDKPublicKey revocation_pubkey_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the DelayedPaymentOutputDescriptor
 */
struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Checks if two DelayedPaymentOutputDescriptors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool DelayedPaymentOutputDescriptor_eq(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR a, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR b);

/**
 * Serialize the DelayedPaymentOutputDescriptor object into a byte array which can be read by DelayedPaymentOutputDescriptor_read
 */
struct LDKCVec_u8Z DelayedPaymentOutputDescriptor_write(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a DelayedPaymentOutputDescriptor from a byte array, created by DelayedPaymentOutputDescriptor_write
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ DelayedPaymentOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the StaticPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void StaticPaymentOutputDescriptor_free(struct LDKStaticPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable.
 */
struct LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable.
 */
void StaticPaymentOutputDescriptor_set_outpoint(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The output which is referenced by the given outpoint.
 *
 * Returns a copy of the field.
 */
struct LDKTxOut StaticPaymentOutputDescriptor_get_output(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The output which is referenced by the given outpoint.
 */
void StaticPaymentOutputDescriptor_set_output(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * Arbitrary identification information returned by a call to [`BaseSign::channel_keys_id`].
 * This may be useful in re-deriving keys used in the channel to spend the output.
 */
const uint8_t (*StaticPaymentOutputDescriptor_get_channel_keys_id(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to [`BaseSign::channel_keys_id`].
 * This may be useful in re-deriving keys used in the channel to spend the output.
 */
void StaticPaymentOutputDescriptor_set_channel_keys_id(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this transactions spends.
 */
uint64_t StaticPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this transactions spends.
 */
void StaticPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new StaticPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the StaticPaymentOutputDescriptor
 */
struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Checks if two StaticPaymentOutputDescriptors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool StaticPaymentOutputDescriptor_eq(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR a, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR b);

/**
 * Serialize the StaticPaymentOutputDescriptor object into a byte array which can be read by StaticPaymentOutputDescriptor_read
 */
struct LDKCVec_u8Z StaticPaymentOutputDescriptor_write(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a StaticPaymentOutputDescriptor from a byte array, created by StaticPaymentOutputDescriptor_write
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ StaticPaymentOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the SpendableOutputDescriptor
 */
void SpendableOutputDescriptor_free(struct LDKSpendableOutputDescriptor this_ptr);

/**
 * Creates a copy of the SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(const struct LDKSpendableOutputDescriptor *NONNULL_PTR orig);

/**
 * Utility method to constructs a new StaticOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_output(struct LDKOutPoint outpoint, struct LDKTxOut output);

/**
 * Utility method to constructs a new DelayedPaymentOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_delayed_payment_output(struct LDKDelayedPaymentOutputDescriptor a);

/**
 * Utility method to constructs a new StaticPaymentOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_payment_output(struct LDKStaticPaymentOutputDescriptor a);

/**
 * Checks if two SpendableOutputDescriptors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SpendableOutputDescriptor_eq(const struct LDKSpendableOutputDescriptor *NONNULL_PTR a, const struct LDKSpendableOutputDescriptor *NONNULL_PTR b);

/**
 * Serialize the SpendableOutputDescriptor object into a byte array which can be read by SpendableOutputDescriptor_read
 */
struct LDKCVec_u8Z SpendableOutputDescriptor_write(const struct LDKSpendableOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a SpendableOutputDescriptor from a byte array, created by SpendableOutputDescriptor_write
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ SpendableOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Calls the free function if one is set
 */
void BaseSign_free(struct LDKBaseSign this_ptr);

/**
 * Creates a copy of a Sign
 */
struct LDKSign Sign_clone(const struct LDKSign *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Sign_free(struct LDKSign this_ptr);

/**
 * Creates a copy of the Recipient
 */
enum LDKRecipient Recipient_clone(const enum LDKRecipient *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Node-variant Recipient
 */
enum LDKRecipient Recipient_node(void);

/**
 * Utility method to constructs a new PhantomNode-variant Recipient
 */
enum LDKRecipient Recipient_phantom_node(void);

/**
 * Calls the free function if one is set
 */
void KeysInterface_free(struct LDKKeysInterface this_ptr);

/**
 * Frees any resources used by the InMemorySigner, if is_owned is set and inner is non-NULL.
 */
void InMemorySigner_free(struct LDKInMemorySigner this_obj);

/**
 * Holder secret key in the 2-of-2 multisig script of a channel. This key also backs the
 * holder's anchor output in a commitment transaction, if one is present.
 */
const uint8_t (*InMemorySigner_get_funding_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key in the 2-of-2 multisig script of a channel. This key also backs the
 * holder's anchor output in a commitment transaction, if one is present.
 */
void InMemorySigner_set_funding_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key for blinded revocation pubkey.
 */
const uint8_t (*InMemorySigner_get_revocation_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key for blinded revocation pubkey.
 */
void InMemorySigner_set_revocation_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions.
 */
const uint8_t (*InMemorySigner_get_payment_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions.
 */
void InMemorySigner_set_payment_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used in an HTLC transaction.
 */
const uint8_t (*InMemorySigner_get_delayed_payment_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used in an HTLC transaction.
 */
void InMemorySigner_set_delayed_payment_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder HTLC secret key used in commitment transaction HTLC outputs.
 */
const uint8_t (*InMemorySigner_get_htlc_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder HTLC secret key used in commitment transaction HTLC outputs.
 */
void InMemorySigner_set_htlc_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Commitment seed.
 */
const uint8_t (*InMemorySigner_get_commitment_seed(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Commitment seed.
 */
void InMemorySigner_set_commitment_seed(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Creates a copy of the InMemorySigner
 */
struct LDKInMemorySigner InMemorySigner_clone(const struct LDKInMemorySigner *NONNULL_PTR orig);

/**
 * Creates a new [`InMemorySigner`].
 */
MUST_USE_RES struct LDKInMemorySigner InMemorySigner_new(struct LDKSecretKey node_secret, struct LDKSecretKey funding_key, struct LDKSecretKey revocation_base_key, struct LDKSecretKey payment_key, struct LDKSecretKey delayed_payment_base_key, struct LDKSecretKey htlc_base_key, struct LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id);

/**
 * Returns the counterparty's pubkeys.
 *
 * Will panic if [`BaseSign::provide_channel_parameters`] has not been called before.
 */
MUST_USE_RES struct LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns the `contest_delay` value specified by our counterparty and applied on holder-broadcastable
 * transactions, i.e., the amount of time that we have to wait to recover our funds if we
 * broadcast a transaction.
 *
 * Will panic if [`BaseSign::provide_channel_parameters`] has not been called before.
 */
MUST_USE_RES uint16_t InMemorySigner_counterparty_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns the `contest_delay` value specified by us and applied on transactions broadcastable
 * by our counterparty, i.e., the amount of time that they have to wait to recover their funds
 * if they broadcast a transaction.
 *
 * Will panic if [`BaseSign::provide_channel_parameters`] has not been called before.
 */
MUST_USE_RES uint16_t InMemorySigner_holder_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns whether the holder is the initiator.
 *
 * Will panic if [`BaseSign::provide_channel_parameters`] has not been called before.
 */
MUST_USE_RES bool InMemorySigner_is_outbound(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Funding outpoint
 *
 * Will panic if [`BaseSign::provide_channel_parameters`] has not been called before.
 */
MUST_USE_RES struct LDKOutPoint InMemorySigner_funding_outpoint(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns a [`ChannelTransactionParameters`] for this channel, to be used when verifying or
 * building transactions.
 *
 * Will panic if [`BaseSign::provide_channel_parameters`] has not been called before.
 */
MUST_USE_RES struct LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns whether anchors should be used.
 *
 * Will panic if [`BaseSign::provide_channel_parameters`] has not been called before.
 */
MUST_USE_RES bool InMemorySigner_opt_anchors(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Sign the single input of `spend_tx` at index `input_idx`, which spends the output described
 * by `descriptor`, returning the witness stack for the input.
 *
 * Returns an error if the input at `input_idx` does not exist, has a non-empty `script_sig`,
 * is not spending the outpoint described by [`descriptor.outpoint`],
 * or if an output descriptor `script_pubkey` does not match the one we can spend.
 *
 * [`descriptor.outpoint`]: StaticPaymentOutputDescriptor::outpoint
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Sign the single input of `spend_tx` at index `input_idx` which spends the output
 * described by `descriptor`, returning the witness stack for the input.
 *
 * Returns an error if the input at `input_idx` does not exist, has a non-empty `script_sig`,
 * is not spending the outpoint described by [`descriptor.outpoint`], does not have a
 * sequence set to [`descriptor.to_self_delay`], or if an output descriptor
 * `script_pubkey` does not match the one we can spend.
 *
 * [`descriptor.outpoint`]: DelayedPaymentOutputDescriptor::outpoint
 * [`descriptor.to_self_delay`]: DelayedPaymentOutputDescriptor::to_self_delay
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Constructs a new BaseSign which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned BaseSign must be freed before this_arg is
 */
struct LDKBaseSign InMemorySigner_as_BaseSign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Constructs a new Sign which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Sign must be freed before this_arg is
 */
struct LDKSign InMemorySigner_as_Sign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Serialize the InMemorySigner object into a byte array which can be read by InMemorySigner_read
 */
struct LDKCVec_u8Z InMemorySigner_write(const struct LDKInMemorySigner *NONNULL_PTR obj);

/**
 * Read a InMemorySigner from a byte array, created by InMemorySigner_write
 */
struct LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(struct LDKu8slice ser, struct LDKSecretKey arg);

/**
 * Frees any resources used by the KeysManager, if is_owned is set and inner is non-NULL.
 */
void KeysManager_free(struct LDKKeysManager this_obj);

/**
 * Constructs a [`KeysManager`] from a 32-byte seed. If the seed is in some way biased (e.g.,
 * your CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
 * `starting_time` isn't strictly required to actually be a time, but it must absolutely,
 * without a doubt, be unique to this instance. ie if you start multiple times with the same
 * `seed`, `starting_time` must be unique to each run. Thus, the easiest way to achieve this
 * is to simply use the current time (with very high precision).
 *
 * The `seed` MUST be backed up safely prior to use so that the keys can be re-created, however,
 * obviously, `starting_time` should be unique every time you reload the library - it is only
 * used to generate new ephemeral key data (which will be stored by the individual channel if
 * necessary).
 *
 * Note that the seed is required to recover certain on-chain funds independent of
 * [`ChannelMonitor`] data, though a current copy of [`ChannelMonitor`] data is also required
 * for any channel, and some on-chain during-closing funds.
 *
 * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
 */
MUST_USE_RES struct LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos);

/**
 * Derive an old [`Sign`] containing per-channel secrets based on a key derivation parameters.
 */
MUST_USE_RES struct LDKInMemorySigner KeysManager_derive_channel_keys(const struct LDKKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);

/**
 * Creates a [`Transaction`] which spends the given descriptors to the given outputs, plus an
 * output to the given change destination (if sufficient change value remains). The
 * transaction will have a feerate, at least, of the given value.
 *
 * Returns `Err(())` if the output value is greater than the input value minus required fee,
 * if a descriptor was duplicated, or if an output descriptor `script_pubkey`
 * does not match the one we can spend.
 *
 * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
 *
 * May panic if the [`SpendableOutputDescriptor`]s were not generated by channels which used
 * this [`KeysManager`] or one of the [`InMemorySigner`] created by this [`KeysManager`].
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);

/**
 * Constructs a new KeysInterface which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
 */
struct LDKKeysInterface KeysManager_as_KeysInterface(const struct LDKKeysManager *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the PhantomKeysManager, if is_owned is set and inner is non-NULL.
 */
void PhantomKeysManager_free(struct LDKPhantomKeysManager this_obj);

/**
 * Constructs a new KeysInterface which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
 */
struct LDKKeysInterface PhantomKeysManager_as_KeysInterface(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);

/**
 * Constructs a [`PhantomKeysManager`] given a 32-byte seed and an additional `cross_node_seed`
 * that is shared across all nodes that intend to participate in [phantom node payments]
 * together.
 *
 * See [`KeysManager::new`] for more information on `seed`, `starting_time_secs`, and
 * `starting_time_nanos`.
 *
 * `cross_node_seed` must be the same across all phantom payment-receiving nodes and also the
 * same across restarts, or else inbound payments may fail.
 *
 * [phantom node payments]: PhantomKeysManager
 */
MUST_USE_RES struct LDKPhantomKeysManager PhantomKeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos, const uint8_t (*cross_node_seed)[32]);

/**
 * See [`KeysManager::spend_spendable_outputs`] for documentation on this method.
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ PhantomKeysManager_spend_spendable_outputs(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);

/**
 * See [`KeysManager::derive_channel_keys`] for documentation on this method.
 */
MUST_USE_RES struct LDKInMemorySigner PhantomKeysManager_derive_channel_keys(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);

/**
 * Frees any resources used by the ChannelManager, if is_owned is set and inner is non-NULL.
 */
void ChannelManager_free(struct LDKChannelManager this_obj);

/**
 * Frees any resources used by the ChainParameters, if is_owned is set and inner is non-NULL.
 */
void ChainParameters_free(struct LDKChainParameters this_obj);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
enum LDKNetwork ChainParameters_get_network(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
void ChainParameters_set_network(struct LDKChainParameters *NONNULL_PTR this_ptr, enum LDKNetwork val);

/**
 * The hash and height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
struct LDKBestBlock ChainParameters_get_best_block(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The hash and height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
void ChainParameters_set_best_block(struct LDKChainParameters *NONNULL_PTR this_ptr, struct LDKBestBlock val);

/**
 * Constructs a new ChainParameters given each field
 */
MUST_USE_RES struct LDKChainParameters ChainParameters_new(enum LDKNetwork network_arg, struct LDKBestBlock best_block_arg);

/**
 * Creates a copy of the ChainParameters
 */
struct LDKChainParameters ChainParameters_clone(const struct LDKChainParameters *NONNULL_PTR orig);

/**
 * Frees any resources used by the CounterpartyForwardingInfo, if is_owned is set and inner is non-NULL.
 */
void CounterpartyForwardingInfo_free(struct LDKCounterpartyForwardingInfo this_obj);

/**
 * Base routing fee in millisatoshis.
 */
uint32_t CounterpartyForwardingInfo_get_fee_base_msat(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * Base routing fee in millisatoshis.
 */
void CounterpartyForwardingInfo_set_fee_base_msat(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Amount in millionths of a satoshi the channel will charge per transferred satoshi.
 */
uint32_t CounterpartyForwardingInfo_get_fee_proportional_millionths(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * Amount in millionths of a satoshi the channel will charge per transferred satoshi.
 */
void CounterpartyForwardingInfo_set_fee_proportional_millionths(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
 * such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
 * `cltv_expiry_delta` for more details.
 */
uint16_t CounterpartyForwardingInfo_get_cltv_expiry_delta(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
 * such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
 * `cltv_expiry_delta` for more details.
 */
void CounterpartyForwardingInfo_set_cltv_expiry_delta(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new CounterpartyForwardingInfo given each field
 */
MUST_USE_RES struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_new(uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, uint16_t cltv_expiry_delta_arg);

/**
 * Creates a copy of the CounterpartyForwardingInfo
 */
struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_clone(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelCounterparty, if is_owned is set and inner is non-NULL.
 */
void ChannelCounterparty_free(struct LDKChannelCounterparty this_obj);

/**
 * The node_id of our counterparty
 */
struct LDKPublicKey ChannelCounterparty_get_node_id(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The node_id of our counterparty
 */
void ChannelCounterparty_set_node_id(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
struct LDKInitFeatures ChannelCounterparty_get_features(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
void ChannelCounterparty_set_features(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * The value, in satoshis, that must always be held in the channel for our counterparty. This
 * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
 *
 * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
 */
uint64_t ChannelCounterparty_get_unspendable_punishment_reserve(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, that must always be held in the channel for our counterparty. This
 * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
 *
 * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
 */
void ChannelCounterparty_set_unspendable_punishment_reserve(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Information on the fees and requirements that the counterparty requires when forwarding
 * payments to us through this channel.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCounterpartyForwardingInfo ChannelCounterparty_get_forwarding_info(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * Information on the fees and requirements that the counterparty requires when forwarding
 * payments to us through this channel.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelCounterparty_set_forwarding_info(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCounterpartyForwardingInfo val);

/**
 * The smallest value HTLC (in msat) the remote peer will accept, for this channel. This field
 * is only `None` before we have received either the `OpenChannel` or `AcceptChannel` message
 * from the remote peer, or for `ChannelCounterparty` objects serialized prior to LDK 0.0.107.
 */
struct LDKCOption_u64Z ChannelCounterparty_get_outbound_htlc_minimum_msat(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The smallest value HTLC (in msat) the remote peer will accept, for this channel. This field
 * is only `None` before we have received either the `OpenChannel` or `AcceptChannel` message
 * from the remote peer, or for `ChannelCounterparty` objects serialized prior to LDK 0.0.107.
 */
void ChannelCounterparty_set_outbound_htlc_minimum_msat(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The largest value HTLC (in msat) the remote peer currently will accept, for this channel.
 */
struct LDKCOption_u64Z ChannelCounterparty_get_outbound_htlc_maximum_msat(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The largest value HTLC (in msat) the remote peer currently will accept, for this channel.
 */
void ChannelCounterparty_set_outbound_htlc_maximum_msat(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new ChannelCounterparty given each field
 */
MUST_USE_RES struct LDKChannelCounterparty ChannelCounterparty_new(struct LDKPublicKey node_id_arg, struct LDKInitFeatures features_arg, uint64_t unspendable_punishment_reserve_arg, struct LDKCounterpartyForwardingInfo forwarding_info_arg, struct LDKCOption_u64Z outbound_htlc_minimum_msat_arg, struct LDKCOption_u64Z outbound_htlc_maximum_msat_arg);

/**
 * Creates a copy of the ChannelCounterparty
 */
struct LDKChannelCounterparty ChannelCounterparty_clone(const struct LDKChannelCounterparty *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelDetails, if is_owned is set and inner is non-NULL.
 */
void ChannelDetails_free(struct LDKChannelDetails this_obj);

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
const uint8_t (*ChannelDetails_get_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr))[32];

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
void ChannelDetails_set_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Parameters which apply to our counterparty. See individual fields for more information.
 */
struct LDKChannelCounterparty ChannelDetails_get_counterparty(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Parameters which apply to our counterparty. See individual fields for more information.
 */
void ChannelDetails_set_counterparty(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelCounterparty val);

/**
 * The Channel's funding transaction output, if we've negotiated the funding transaction with
 * our counterparty already.
 *
 * Note that, if this has been set, `channel_id` will be equivalent to
 * `funding_txo.unwrap().to_channel_id()`.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKOutPoint ChannelDetails_get_funding_txo(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The Channel's funding transaction output, if we've negotiated the funding transaction with
 * our counterparty already.
 *
 * Note that, if this has been set, `channel_id` will be equivalent to
 * `funding_txo.unwrap().to_channel_id()`.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelDetails_set_funding_txo(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The features which this channel operates with. See individual features for more info.
 *
 * `None` until negotiation completes and the channel type is finalized.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures ChannelDetails_get_channel_type(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The features which this channel operates with. See individual features for more info.
 *
 * `None` until negotiation completes and the channel type is finalized.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelDetails_set_channel_type(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * The position of the funding transaction in the chain. None if the funding transaction has
 * not yet been confirmed and the channel fully opened.
 *
 * Note that if [`inbound_scid_alias`] is set, it must be used for invoices and inbound
 * payments instead of this. See [`get_inbound_payment_scid`].
 *
 * For channels with [`confirmations_required`] set to `Some(0)`, [`outbound_scid_alias`] may
 * be used in place of this in outbound routes. See [`get_outbound_payment_scid`].
 *
 * [`inbound_scid_alias`]: Self::inbound_scid_alias
 * [`outbound_scid_alias`]: Self::outbound_scid_alias
 * [`get_inbound_payment_scid`]: Self::get_inbound_payment_scid
 * [`get_outbound_payment_scid`]: Self::get_outbound_payment_scid
 * [`confirmations_required`]: Self::confirmations_required
 */
struct LDKCOption_u64Z ChannelDetails_get_short_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The position of the funding transaction in the chain. None if the funding transaction has
 * not yet been confirmed and the channel fully opened.
 *
 * Note that if [`inbound_scid_alias`] is set, it must be used for invoices and inbound
 * payments instead of this. See [`get_inbound_payment_scid`].
 *
 * For channels with [`confirmations_required`] set to `Some(0)`, [`outbound_scid_alias`] may
 * be used in place of this in outbound routes. See [`get_outbound_payment_scid`].
 *
 * [`inbound_scid_alias`]: Self::inbound_scid_alias
 * [`outbound_scid_alias`]: Self::outbound_scid_alias
 * [`get_inbound_payment_scid`]: Self::get_inbound_payment_scid
 * [`get_outbound_payment_scid`]: Self::get_outbound_payment_scid
 * [`confirmations_required`]: Self::confirmations_required
 */
void ChannelDetails_set_short_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by us and
 * usable in place of [`short_channel_id`] to reference the channel in outbound routes when
 * the channel has not yet been confirmed (as long as [`confirmations_required`] is
 * `Some(0)`).
 *
 * This will be `None` as long as the channel is not available for routing outbound payments.
 *
 * [`short_channel_id`]: Self::short_channel_id
 * [`confirmations_required`]: Self::confirmations_required
 */
struct LDKCOption_u64Z ChannelDetails_get_outbound_scid_alias(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by us and
 * usable in place of [`short_channel_id`] to reference the channel in outbound routes when
 * the channel has not yet been confirmed (as long as [`confirmations_required`] is
 * `Some(0)`).
 *
 * This will be `None` as long as the channel is not available for routing outbound payments.
 *
 * [`short_channel_id`]: Self::short_channel_id
 * [`confirmations_required`]: Self::confirmations_required
 */
void ChannelDetails_set_outbound_scid_alias(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by our
 * counterparty and usable in place of [`short_channel_id`] in invoice route hints. Our
 * counterparty will recognize the alias provided here in place of the [`short_channel_id`]
 * when they see a payment to be routed to us.
 *
 * Our counterparty may choose to rotate this value at any time, though will always recognize
 * previous values for inbound payment forwarding.
 *
 * [`short_channel_id`]: Self::short_channel_id
 */
struct LDKCOption_u64Z ChannelDetails_get_inbound_scid_alias(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by our
 * counterparty and usable in place of [`short_channel_id`] in invoice route hints. Our
 * counterparty will recognize the alias provided here in place of the [`short_channel_id`]
 * when they see a payment to be routed to us.
 *
 * Our counterparty may choose to rotate this value at any time, though will always recognize
 * previous values for inbound payment forwarding.
 *
 * [`short_channel_id`]: Self::short_channel_id
 */
void ChannelDetails_set_inbound_scid_alias(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
uint64_t ChannelDetails_get_channel_value_satoshis(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
void ChannelDetails_set_channel_value_satoshis(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The value, in satoshis, that must always be held in the channel for us. This value ensures
 * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
 * this value on chain.
 *
 * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
 */
struct LDKCOption_u64Z ChannelDetails_get_unspendable_punishment_reserve(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, that must always be held in the channel for us. This value ensures
 * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
 * this value on chain.
 *
 * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
 */
void ChannelDetails_set_unspendable_punishment_reserve(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The `user_channel_id` passed in to create_channel, or a random value if the channel was
 * inbound. This may be zero for inbound channels serialized with LDK versions prior to
 * 0.0.113.
 */
struct LDKU128 ChannelDetails_get_user_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The `user_channel_id` passed in to create_channel, or a random value if the channel was
 * inbound. This may be zero for inbound channels serialized with LDK versions prior to
 * 0.0.113.
 */
void ChannelDetails_set_user_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKU128 val);

/**
 * Our total balance.  This is the amount we would get if we close the channel.
 * This value is not exact. Due to various in-flight changes and feerate changes, exactly this
 * amount is not likely to be recoverable on close.
 *
 * This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
 * balance is not available for inclusion in new outbound HTLCs). This further does not include
 * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
 * This does not consider any on-chain fees.
 *
 * See also [`ChannelDetails::outbound_capacity_msat`]
 */
uint64_t ChannelDetails_get_balance_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Our total balance.  This is the amount we would get if we close the channel.
 * This value is not exact. Due to various in-flight changes and feerate changes, exactly this
 * amount is not likely to be recoverable on close.
 *
 * This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
 * balance is not available for inclusion in new outbound HTLCs). This further does not include
 * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
 * This does not consider any on-chain fees.
 *
 * See also [`ChannelDetails::outbound_capacity_msat`]
 */
void ChannelDetails_set_balance_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 *
 * See also [`ChannelDetails::balance_msat`]
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
 * should be able to spend nearly this amount.
 */
uint64_t ChannelDetails_get_outbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 *
 * See also [`ChannelDetails::balance_msat`]
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
 * should be able to spend nearly this amount.
 */
void ChannelDetails_set_outbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available outbound capacity for sending a single HTLC to the remote peer. This is
 * similar to [`ChannelDetails::outbound_capacity_msat`] but it may be further restricted by
 * the current state and per-HTLC limit(s). This is intended for use when routing, allowing us
 * to use a limit as close as possible to the HTLC limit we can currently send.
 *
 * See also [`ChannelDetails::balance_msat`] and [`ChannelDetails::outbound_capacity_msat`].
 */
uint64_t ChannelDetails_get_next_outbound_htlc_limit_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available outbound capacity for sending a single HTLC to the remote peer. This is
 * similar to [`ChannelDetails::outbound_capacity_msat`] but it may be further restricted by
 * the current state and per-HTLC limit(s). This is intended for use when routing, allowing us
 * to use a limit as close as possible to the HTLC limit we can currently send.
 *
 * See also [`ChannelDetails::balance_msat`] and [`ChannelDetails::outbound_capacity_msat`].
 */
void ChannelDetails_set_next_outbound_htlc_limit_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
 * However, our counterparty should be able to spend nearly this amount.
 */
uint64_t ChannelDetails_get_inbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
 * However, our counterparty should be able to spend nearly this amount.
 */
void ChannelDetails_set_inbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The number of required confirmations on the funding transaction before the funding will be
 * considered \"locked\". This number is selected by the channel fundee (i.e. us if
 * [`is_outbound`] is *not* set), and can be selected for inbound channels with
 * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
 * [`ChannelHandshakeLimits::max_minimum_depth`].
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`is_outbound`]: ChannelDetails::is_outbound
 * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
 * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
 */
struct LDKCOption_u32Z ChannelDetails_get_confirmations_required(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The number of required confirmations on the funding transaction before the funding will be
 * considered \"locked\". This number is selected by the channel fundee (i.e. us if
 * [`is_outbound`] is *not* set), and can be selected for inbound channels with
 * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
 * [`ChannelHandshakeLimits::max_minimum_depth`].
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`is_outbound`]: ChannelDetails::is_outbound
 * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
 * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
 */
void ChannelDetails_set_confirmations_required(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * The current number of confirmations on the funding transaction.
 *
 * This value will be `None` for objects serialized with LDK versions prior to 0.0.113.
 */
struct LDKCOption_u32Z ChannelDetails_get_confirmations(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The current number of confirmations on the funding transaction.
 *
 * This value will be `None` for objects serialized with LDK versions prior to 0.0.113.
 */
void ChannelDetails_set_confirmations(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * The number of blocks (after our commitment transaction confirms) that we will need to wait
 * until we can claim our funds after we force-close the channel. During this time our
 * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
 * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
 * time to claim our non-HTLC-encumbered funds.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 */
struct LDKCOption_u16Z ChannelDetails_get_force_close_spend_delay(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The number of blocks (after our commitment transaction confirms) that we will need to wait
 * until we can claim our funds after we force-close the channel. During this time our
 * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
 * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
 * time to claim our non-HTLC-encumbered funds.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 */
void ChannelDetails_set_force_close_spend_delay(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);

/**
 * True if the channel was initiated (and thus funded) by us.
 */
bool ChannelDetails_get_is_outbound(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel was initiated (and thus funded) by us.
 */
void ChannelDetails_set_is_outbound(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if the channel is confirmed, channel_ready messages have been exchanged, and the
 * channel is not currently being shut down. `channel_ready` message exchange implies the
 * required confirmation count has been reached (and we were connected to the peer at some
 * point after the funding transaction received enough confirmations). The required
 * confirmation count is provided in [`confirmations_required`].
 *
 * [`confirmations_required`]: ChannelDetails::confirmations_required
 */
bool ChannelDetails_get_is_channel_ready(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is confirmed, channel_ready messages have been exchanged, and the
 * channel is not currently being shut down. `channel_ready` message exchange implies the
 * required confirmation count has been reached (and we were connected to the peer at some
 * point after the funding transaction received enough confirmations). The required
 * confirmation count is provided in [`confirmations_required`].
 *
 * [`confirmations_required`]: ChannelDetails::confirmations_required
 */
void ChannelDetails_set_is_channel_ready(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if the channel is (a) confirmed and channel_ready messages have been exchanged, (b)
 * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
 *
 * This is a strict superset of `is_channel_ready`.
 */
bool ChannelDetails_get_is_usable(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is (a) confirmed and channel_ready messages have been exchanged, (b)
 * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
 *
 * This is a strict superset of `is_channel_ready`.
 */
void ChannelDetails_set_is_usable(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if this channel is (or will be) publicly-announced.
 */
bool ChannelDetails_get_is_public(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if this channel is (or will be) publicly-announced.
 */
void ChannelDetails_set_is_public(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * The smallest value HTLC (in msat) we will accept, for this channel. This field
 * is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.107
 */
struct LDKCOption_u64Z ChannelDetails_get_inbound_htlc_minimum_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The smallest value HTLC (in msat) we will accept, for this channel. This field
 * is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.107
 */
void ChannelDetails_set_inbound_htlc_minimum_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The largest value HTLC (in msat) we currently will accept, for this channel.
 */
struct LDKCOption_u64Z ChannelDetails_get_inbound_htlc_maximum_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The largest value HTLC (in msat) we currently will accept, for this channel.
 */
void ChannelDetails_set_inbound_htlc_maximum_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Set of configurable parameters that affect channel operation.
 *
 * This field is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.109.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelConfig ChannelDetails_get_config(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Set of configurable parameters that affect channel operation.
 *
 * This field is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.109.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelDetails_set_config(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelConfig val);

/**
 * Constructs a new ChannelDetails given each field
 */
MUST_USE_RES struct LDKChannelDetails ChannelDetails_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKChannelCounterparty counterparty_arg, struct LDKOutPoint funding_txo_arg, struct LDKChannelTypeFeatures channel_type_arg, struct LDKCOption_u64Z short_channel_id_arg, struct LDKCOption_u64Z outbound_scid_alias_arg, struct LDKCOption_u64Z inbound_scid_alias_arg, uint64_t channel_value_satoshis_arg, struct LDKCOption_u64Z unspendable_punishment_reserve_arg, struct LDKU128 user_channel_id_arg, uint64_t balance_msat_arg, uint64_t outbound_capacity_msat_arg, uint64_t next_outbound_htlc_limit_msat_arg, uint64_t inbound_capacity_msat_arg, struct LDKCOption_u32Z confirmations_required_arg, struct LDKCOption_u32Z confirmations_arg, struct LDKCOption_u16Z force_close_spend_delay_arg, bool is_outbound_arg, bool is_channel_ready_arg, bool is_usable_arg, bool is_public_arg, struct LDKCOption_u64Z inbound_htlc_minimum_msat_arg, struct LDKCOption_u64Z inbound_htlc_maximum_msat_arg, struct LDKChannelConfig config_arg);

/**
 * Creates a copy of the ChannelDetails
 */
struct LDKChannelDetails ChannelDetails_clone(const struct LDKChannelDetails *NONNULL_PTR orig);

/**
 * Gets the current SCID which should be used to identify this channel for inbound payments.
 * This should be used for providing invoice hints or in any other context where our
 * counterparty will forward a payment to us.
 *
 * This is either the [`ChannelDetails::inbound_scid_alias`], if set, or the
 * [`ChannelDetails::short_channel_id`]. See those for more information.
 */
MUST_USE_RES struct LDKCOption_u64Z ChannelDetails_get_inbound_payment_scid(const struct LDKChannelDetails *NONNULL_PTR this_arg);

/**
 * Gets the current SCID which should be used to identify this channel for outbound payments.
 * This should be used in [`Route`]s to describe the first hop or in other contexts where
 * we're sending or forwarding a payment outbound over this channel.
 *
 * This is either the [`ChannelDetails::short_channel_id`], if set, or the
 * [`ChannelDetails::outbound_scid_alias`]. See those for more information.
 */
MUST_USE_RES struct LDKCOption_u64Z ChannelDetails_get_outbound_payment_scid(const struct LDKChannelDetails *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the PaymentSendFailure
 */
void PaymentSendFailure_free(struct LDKPaymentSendFailure this_ptr);

/**
 * Creates a copy of the PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_clone(const struct LDKPaymentSendFailure *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ParameterError-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_parameter_error(struct LDKAPIError a);

/**
 * Utility method to constructs a new PathParameterError-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_path_parameter_error(struct LDKCVec_CResult_NoneAPIErrorZZ a);

/**
 * Utility method to constructs a new AllFailedResendSafe-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_all_failed_resend_safe(struct LDKCVec_APIErrorZ a);

/**
 * Utility method to constructs a new DuplicatePayment-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_duplicate_payment(void);

/**
 * Utility method to constructs a new PartialFailure-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_partial_failure(struct LDKCVec_CResult_NoneAPIErrorZZ results, struct LDKRouteParameters failed_paths_retry, struct LDKThirtyTwoBytes payment_id);

/**
 * Frees any resources used by the PhantomRouteHints, if is_owned is set and inner is non-NULL.
 */
void PhantomRouteHints_free(struct LDKPhantomRouteHints this_obj);

/**
 * The list of channels to be included in the invoice route hints.
 */
struct LDKCVec_ChannelDetailsZ PhantomRouteHints_get_channels(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * The list of channels to be included in the invoice route hints.
 */
void PhantomRouteHints_set_channels(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKCVec_ChannelDetailsZ val);

/**
 * A fake scid used for representing the phantom node's fake channel in generating the invoice
 * route hints.
 */
uint64_t PhantomRouteHints_get_phantom_scid(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * A fake scid used for representing the phantom node's fake channel in generating the invoice
 * route hints.
 */
void PhantomRouteHints_set_phantom_scid(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The pubkey of the real backing node that would ultimately receive the payment.
 */
struct LDKPublicKey PhantomRouteHints_get_real_node_pubkey(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * The pubkey of the real backing node that would ultimately receive the payment.
 */
void PhantomRouteHints_set_real_node_pubkey(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new PhantomRouteHints given each field
 */
MUST_USE_RES struct LDKPhantomRouteHints PhantomRouteHints_new(struct LDKCVec_ChannelDetailsZ channels_arg, uint64_t phantom_scid_arg, struct LDKPublicKey real_node_pubkey_arg);

/**
 * Creates a copy of the PhantomRouteHints
 */
struct LDKPhantomRouteHints PhantomRouteHints_clone(const struct LDKPhantomRouteHints *NONNULL_PTR orig);

/**
 * Constructs a new ChannelManager to hold several channels and route between them.
 *
 * This is the main \"logic hub\" for all channel-related actions, and implements
 * ChannelMessageHandler.
 *
 * Non-proportional fees are fixed according to our risk using the provided fee estimator.
 *
 * Users need to notify the new ChannelManager when a new block is connected or
 * disconnected using its `block_connected` and `block_disconnected` methods, starting
 * from after `params.latest_hash`.
 */
MUST_USE_RES struct LDKChannelManager ChannelManager_new(struct LDKFeeEstimator fee_est, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKKeysInterface keys_manager, struct LDKUserConfig config, struct LDKChainParameters params);

/**
 * Gets the current configuration applied to all new channels.
 */
MUST_USE_RES struct LDKUserConfig ChannelManager_get_current_default_configuration(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Creates a new outbound channel to the given remote node and with the given value.
 *
 * `user_channel_id` will be provided back as in
 * [`Event::FundingGenerationReady::user_channel_id`] to allow tracking of which events
 * correspond with which `create_channel` call. Note that the `user_channel_id` defaults to a
 * randomized value for inbound channels. `user_channel_id` has no meaning inside of LDK, it
 * is simply copied to events and otherwise ignored.
 *
 * Raises [`APIError::APIMisuseError`] when `channel_value_satoshis` > 2**24 or `push_msat` is
 * greater than `channel_value_satoshis * 1k` or `channel_value_satoshis < 1000`.
 *
 * Note that we do not check if you are currently connected to the given peer. If no
 * connection is available, the outbound `open_channel` message may fail to send, resulting in
 * the channel eventually being silently forgotten (dropped on reload).
 *
 * Returns the new Channel's temporary `channel_id`. This ID will appear as
 * [`Event::FundingGenerationReady::temporary_channel_id`] and in
 * [`ChannelDetails::channel_id`] until after
 * [`ChannelManager::funding_transaction_generated`] is called, swapping the Channel's ID for
 * one derived from the funding transaction's TXID. If the counterparty rejects the channel
 * immediately, this temporary ID will appear in [`Event::ChannelClosed::channel_id`].
 *
 * [`Event::FundingGenerationReady::user_channel_id`]: events::Event::FundingGenerationReady::user_channel_id
 * [`Event::FundingGenerationReady::temporary_channel_id`]: events::Event::FundingGenerationReady::temporary_channel_id
 * [`Event::ChannelClosed::channel_id`]: events::Event::ChannelClosed::channel_id
 *
 * Note that override_config (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult__u832APIErrorZ ChannelManager_create_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, struct LDKU128 user_channel_id, struct LDKUserConfig override_config);

/**
 * Gets the list of open channels, in random order. See ChannelDetail field documentation for
 * more information.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the list of usable channels, in random order. Useful as an argument to [`find_route`]
 * to ensure non-announced channels are used.
 *
 * These are guaranteed to have their [`ChannelDetails::is_usable`] value set to true, see the
 * documentation for [`ChannelDetails::is_usable`] for more info on exactly what the criteria
 * are.
 *
 * [`find_route`]: crate::routing::router::find_route
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
 * will be accepted on the given channel, and after additional timeout/the closing of all
 * pending HTLCs, the channel will be closed on chain.
 *
 *  * If we are the channel initiator, we will pay between our [`Background`] and
 *    [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
 *    estimate.
 *  * If our counterparty is the channel initiator, we will require a channel closing
 *    transaction feerate of at least our [`Background`] feerate or the feerate which
 *    would appear on a force-closure transaction, whichever is lower. We will allow our
 *    counterparty to pay as much fee as they'd like, however.
 *
 * May generate a SendShutdown message event on success, which should be relayed.
 *
 * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);

/**
 * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
 * will be accepted on the given channel, and after additional timeout/the closing of all
 * pending HTLCs, the channel will be closed on chain.
 *
 * `target_feerate_sat_per_1000_weight` has different meanings depending on if we initiated
 * the channel being closed or not:
 *  * If we are the channel initiator, we will pay at least this feerate on the closing
 *    transaction. The upper-bound is set by
 *    [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
 *    estimate (or `target_feerate_sat_per_1000_weight`, if it is greater).
 *  * If our counterparty is the channel initiator, we will refuse to accept a channel closure
 *    transaction feerate below `target_feerate_sat_per_1000_weight` (or the feerate which
 *    will appear on a force-closure transaction, whichever is lower).
 *
 * May generate a SendShutdown message event on success, which should be relayed.
 *
 * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel_with_target_feerate(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id, uint32_t target_feerate_sats_per_1000_weight);

/**
 * Force closes a channel, immediately broadcasting the latest local transaction(s) and
 * rejecting new HTLCs on the given channel. Fails if `channel_id` is unknown to
 * the manager, or if the `counterparty_node_id` isn't the counterparty of the corresponding
 * channel.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_broadcasting_latest_txn(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);

/**
 * Force closes a channel, rejecting new HTLCs on the given channel but skips broadcasting
 * the latest local transaction(s). Fails if `channel_id` is unknown to the manager, or if the
 * `counterparty_node_id` isn't the counterparty of the corresponding channel.
 *
 * You can always get the latest local transaction(s) to broadcast from
 * [`ChannelMonitor::get_latest_holder_commitment_txn`].
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_without_broadcasting_txn(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);

/**
 * Force close all channels, immediately broadcasting the latest local commitment transaction
 * for each to the chain and rejecting new HTLCs on each.
 */
void ChannelManager_force_close_all_channels_broadcasting_latest_txn(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Force close all channels rejecting new HTLCs on each but without broadcasting the latest
 * local transaction(s).
 */
void ChannelManager_force_close_all_channels_without_broadcasting_txn(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Sends a payment along a given route.
 *
 * Value parameters are provided via the last hop in route, see documentation for RouteHop
 * fields for more info.
 *
 * If a pending payment is currently in-flight with the same [`PaymentId`] provided, this
 * method will error with an [`APIError::InvalidRoute`]. Note, however, that once a payment
 * is no longer pending (either via [`ChannelManager::abandon_payment`], or handling of an
 * [`Event::PaymentSent`]) LDK will not stop you from sending a second payment with the same
 * [`PaymentId`].
 *
 * Thus, in order to ensure duplicate payments are not sent, you should implement your own
 * tracking of payments, including state to indicate once a payment has completed. Because you
 * should also ensure that [`PaymentHash`]es are not re-used, for simplicity, you should
 * consider using the [`PaymentHash`] as the key for tracking payments. In that case, the
 * [`PaymentId`] should be a copy of the [`PaymentHash`] bytes.
 *
 * May generate SendHTLCs message(s) event on success, which should be relayed (e.g. via
 * [`PeerManager::process_events`]).
 *
 * Each path may have a different return value, and PaymentSendValue may return a Vec with
 * each entry matching the corresponding-index entry in the route paths, see
 * PaymentSendFailure for more info.
 *
 * In general, a path may raise:
 *  * [`APIError::InvalidRoute`] when an invalid route or forwarding parameter (cltv_delta, fee,
 *    node public key) is specified.
 *  * [`APIError::ChannelUnavailable`] if the next-hop channel is not available for updates
 *    (including due to previous monitor update failure or new permanent monitor update
 *    failure).
 *  * [`APIError::MonitorUpdateInProgress`] if a new monitor update failure prevented sending the
 *    relevant updates.
 *
 * Note that depending on the type of the PaymentSendFailure the HTLC may have been
 * irrevocably committed to on our end. In such a case, do NOT retry the payment with a
 * different route unless you intend to pay twice!
 *
 * payment_secret is unrelated to payment_hash (or PaymentPreimage) and exists to authenticate
 * the sender to the recipient and prevent payment-probing (deanonymization) attacks. For
 * newer nodes, it will be provided to you in the invoice. If you do not have one, the Route
 * must not contain multiple paths as multi-path payments require a recipient-provided
 * payment_secret.
 *
 * If a payment_secret *is* provided, we assume that the invoice had the payment_secret feature
 * bit set (either as required or as available). If multiple paths are present in the Route,
 * we assume the invoice had the basic_mpp feature set.
 *
 * [`Event::PaymentSent`]: events::Event::PaymentSent
 * [`PeerManager::process_events`]: crate::ln::peer_handler::PeerManager::process_events
 *
 * Note that payment_secret (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_send_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret, struct LDKThirtyTwoBytes payment_id);

/**
 * Retries a payment along the given [`Route`].
 *
 * Errors returned are a superset of those returned from [`send_payment`], so see
 * [`send_payment`] documentation for more details on errors. This method will also error if the
 * retry amount puts the payment more than 10% over the payment's total amount, if the payment
 * for the given `payment_id` cannot be found (likely due to timeout or success), or if
 * further retries have been disabled with [`abandon_payment`].
 *
 * [`send_payment`]: [`ChannelManager::send_payment`]
 * [`abandon_payment`]: [`ChannelManager::abandon_payment`]
 */
MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_retry_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_id);

/**
 * Signals that no further retries for the given payment will occur.
 *
 * After this method returns, no future calls to [`retry_payment`] for the given `payment_id`
 * are allowed. If no [`Event::PaymentFailed`] event had been generated before, one will be
 * generated as soon as there are no remaining pending HTLCs for this payment.
 *
 * Note that calling this method does *not* prevent a payment from succeeding. You must still
 * wait until you receive either a [`Event::PaymentFailed`] or [`Event::PaymentSent`] event to
 * determine the ultimate status of a payment.
 *
 * If an [`Event::PaymentFailed`] event is generated and we restart without this
 * [`ChannelManager`] having been persisted, the payment may still be in the pending state
 * upon restart. This allows further calls to [`retry_payment`] (and requiring a second call
 * to [`abandon_payment`] to mark the payment as failed again). Otherwise, future calls to
 * [`retry_payment`] will fail with [`PaymentSendFailure::ParameterError`].
 *
 * [`abandon_payment`]: Self::abandon_payment
 * [`retry_payment`]: Self::retry_payment
 * [`Event::PaymentFailed`]: events::Event::PaymentFailed
 * [`Event::PaymentSent`]: events::Event::PaymentSent
 */
void ChannelManager_abandon_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_id);

/**
 * Send a spontaneous payment, which is a payment that does not require the recipient to have
 * generated an invoice. Optionally, you may specify the preimage. If you do choose to specify
 * the preimage, it must be a cryptographically secure random value that no intermediate node
 * would be able to guess -- otherwise, an intermediate node may claim the payment and it will
 * never reach the recipient.
 *
 * See [`send_payment`] documentation for more details on the return value of this function
 * and idempotency guarantees provided by the [`PaymentId`] key.
 *
 * Similar to regular payments, you MUST NOT reuse a `payment_preimage` value. See
 * [`send_payment`] for more information about the risks of duplicate preimage usage.
 *
 * Note that `route` must have exactly one path.
 *
 * [`send_payment`]: Self::send_payment
 *
 * Note that payment_preimage (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult_PaymentHashPaymentSendFailureZ ChannelManager_send_spontaneous_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_id);

/**
 * Send a payment that is probing the given route for liquidity. We calculate the
 * [`PaymentHash`] of probes based on a static secret and a random [`PaymentId`], which allows
 * us to easily discern them from real payments.
 */
MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ ChannelManager_send_probe(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCVec_RouteHopZ hops);

/**
 * Call this upon creation of a funding transaction for the given channel.
 *
 * Returns an [`APIError::APIMisuseError`] if the funding_transaction spent non-SegWit outputs
 * or if no output was found which matches the parameters in [`Event::FundingGenerationReady`].
 *
 * Returns [`APIError::APIMisuseError`] if the funding transaction is not final for propagation
 * across the p2p network.
 *
 * Returns [`APIError::ChannelUnavailable`] if a funding transaction has already been provided
 * for the channel or if the channel has been closed as indicated by [`Event::ChannelClosed`].
 *
 * May panic if the output found in the funding transaction is duplicative with some other
 * channel (note that this should be trivially prevented by using unique funding transaction
 * keys per-channel).
 *
 * Do NOT broadcast the funding transaction yourself. When we have safely received our
 * counterparty's signature the funding transaction will automatically be broadcast via the
 * [`BroadcasterInterface`] provided when this `ChannelManager` was constructed.
 *
 * Note that this includes RBF or similar transaction replacement strategies - lightning does
 * not currently support replacing a funding transaction on an existing channel. Instead,
 * create a new channel with a conflicting funding transaction.
 *
 * Note to keep the miner incentives aligned in moving the blockchain forward, we recommend
 * the wallet software generating the funding transaction to apply anti-fee sniping as
 * implemented by Bitcoin Core wallet. See <https://bitcoinops.org/en/topics/fee-sniping/>
 * for more details.
 *
 * [`Event::FundingGenerationReady`]: crate::util::events::Event::FundingGenerationReady
 * [`Event::ChannelClosed`]: crate::util::events::Event::ChannelClosed
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKTransaction funding_transaction);

/**
 * Atomically updates the [`ChannelConfig`] for the given channels.
 *
 * Once the updates are applied, each eligible channel (advertised with a known short channel
 * ID and a change in [`forwarding_fee_proportional_millionths`], [`forwarding_fee_base_msat`],
 * or [`cltv_expiry_delta`]) has a [`BroadcastChannelUpdate`] event message generated
 * containing the new [`ChannelUpdate`] message which should be broadcast to the network.
 *
 * Returns [`ChannelUnavailable`] when a channel is not found or an incorrect
 * `counterparty_node_id` is provided.
 *
 * Returns [`APIMisuseError`] when a [`cltv_expiry_delta`] update is to be applied with a value
 * below [`MIN_CLTV_EXPIRY_DELTA`].
 *
 * If an error is returned, none of the updates should be considered applied.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 * [`forwarding_fee_base_msat`]: ChannelConfig::forwarding_fee_base_msat
 * [`cltv_expiry_delta`]: ChannelConfig::cltv_expiry_delta
 * [`BroadcastChannelUpdate`]: events::MessageSendEvent::BroadcastChannelUpdate
 * [`ChannelUpdate`]: msgs::ChannelUpdate
 * [`ChannelUnavailable`]: APIError::ChannelUnavailable
 * [`APIMisuseError`]: APIError::APIMisuseError
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_update_channel_config(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey counterparty_node_id, struct LDKCVec_ThirtyTwoBytesZ channel_ids, const struct LDKChannelConfig *NONNULL_PTR config);

/**
 * Attempts to forward an intercepted HTLC over the provided channel id and with the provided
 * amount to forward. Should only be called in response to an [`HTLCIntercepted`] event.
 *
 * Intercepted HTLCs can be useful for Lightning Service Providers (LSPs) to open a just-in-time
 * channel to a receiving node if the node lacks sufficient inbound liquidity.
 *
 * To make use of intercepted HTLCs, set [`UserConfig::accept_intercept_htlcs`] and use
 * [`ChannelManager::get_intercept_scid`] to generate short channel id(s) to put in the
 * receiver's invoice route hints. These route hints will signal to LDK to generate an
 * [`HTLCIntercepted`] event when it receives the forwarded HTLC, and this method or
 * [`ChannelManager::fail_intercepted_htlc`] MUST be called in response to the event.
 *
 * Note that LDK does not enforce fee requirements in `amt_to_forward_msat`, and will not stop
 * you from forwarding more than you received.
 *
 * Errors if the event was not handled in time, in which case the HTLC was automatically failed
 * backwards.
 *
 * [`UserConfig::accept_intercept_htlcs`]: crate::util::config::UserConfig::accept_intercept_htlcs
 * [`HTLCIntercepted`]: events::Event::HTLCIntercepted
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_forward_intercepted_htlc(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes intercept_id, const uint8_t (*next_hop_channel_id)[32], struct LDKPublicKey _next_node_id, uint64_t amt_to_forward_msat);

/**
 * Fails the intercepted HTLC indicated by intercept_id. Should only be called in response to
 * an [`HTLCIntercepted`] event. See [`ChannelManager::forward_intercepted_htlc`].
 *
 * Errors if the event was not handled in time, in which case the HTLC was automatically failed
 * backwards.
 *
 * [`HTLCIntercepted`]: events::Event::HTLCIntercepted
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_fail_intercepted_htlc(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes intercept_id);

/**
 * Processes HTLCs which are pending waiting on random forward delay.
 *
 * Should only really ever be called in response to a PendingHTLCsForwardable event.
 * Will likely generate further events.
 */
void ChannelManager_process_pending_htlc_forwards(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Performs actions which should happen on startup and roughly once per minute thereafter.
 *
 * This currently includes:
 *  * Increasing or decreasing the on-chain feerate estimates for our outbound channels,
 *  * Broadcasting `ChannelUpdate` messages if we've been disconnected from our peer for more
 *    than a minute, informing the network that they should no longer attempt to route over
 *    the channel.
 *  * Expiring a channel's previous `ChannelConfig` if necessary to only allow forwarding HTLCs
 *    with the current `ChannelConfig`.
 *
 * Note that this may cause reentrancy through `chain::Watch::update_channel` calls or feerate
 * estimate fetches.
 */
void ChannelManager_timer_tick_occurred(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Indicates that the preimage for payment_hash is unknown or the received amount is incorrect
 * after a PaymentClaimable event, failing the HTLC back to its origin and freeing resources
 * along the path (including in our own channel on which we received it).
 *
 * Note that in some cases around unclean shutdown, it is possible the payment may have
 * already been claimed by you via [`ChannelManager::claim_funds`] prior to you seeing (a
 * second copy of) the [`events::Event::PaymentClaimable`] event. Alternatively, the payment
 * may have already been failed automatically by LDK if it was nearing its expiration time.
 *
 * While LDK will never claim a payment automatically on your behalf (i.e. without you calling
 * [`ChannelManager::claim_funds`]), you should still monitor for
 * [`events::Event::PaymentClaimed`] events even for payments you intend to fail, especially on
 * startup during which time claims that were in-progress at shutdown may be replayed.
 */
void ChannelManager_fail_htlc_backwards(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);

/**
 * Provides a payment preimage in response to [`Event::PaymentClaimable`], generating any
 * [`MessageSendEvent`]s needed to claim the payment.
 *
 * Note that calling this method does *not* guarantee that the payment has been claimed. You
 * *must* wait for an [`Event::PaymentClaimed`] event which upon a successful claim will be
 * provided to your [`EventHandler`] when [`process_pending_events`] is next called.
 *
 * Note that if you did not set an `amount_msat` when calling [`create_inbound_payment`] or
 * [`create_inbound_payment_for_hash`] you must check that the amount in the `PaymentClaimable`
 * event matches your expectation. If you fail to do so and call this method, you may provide
 * the sender \"proof-of-payment\" when they did not fulfill the full expected payment.
 *
 * [`Event::PaymentClaimable`]: crate::util::events::Event::PaymentClaimable
 * [`Event::PaymentClaimed`]: crate::util::events::Event::PaymentClaimed
 * [`process_pending_events`]: EventsProvider::process_pending_events
 * [`create_inbound_payment`]: Self::create_inbound_payment
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 */
void ChannelManager_claim_funds(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage);

/**
 * Gets the node_id held by this ChannelManager
 */
MUST_USE_RES struct LDKPublicKey ChannelManager_get_our_node_id(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Accepts a request to open a channel after a [`Event::OpenChannelRequest`].
 *
 * The `temporary_channel_id` parameter indicates which inbound channel should be accepted,
 * and the `counterparty_node_id` parameter is the id of the peer which has requested to open
 * the channel.
 *
 * The `user_channel_id` parameter will be provided back in
 * [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
 * with which `accept_inbound_channel`/`accept_inbound_channel_from_trusted_peer_0conf` call.
 *
 * Note that this method will return an error and reject the channel, if it requires support
 * for zero confirmations. Instead, `accept_inbound_channel_from_trusted_peer_0conf` must be
 * used to accept such channels.
 *
 * [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
 * [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKU128 user_channel_id);

/**
 * Accepts a request to open a channel after a [`events::Event::OpenChannelRequest`], treating
 * it as confirmed immediately.
 *
 * The `user_channel_id` parameter will be provided back in
 * [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
 * with which `accept_inbound_channel`/`accept_inbound_channel_from_trusted_peer_0conf` call.
 *
 * Unlike [`ChannelManager::accept_inbound_channel`], this method accepts the incoming channel
 * and (if the counterparty agrees), enables forwarding of payments immediately.
 *
 * This fully trusts that the counterparty has honestly and correctly constructed the funding
 * transaction and blindly assumes that it will eventually confirm.
 *
 * If it does not confirm before we decide to close the channel, or if the funding transaction
 * does not pay to the correct script the correct amount, *you will lose funds*.
 *
 * [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
 * [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel_from_trusted_peer_0conf(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKU128 user_channel_id);

/**
 * Gets a payment secret and payment hash for use in an invoice given to a third party wishing
 * to pay us.
 *
 * This differs from [`create_inbound_payment_for_hash`] only in that it generates the
 * [`PaymentHash`] and [`PaymentPreimage`] for you.
 *
 * The [`PaymentPreimage`] will ultimately be returned to you in the [`PaymentClaimable`], which
 * will have the [`PaymentClaimable::payment_preimage`] field filled in. That should then be
 * passed directly to [`claim_funds`].
 *
 * See [`create_inbound_payment_for_hash`] for detailed documentation on behavior and requirements.
 *
 * Note that a malicious eavesdropper can intuit whether an inbound payment was created by
 * `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
 *
 * # Note
 *
 * If you register an inbound payment with this method, then serialize the `ChannelManager`, then
 * deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
 *
 * Errors if `min_value_msat` is greater than total bitcoin supply.
 *
 * [`claim_funds`]: Self::claim_funds
 * [`PaymentClaimable`]: events::Event::PaymentClaimable
 * [`PaymentClaimable::payment_preimage`]: events::Event::PaymentClaimable::payment_preimage
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 */
MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ ChannelManager_create_inbound_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);

/**
 * Legacy version of [`create_inbound_payment`]. Use this method if you wish to share
 * serialized state with LDK node(s) running 0.0.103 and earlier.
 *
 * May panic if `invoice_expiry_delta_secs` is greater than one year.
 *
 * # Note
 * This method is deprecated and will be removed soon.
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 */
MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ ChannelManager_create_inbound_payment_legacy(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);

/**
 * Gets a [`PaymentSecret`] for a given [`PaymentHash`], for which the payment preimage is
 * stored external to LDK.
 *
 * A [`PaymentClaimable`] event will only be generated if the [`PaymentSecret`] matches a
 * payment secret fetched via this method or [`create_inbound_payment`], and which is at least
 * the `min_value_msat` provided here, if one is provided.
 *
 * The [`PaymentHash`] (and corresponding [`PaymentPreimage`]) should be globally unique, though
 * note that LDK will not stop you from registering duplicate payment hashes for inbound
 * payments.
 *
 * `min_value_msat` should be set if the invoice being generated contains a value. Any payment
 * received for the returned [`PaymentHash`] will be required to be at least `min_value_msat`
 * before a [`PaymentClaimable`] event will be generated, ensuring that we do not provide the
 * sender \"proof-of-payment\" unless they have paid the required amount.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time. This should roughly match the expiry time set in the invoice.
 * After this many seconds, we will remove the inbound payment, resulting in any attempts to
 * pay the invoice failing. The BOLT spec suggests 3,600 secs as a default validity time for
 * invoices when no timeout is set.
 *
 * Note that we use block header time to time-out pending inbound payments (with some margin
 * to compensate for the inaccuracy of block header timestamps). Thus, in practice we will
 * accept a payment and generate a [`PaymentClaimable`] event for some time after the expiry.
 * If you need exact expiry semantics, you should enforce them upon receipt of
 * [`PaymentClaimable`].
 *
 * Note that invoices generated for inbound payments should have their `min_final_cltv_expiry`
 * set to at least [`MIN_FINAL_CLTV_EXPIRY`].
 *
 * Note that a malicious eavesdropper can intuit whether an inbound payment was created by
 * `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
 *
 * # Note
 *
 * If you register an inbound payment with this method, then serialize the `ChannelManager`, then
 * deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
 *
 * Errors if `min_value_msat` is greater than total bitcoin supply.
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 * [`PaymentClaimable`]: events::Event::PaymentClaimable
 */
MUST_USE_RES struct LDKCResult_PaymentSecretNoneZ ChannelManager_create_inbound_payment_for_hash(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);

/**
 * Legacy version of [`create_inbound_payment_for_hash`]. Use this method if you wish to share
 * serialized state with LDK node(s) running 0.0.103 and earlier.
 *
 * May panic if `invoice_expiry_delta_secs` is greater than one year.
 *
 * # Note
 * This method is deprecated and will be removed soon.
 *
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 */
MUST_USE_RES struct LDKCResult_PaymentSecretAPIErrorZ ChannelManager_create_inbound_payment_for_hash_legacy(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);

/**
 * Gets an LDK-generated payment preimage from a payment hash and payment secret that were
 * previously returned from [`create_inbound_payment`].
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 */
MUST_USE_RES struct LDKCResult_PaymentPreimageAPIErrorZ ChannelManager_get_payment_preimage(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);

/**
 * Gets a fake short channel id for use in receiving [phantom node payments]. These fake scids
 * are used when constructing the phantom invoice's route hints.
 *
 * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
 */
MUST_USE_RES uint64_t ChannelManager_get_phantom_scid(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets route hints for use in receiving [phantom node payments].
 *
 * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
 */
MUST_USE_RES struct LDKPhantomRouteHints ChannelManager_get_phantom_route_hints(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets a fake short channel id for use in receiving intercepted payments. These fake scids are
 * used when constructing the route hints for HTLCs intended to be intercepted. See
 * [`ChannelManager::forward_intercepted_htlc`].
 *
 * Note that this method is not guaranteed to return unique values, you may need to call it a few
 * times to get a unique scid.
 */
MUST_USE_RES uint64_t ChannelManager_get_intercept_scid(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets inflight HTLC information by processing pending outbound payments that are in
 * our channels. May be used during pathfinding to account for in-use channel liquidity.
 */
MUST_USE_RES struct LDKInFlightHtlcs ChannelManager_compute_inflight_htlcs(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChannelManager_as_EventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChannelManager_as_Listen(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Confirm which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
 */
struct LDKConfirm ChannelManager_as_Confirm(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Blocks until ChannelManager needs to be persisted or a timeout is reached. It returns a bool
 * indicating whether persistence is necessary. Only one listener on
 * [`await_persistable_update`], [`await_persistable_update_timeout`], or a future returned by
 * [`get_persistable_update_future`] is guaranteed to be woken up.
 *
 * Note that this method is not available with the `no-std` feature.
 *
 * [`await_persistable_update`]: Self::await_persistable_update
 * [`await_persistable_update_timeout`]: Self::await_persistable_update_timeout
 * [`get_persistable_update_future`]: Self::get_persistable_update_future
 */
MUST_USE_RES bool ChannelManager_await_persistable_update_timeout(const struct LDKChannelManager *NONNULL_PTR this_arg, uint64_t max_wait);

/**
 * Blocks until ChannelManager needs to be persisted. Only one listener on
 * [`await_persistable_update`], `await_persistable_update_timeout`, or a future returned by
 * [`get_persistable_update_future`] is guaranteed to be woken up.
 *
 * [`await_persistable_update`]: Self::await_persistable_update
 * [`get_persistable_update_future`]: Self::get_persistable_update_future
 */
void ChannelManager_await_persistable_update(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets a [`Future`] that completes when a persistable update is available. Note that
 * callbacks registered on the [`Future`] MUST NOT call back into this [`ChannelManager`] and
 * should instead register actions to be taken later.
 */
MUST_USE_RES struct LDKFuture ChannelManager_get_persistable_update_future(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the latest best block which was connected either via the [`chain::Listen`] or
 * [`chain::Confirm`] interfaces.
 */
MUST_USE_RES struct LDKBestBlock ChannelManager_current_best_block(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Fetches the set of [`NodeFeatures`] flags which are provided by or required by
 * [`ChannelManager`].
 */
struct LDKNodeFeatures provided_node_features(void);

/**
 * Fetches the set of [`ChannelFeatures`] flags which are provided by or required by
 * [`ChannelManager`].
 */
struct LDKChannelFeatures provided_channel_features(void);

/**
 * Fetches the set of [`InitFeatures`] flags which are provided by or required by
 * [`ChannelManager`].
 */
struct LDKInitFeatures provided_init_features(void);

/**
 * Serialize the CounterpartyForwardingInfo object into a byte array which can be read by CounterpartyForwardingInfo_read
 */
struct LDKCVec_u8Z CounterpartyForwardingInfo_write(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR obj);

/**
 * Read a CounterpartyForwardingInfo from a byte array, created by CounterpartyForwardingInfo_write
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CounterpartyForwardingInfo_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelCounterparty object into a byte array which can be read by ChannelCounterparty_read
 */
struct LDKCVec_u8Z ChannelCounterparty_write(const struct LDKChannelCounterparty *NONNULL_PTR obj);

/**
 * Read a ChannelCounterparty from a byte array, created by ChannelCounterparty_write
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ ChannelCounterparty_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelDetails object into a byte array which can be read by ChannelDetails_read
 */
struct LDKCVec_u8Z ChannelDetails_write(const struct LDKChannelDetails *NONNULL_PTR obj);

/**
 * Read a ChannelDetails from a byte array, created by ChannelDetails_write
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ ChannelDetails_read(struct LDKu8slice ser);

/**
 * Serialize the PhantomRouteHints object into a byte array which can be read by PhantomRouteHints_read
 */
struct LDKCVec_u8Z PhantomRouteHints_write(const struct LDKPhantomRouteHints *NONNULL_PTR obj);

/**
 * Read a PhantomRouteHints from a byte array, created by PhantomRouteHints_write
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ PhantomRouteHints_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelManager object into a byte array which can be read by ChannelManager_read
 */
struct LDKCVec_u8Z ChannelManager_write(const struct LDKChannelManager *NONNULL_PTR obj);

/**
 * Frees any resources used by the ChannelManagerReadArgs, if is_owned is set and inner is non-NULL.
 */
void ChannelManagerReadArgs_free(struct LDKChannelManagerReadArgs this_obj);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
const struct LDKKeysInterface *ChannelManagerReadArgs_get_keys_manager(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
void ChannelManagerReadArgs_set_keys_manager(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKKeysInterface val);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
const struct LDKFeeEstimator *ChannelManagerReadArgs_get_fee_estimator(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
void ChannelManagerReadArgs_set_fee_estimator(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKFeeEstimator val);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
const struct LDKWatch *ChannelManagerReadArgs_get_chain_monitor(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
void ChannelManagerReadArgs_set_chain_monitor(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKWatch val);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
const struct LDKBroadcasterInterface *ChannelManagerReadArgs_get_tx_broadcaster(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
void ChannelManagerReadArgs_set_tx_broadcaster(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKBroadcasterInterface val);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
const struct LDKLogger *ChannelManagerReadArgs_get_logger(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
void ChannelManagerReadArgs_set_logger(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKLogger val);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
struct LDKUserConfig ChannelManagerReadArgs_get_default_config(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
void ChannelManagerReadArgs_set_default_config(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKUserConfig val);

/**
 * Simple utility function to create a ChannelManagerReadArgs which creates the monitor
 * HashMap for you. This is primarily useful for C bindings where it is not practical to
 * populate a HashMap directly from C.
 */
MUST_USE_RES struct LDKChannelManagerReadArgs ChannelManagerReadArgs_new(struct LDKKeysInterface keys_manager, struct LDKFeeEstimator fee_estimator, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKUserConfig default_config, struct LDKCVec_ChannelMonitorZ channel_monitors);

/**
 * Read a C2Tuple_BlockHashChannelManagerZ from a byte array, created by C2Tuple_BlockHashChannelManagerZ_write
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ C2Tuple_BlockHashChannelManagerZ_read(struct LDKu8slice ser, struct LDKChannelManagerReadArgs arg);

/**
 * Frees any resources used by the ExpandedKey, if is_owned is set and inner is non-NULL.
 */
void ExpandedKey_free(struct LDKExpandedKey this_obj);

/**
 * Create a  new [`ExpandedKey`] for generating an inbound payment hash and secret.
 *
 * It is recommended to cache this value and not regenerate it for each new inbound payment.
 */
MUST_USE_RES struct LDKExpandedKey ExpandedKey_new(const uint8_t (*key_material)[32]);

/**
 * Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment`], but no
 * `ChannelManager` is required. Useful for generating invoices for [phantom node payments] without
 * a `ChannelManager`.
 *
 * `keys` is generated by calling [`KeysInterface::get_inbound_payment_key_material`] and then
 * calling [`ExpandedKey::new`] with its result. It is recommended to cache this value and not
 * regenerate it for each new inbound payment.
 *
 * `current_time` is a Unix timestamp representing the current time.
 *
 * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ create(const struct LDKExpandedKey *NONNULL_PTR keys, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, const struct LDKKeysInterface *NONNULL_PTR keys_manager, uint64_t current_time);

/**
 * Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash`],
 * but no `ChannelManager` is required. Useful for generating invoices for [phantom node payments]
 * without a `ChannelManager`.
 *
 * See [`create`] for information on the `keys` and `current_time` parameters.
 *
 * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
 */
struct LDKCResult_PaymentSecretNoneZ create_from_hash(const struct LDKExpandedKey *NONNULL_PTR keys, struct LDKCOption_u64Z min_value_msat, struct LDKThirtyTwoBytes payment_hash, uint32_t invoice_expiry_delta_secs, uint64_t current_time);

/**
 * Frees any resources used by the DecodeError
 */
void DecodeError_free(struct LDKDecodeError this_ptr);

/**
 * Creates a copy of the DecodeError
 */
struct LDKDecodeError DecodeError_clone(const struct LDKDecodeError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new UnknownVersion-variant DecodeError
 */
struct LDKDecodeError DecodeError_unknown_version(void);

/**
 * Utility method to constructs a new UnknownRequiredFeature-variant DecodeError
 */
struct LDKDecodeError DecodeError_unknown_required_feature(void);

/**
 * Utility method to constructs a new InvalidValue-variant DecodeError
 */
struct LDKDecodeError DecodeError_invalid_value(void);

/**
 * Utility method to constructs a new ShortRead-variant DecodeError
 */
struct LDKDecodeError DecodeError_short_read(void);

/**
 * Utility method to constructs a new BadLengthDescriptor-variant DecodeError
 */
struct LDKDecodeError DecodeError_bad_length_descriptor(void);

/**
 * Utility method to constructs a new Io-variant DecodeError
 */
struct LDKDecodeError DecodeError_io(enum LDKIOError a);

/**
 * Utility method to constructs a new UnsupportedCompression-variant DecodeError
 */
struct LDKDecodeError DecodeError_unsupported_compression(void);

/**
 * Checks if two DecodeErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool DecodeError_eq(const struct LDKDecodeError *NONNULL_PTR a, const struct LDKDecodeError *NONNULL_PTR b);

/**
 * Frees any resources used by the Init, if is_owned is set and inner is non-NULL.
 */
void Init_free(struct LDKInit this_obj);

/**
 * The relevant features which the sender supports
 */
struct LDKInitFeatures Init_get_features(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * The relevant features which the sender supports
 */
void Init_set_features(struct LDKInit *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * The receipient's network address. This adds the option to report a remote IP address
 * back to a connecting peer using the init message. A node can decide to use that information
 * to discover a potential update to its public IPv4 address (NAT) and use
 * that for a node_announcement update message containing the new address.
 */
struct LDKCOption_NetAddressZ Init_get_remote_network_address(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * The receipient's network address. This adds the option to report a remote IP address
 * back to a connecting peer using the init message. A node can decide to use that information
 * to discover a potential update to its public IPv4 address (NAT) and use
 * that for a node_announcement update message containing the new address.
 */
void Init_set_remote_network_address(struct LDKInit *NONNULL_PTR this_ptr, struct LDKCOption_NetAddressZ val);

/**
 * Constructs a new Init given each field
 */
MUST_USE_RES struct LDKInit Init_new(struct LDKInitFeatures features_arg, struct LDKCOption_NetAddressZ remote_network_address_arg);

/**
 * Creates a copy of the Init
 */
struct LDKInit Init_clone(const struct LDKInit *NONNULL_PTR orig);

/**
 * Checks if two Inits contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Init_eq(const struct LDKInit *NONNULL_PTR a, const struct LDKInit *NONNULL_PTR b);

/**
 * Frees any resources used by the ErrorMessage, if is_owned is set and inner is non-NULL.
 */
void ErrorMessage_free(struct LDKErrorMessage this_obj);

/**
 * The channel ID involved in the error.
 *
 * All-0s indicates a general error unrelated to a specific channel, after which all channels
 * with the sending peer should be closed.
 */
const uint8_t (*ErrorMessage_get_channel_id(const struct LDKErrorMessage *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID involved in the error.
 *
 * All-0s indicates a general error unrelated to a specific channel, after which all channels
 * with the sending peer should be closed.
 */
void ErrorMessage_set_channel_id(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A possibly human-readable error description.
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
struct LDKStr ErrorMessage_get_data(const struct LDKErrorMessage *NONNULL_PTR this_ptr);

/**
 * A possibly human-readable error description.
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
void ErrorMessage_set_data(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new ErrorMessage given each field
 */
MUST_USE_RES struct LDKErrorMessage ErrorMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);

/**
 * Creates a copy of the ErrorMessage
 */
struct LDKErrorMessage ErrorMessage_clone(const struct LDKErrorMessage *NONNULL_PTR orig);

/**
 * Checks if two ErrorMessages contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ErrorMessage_eq(const struct LDKErrorMessage *NONNULL_PTR a, const struct LDKErrorMessage *NONNULL_PTR b);

/**
 * Frees any resources used by the WarningMessage, if is_owned is set and inner is non-NULL.
 */
void WarningMessage_free(struct LDKWarningMessage this_obj);

/**
 * The channel ID involved in the warning.
 *
 * All-0s indicates a warning unrelated to a specific channel.
 */
const uint8_t (*WarningMessage_get_channel_id(const struct LDKWarningMessage *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID involved in the warning.
 *
 * All-0s indicates a warning unrelated to a specific channel.
 */
void WarningMessage_set_channel_id(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A possibly human-readable warning description.
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
struct LDKStr WarningMessage_get_data(const struct LDKWarningMessage *NONNULL_PTR this_ptr);

/**
 * A possibly human-readable warning description.
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
void WarningMessage_set_data(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new WarningMessage given each field
 */
MUST_USE_RES struct LDKWarningMessage WarningMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);

/**
 * Creates a copy of the WarningMessage
 */
struct LDKWarningMessage WarningMessage_clone(const struct LDKWarningMessage *NONNULL_PTR orig);

/**
 * Checks if two WarningMessages contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool WarningMessage_eq(const struct LDKWarningMessage *NONNULL_PTR a, const struct LDKWarningMessage *NONNULL_PTR b);

/**
 * Frees any resources used by the Ping, if is_owned is set and inner is non-NULL.
 */
void Ping_free(struct LDKPing this_obj);

/**
 * The desired response length
 */
uint16_t Ping_get_ponglen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The desired response length
 */
void Ping_set_ponglen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The ping packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Ping_get_byteslen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The ping packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Ping_set_byteslen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Ping given each field
 */
MUST_USE_RES struct LDKPing Ping_new(uint16_t ponglen_arg, uint16_t byteslen_arg);

/**
 * Creates a copy of the Ping
 */
struct LDKPing Ping_clone(const struct LDKPing *NONNULL_PTR orig);

/**
 * Checks if two Pings contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Ping_eq(const struct LDKPing *NONNULL_PTR a, const struct LDKPing *NONNULL_PTR b);

/**
 * Frees any resources used by the Pong, if is_owned is set and inner is non-NULL.
 */
void Pong_free(struct LDKPong this_obj);

/**
 * The pong packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Pong_get_byteslen(const struct LDKPong *NONNULL_PTR this_ptr);

/**
 * The pong packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Pong_set_byteslen(struct LDKPong *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Pong given each field
 */
MUST_USE_RES struct LDKPong Pong_new(uint16_t byteslen_arg);

/**
 * Creates a copy of the Pong
 */
struct LDKPong Pong_clone(const struct LDKPong *NONNULL_PTR orig);

/**
 * Checks if two Pongs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Pong_eq(const struct LDKPong *NONNULL_PTR a, const struct LDKPong *NONNULL_PTR b);

/**
 * Frees any resources used by the OpenChannel, if is_owned is set and inner is non-NULL.
 */
void OpenChannel_free(struct LDKOpenChannel this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*OpenChannel_get_chain_hash(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void OpenChannel_set_chain_hash(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*OpenChannel_get_temporary_channel_id(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void OpenChannel_set_temporary_channel_id(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The channel value
 */
uint64_t OpenChannel_get_funding_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel value
 */
void OpenChannel_set_funding_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
uint64_t OpenChannel_get_push_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
void OpenChannel_set_push_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t OpenChannel_get_dust_limit_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void OpenChannel_set_dust_limit_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t OpenChannel_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void OpenChannel_set_max_htlc_value_in_flight_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t OpenChannel_get_channel_reserve_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void OpenChannel_set_channel_reserve_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t OpenChannel_get_htlc_minimum_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void OpenChannel_set_htlc_minimum_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
 */
uint32_t OpenChannel_get_feerate_per_kw(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
 */
void OpenChannel_set_feerate_per_kw(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t OpenChannel_get_to_self_delay(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void OpenChannel_set_to_self_delay(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t OpenChannel_get_max_accepted_htlcs(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void OpenChannel_set_max_accepted_htlcs(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey OpenChannel_get_funding_pubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void OpenChannel_set_funding_pubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_revocation_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void OpenChannel_set_revocation_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_payment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void OpenChannel_set_payment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey OpenChannel_get_delayed_payment_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void OpenChannel_set_delayed_payment_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender
 */
struct LDKPublicKey OpenChannel_get_htlc_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender
 */
void OpenChannel_set_htlc_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey OpenChannel_get_first_per_commitment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void OpenChannel_set_first_per_commitment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Channel flags
 */
uint8_t OpenChannel_get_channel_flags(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void OpenChannel_set_channel_flags(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint8_t val);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures OpenChannel_get_channel_type(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void OpenChannel_set_channel_type(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Creates a copy of the OpenChannel
 */
struct LDKOpenChannel OpenChannel_clone(const struct LDKOpenChannel *NONNULL_PTR orig);

/**
 * Checks if two OpenChannels contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OpenChannel_eq(const struct LDKOpenChannel *NONNULL_PTR a, const struct LDKOpenChannel *NONNULL_PTR b);

/**
 * Frees any resources used by the AcceptChannel, if is_owned is set and inner is non-NULL.
 */
void AcceptChannel_free(struct LDKAcceptChannel this_obj);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*AcceptChannel_get_temporary_channel_id(const struct LDKAcceptChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void AcceptChannel_set_temporary_channel_id(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t AcceptChannel_get_dust_limit_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void AcceptChannel_set_dust_limit_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void AcceptChannel_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t AcceptChannel_get_channel_reserve_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void AcceptChannel_set_channel_reserve_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_htlc_minimum_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void AcceptChannel_set_htlc_minimum_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
uint32_t AcceptChannel_get_minimum_depth(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
void AcceptChannel_set_minimum_depth(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t AcceptChannel_get_to_self_delay(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void AcceptChannel_set_to_self_delay(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t AcceptChannel_get_max_accepted_htlcs(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void AcceptChannel_set_max_accepted_htlcs(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey AcceptChannel_get_funding_pubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void AcceptChannel_set_funding_pubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_revocation_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void AcceptChannel_set_revocation_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_payment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_payment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void AcceptChannel_set_delayed_payment_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_htlc_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_htlc_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey AcceptChannel_get_first_per_commitment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void AcceptChannel_set_first_per_commitment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * This is required to match the equivalent field in [`OpenChannel::channel_type`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures AcceptChannel_get_channel_type(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * This is required to match the equivalent field in [`OpenChannel::channel_type`].
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void AcceptChannel_set_channel_type(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Creates a copy of the AcceptChannel
 */
struct LDKAcceptChannel AcceptChannel_clone(const struct LDKAcceptChannel *NONNULL_PTR orig);

/**
 * Checks if two AcceptChannels contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool AcceptChannel_eq(const struct LDKAcceptChannel *NONNULL_PTR a, const struct LDKAcceptChannel *NONNULL_PTR b);

/**
 * Frees any resources used by the FundingCreated, if is_owned is set and inner is non-NULL.
 */
void FundingCreated_free(struct LDKFundingCreated this_obj);

/**
 * A temporary channel ID, until the funding is established
 */
const uint8_t (*FundingCreated_get_temporary_channel_id(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding is established
 */
void FundingCreated_set_temporary_channel_id(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The funding transaction ID
 */
const uint8_t (*FundingCreated_get_funding_txid(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * The funding transaction ID
 */
void FundingCreated_set_funding_txid(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The specific output index funding this channel
 */
uint16_t FundingCreated_get_funding_output_index(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The specific output index funding this channel
 */
void FundingCreated_set_funding_output_index(struct LDKFundingCreated *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The signature of the channel initiator (funder) on the initial commitment transaction
 */
struct LDKSignature FundingCreated_get_signature(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The signature of the channel initiator (funder) on the initial commitment transaction
 */
void FundingCreated_set_signature(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new FundingCreated given each field
 */
MUST_USE_RES struct LDKFundingCreated FundingCreated_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, struct LDKThirtyTwoBytes funding_txid_arg, uint16_t funding_output_index_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the FundingCreated
 */
struct LDKFundingCreated FundingCreated_clone(const struct LDKFundingCreated *NONNULL_PTR orig);

/**
 * Checks if two FundingCreateds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool FundingCreated_eq(const struct LDKFundingCreated *NONNULL_PTR a, const struct LDKFundingCreated *NONNULL_PTR b);

/**
 * Frees any resources used by the FundingSigned, if is_owned is set and inner is non-NULL.
 */
void FundingSigned_free(struct LDKFundingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*FundingSigned_get_channel_id(const struct LDKFundingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void FundingSigned_set_channel_id(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The signature of the channel acceptor (fundee) on the initial commitment transaction
 */
struct LDKSignature FundingSigned_get_signature(const struct LDKFundingSigned *NONNULL_PTR this_ptr);

/**
 * The signature of the channel acceptor (fundee) on the initial commitment transaction
 */
void FundingSigned_set_signature(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new FundingSigned given each field
 */
MUST_USE_RES struct LDKFundingSigned FundingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the FundingSigned
 */
struct LDKFundingSigned FundingSigned_clone(const struct LDKFundingSigned *NONNULL_PTR orig);

/**
 * Checks if two FundingSigneds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool FundingSigned_eq(const struct LDKFundingSigned *NONNULL_PTR a, const struct LDKFundingSigned *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelReady, if is_owned is set and inner is non-NULL.
 */
void ChannelReady_free(struct LDKChannelReady this_obj);

/**
 * The channel ID
 */
const uint8_t (*ChannelReady_get_channel_id(const struct LDKChannelReady *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ChannelReady_set_channel_id(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The per-commitment point of the second commitment transaction
 */
struct LDKPublicKey ChannelReady_get_next_per_commitment_point(const struct LDKChannelReady *NONNULL_PTR this_ptr);

/**
 * The per-commitment point of the second commitment transaction
 */
void ChannelReady_set_next_per_commitment_point(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * If set, provides a short_channel_id alias for this channel. The sender will accept payments
 * to be forwarded over this SCID and forward them to this messages' recipient.
 */
struct LDKCOption_u64Z ChannelReady_get_short_channel_id_alias(const struct LDKChannelReady *NONNULL_PTR this_ptr);

/**
 * If set, provides a short_channel_id alias for this channel. The sender will accept payments
 * to be forwarded over this SCID and forward them to this messages' recipient.
 */
void ChannelReady_set_short_channel_id_alias(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new ChannelReady given each field
 */
MUST_USE_RES struct LDKChannelReady ChannelReady_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKPublicKey next_per_commitment_point_arg, struct LDKCOption_u64Z short_channel_id_alias_arg);

/**
 * Creates a copy of the ChannelReady
 */
struct LDKChannelReady ChannelReady_clone(const struct LDKChannelReady *NONNULL_PTR orig);

/**
 * Checks if two ChannelReadys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelReady_eq(const struct LDKChannelReady *NONNULL_PTR a, const struct LDKChannelReady *NONNULL_PTR b);

/**
 * Frees any resources used by the Shutdown, if is_owned is set and inner is non-NULL.
 */
void Shutdown_free(struct LDKShutdown this_obj);

/**
 * The channel ID
 */
const uint8_t (*Shutdown_get_channel_id(const struct LDKShutdown *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void Shutdown_set_channel_id(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The destination of this peer's funds on closing.
 * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
 */
struct LDKu8slice Shutdown_get_scriptpubkey(const struct LDKShutdown *NONNULL_PTR this_ptr);

/**
 * The destination of this peer's funds on closing.
 * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
 */
void Shutdown_set_scriptpubkey(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new Shutdown given each field
 */
MUST_USE_RES struct LDKShutdown Shutdown_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z scriptpubkey_arg);

/**
 * Creates a copy of the Shutdown
 */
struct LDKShutdown Shutdown_clone(const struct LDKShutdown *NONNULL_PTR orig);

/**
 * Checks if two Shutdowns contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Shutdown_eq(const struct LDKShutdown *NONNULL_PTR a, const struct LDKShutdown *NONNULL_PTR b);

/**
 * Frees any resources used by the ClosingSignedFeeRange, if is_owned is set and inner is non-NULL.
 */
void ClosingSignedFeeRange_free(struct LDKClosingSignedFeeRange this_obj);

/**
 * The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
uint64_t ClosingSignedFeeRange_get_min_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);

/**
 * The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
void ClosingSignedFeeRange_set_min_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
uint64_t ClosingSignedFeeRange_get_max_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);

/**
 * The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
void ClosingSignedFeeRange_set_max_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ClosingSignedFeeRange given each field
 */
MUST_USE_RES struct LDKClosingSignedFeeRange ClosingSignedFeeRange_new(uint64_t min_fee_satoshis_arg, uint64_t max_fee_satoshis_arg);

/**
 * Creates a copy of the ClosingSignedFeeRange
 */
struct LDKClosingSignedFeeRange ClosingSignedFeeRange_clone(const struct LDKClosingSignedFeeRange *NONNULL_PTR orig);

/**
 * Checks if two ClosingSignedFeeRanges contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ClosingSignedFeeRange_eq(const struct LDKClosingSignedFeeRange *NONNULL_PTR a, const struct LDKClosingSignedFeeRange *NONNULL_PTR b);

/**
 * Frees any resources used by the ClosingSigned, if is_owned is set and inner is non-NULL.
 */
void ClosingSigned_free(struct LDKClosingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*ClosingSigned_get_channel_id(const struct LDKClosingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ClosingSigned_set_channel_id(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The proposed total fee for the closing transaction
 */
uint64_t ClosingSigned_get_fee_satoshis(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * The proposed total fee for the closing transaction
 */
void ClosingSigned_set_fee_satoshis(struct LDKClosingSigned *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature on the closing transaction
 */
struct LDKSignature ClosingSigned_get_signature(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the closing transaction
 */
void ClosingSigned_set_signature(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The minimum and maximum fees which the sender is willing to accept, provided only by new
 * nodes.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKClosingSignedFeeRange ClosingSigned_get_fee_range(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * The minimum and maximum fees which the sender is willing to accept, provided only by new
 * nodes.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ClosingSigned_set_fee_range(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKClosingSignedFeeRange val);

/**
 * Constructs a new ClosingSigned given each field
 */
MUST_USE_RES struct LDKClosingSigned ClosingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t fee_satoshis_arg, struct LDKSignature signature_arg, struct LDKClosingSignedFeeRange fee_range_arg);

/**
 * Creates a copy of the ClosingSigned
 */
struct LDKClosingSigned ClosingSigned_clone(const struct LDKClosingSigned *NONNULL_PTR orig);

/**
 * Checks if two ClosingSigneds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ClosingSigned_eq(const struct LDKClosingSigned *NONNULL_PTR a, const struct LDKClosingSigned *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateAddHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateAddHTLC_free(struct LDKUpdateAddHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateAddHTLC_get_channel_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateAddHTLC_set_channel_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateAddHTLC_get_htlc_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateAddHTLC_set_htlc_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The HTLC value in milli-satoshi
 */
uint64_t UpdateAddHTLC_get_amount_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC value in milli-satoshi
 */
void UpdateAddHTLC_set_amount_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
const uint8_t (*UpdateAddHTLC_get_payment_hash(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
void UpdateAddHTLC_set_payment_hash(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The expiry height of the HTLC
 */
uint32_t UpdateAddHTLC_get_cltv_expiry(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The expiry height of the HTLC
 */
void UpdateAddHTLC_set_cltv_expiry(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the UpdateAddHTLC
 */
struct LDKUpdateAddHTLC UpdateAddHTLC_clone(const struct LDKUpdateAddHTLC *NONNULL_PTR orig);

/**
 * Checks if two UpdateAddHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateAddHTLC_eq(const struct LDKUpdateAddHTLC *NONNULL_PTR a, const struct LDKUpdateAddHTLC *NONNULL_PTR b);

/**
 * Frees any resources used by the OnionMessage, if is_owned is set and inner is non-NULL.
 */
void OnionMessage_free(struct LDKOnionMessage this_obj);

/**
 * Used in decrypting the onion packet's payload.
 */
struct LDKPublicKey OnionMessage_get_blinding_point(const struct LDKOnionMessage *NONNULL_PTR this_ptr);

/**
 * Used in decrypting the onion packet's payload.
 */
void OnionMessage_set_blinding_point(struct LDKOnionMessage *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Creates a copy of the OnionMessage
 */
struct LDKOnionMessage OnionMessage_clone(const struct LDKOnionMessage *NONNULL_PTR orig);

/**
 * Checks if two OnionMessages contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OnionMessage_eq(const struct LDKOnionMessage *NONNULL_PTR a, const struct LDKOnionMessage *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateFulfillHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFulfillHTLC_free(struct LDKUpdateFulfillHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFulfillHTLC_get_channel_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFulfillHTLC_set_channel_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFulfillHTLC_get_htlc_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFulfillHTLC_set_htlc_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
const uint8_t (*UpdateFulfillHTLC_get_payment_preimage(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
void UpdateFulfillHTLC_set_payment_preimage(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new UpdateFulfillHTLC given each field
 */
MUST_USE_RES struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t htlc_id_arg, struct LDKThirtyTwoBytes payment_preimage_arg);

/**
 * Creates a copy of the UpdateFulfillHTLC
 */
struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(const struct LDKUpdateFulfillHTLC *NONNULL_PTR orig);

/**
 * Checks if two UpdateFulfillHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateFulfillHTLC_eq(const struct LDKUpdateFulfillHTLC *NONNULL_PTR a, const struct LDKUpdateFulfillHTLC *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateFailHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailHTLC_free(struct LDKUpdateFailHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailHTLC_get_channel_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailHTLC_set_channel_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailHTLC_get_htlc_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailHTLC_set_htlc_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the UpdateFailHTLC
 */
struct LDKUpdateFailHTLC UpdateFailHTLC_clone(const struct LDKUpdateFailHTLC *NONNULL_PTR orig);

/**
 * Checks if two UpdateFailHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateFailHTLC_eq(const struct LDKUpdateFailHTLC *NONNULL_PTR a, const struct LDKUpdateFailHTLC *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateFailMalformedHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailMalformedHTLC_free(struct LDKUpdateFailMalformedHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailMalformedHTLC_get_channel_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailMalformedHTLC_set_channel_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailMalformedHTLC_get_htlc_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailMalformedHTLC_set_htlc_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The failure code
 */
uint16_t UpdateFailMalformedHTLC_get_failure_code(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The failure code
 */
void UpdateFailMalformedHTLC_set_failure_code(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Creates a copy of the UpdateFailMalformedHTLC
 */
struct LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR orig);

/**
 * Checks if two UpdateFailMalformedHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateFailMalformedHTLC_eq(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR a, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR b);

/**
 * Frees any resources used by the CommitmentSigned, if is_owned is set and inner is non-NULL.
 */
void CommitmentSigned_free(struct LDKCommitmentSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*CommitmentSigned_get_channel_id(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void CommitmentSigned_set_channel_id(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A signature on the commitment transaction
 */
struct LDKSignature CommitmentSigned_get_signature(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the commitment transaction
 */
void CommitmentSigned_set_signature(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Signatures on the HTLC transactions
 *
 * Returns a copy of the field.
 */
struct LDKCVec_SignatureZ CommitmentSigned_get_htlc_signatures(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);

/**
 * Signatures on the HTLC transactions
 */
void CommitmentSigned_set_htlc_signatures(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);

/**
 * Constructs a new CommitmentSigned given each field
 */
MUST_USE_RES struct LDKCommitmentSigned CommitmentSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg, struct LDKCVec_SignatureZ htlc_signatures_arg);

/**
 * Creates a copy of the CommitmentSigned
 */
struct LDKCommitmentSigned CommitmentSigned_clone(const struct LDKCommitmentSigned *NONNULL_PTR orig);

/**
 * Checks if two CommitmentSigneds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool CommitmentSigned_eq(const struct LDKCommitmentSigned *NONNULL_PTR a, const struct LDKCommitmentSigned *NONNULL_PTR b);

/**
 * Frees any resources used by the RevokeAndACK, if is_owned is set and inner is non-NULL.
 */
void RevokeAndACK_free(struct LDKRevokeAndACK this_obj);

/**
 * The channel ID
 */
const uint8_t (*RevokeAndACK_get_channel_id(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void RevokeAndACK_set_channel_id(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The secret corresponding to the per-commitment point
 */
const uint8_t (*RevokeAndACK_get_per_commitment_secret(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The secret corresponding to the per-commitment point
 */
void RevokeAndACK_set_per_commitment_secret(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
struct LDKPublicKey RevokeAndACK_get_next_per_commitment_point(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
void RevokeAndACK_set_next_per_commitment_point(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new RevokeAndACK given each field
 */
MUST_USE_RES struct LDKRevokeAndACK RevokeAndACK_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes per_commitment_secret_arg, struct LDKPublicKey next_per_commitment_point_arg);

/**
 * Creates a copy of the RevokeAndACK
 */
struct LDKRevokeAndACK RevokeAndACK_clone(const struct LDKRevokeAndACK *NONNULL_PTR orig);

/**
 * Checks if two RevokeAndACKs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RevokeAndACK_eq(const struct LDKRevokeAndACK *NONNULL_PTR a, const struct LDKRevokeAndACK *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateFee, if is_owned is set and inner is non-NULL.
 */
void UpdateFee_free(struct LDKUpdateFee this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFee_get_channel_id(const struct LDKUpdateFee *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFee_set_channel_id(struct LDKUpdateFee *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Fee rate per 1000-weight of the transaction
 */
uint32_t UpdateFee_get_feerate_per_kw(const struct LDKUpdateFee *NONNULL_PTR this_ptr);

/**
 * Fee rate per 1000-weight of the transaction
 */
void UpdateFee_set_feerate_per_kw(struct LDKUpdateFee *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new UpdateFee given each field
 */
MUST_USE_RES struct LDKUpdateFee UpdateFee_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t feerate_per_kw_arg);

/**
 * Creates a copy of the UpdateFee
 */
struct LDKUpdateFee UpdateFee_clone(const struct LDKUpdateFee *NONNULL_PTR orig);

/**
 * Checks if two UpdateFees contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateFee_eq(const struct LDKUpdateFee *NONNULL_PTR a, const struct LDKUpdateFee *NONNULL_PTR b);

/**
 * Frees any resources used by the DataLossProtect, if is_owned is set and inner is non-NULL.
 */
void DataLossProtect_free(struct LDKDataLossProtect this_obj);

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
const uint8_t (*DataLossProtect_get_your_last_per_commitment_secret(const struct LDKDataLossProtect *NONNULL_PTR this_ptr))[32];

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
void DataLossProtect_set_your_last_per_commitment_secret(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
struct LDKPublicKey DataLossProtect_get_my_current_per_commitment_point(const struct LDKDataLossProtect *NONNULL_PTR this_ptr);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
void DataLossProtect_set_my_current_per_commitment_point(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new DataLossProtect given each field
 */
MUST_USE_RES struct LDKDataLossProtect DataLossProtect_new(struct LDKThirtyTwoBytes your_last_per_commitment_secret_arg, struct LDKPublicKey my_current_per_commitment_point_arg);

/**
 * Creates a copy of the DataLossProtect
 */
struct LDKDataLossProtect DataLossProtect_clone(const struct LDKDataLossProtect *NONNULL_PTR orig);

/**
 * Checks if two DataLossProtects contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool DataLossProtect_eq(const struct LDKDataLossProtect *NONNULL_PTR a, const struct LDKDataLossProtect *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelReestablish, if is_owned is set and inner is non-NULL.
 */
void ChannelReestablish_free(struct LDKChannelReestablish this_obj);

/**
 * The channel ID
 */
const uint8_t (*ChannelReestablish_get_channel_id(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ChannelReestablish_set_channel_id(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next commitment number for the sender
 */
uint64_t ChannelReestablish_get_next_local_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the sender
 */
void ChannelReestablish_set_next_local_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The next commitment number for the recipient
 */
uint64_t ChannelReestablish_get_next_remote_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the recipient
 */
void ChannelReestablish_set_next_remote_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelReestablish
 */
struct LDKChannelReestablish ChannelReestablish_clone(const struct LDKChannelReestablish *NONNULL_PTR orig);

/**
 * Checks if two ChannelReestablishs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelReestablish_eq(const struct LDKChannelReestablish *NONNULL_PTR a, const struct LDKChannelReestablish *NONNULL_PTR b);

/**
 * Frees any resources used by the AnnouncementSignatures, if is_owned is set and inner is non-NULL.
 */
void AnnouncementSignatures_free(struct LDKAnnouncementSignatures this_obj);

/**
 * The channel ID
 */
const uint8_t (*AnnouncementSignatures_get_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void AnnouncementSignatures_set_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t AnnouncementSignatures_get_short_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void AnnouncementSignatures_set_short_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature by the node key
 */
struct LDKSignature AnnouncementSignatures_get_node_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the node key
 */
void AnnouncementSignatures_set_node_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * A signature by the funding key
 */
struct LDKSignature AnnouncementSignatures_get_bitcoin_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the funding key
 */
void AnnouncementSignatures_set_bitcoin_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new AnnouncementSignatures given each field
 */
MUST_USE_RES struct LDKAnnouncementSignatures AnnouncementSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t short_channel_id_arg, struct LDKSignature node_signature_arg, struct LDKSignature bitcoin_signature_arg);

/**
 * Creates a copy of the AnnouncementSignatures
 */
struct LDKAnnouncementSignatures AnnouncementSignatures_clone(const struct LDKAnnouncementSignatures *NONNULL_PTR orig);

/**
 * Checks if two AnnouncementSignaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool AnnouncementSignatures_eq(const struct LDKAnnouncementSignatures *NONNULL_PTR a, const struct LDKAnnouncementSignatures *NONNULL_PTR b);

/**
 * Frees any resources used by the NetAddress
 */
void NetAddress_free(struct LDKNetAddress this_ptr);

/**
 * Creates a copy of the NetAddress
 */
struct LDKNetAddress NetAddress_clone(const struct LDKNetAddress *NONNULL_PTR orig);

/**
 * Utility method to constructs a new IPv4-variant NetAddress
 */
struct LDKNetAddress NetAddress_ipv4(struct LDKFourBytes addr, uint16_t port);

/**
 * Utility method to constructs a new IPv6-variant NetAddress
 */
struct LDKNetAddress NetAddress_ipv6(struct LDKSixteenBytes addr, uint16_t port);

/**
 * Utility method to constructs a new OnionV2-variant NetAddress
 */
struct LDKNetAddress NetAddress_onion_v2(struct LDKTwelveBytes a);

/**
 * Utility method to constructs a new OnionV3-variant NetAddress
 */
struct LDKNetAddress NetAddress_onion_v3(struct LDKThirtyTwoBytes ed25519_pubkey, uint16_t checksum, uint8_t version, uint16_t port);

/**
 * Utility method to constructs a new Hostname-variant NetAddress
 */
struct LDKNetAddress NetAddress_hostname(struct LDKHostname hostname, uint16_t port);

/**
 * Checks if two NetAddresss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool NetAddress_eq(const struct LDKNetAddress *NONNULL_PTR a, const struct LDKNetAddress *NONNULL_PTR b);

/**
 * Serialize the NetAddress object into a byte array which can be read by NetAddress_read
 */
struct LDKCVec_u8Z NetAddress_write(const struct LDKNetAddress *NONNULL_PTR obj);

/**
 * Read a NetAddress from a byte array, created by NetAddress_write
 */
struct LDKCResult_NetAddressDecodeErrorZ NetAddress_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UnsignedNodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedNodeAnnouncement_free(struct LDKUnsignedNodeAnnouncement this_obj);

/**
 * The advertised features
 */
struct LDKNodeFeatures UnsignedNodeAnnouncement_get_features(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised features
 */
void UnsignedNodeAnnouncement_set_features(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
uint32_t UnsignedNodeAnnouncement_get_timestamp(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
void UnsignedNodeAnnouncement_set_timestamp(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The node_id this announcement originated from (don't rebroadcast the node_announcement back
 * to this node).
 */
struct LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The node_id this announcement originated from (don't rebroadcast the node_announcement back
 * to this node).
 */
void UnsignedNodeAnnouncement_set_node_id(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * An RGB color for UI purposes
 */
const uint8_t (*UnsignedNodeAnnouncement_get_rgb(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[3];

/**
 * An RGB color for UI purposes
 */
void UnsignedNodeAnnouncement_set_rgb(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
 * of uniqueness.
 */
const uint8_t (*UnsignedNodeAnnouncement_get_alias(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
 * of uniqueness.
 */
void UnsignedNodeAnnouncement_set_alias(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * List of addresses on which this node is reachable
 *
 * Returns a copy of the field.
 */
struct LDKCVec_NetAddressZ UnsignedNodeAnnouncement_get_addresses(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * List of addresses on which this node is reachable
 */
void UnsignedNodeAnnouncement_set_addresses(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);

/**
 * Creates a copy of the UnsignedNodeAnnouncement
 */
struct LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR orig);

/**
 * Checks if two UnsignedNodeAnnouncements contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UnsignedNodeAnnouncement_eq(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR a, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR b);

/**
 * Frees any resources used by the NodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncement_free(struct LDKNodeAnnouncement this_obj);

/**
 * The signature by the node key
 */
struct LDKSignature NodeAnnouncement_get_signature(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The signature by the node key
 */
void NodeAnnouncement_set_signature(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual content of the announcement
 */
struct LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual content of the announcement
 */
void NodeAnnouncement_set_contents(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncement given each field
 */
MUST_USE_RES struct LDKNodeAnnouncement NodeAnnouncement_new(struct LDKSignature signature_arg, struct LDKUnsignedNodeAnnouncement contents_arg);

/**
 * Creates a copy of the NodeAnnouncement
 */
struct LDKNodeAnnouncement NodeAnnouncement_clone(const struct LDKNodeAnnouncement *NONNULL_PTR orig);

/**
 * Checks if two NodeAnnouncements contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeAnnouncement_eq(const struct LDKNodeAnnouncement *NONNULL_PTR a, const struct LDKNodeAnnouncement *NONNULL_PTR b);

/**
 * Frees any resources used by the UnsignedChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelAnnouncement_free(struct LDKUnsignedChannelAnnouncement this_obj);

/**
 * The advertised channel features
 */
struct LDKChannelFeatures UnsignedChannelAnnouncement_get_features(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised channel features
 */
void UnsignedChannelAnnouncement_set_features(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelAnnouncement_get_chain_hash(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelAnnouncement_set_chain_hash(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelAnnouncement_get_short_channel_id(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelAnnouncement_set_short_channel_id(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, uint64_t val);

/**
 * One of the two node_ids which are endpoints of this channel
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * One of the two node_ids which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The other of the two node_ids which are endpoints of this channel
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The other of the two node_ids which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The funding key for the first node
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the first node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The funding key for the second node
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the second node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Creates a copy of the UnsignedChannelAnnouncement
 */
struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR orig);

/**
 * Checks if two UnsignedChannelAnnouncements contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UnsignedChannelAnnouncement_eq(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR a, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void ChannelAnnouncement_free(struct LDKChannelAnnouncement this_obj);

/**
 * Authentication of the announcement by the first public node
 */
struct LDKSignature ChannelAnnouncement_get_node_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the first public node
 */
void ChannelAnnouncement_set_node_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Authentication of the announcement by the second public node
 */
struct LDKSignature ChannelAnnouncement_get_node_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the second public node
 */
void ChannelAnnouncement_set_node_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Proof of funding UTXO ownership by the first public node
 */
struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the first public node
 */
void ChannelAnnouncement_set_bitcoin_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Proof of funding UTXO ownership by the second public node
 */
struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the second public node
 */
void ChannelAnnouncement_set_bitcoin_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual announcement
 */
struct LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual announcement
 */
void ChannelAnnouncement_set_contents(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedChannelAnnouncement val);

/**
 * Constructs a new ChannelAnnouncement given each field
 */
MUST_USE_RES struct LDKChannelAnnouncement ChannelAnnouncement_new(struct LDKSignature node_signature_1_arg, struct LDKSignature node_signature_2_arg, struct LDKSignature bitcoin_signature_1_arg, struct LDKSignature bitcoin_signature_2_arg, struct LDKUnsignedChannelAnnouncement contents_arg);

/**
 * Creates a copy of the ChannelAnnouncement
 */
struct LDKChannelAnnouncement ChannelAnnouncement_clone(const struct LDKChannelAnnouncement *NONNULL_PTR orig);

/**
 * Checks if two ChannelAnnouncements contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelAnnouncement_eq(const struct LDKChannelAnnouncement *NONNULL_PTR a, const struct LDKChannelAnnouncement *NONNULL_PTR b);

/**
 * Frees any resources used by the UnsignedChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelUpdate_free(struct LDKUnsignedChannelUpdate this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelUpdate_get_chain_hash(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelUpdate_set_chain_hash(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelUpdate_get_short_channel_id(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelUpdate_set_short_channel_id(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
uint32_t UnsignedChannelUpdate_get_timestamp(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
void UnsignedChannelUpdate_set_timestamp(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Channel flags
 */
uint8_t UnsignedChannelUpdate_get_flags(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void UnsignedChannelUpdate_set_flags(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint8_t val);

/**
 * The number of blocks such that if:
 * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
 * then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
 * the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
 * cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
 * then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
 * forwarding. Note that the HTLC sender is the one who originally sets this value when
 * constructing the route.
 */
uint16_t UnsignedChannelUpdate_get_cltv_expiry_delta(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The number of blocks such that if:
 * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
 * then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
 * the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
 * cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
 * then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
 * forwarding. Note that the HTLC sender is the one who originally sets this value when
 * constructing the route.
 */
void UnsignedChannelUpdate_set_cltv_expiry_delta(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t UnsignedChannelUpdate_get_htlc_minimum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_htlc_minimum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum HTLC value incoming to sender, in milli-satoshi. Used to be optional.
 */
uint64_t UnsignedChannelUpdate_get_htlc_maximum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The maximum HTLC value incoming to sender, in milli-satoshi. Used to be optional.
 */
void UnsignedChannelUpdate_set_htlc_maximum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_base_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_fee_base_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_proportional_millionths(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
void UnsignedChannelUpdate_set_fee_proportional_millionths(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Excess data which was signed as a part of the message which we do not (yet) understand how
 * to decode. This is stored to ensure forward-compatibility as new fields are added to the
 * lightning gossip
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u8Z UnsignedChannelUpdate_get_excess_data(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * Excess data which was signed as a part of the message which we do not (yet) understand how
 * to decode. This is stored to ensure forward-compatibility as new fields are added to the
 * lightning gossip
 */
void UnsignedChannelUpdate_set_excess_data(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new UnsignedChannelUpdate given each field
 */
MUST_USE_RES struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_new(struct LDKThirtyTwoBytes chain_hash_arg, uint64_t short_channel_id_arg, uint32_t timestamp_arg, uint8_t flags_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, uint64_t htlc_maximum_msat_arg, uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, struct LDKCVec_u8Z excess_data_arg);

/**
 * Creates a copy of the UnsignedChannelUpdate
 */
struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(const struct LDKUnsignedChannelUpdate *NONNULL_PTR orig);

/**
 * Checks if two UnsignedChannelUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UnsignedChannelUpdate_eq(const struct LDKUnsignedChannelUpdate *NONNULL_PTR a, const struct LDKUnsignedChannelUpdate *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelUpdate_free(struct LDKChannelUpdate this_obj);

/**
 * A signature of the channel update
 */
struct LDKSignature ChannelUpdate_get_signature(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A signature of the channel update
 */
void ChannelUpdate_set_signature(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual channel update
 */
struct LDKUnsignedChannelUpdate ChannelUpdate_get_contents(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The actual channel update
 */
void ChannelUpdate_set_contents(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKUnsignedChannelUpdate val);

/**
 * Constructs a new ChannelUpdate given each field
 */
MUST_USE_RES struct LDKChannelUpdate ChannelUpdate_new(struct LDKSignature signature_arg, struct LDKUnsignedChannelUpdate contents_arg);

/**
 * Creates a copy of the ChannelUpdate
 */
struct LDKChannelUpdate ChannelUpdate_clone(const struct LDKChannelUpdate *NONNULL_PTR orig);

/**
 * Checks if two ChannelUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelUpdate_eq(const struct LDKChannelUpdate *NONNULL_PTR a, const struct LDKChannelUpdate *NONNULL_PTR b);

/**
 * Frees any resources used by the QueryChannelRange, if is_owned is set and inner is non-NULL.
 */
void QueryChannelRange_free(struct LDKQueryChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryChannelRange_get_chain_hash(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryChannelRange_set_chain_hash(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block for the channel UTXOs being queried
 */
uint32_t QueryChannelRange_get_first_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block for the channel UTXOs being queried
 */
void QueryChannelRange_set_first_blocknum(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks to include in the query results
 */
uint32_t QueryChannelRange_get_number_of_blocks(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks to include in the query results
 */
void QueryChannelRange_set_number_of_blocks(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new QueryChannelRange given each field
 */
MUST_USE_RES struct LDKQueryChannelRange QueryChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg);

/**
 * Creates a copy of the QueryChannelRange
 */
struct LDKQueryChannelRange QueryChannelRange_clone(const struct LDKQueryChannelRange *NONNULL_PTR orig);

/**
 * Checks if two QueryChannelRanges contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool QueryChannelRange_eq(const struct LDKQueryChannelRange *NONNULL_PTR a, const struct LDKQueryChannelRange *NONNULL_PTR b);

/**
 * Frees any resources used by the ReplyChannelRange, if is_owned is set and inner is non-NULL.
 */
void ReplyChannelRange_free(struct LDKReplyChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*ReplyChannelRange_get_chain_hash(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void ReplyChannelRange_set_chain_hash(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block in the range of the reply
 */
uint32_t ReplyChannelRange_get_first_blocknum(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block in the range of the reply
 */
void ReplyChannelRange_set_first_blocknum(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks included in the range of the reply
 */
uint32_t ReplyChannelRange_get_number_of_blocks(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks included in the range of the reply
 */
void ReplyChannelRange_set_number_of_blocks(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * True when this is the final reply for a query
 */
bool ReplyChannelRange_get_sync_complete(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * True when this is the final reply for a query
 */
void ReplyChannelRange_set_sync_complete(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, bool val);

/**
 * The short_channel_ids in the channel range
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u64Z ReplyChannelRange_get_short_channel_ids(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The short_channel_ids in the channel range
 */
void ReplyChannelRange_set_short_channel_ids(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new ReplyChannelRange given each field
 */
MUST_USE_RES struct LDKReplyChannelRange ReplyChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg, bool sync_complete_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the ReplyChannelRange
 */
struct LDKReplyChannelRange ReplyChannelRange_clone(const struct LDKReplyChannelRange *NONNULL_PTR orig);

/**
 * Checks if two ReplyChannelRanges contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ReplyChannelRange_eq(const struct LDKReplyChannelRange *NONNULL_PTR a, const struct LDKReplyChannelRange *NONNULL_PTR b);

/**
 * Frees any resources used by the QueryShortChannelIds, if is_owned is set and inner is non-NULL.
 */
void QueryShortChannelIds_free(struct LDKQueryShortChannelIds this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryShortChannelIds_get_chain_hash(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryShortChannelIds_set_chain_hash(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short_channel_ids that are being queried
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u64Z QueryShortChannelIds_get_short_channel_ids(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr);

/**
 * The short_channel_ids that are being queried
 */
void QueryShortChannelIds_set_short_channel_ids(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new QueryShortChannelIds given each field
 */
MUST_USE_RES struct LDKQueryShortChannelIds QueryShortChannelIds_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the QueryShortChannelIds
 */
struct LDKQueryShortChannelIds QueryShortChannelIds_clone(const struct LDKQueryShortChannelIds *NONNULL_PTR orig);

/**
 * Checks if two QueryShortChannelIdss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool QueryShortChannelIds_eq(const struct LDKQueryShortChannelIds *NONNULL_PTR a, const struct LDKQueryShortChannelIds *NONNULL_PTR b);

/**
 * Frees any resources used by the ReplyShortChannelIdsEnd, if is_owned is set and inner is non-NULL.
 */
void ReplyShortChannelIdsEnd_free(struct LDKReplyShortChannelIdsEnd this_obj);

/**
 * The genesis hash of the blockchain that was queried
 */
const uint8_t (*ReplyShortChannelIdsEnd_get_chain_hash(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain that was queried
 */
void ReplyShortChannelIdsEnd_set_chain_hash(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the chain_hash
 */
bool ReplyShortChannelIdsEnd_get_full_information(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the chain_hash
 */
void ReplyShortChannelIdsEnd_set_full_information(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ReplyShortChannelIdsEnd given each field
 */
MUST_USE_RES struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(struct LDKThirtyTwoBytes chain_hash_arg, bool full_information_arg);

/**
 * Creates a copy of the ReplyShortChannelIdsEnd
 */
struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR orig);

/**
 * Checks if two ReplyShortChannelIdsEnds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ReplyShortChannelIdsEnd_eq(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR a, const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR b);

/**
 * Frees any resources used by the GossipTimestampFilter, if is_owned is set and inner is non-NULL.
 */
void GossipTimestampFilter_free(struct LDKGossipTimestampFilter this_obj);

/**
 * The genesis hash of the blockchain for channel and node information
 */
const uint8_t (*GossipTimestampFilter_get_chain_hash(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain for channel and node information
 */
void GossipTimestampFilter_set_chain_hash(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The starting unix timestamp
 */
uint32_t GossipTimestampFilter_get_first_timestamp(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The starting unix timestamp
 */
void GossipTimestampFilter_set_first_timestamp(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The range of information in seconds
 */
uint32_t GossipTimestampFilter_get_timestamp_range(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The range of information in seconds
 */
void GossipTimestampFilter_set_timestamp_range(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new GossipTimestampFilter given each field
 */
MUST_USE_RES struct LDKGossipTimestampFilter GossipTimestampFilter_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_timestamp_arg, uint32_t timestamp_range_arg);

/**
 * Creates a copy of the GossipTimestampFilter
 */
struct LDKGossipTimestampFilter GossipTimestampFilter_clone(const struct LDKGossipTimestampFilter *NONNULL_PTR orig);

/**
 * Checks if two GossipTimestampFilters contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool GossipTimestampFilter_eq(const struct LDKGossipTimestampFilter *NONNULL_PTR a, const struct LDKGossipTimestampFilter *NONNULL_PTR b);

/**
 * Frees any resources used by the ErrorAction
 */
void ErrorAction_free(struct LDKErrorAction this_ptr);

/**
 * Creates a copy of the ErrorAction
 */
struct LDKErrorAction ErrorAction_clone(const struct LDKErrorAction *NONNULL_PTR orig);

/**
 * Utility method to constructs a new DisconnectPeer-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_disconnect_peer(struct LDKErrorMessage msg);

/**
 * Utility method to constructs a new IgnoreError-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_error(void);

/**
 * Utility method to constructs a new IgnoreAndLog-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_and_log(enum LDKLevel a);

/**
 * Utility method to constructs a new IgnoreDuplicateGossip-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_duplicate_gossip(void);

/**
 * Utility method to constructs a new SendErrorMessage-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_send_error_message(struct LDKErrorMessage msg);

/**
 * Utility method to constructs a new SendWarningMessage-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_send_warning_message(struct LDKWarningMessage msg, enum LDKLevel log_level);

/**
 * Frees any resources used by the LightningError, if is_owned is set and inner is non-NULL.
 */
void LightningError_free(struct LDKLightningError this_obj);

/**
 * A human-readable message describing the error
 */
struct LDKStr LightningError_get_err(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * A human-readable message describing the error
 */
void LightningError_set_err(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The action which should be taken against the offending peer.
 */
struct LDKErrorAction LightningError_get_action(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * The action which should be taken against the offending peer.
 */
void LightningError_set_action(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKErrorAction val);

/**
 * Constructs a new LightningError given each field
 */
MUST_USE_RES struct LDKLightningError LightningError_new(struct LDKStr err_arg, struct LDKErrorAction action_arg);

/**
 * Creates a copy of the LightningError
 */
struct LDKLightningError LightningError_clone(const struct LDKLightningError *NONNULL_PTR orig);

/**
 * Frees any resources used by the CommitmentUpdate, if is_owned is set and inner is non-NULL.
 */
void CommitmentUpdate_free(struct LDKCommitmentUpdate this_obj);

/**
 * update_add_htlc messages which should be sent
 */
struct LDKCVec_UpdateAddHTLCZ CommitmentUpdate_get_update_add_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * update_add_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_add_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateAddHTLCZ val);

/**
 * update_fulfill_htlc messages which should be sent
 */
struct LDKCVec_UpdateFulfillHTLCZ CommitmentUpdate_get_update_fulfill_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * update_fulfill_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fulfill_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFulfillHTLCZ val);

/**
 * update_fail_htlc messages which should be sent
 */
struct LDKCVec_UpdateFailHTLCZ CommitmentUpdate_get_update_fail_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * update_fail_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fail_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailHTLCZ val);

/**
 * update_fail_malformed_htlc messages which should be sent
 */
struct LDKCVec_UpdateFailMalformedHTLCZ CommitmentUpdate_get_update_fail_malformed_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * update_fail_malformed_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fail_malformed_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailMalformedHTLCZ val);

/**
 * An update_fee message which should be sent
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKUpdateFee CommitmentUpdate_get_update_fee(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * An update_fee message which should be sent
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void CommitmentUpdate_set_update_fee(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKUpdateFee val);

/**
 * Finally, the commitment_signed message which should be sent
 */
struct LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * Finally, the commitment_signed message which should be sent
 */
void CommitmentUpdate_set_commitment_signed(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCommitmentSigned val);

/**
 * Constructs a new CommitmentUpdate given each field
 */
MUST_USE_RES struct LDKCommitmentUpdate CommitmentUpdate_new(struct LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, struct LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, struct LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, struct LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, struct LDKUpdateFee update_fee_arg, struct LDKCommitmentSigned commitment_signed_arg);

/**
 * Creates a copy of the CommitmentUpdate
 */
struct LDKCommitmentUpdate CommitmentUpdate_clone(const struct LDKCommitmentUpdate *NONNULL_PTR orig);

/**
 * Checks if two CommitmentUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool CommitmentUpdate_eq(const struct LDKCommitmentUpdate *NONNULL_PTR a, const struct LDKCommitmentUpdate *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void ChannelMessageHandler_free(struct LDKChannelMessageHandler this_ptr);

/**
 * Calls the free function if one is set
 */
void RoutingMessageHandler_free(struct LDKRoutingMessageHandler this_ptr);

/**
 * Calls the free function if one is set
 */
void OnionMessageHandler_free(struct LDKOnionMessageHandler this_ptr);

/**
 * Serialize the AcceptChannel object into a byte array which can be read by AcceptChannel_read
 */
struct LDKCVec_u8Z AcceptChannel_write(const struct LDKAcceptChannel *NONNULL_PTR obj);

/**
 * Read a AcceptChannel from a byte array, created by AcceptChannel_write
 */
struct LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(struct LDKu8slice ser);

/**
 * Serialize the AnnouncementSignatures object into a byte array which can be read by AnnouncementSignatures_read
 */
struct LDKCVec_u8Z AnnouncementSignatures_write(const struct LDKAnnouncementSignatures *NONNULL_PTR obj);

/**
 * Read a AnnouncementSignatures from a byte array, created by AnnouncementSignatures_write
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelReestablish object into a byte array which can be read by ChannelReestablish_read
 */
struct LDKCVec_u8Z ChannelReestablish_write(const struct LDKChannelReestablish *NONNULL_PTR obj);

/**
 * Read a ChannelReestablish from a byte array, created by ChannelReestablish_write
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(struct LDKu8slice ser);

/**
 * Serialize the ClosingSigned object into a byte array which can be read by ClosingSigned_read
 */
struct LDKCVec_u8Z ClosingSigned_write(const struct LDKClosingSigned *NONNULL_PTR obj);

/**
 * Read a ClosingSigned from a byte array, created by ClosingSigned_write
 */
struct LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the ClosingSignedFeeRange object into a byte array which can be read by ClosingSignedFeeRange_read
 */
struct LDKCVec_u8Z ClosingSignedFeeRange_write(const struct LDKClosingSignedFeeRange *NONNULL_PTR obj);

/**
 * Read a ClosingSignedFeeRange from a byte array, created by ClosingSignedFeeRange_write
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ ClosingSignedFeeRange_read(struct LDKu8slice ser);

/**
 * Serialize the CommitmentSigned object into a byte array which can be read by CommitmentSigned_read
 */
struct LDKCVec_u8Z CommitmentSigned_write(const struct LDKCommitmentSigned *NONNULL_PTR obj);

/**
 * Read a CommitmentSigned from a byte array, created by CommitmentSigned_write
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(struct LDKu8slice ser);

/**
 * Serialize the FundingCreated object into a byte array which can be read by FundingCreated_read
 */
struct LDKCVec_u8Z FundingCreated_write(const struct LDKFundingCreated *NONNULL_PTR obj);

/**
 * Read a FundingCreated from a byte array, created by FundingCreated_write
 */
struct LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(struct LDKu8slice ser);

/**
 * Serialize the FundingSigned object into a byte array which can be read by FundingSigned_read
 */
struct LDKCVec_u8Z FundingSigned_write(const struct LDKFundingSigned *NONNULL_PTR obj);

/**
 * Read a FundingSigned from a byte array, created by FundingSigned_write
 */
struct LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelReady object into a byte array which can be read by ChannelReady_read
 */
struct LDKCVec_u8Z ChannelReady_write(const struct LDKChannelReady *NONNULL_PTR obj);

/**
 * Read a ChannelReady from a byte array, created by ChannelReady_write
 */
struct LDKCResult_ChannelReadyDecodeErrorZ ChannelReady_read(struct LDKu8slice ser);

/**
 * Serialize the Init object into a byte array which can be read by Init_read
 */
struct LDKCVec_u8Z Init_write(const struct LDKInit *NONNULL_PTR obj);

/**
 * Read a Init from a byte array, created by Init_write
 */
struct LDKCResult_InitDecodeErrorZ Init_read(struct LDKu8slice ser);

/**
 * Serialize the OpenChannel object into a byte array which can be read by OpenChannel_read
 */
struct LDKCVec_u8Z OpenChannel_write(const struct LDKOpenChannel *NONNULL_PTR obj);

/**
 * Read a OpenChannel from a byte array, created by OpenChannel_write
 */
struct LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(struct LDKu8slice ser);

/**
 * Serialize the RevokeAndACK object into a byte array which can be read by RevokeAndACK_read
 */
struct LDKCVec_u8Z RevokeAndACK_write(const struct LDKRevokeAndACK *NONNULL_PTR obj);

/**
 * Read a RevokeAndACK from a byte array, created by RevokeAndACK_write
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(struct LDKu8slice ser);

/**
 * Serialize the Shutdown object into a byte array which can be read by Shutdown_read
 */
struct LDKCVec_u8Z Shutdown_write(const struct LDKShutdown *NONNULL_PTR obj);

/**
 * Read a Shutdown from a byte array, created by Shutdown_write
 */
struct LDKCResult_ShutdownDecodeErrorZ Shutdown_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailHTLC object into a byte array which can be read by UpdateFailHTLC_read
 */
struct LDKCVec_u8Z UpdateFailHTLC_write(const struct LDKUpdateFailHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailHTLC from a byte array, created by UpdateFailHTLC_write
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailMalformedHTLC object into a byte array which can be read by UpdateFailMalformedHTLC_read
 */
struct LDKCVec_u8Z UpdateFailMalformedHTLC_write(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailMalformedHTLC from a byte array, created by UpdateFailMalformedHTLC_write
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFee object into a byte array which can be read by UpdateFee_read
 */
struct LDKCVec_u8Z UpdateFee_write(const struct LDKUpdateFee *NONNULL_PTR obj);

/**
 * Read a UpdateFee from a byte array, created by UpdateFee_write
 */
struct LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFulfillHTLC object into a byte array which can be read by UpdateFulfillHTLC_read
 */
struct LDKCVec_u8Z UpdateFulfillHTLC_write(const struct LDKUpdateFulfillHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFulfillHTLC from a byte array, created by UpdateFulfillHTLC_write
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateAddHTLC object into a byte array which can be read by UpdateAddHTLC_read
 */
struct LDKCVec_u8Z UpdateAddHTLC_write(const struct LDKUpdateAddHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateAddHTLC from a byte array, created by UpdateAddHTLC_write
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(struct LDKu8slice ser);

/**
 * Read a OnionMessage from a byte array, created by OnionMessage_write
 */
struct LDKCResult_OnionMessageDecodeErrorZ OnionMessage_read(struct LDKu8slice ser);

/**
 * Serialize the OnionMessage object into a byte array which can be read by OnionMessage_read
 */
struct LDKCVec_u8Z OnionMessage_write(const struct LDKOnionMessage *NONNULL_PTR obj);

/**
 * Serialize the Ping object into a byte array which can be read by Ping_read
 */
struct LDKCVec_u8Z Ping_write(const struct LDKPing *NONNULL_PTR obj);

/**
 * Read a Ping from a byte array, created by Ping_write
 */
struct LDKCResult_PingDecodeErrorZ Ping_read(struct LDKu8slice ser);

/**
 * Serialize the Pong object into a byte array which can be read by Pong_read
 */
struct LDKCVec_u8Z Pong_write(const struct LDKPong *NONNULL_PTR obj);

/**
 * Read a Pong from a byte array, created by Pong_write
 */
struct LDKCResult_PongDecodeErrorZ Pong_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelAnnouncement object into a byte array which can be read by UnsignedChannelAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedChannelAnnouncement_write(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelAnnouncement from a byte array, created by UnsignedChannelAnnouncement_write
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ UnsignedChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelAnnouncement object into a byte array which can be read by ChannelAnnouncement_read
 */
struct LDKCVec_u8Z ChannelAnnouncement_write(const struct LDKChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a ChannelAnnouncement from a byte array, created by ChannelAnnouncement_write
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelUpdate object into a byte array which can be read by UnsignedChannelUpdate_read
 */
struct LDKCVec_u8Z UnsignedChannelUpdate_write(const struct LDKUnsignedChannelUpdate *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelUpdate from a byte array, created by UnsignedChannelUpdate_write
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelUpdate object into a byte array which can be read by ChannelUpdate_read
 */
struct LDKCVec_u8Z ChannelUpdate_write(const struct LDKChannelUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelUpdate from a byte array, created by ChannelUpdate_write
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ErrorMessage object into a byte array which can be read by ErrorMessage_read
 */
struct LDKCVec_u8Z ErrorMessage_write(const struct LDKErrorMessage *NONNULL_PTR obj);

/**
 * Read a ErrorMessage from a byte array, created by ErrorMessage_write
 */
struct LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(struct LDKu8slice ser);

/**
 * Serialize the WarningMessage object into a byte array which can be read by WarningMessage_read
 */
struct LDKCVec_u8Z WarningMessage_write(const struct LDKWarningMessage *NONNULL_PTR obj);

/**
 * Read a WarningMessage from a byte array, created by WarningMessage_write
 */
struct LDKCResult_WarningMessageDecodeErrorZ WarningMessage_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedNodeAnnouncement object into a byte array which can be read by UnsignedNodeAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedNodeAnnouncement_write(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedNodeAnnouncement from a byte array, created by UnsignedNodeAnnouncement_write
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the NodeAnnouncement object into a byte array which can be read by NodeAnnouncement_read
 */
struct LDKCVec_u8Z NodeAnnouncement_write(const struct LDKNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncement from a byte array, created by NodeAnnouncement_write
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Read a QueryShortChannelIds from a byte array, created by QueryShortChannelIds_write
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(struct LDKu8slice ser);

/**
 * Serialize the QueryShortChannelIds object into a byte array which can be read by QueryShortChannelIds_read
 */
struct LDKCVec_u8Z QueryShortChannelIds_write(const struct LDKQueryShortChannelIds *NONNULL_PTR obj);

/**
 * Serialize the ReplyShortChannelIdsEnd object into a byte array which can be read by ReplyShortChannelIdsEnd_read
 */
struct LDKCVec_u8Z ReplyShortChannelIdsEnd_write(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR obj);

/**
 * Read a ReplyShortChannelIdsEnd from a byte array, created by ReplyShortChannelIdsEnd_write
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(struct LDKu8slice ser);

/**
 *\n\t * Calculates the overflow safe ending block height for the query.\n\t * Overflow returns `0xffffffff`, otherwise returns `first_blocknum + number_of_blocks`\n\t
 */
MUST_USE_RES uint32_t QueryChannelRange_end_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_arg);

/**
 * Serialize the QueryChannelRange object into a byte array which can be read by QueryChannelRange_read
 */
struct LDKCVec_u8Z QueryChannelRange_write(const struct LDKQueryChannelRange *NONNULL_PTR obj);

/**
 * Read a QueryChannelRange from a byte array, created by QueryChannelRange_write
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(struct LDKu8slice ser);

/**
 * Read a ReplyChannelRange from a byte array, created by ReplyChannelRange_write
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(struct LDKu8slice ser);

/**
 * Serialize the ReplyChannelRange object into a byte array which can be read by ReplyChannelRange_read
 */
struct LDKCVec_u8Z ReplyChannelRange_write(const struct LDKReplyChannelRange *NONNULL_PTR obj);

/**
 * Serialize the GossipTimestampFilter object into a byte array which can be read by GossipTimestampFilter_read
 */
struct LDKCVec_u8Z GossipTimestampFilter_write(const struct LDKGossipTimestampFilter *NONNULL_PTR obj);

/**
 * Read a GossipTimestampFilter from a byte array, created by GossipTimestampFilter_write
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(struct LDKu8slice ser);

/**
 * Calls the free function if one is set
 */
void CustomMessageHandler_free(struct LDKCustomMessageHandler this_ptr);

/**
 * Frees any resources used by the IgnoringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void IgnoringMessageHandler_free(struct LDKIgnoringMessageHandler this_obj);

/**
 * Constructs a new IgnoringMessageHandler given each field
 */
MUST_USE_RES struct LDKIgnoringMessageHandler IgnoringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider IgnoringMessageHandler_as_MessageSendEventsProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new OnionMessageProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OnionMessageProvider must be freed before this_arg is
 */
struct LDKOnionMessageProvider IgnoringMessageHandler_as_OnionMessageProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new OnionMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OnionMessageHandler must be freed before this_arg is
 */
struct LDKOnionMessageHandler IgnoringMessageHandler_as_OnionMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new CustomOnionMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CustomOnionMessageHandler must be freed before this_arg is
 */
struct LDKCustomOnionMessageHandler IgnoringMessageHandler_as_CustomOnionMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new CustomMessageReader which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CustomMessageReader must be freed before this_arg is
 */
struct LDKCustomMessageReader IgnoringMessageHandler_as_CustomMessageReader(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new CustomMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CustomMessageHandler must be freed before this_arg is
 */
struct LDKCustomMessageHandler IgnoringMessageHandler_as_CustomMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ErroringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void ErroringMessageHandler_free(struct LDKErroringMessageHandler this_obj);

/**
 * Constructs a new ErroringMessageHandler
 */
MUST_USE_RES struct LDKErroringMessageHandler ErroringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ErroringMessageHandler_as_MessageSendEventsProvider(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the MessageHandler, if is_owned is set and inner is non-NULL.
 */
void MessageHandler_free(struct LDKMessageHandler this_obj);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * [`ChannelManager`] object or an [`ErroringMessageHandler`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
const struct LDKChannelMessageHandler *MessageHandler_get_chan_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * [`ChannelManager`] object or an [`ErroringMessageHandler`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
void MessageHandler_set_chan_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKChannelMessageHandler val);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
 *
 * [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
 */
const struct LDKRoutingMessageHandler *MessageHandler_get_route_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
 *
 * [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
 */
void MessageHandler_set_route_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKRoutingMessageHandler val);

/**
 * A message handler which handles onion messages. For now, this can only be an
 * [`IgnoringMessageHandler`].
 */
const struct LDKOnionMessageHandler *MessageHandler_get_onion_message_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles onion messages. For now, this can only be an
 * [`IgnoringMessageHandler`].
 */
void MessageHandler_set_onion_message_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKOnionMessageHandler val);

/**
 * Constructs a new MessageHandler given each field
 */
MUST_USE_RES struct LDKMessageHandler MessageHandler_new(struct LDKChannelMessageHandler chan_handler_arg, struct LDKRoutingMessageHandler route_handler_arg, struct LDKOnionMessageHandler onion_message_handler_arg);

/**
 * Creates a copy of a SocketDescriptor
 */
struct LDKSocketDescriptor SocketDescriptor_clone(const struct LDKSocketDescriptor *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void SocketDescriptor_free(struct LDKSocketDescriptor this_ptr);

/**
 * Frees any resources used by the PeerHandleError, if is_owned is set and inner is non-NULL.
 */
void PeerHandleError_free(struct LDKPeerHandleError this_obj);

/**
 * Used to indicate that we probably can't make any future connections to this peer (e.g.
 * because we required features that our peer was missing, or vice versa).
 *
 * While LDK's [`ChannelManager`] will not do it automatically, you likely wish to force-close
 * any channels with this peer or check for new versions of LDK.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
bool PeerHandleError_get_no_connection_possible(const struct LDKPeerHandleError *NONNULL_PTR this_ptr);

/**
 * Used to indicate that we probably can't make any future connections to this peer (e.g.
 * because we required features that our peer was missing, or vice versa).
 *
 * While LDK's [`ChannelManager`] will not do it automatically, you likely wish to force-close
 * any channels with this peer or check for new versions of LDK.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
void PeerHandleError_set_no_connection_possible(struct LDKPeerHandleError *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new PeerHandleError given each field
 */
MUST_USE_RES struct LDKPeerHandleError PeerHandleError_new(bool no_connection_possible_arg);

/**
 * Creates a copy of the PeerHandleError
 */
struct LDKPeerHandleError PeerHandleError_clone(const struct LDKPeerHandleError *NONNULL_PTR orig);

/**
 * Frees any resources used by the PeerManager, if is_owned is set and inner is non-NULL.
 */
void PeerManager_free(struct LDKPeerManager this_obj);

/**
 * Constructs a new PeerManager with the given message handlers and node_id secret key
 * ephemeral_random_data is used to derive per-connection ephemeral keys and must be
 * cryptographically secure random bytes.
 *
 * `current_time` is used as an always-increasing counter that survives across restarts and is
 * incremented irregularly internally. In general it is best to simply use the current UNIX
 * timestamp, however if it is not available a persistent counter that increases once per
 * minute should suffice.
 */
MUST_USE_RES struct LDKPeerManager PeerManager_new(struct LDKMessageHandler message_handler, struct LDKSecretKey our_node_secret, uint32_t current_time, const uint8_t (*ephemeral_random_data)[32], struct LDKLogger logger, struct LDKCustomMessageHandler custom_message_handler);

/**
 * Get the list of node ids for peers which have completed the initial handshake.
 *
 * For outbound connections, this will be the same as the their_node_id parameter passed in to
 * new_outbound_connection, however entries will only appear once the initial handshake has
 * completed and we are sure the remote peer has the private key for the given node_id.
 */
MUST_USE_RES struct LDKCVec_PublicKeyZ PeerManager_get_peer_node_ids(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates a new outbound connection has been established to a node with the given node_id
 * and an optional remote network address.
 *
 * The remote network address adds the option to report a remote IP address back to a connecting
 * peer using the init message.
 * The user should pass the remote network address of the host they are connected to.
 *
 * If an `Err` is returned here you must disconnect the connection immediately.
 *
 * Returns a small number of bytes to send to the remote node (currently always 50).
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet been
 * [`socket_disconnected()`].
 *
 * [`socket_disconnected()`]: PeerManager::socket_disconnected
 */
MUST_USE_RES struct LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKSocketDescriptor descriptor, struct LDKCOption_NetAddressZ remote_network_address);

/**
 * Indicates a new inbound connection has been established to a node with an optional remote
 * network address.
 *
 * The remote network address adds the option to report a remote IP address back to a connecting
 * peer using the init message.
 * The user should pass the remote network address of the host they are connected to.
 *
 * May refuse the connection by returning an Err, but will never write bytes to the remote end
 * (outbound connector always speaks first). If an `Err` is returned here you must disconnect
 * the connection immediately.
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet been
 * [`socket_disconnected()`].
 *
 * [`socket_disconnected()`]: PeerManager::socket_disconnected
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor descriptor, struct LDKCOption_NetAddressZ remote_network_address);

/**
 * Indicates that there is room to write data to the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
 * returning. Thus, be very careful with reentrancy issues! The invariants around calling
 * [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
 * ready to call `[write_buffer_space_avail`] again if a write call generated here isn't
 * sufficient!
 *
 * [`send_data`]: SocketDescriptor::send_data
 * [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Indicates that data was read from the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
 * Thus, however, you should call [`process_events`] after any `read_event` to generate
 * [`send_data`] calls to handle responses.
 *
 * If `Ok(true)` is returned, further read_events should not be triggered until a
 * [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
 * send buffer).
 *
 * [`send_data`]: SocketDescriptor::send_data
 * [`process_events`]: PeerManager::process_events
 */
MUST_USE_RES struct LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR peer_descriptor, struct LDKu8slice data);

/**
 * Checks for any events generated by our handlers and processes them. Includes sending most
 * response messages as well as messages generated by calls to handler functions directly (eg
 * functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
 *
 * May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
 * issues!
 *
 * You don't have to call this function explicitly if you are using [`lightning-net-tokio`]
 * or one of the other clients provided in our language bindings.
 *
 * Note that if there are any other calls to this function waiting on lock(s) this may return
 * without doing any work. All available events that need handling will be handled before the
 * other calls return.
 *
 * [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
 * [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
 * [`send_data`]: SocketDescriptor::send_data
 */
void PeerManager_process_events(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates that the given socket descriptor's connection is now closed.
 */
void PeerManager_socket_disconnected(const struct LDKPeerManager *NONNULL_PTR this_arg, const struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Disconnect a peer given its node id.
 *
 * Set `no_connection_possible` to true to prevent any further connection with this peer,
 * force-closing any channels we have with it.
 *
 * If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
 * peer. Thus, be very careful about reentrancy issues.
 *
 * [`disconnect_socket`]: SocketDescriptor::disconnect_socket
 */
void PeerManager_disconnect_by_node_id(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id, bool no_connection_possible);

/**
 * Disconnects all currently-connected peers. This is useful on platforms where there may be
 * an indication that TCP sockets have stalled even if we weren't around to time them out
 * using regular ping/pongs.
 */
void PeerManager_disconnect_all_peers(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Send pings to each peer and disconnect those which did not respond to the last round of
 * pings.
 *
 * This may be called on any timescale you want, however, roughly once every ten seconds is
 * preferred. The call rate determines both how often we send a ping to our peers and how much
 * time they have to respond before we disconnect them.
 *
 * May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
 * issues!
 *
 * [`send_data`]: SocketDescriptor::send_data
 */
void PeerManager_timer_tick_occurred(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Generates a signed node_announcement from the given arguments, sending it to all connected
 * peers. Note that peers will likely ignore this message unless we have at least one public
 * channel which has at least six confirmations on-chain.
 *
 * `rgb` is a node \"color\" and `alias` is a printable human-readable string to describe this
 * node to humans. They carry no in-protocol meaning.
 *
 * `addresses` represent the set (possibly empty) of socket addresses on which this node
 * accepts incoming connections. These will be included in the node_announcement, publicly
 * tying these addresses together and to this node. If you wish to preserve user privacy,
 * addresses should likely contain only Tor Onion addresses.
 *
 * Panics if `addresses` is absurdly large (more than 100).
 *
 * [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
 */
void PeerManager_broadcast_node_announcement(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKThreeBytes rgb, struct LDKThirtyTwoBytes alias, struct LDKCVec_NetAddressZ addresses);

/**
 * Gets the weight for an HTLC-Success transaction.
 */
uint64_t htlc_success_tx_weight(bool opt_anchors);

/**
 * Gets the weight for an HTLC-Timeout transaction.
 */
uint64_t htlc_timeout_tx_weight(bool opt_anchors);

/**
 * Creates a copy of the HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_clone(const enum LDKHTLCClaim *NONNULL_PTR orig);

/**
 * Utility method to constructs a new OfferedTimeout-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_offered_timeout(void);

/**
 * Utility method to constructs a new OfferedPreimage-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_offered_preimage(void);

/**
 * Utility method to constructs a new AcceptedTimeout-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_accepted_timeout(void);

/**
 * Utility method to constructs a new AcceptedPreimage-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_accepted_preimage(void);

/**
 * Utility method to constructs a new Revocation-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_revocation(void);

/**
 * Checks if two HTLCClaims contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool HTLCClaim_eq(const enum LDKHTLCClaim *NONNULL_PTR a, const enum LDKHTLCClaim *NONNULL_PTR b);

/**
 * Check if a given input witness attempts to claim a HTLC.
 */
MUST_USE_RES struct LDKCOption_HTLCClaimZ HTLCClaim_from_witness(struct LDKWitness witness);

/**
 * Build the commitment secret from the seed and the commitment number
 */
struct LDKThirtyTwoBytes build_commitment_secret(const uint8_t (*commitment_seed)[32], uint64_t idx);

/**
 * Build a closing transaction
 */
struct LDKTransaction build_closing_transaction(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);

/**
 * Frees any resources used by the CounterpartyCommitmentSecrets, if is_owned is set and inner is non-NULL.
 */
void CounterpartyCommitmentSecrets_free(struct LDKCounterpartyCommitmentSecrets this_obj);

/**
 * Creates a copy of the CounterpartyCommitmentSecrets
 */
struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_clone(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR orig);

/**
 * Creates a new empty `CounterpartyCommitmentSecrets` structure.
 */
MUST_USE_RES struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_new(void);

/**
 * Returns the minimum index of all stored secrets. Note that indexes start
 * at 1 << 48 and get decremented by one for each new secret.
 */
MUST_USE_RES uint64_t CounterpartyCommitmentSecrets_get_min_seen_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg);

/**
 * Inserts the `secret` at `idx`. Returns `Ok(())` if the secret
 * was generated in accordance with BOLT 3 and is consistent with previous secrets.
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ CounterpartyCommitmentSecrets_provide_secret(struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx, struct LDKThirtyTwoBytes secret);

/**
 * Returns the secret at `idx`.
 * Returns `None` if `idx` is < [`CounterpartyCommitmentSecrets::get_min_seen_secret`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKThirtyTwoBytes CounterpartyCommitmentSecrets_get_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx);

/**
 * Serialize the CounterpartyCommitmentSecrets object into a byte array which can be read by CounterpartyCommitmentSecrets_read
 */
struct LDKCVec_u8Z CounterpartyCommitmentSecrets_write(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR obj);

/**
 * Read a CounterpartyCommitmentSecrets from a byte array, created by CounterpartyCommitmentSecrets_write
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CounterpartyCommitmentSecrets_read(struct LDKu8slice ser);

/**
 * Derives a per-commitment-transaction private key (eg an htlc key or delayed_payment key)
 * from the base secret and the per_commitment_point.
 */
struct LDKSecretKey derive_private_key(struct LDKPublicKey per_commitment_point, const uint8_t (*base_secret)[32]);

/**
 * Derives a per-commitment-transaction public key (eg an htlc key or a delayed_payment key)
 * from the base point and the per_commitment_key. This is the public equivalent of
 * derive_private_key - using only public keys to derive a public key instead of private keys.
 */
struct LDKPublicKey derive_public_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey base_point);

/**
 * Derives a per-commitment-transaction revocation key from its constituent parts.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_secret always come from cheater
 * and revocation_base_secret always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 */
struct LDKSecretKey derive_private_revocation_key(const uint8_t (*per_commitment_secret)[32], const uint8_t (*countersignatory_revocation_base_secret)[32]);

/**
 * Derives a per-commitment-transaction revocation public key from its constituent parts. This is
 * the public equivalend of derive_private_revocation_key - using only public keys to derive a
 * public key instead of private keys.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_point always come from cheater
 * and revocation_base_point always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKPublicKey derive_public_revocation_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey countersignatory_revocation_base_point);

/**
 * Frees any resources used by the TxCreationKeys, if is_owned is set and inner is non-NULL.
 */
void TxCreationKeys_free(struct LDKTxCreationKeys this_obj);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
struct LDKPublicKey TxCreationKeys_get_per_commitment_point(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
void TxCreationKeys_set_per_commitment_point(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
struct LDKPublicKey TxCreationKeys_get_revocation_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
void TxCreationKeys_set_revocation_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's HTLC Key
 */
void TxCreationKeys_set_broadcaster_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Countersignatory's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Countersignatory's HTLC Key
 */
void TxCreationKeys_set_countersignatory_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
void TxCreationKeys_set_broadcaster_delayed_payment_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new TxCreationKeys given each field
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_new(struct LDKPublicKey per_commitment_point_arg, struct LDKPublicKey revocation_key_arg, struct LDKPublicKey broadcaster_htlc_key_arg, struct LDKPublicKey countersignatory_htlc_key_arg, struct LDKPublicKey broadcaster_delayed_payment_key_arg);

/**
 * Checks if two TxCreationKeyss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxCreationKeys_eq(const struct LDKTxCreationKeys *NONNULL_PTR a, const struct LDKTxCreationKeys *NONNULL_PTR b);

/**
 * Creates a copy of the TxCreationKeys
 */
struct LDKTxCreationKeys TxCreationKeys_clone(const struct LDKTxCreationKeys *NONNULL_PTR orig);

/**
 * Serialize the TxCreationKeys object into a byte array which can be read by TxCreationKeys_read
 */
struct LDKCVec_u8Z TxCreationKeys_write(const struct LDKTxCreationKeys *NONNULL_PTR obj);

/**
 * Read a TxCreationKeys from a byte array, created by TxCreationKeys_write
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelPublicKeys, if is_owned is set and inner is non-NULL.
 */
void ChannelPublicKeys_free(struct LDKChannelPublicKeys this_obj);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
struct LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
void ChannelPublicKeys_set_funding_pubkey(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
struct LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
void ChannelPublicKeys_set_revocation_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
struct LDKPublicKey ChannelPublicKeys_get_payment_point(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
void ChannelPublicKeys_set_payment_point(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
struct LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
void ChannelPublicKeys_set_delayed_payment_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
struct LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
void ChannelPublicKeys_set_htlc_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new ChannelPublicKeys given each field
 */
MUST_USE_RES struct LDKChannelPublicKeys ChannelPublicKeys_new(struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg);

/**
 * Creates a copy of the ChannelPublicKeys
 */
struct LDKChannelPublicKeys ChannelPublicKeys_clone(const struct LDKChannelPublicKeys *NONNULL_PTR orig);

/**
 * Checks if two ChannelPublicKeyss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelPublicKeys_eq(const struct LDKChannelPublicKeys *NONNULL_PTR a, const struct LDKChannelPublicKeys *NONNULL_PTR b);

/**
 * Serialize the ChannelPublicKeys object into a byte array which can be read by ChannelPublicKeys_read
 */
struct LDKCVec_u8Z ChannelPublicKeys_write(const struct LDKChannelPublicKeys *NONNULL_PTR obj);

/**
 * Read a ChannelPublicKeys from a byte array, created by ChannelPublicKeys_write
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(struct LDKu8slice ser);

/**
 * Create per-state keys from channel base points and the per-commitment point.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_derive_new(struct LDKPublicKey per_commitment_point, struct LDKPublicKey broadcaster_delayed_payment_base, struct LDKPublicKey broadcaster_htlc_base, struct LDKPublicKey countersignatory_revocation_base, struct LDKPublicKey countersignatory_htlc_base);

/**
 * Generate per-state keys from channel static keys.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_from_channel_static_keys(struct LDKPublicKey per_commitment_point, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * A script either spendable by the revocation
 * key or the broadcaster_delayed_payment_key and satisfying the relative-locktime OP_CSV constrain.
 * Encumbering a `to_holder` output on a commitment transaction or 2nd-stage HTLC transactions.
 */
struct LDKCVec_u8Z get_revokeable_redeemscript(struct LDKPublicKey revocation_key, uint16_t contest_delay, struct LDKPublicKey broadcaster_delayed_payment_key);

/**
 * Frees any resources used by the HTLCOutputInCommitment, if is_owned is set and inner is non-NULL.
 */
void HTLCOutputInCommitment_free(struct LDKHTLCOutputInCommitment this_obj);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
bool HTLCOutputInCommitment_get_offered(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
void HTLCOutputInCommitment_set_offered(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, bool val);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
uint64_t HTLCOutputInCommitment_get_amount_msat(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
void HTLCOutputInCommitment_set_amount_msat(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
uint32_t HTLCOutputInCommitment_get_cltv_expiry(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
void HTLCOutputInCommitment_set_cltv_expiry(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The hash of the preimage which unlocks this HTLC.
 */
const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr))[32];

/**
 * The hash of the preimage which unlocks this HTLC.
 */
void HTLCOutputInCommitment_set_payment_hash(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The position within the commitment transactions' outputs. This may be None if the value is
 * below the dust limit (in which case no output appears in the commitment transaction and the
 * value is spent to additional transaction fees).
 */
struct LDKCOption_u32Z HTLCOutputInCommitment_get_transaction_output_index(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The position within the commitment transactions' outputs. This may be None if the value is
 * below the dust limit (in which case no output appears in the commitment transaction and the
 * value is spent to additional transaction fees).
 */
void HTLCOutputInCommitment_set_transaction_output_index(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * Constructs a new HTLCOutputInCommitment given each field
 */
MUST_USE_RES struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_new(bool offered_arg, uint64_t amount_msat_arg, uint32_t cltv_expiry_arg, struct LDKThirtyTwoBytes payment_hash_arg, struct LDKCOption_u32Z transaction_output_index_arg);

/**
 * Creates a copy of the HTLCOutputInCommitment
 */
struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(const struct LDKHTLCOutputInCommitment *NONNULL_PTR orig);

/**
 * Checks if two HTLCOutputInCommitments contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool HTLCOutputInCommitment_eq(const struct LDKHTLCOutputInCommitment *NONNULL_PTR a, const struct LDKHTLCOutputInCommitment *NONNULL_PTR b);

/**
 * Serialize the HTLCOutputInCommitment object into a byte array which can be read by HTLCOutputInCommitment_read
 */
struct LDKCVec_u8Z HTLCOutputInCommitment_write(const struct LDKHTLCOutputInCommitment *NONNULL_PTR obj);

/**
 * Read a HTLCOutputInCommitment from a byte array, created by HTLCOutputInCommitment_write
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(struct LDKu8slice ser);

/**
 * Gets the witness redeemscript for an HTLC output in a commitment transaction. Note that htlc
 * does not need to have its previous_output_index filled.
 */
struct LDKCVec_u8Z get_htlc_redeemscript(const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, bool opt_anchors, const struct LDKTxCreationKeys *NONNULL_PTR keys);

/**
 * Gets the redeemscript for a funding output from the two funding public keys.
 * Note that the order of funding public keys does not matter.
 */
struct LDKCVec_u8Z make_funding_redeemscript(struct LDKPublicKey broadcaster, struct LDKPublicKey countersignatory);

/**
 * Builds an unsigned HTLC-Success or HTLC-Timeout transaction from the given channel and HTLC
 * parameters. This is used by [`TrustedCommitmentTransaction::get_htlc_sigs`] to fetch the
 * transaction which needs signing, and can be used to construct an HTLC transaction which is
 * broadcastable given a counterparty HTLC signature.
 *
 * Panics if htlc.transaction_output_index.is_none() (as such HTLCs do not appear in the
 * commitment transaction).
 */
struct LDKTransaction build_htlc_transaction(const uint8_t (*commitment_txid)[32], uint32_t feerate_per_kw, uint16_t contest_delay, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, bool opt_anchors, bool use_non_zero_fee_anchors, struct LDKPublicKey broadcaster_delayed_payment_key, struct LDKPublicKey revocation_key);

/**
 * Returns the witness required to satisfy and spend a HTLC input.
 *
 * Note that preimage (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKWitness build_htlc_input_witness(struct LDKSignature local_sig, struct LDKSignature remote_sig, struct LDKThirtyTwoBytes preimage, struct LDKu8slice redeem_script, bool opt_anchors);

/**
 * Gets the witnessScript for the to_remote output when anchors are enabled.
 */
struct LDKCVec_u8Z get_to_countersignatory_with_anchors_redeemscript(struct LDKPublicKey payment_point);

/**
 * Gets the witnessScript for an anchor output from the funding public key.
 * The witness in the spending input must be:
 * <BIP 143 funding_signature>
 * After 16 blocks of confirmation, an alternative satisfying witness could be:
 * <>
 * (empty vector required to satisfy compliance with MINIMALIF-standard rule)
 */
struct LDKCVec_u8Z get_anchor_redeemscript(struct LDKPublicKey funding_pubkey);

/**
 * Returns the witness required to satisfy and spend an anchor input.
 */
struct LDKWitness build_anchor_input_witness(struct LDKPublicKey funding_key, struct LDKSignature funding_sig);

/**
 * Frees any resources used by the ChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void ChannelTransactionParameters_free(struct LDKChannelTransactionParameters this_obj);

/**
 * Holder public keys
 */
struct LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Holder public keys
 */
void ChannelTransactionParameters_set_holder_pubkeys(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
uint16_t ChannelTransactionParameters_get_holder_selected_contest_delay(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
void ChannelTransactionParameters_set_holder_selected_contest_delay(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
bool ChannelTransactionParameters_get_is_outbound_from_holder(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
void ChannelTransactionParameters_set_is_outbound_from_holder(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, bool val);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCounterpartyChannelTransactionParameters ChannelTransactionParameters_get_counterparty_parameters(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelTransactionParameters_set_counterparty_parameters(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKCounterpartyChannelTransactionParameters val);

/**
 * The late-bound funding outpoint
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound funding outpoint
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelTransactionParameters_set_funding_outpoint(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Are anchors (zero fee HTLC transaction variant) used for this channel. Boolean is
 * serialization backwards-compatible.
 */
enum LDKCOption_NoneZ ChannelTransactionParameters_get_opt_anchors(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Are anchors (zero fee HTLC transaction variant) used for this channel. Boolean is
 * serialization backwards-compatible.
 */
void ChannelTransactionParameters_set_opt_anchors(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);

/**
 * Are non-zero-fee anchors are enabled (used in conjuction with opt_anchors)
 * It is intended merely for backwards compatibility with signers that need it.
 * There is no support for this feature in LDK channel negotiation.
 */
enum LDKCOption_NoneZ ChannelTransactionParameters_get_opt_non_zero_fee_anchors(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Are non-zero-fee anchors are enabled (used in conjuction with opt_anchors)
 * It is intended merely for backwards compatibility with signers that need it.
 * There is no support for this feature in LDK channel negotiation.
 */
void ChannelTransactionParameters_set_opt_non_zero_fee_anchors(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);

/**
 * Constructs a new ChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKChannelTransactionParameters ChannelTransactionParameters_new(struct LDKChannelPublicKeys holder_pubkeys_arg, uint16_t holder_selected_contest_delay_arg, bool is_outbound_from_holder_arg, struct LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg, struct LDKOutPoint funding_outpoint_arg, enum LDKCOption_NoneZ opt_anchors_arg, enum LDKCOption_NoneZ opt_non_zero_fee_anchors_arg);

/**
 * Creates a copy of the ChannelTransactionParameters
 */
struct LDKChannelTransactionParameters ChannelTransactionParameters_clone(const struct LDKChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Frees any resources used by the CounterpartyChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void CounterpartyChannelTransactionParameters_free(struct LDKCounterpartyChannelTransactionParameters this_obj);

/**
 * Counter-party public keys
 */
struct LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Counter-party public keys
 */
void CounterpartyChannelTransactionParameters_set_pubkeys(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
uint16_t CounterpartyChannelTransactionParameters_get_selected_contest_delay(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
void CounterpartyChannelTransactionParameters_set_selected_contest_delay(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new CounterpartyChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_new(struct LDKChannelPublicKeys pubkeys_arg, uint16_t selected_contest_delay_arg);

/**
 * Creates a copy of the CounterpartyChannelTransactionParameters
 */
struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_clone(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Whether the late bound parameters are populated.
 */
MUST_USE_RES bool ChannelTransactionParameters_is_populated(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the holder is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_holder_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the counterparty is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_counterparty_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Serialize the CounterpartyChannelTransactionParameters object into a byte array which can be read by CounterpartyChannelTransactionParameters_read
 */
struct LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a CounterpartyChannelTransactionParameters from a byte array, created by CounterpartyChannelTransactionParameters_write
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CounterpartyChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelTransactionParameters object into a byte array which can be read by ChannelTransactionParameters_read
 */
struct LDKCVec_u8Z ChannelTransactionParameters_write(const struct LDKChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a ChannelTransactionParameters from a byte array, created by ChannelTransactionParameters_write
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ ChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DirectedChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void DirectedChannelTransactionParameters_free(struct LDKDirectedChannelTransactionParameters this_obj);

/**
 * Get the channel pubkeys for the broadcaster
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the channel pubkeys for the countersignatory
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_countersignatory_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the contest delay applicable to the transactions.
 * Note that the contest delay was selected by the countersignatory.
 */
MUST_USE_RES uint16_t DirectedChannelTransactionParameters_contest_delay(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Whether the channel is outbound from the broadcaster.
 *
 * The boolean representing the side that initiated the channel is
 * an input to the commitment number obscure factor computation.
 */
MUST_USE_RES bool DirectedChannelTransactionParameters_is_outbound(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * The funding outpoint
 */
MUST_USE_RES struct LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Whether to use anchors for this channel
 */
MUST_USE_RES bool DirectedChannelTransactionParameters_opt_anchors(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the HolderCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void HolderCommitmentTransaction_free(struct LDKHolderCommitmentTransaction this_obj);

/**
 * Our counterparty's signature for the transaction
 */
struct LDKSignature HolderCommitmentTransaction_get_counterparty_sig(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * Our counterparty's signature for the transaction
 */
void HolderCommitmentTransaction_set_counterparty_sig(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * All non-dust counterparty HTLC signatures, in the order they appear in the transaction
 *
 * Returns a copy of the field.
 */
struct LDKCVec_SignatureZ HolderCommitmentTransaction_get_counterparty_htlc_sigs(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * All non-dust counterparty HTLC signatures, in the order they appear in the transaction
 */
void HolderCommitmentTransaction_set_counterparty_htlc_sigs(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);

/**
 * Creates a copy of the HolderCommitmentTransaction
 */
struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(const struct LDKHolderCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the HolderCommitmentTransaction object into a byte array which can be read by HolderCommitmentTransaction_read
 */
struct LDKCVec_u8Z HolderCommitmentTransaction_write(const struct LDKHolderCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a HolderCommitmentTransaction from a byte array, created by HolderCommitmentTransaction_write
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ HolderCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Create a new holder transaction with the given counterparty signatures.
 * The funding keys are used to figure out which signature should go first when building the transaction for broadcast.
 */
MUST_USE_RES struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(struct LDKCommitmentTransaction commitment_tx, struct LDKSignature counterparty_sig, struct LDKCVec_SignatureZ counterparty_htlc_sigs, struct LDKPublicKey holder_funding_key, struct LDKPublicKey counterparty_funding_key);

/**
 * Frees any resources used by the BuiltCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void BuiltCommitmentTransaction_free(struct LDKBuiltCommitmentTransaction this_obj);

/**
 * The commitment transaction
 */
struct LDKTransaction BuiltCommitmentTransaction_get_transaction(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * The commitment transaction
 */
void BuiltCommitmentTransaction_set_transaction(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKTransaction val);

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
const uint8_t (*BuiltCommitmentTransaction_get_txid(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr))[32];

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
void BuiltCommitmentTransaction_set_txid(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new BuiltCommitmentTransaction given each field
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(struct LDKTransaction transaction_arg, struct LDKThirtyTwoBytes txid_arg);

/**
 * Creates a copy of the BuiltCommitmentTransaction
 */
struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the BuiltCommitmentTransaction object into a byte array which can be read by BuiltCommitmentTransaction_read
 */
struct LDKCVec_u8Z BuiltCommitmentTransaction_write(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a BuiltCommitmentTransaction from a byte array, created by BuiltCommitmentTransaction_write
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ BuiltCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Get the SIGHASH_ALL sighash value of the transaction.
 *
 * This can be used to verify a signature.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Sign a transaction, either because we are counter-signing the counterparty's transaction or
 * because we are about to broadcast a holder transaction.
 */
MUST_USE_RES struct LDKSignature BuiltCommitmentTransaction_sign(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Frees any resources used by the ClosingTransaction, if is_owned is set and inner is non-NULL.
 */
void ClosingTransaction_free(struct LDKClosingTransaction this_obj);

/**
 * Creates a copy of the ClosingTransaction
 */
struct LDKClosingTransaction ClosingTransaction_clone(const struct LDKClosingTransaction *NONNULL_PTR orig);

/**
 * Checks if two ClosingTransactions contain equal inner contents.
 */
uint64_t ClosingTransaction_hash(const struct LDKClosingTransaction *NONNULL_PTR o);

/**
 * Checks if two ClosingTransactions contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ClosingTransaction_eq(const struct LDKClosingTransaction *NONNULL_PTR a, const struct LDKClosingTransaction *NONNULL_PTR b);

/**
 * Construct an object of the class
 */
MUST_USE_RES struct LDKClosingTransaction ClosingTransaction_new(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);

/**
 * Trust our pre-built transaction.
 *
 * Applies a wrapper which allows access to the transaction.
 *
 * This should only be used if you fully trust the builder of this object. It should not
 * be used by an external signer - instead use the verify function.
 */
MUST_USE_RES struct LDKTrustedClosingTransaction ClosingTransaction_trust(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * Verify our pre-built transaction.
 *
 * Applies a wrapper which allows access to the transaction.
 *
 * An external validating signer must call this method before signing
 * or using the built transaction.
 */
MUST_USE_RES struct LDKCResult_TrustedClosingTransactionNoneZ ClosingTransaction_verify(const struct LDKClosingTransaction *NONNULL_PTR this_arg, struct LDKOutPoint funding_outpoint);

/**
 * The value to be sent to the holder, or zero if the output will be omitted
 */
MUST_USE_RES uint64_t ClosingTransaction_to_holder_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the counterparty, or zero if the output will be omitted
 */
MUST_USE_RES uint64_t ClosingTransaction_to_counterparty_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The destination of the holder's output
 */
MUST_USE_RES struct LDKu8slice ClosingTransaction_to_holder_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The destination of the counterparty's output
 */
MUST_USE_RES struct LDKu8slice ClosingTransaction_to_counterparty_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the TrustedClosingTransaction, if is_owned is set and inner is non-NULL.
 */
void TrustedClosingTransaction_free(struct LDKTrustedClosingTransaction this_obj);

/**
 * The pre-built Bitcoin commitment transaction
 */
MUST_USE_RES struct LDKTransaction TrustedClosingTransaction_built_transaction(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg);

/**
 * Get the SIGHASH_ALL sighash value of the transaction.
 *
 * This can be used to verify a signature.
 */
MUST_USE_RES struct LDKThirtyTwoBytes TrustedClosingTransaction_get_sighash_all(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Sign a transaction, either because we are counter-signing the counterparty's transaction or
 * because we are about to broadcast a holder transaction.
 */
MUST_USE_RES struct LDKSignature TrustedClosingTransaction_sign(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Frees any resources used by the CommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void CommitmentTransaction_free(struct LDKCommitmentTransaction this_obj);

/**
 * Creates a copy of the CommitmentTransaction
 */
struct LDKCommitmentTransaction CommitmentTransaction_clone(const struct LDKCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the CommitmentTransaction object into a byte array which can be read by CommitmentTransaction_read
 */
struct LDKCVec_u8Z CommitmentTransaction_write(const struct LDKCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a CommitmentTransaction from a byte array, created by CommitmentTransaction_write
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(struct LDKu8slice ser);

/**
 * The backwards-counting commitment number
 */
MUST_USE_RES uint64_t CommitmentTransaction_commitment_number(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the broadcaster
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_broadcaster_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the counterparty
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_countersignatory_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The feerate paid per 1000-weight-unit in this commitment transaction.
 */
MUST_USE_RES uint32_t CommitmentTransaction_feerate_per_kw(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Trust our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * This should only be used if you fully trust the builder of this object.  It should not
 * be used by an external signer - instead use the verify function.
 */
MUST_USE_RES struct LDKTrustedCommitmentTransaction CommitmentTransaction_trust(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Verify our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * An external validating signer must call this method before signing
 * or using the built transaction.
 */
MUST_USE_RES struct LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg, const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * Frees any resources used by the TrustedCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void TrustedCommitmentTransaction_free(struct LDKTrustedCommitmentTransaction this_obj);

/**
 * The transaction ID of the built Bitcoin transaction
 */
MUST_USE_RES struct LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-built Bitcoin commitment transaction
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-calculated transaction creation public keys.
 */
MUST_USE_RES struct LDKTxCreationKeys TrustedCommitmentTransaction_keys(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Should anchors be used.
 */
MUST_USE_RES bool TrustedCommitmentTransaction_opt_anchors(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Get a signature for each HTLC which was included in the commitment transaction (ie for
 * which HTLCOutputInCommitment::transaction_output_index.is_some()).
 *
 * The returned Vec has one entry for each HTLC, and in the same order.
 *
 * This function is only valid in the holder commitment context, it always uses EcdsaSighashType::All.
 */
MUST_USE_RES struct LDKCResult_CVec_SignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*htlc_base_key)[32], const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters);

/**
 * Commitment transaction numbers which appear in the transactions themselves are XOR'd with a
 * shared secret first. This prevents on-chain observers from discovering how many commitment
 * transactions occurred in a channel before it was closed.
 *
 * This function gets the shared secret from relevant channel public keys and can be used to
 * \"decrypt\" the commitment transaction number given a commitment transaction on-chain.
 */
uint64_t get_commitment_transaction_number_obscure_factor(struct LDKPublicKey broadcaster_payment_basepoint, struct LDKPublicKey countersignatory_payment_basepoint, bool outbound_from_broadcaster);

/**
 * Checks if two InitFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InitFeatures_eq(const struct LDKInitFeatures *NONNULL_PTR a, const struct LDKInitFeatures *NONNULL_PTR b);

/**
 * Checks if two NodeFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeFeatures_eq(const struct LDKNodeFeatures *NONNULL_PTR a, const struct LDKNodeFeatures *NONNULL_PTR b);

/**
 * Checks if two ChannelFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelFeatures_eq(const struct LDKChannelFeatures *NONNULL_PTR a, const struct LDKChannelFeatures *NONNULL_PTR b);

/**
 * Checks if two InvoiceFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InvoiceFeatures_eq(const struct LDKInvoiceFeatures *NONNULL_PTR a, const struct LDKInvoiceFeatures *NONNULL_PTR b);

/**
 * Checks if two OfferFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OfferFeatures_eq(const struct LDKOfferFeatures *NONNULL_PTR a, const struct LDKOfferFeatures *NONNULL_PTR b);

/**
 * Checks if two InvoiceRequestFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InvoiceRequestFeatures_eq(const struct LDKInvoiceRequestFeatures *NONNULL_PTR a, const struct LDKInvoiceRequestFeatures *NONNULL_PTR b);

/**
 * Checks if two ChannelTypeFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelTypeFeatures_eq(const struct LDKChannelTypeFeatures *NONNULL_PTR a, const struct LDKChannelTypeFeatures *NONNULL_PTR b);

/**
 * Creates a copy of the InitFeatures
 */
struct LDKInitFeatures InitFeatures_clone(const struct LDKInitFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the NodeFeatures
 */
struct LDKNodeFeatures NodeFeatures_clone(const struct LDKNodeFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the ChannelFeatures
 */
struct LDKChannelFeatures ChannelFeatures_clone(const struct LDKChannelFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the InvoiceFeatures
 */
struct LDKInvoiceFeatures InvoiceFeatures_clone(const struct LDKInvoiceFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the OfferFeatures
 */
struct LDKOfferFeatures OfferFeatures_clone(const struct LDKOfferFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the InvoiceRequestFeatures
 */
struct LDKInvoiceRequestFeatures InvoiceRequestFeatures_clone(const struct LDKInvoiceRequestFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the ChannelTypeFeatures
 */
struct LDKChannelTypeFeatures ChannelTypeFeatures_clone(const struct LDKChannelTypeFeatures *NONNULL_PTR orig);

/**
 * Frees any resources used by the InitFeatures, if is_owned is set and inner is non-NULL.
 */
void InitFeatures_free(struct LDKInitFeatures this_obj);

/**
 * Frees any resources used by the NodeFeatures, if is_owned is set and inner is non-NULL.
 */
void NodeFeatures_free(struct LDKNodeFeatures this_obj);

/**
 * Frees any resources used by the ChannelFeatures, if is_owned is set and inner is non-NULL.
 */
void ChannelFeatures_free(struct LDKChannelFeatures this_obj);

/**
 * Frees any resources used by the InvoiceFeatures, if is_owned is set and inner is non-NULL.
 */
void InvoiceFeatures_free(struct LDKInvoiceFeatures this_obj);

/**
 * Frees any resources used by the OfferFeatures, if is_owned is set and inner is non-NULL.
 */
void OfferFeatures_free(struct LDKOfferFeatures this_obj);

/**
 * Frees any resources used by the InvoiceRequestFeatures, if is_owned is set and inner is non-NULL.
 */
void InvoiceRequestFeatures_free(struct LDKInvoiceRequestFeatures this_obj);

/**
 * Frees any resources used by the ChannelTypeFeatures, if is_owned is set and inner is non-NULL.
 */
void ChannelTypeFeatures_free(struct LDKChannelTypeFeatures this_obj);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInitFeatures InitFeatures_empty(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool InitFeatures_requires_unknown_bits(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKNodeFeatures NodeFeatures_empty(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool NodeFeatures_requires_unknown_bits(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_empty(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool ChannelFeatures_requires_unknown_bits(const struct LDKChannelFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_empty(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool InvoiceFeatures_requires_unknown_bits(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKOfferFeatures OfferFeatures_empty(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool OfferFeatures_requires_unknown_bits(const struct LDKOfferFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInvoiceRequestFeatures InvoiceRequestFeatures_empty(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool InvoiceRequestFeatures_requires_unknown_bits(const struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_empty(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_unknown_bits(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Serialize the InitFeatures object into a byte array which can be read by InitFeatures_read
 */
struct LDKCVec_u8Z InitFeatures_write(const struct LDKInitFeatures *NONNULL_PTR obj);

/**
 * Read a InitFeatures from a byte array, created by InitFeatures_write
 */
struct LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelFeatures object into a byte array which can be read by ChannelFeatures_read
 */
struct LDKCVec_u8Z ChannelFeatures_write(const struct LDKChannelFeatures *NONNULL_PTR obj);

/**
 * Read a ChannelFeatures from a byte array, created by ChannelFeatures_write
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the NodeFeatures object into a byte array which can be read by NodeFeatures_read
 */
struct LDKCVec_u8Z NodeFeatures_write(const struct LDKNodeFeatures *NONNULL_PTR obj);

/**
 * Read a NodeFeatures from a byte array, created by NodeFeatures_write
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the InvoiceFeatures object into a byte array which can be read by InvoiceFeatures_read
 */
struct LDKCVec_u8Z InvoiceFeatures_write(const struct LDKInvoiceFeatures *NONNULL_PTR obj);

/**
 * Read a InvoiceFeatures from a byte array, created by InvoiceFeatures_write
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ InvoiceFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelTypeFeatures object into a byte array which can be read by ChannelTypeFeatures_read
 */
struct LDKCVec_u8Z ChannelTypeFeatures_write(const struct LDKChannelTypeFeatures *NONNULL_PTR obj);

/**
 * Read a ChannelTypeFeatures from a byte array, created by ChannelTypeFeatures_write
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ ChannelTypeFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the OfferFeatures object into a byte array which can be read by OfferFeatures_read
 */
struct LDKCVec_u8Z OfferFeatures_write(const struct LDKOfferFeatures *NONNULL_PTR obj);

/**
 * Read a OfferFeatures from a byte array, created by OfferFeatures_write
 */
struct LDKCResult_OfferFeaturesDecodeErrorZ OfferFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the InvoiceRequestFeatures object into a byte array which can be read by InvoiceRequestFeatures_read
 */
struct LDKCVec_u8Z InvoiceRequestFeatures_write(const struct LDKInvoiceRequestFeatures *NONNULL_PTR obj);

/**
 * Read a InvoiceRequestFeatures from a byte array, created by InvoiceRequestFeatures_write
 */
struct LDKCResult_InvoiceRequestFeaturesDecodeErrorZ InvoiceRequestFeatures_read(struct LDKu8slice ser);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_data_loss_protect_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_data_loss_protect_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_data_loss_protect(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_data_loss_protect_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_data_loss_protect_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_data_loss_protect(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_data_loss_protect(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_data_loss_protect(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_initial_routing_sync_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_initial_routing_sync_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_initial_routing_sync(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_upfront_shutdown_script_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_upfront_shutdown_script_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_upfront_shutdown_script(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_upfront_shutdown_script_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_upfront_shutdown_script_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_upfront_shutdown_script(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_upfront_shutdown_script(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_upfront_shutdown_script(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_gossip_queries_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_gossip_queries_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_gossip_queries(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_gossip_queries_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_gossip_queries_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_gossip_queries(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_gossip_queries(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_gossip_queries(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_variable_length_onion_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_variable_length_onion_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_variable_length_onion(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_variable_length_onion_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_variable_length_onion_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_variable_length_onion(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InvoiceFeatures_set_variable_length_onion_optional(struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InvoiceFeatures_set_variable_length_onion_required(struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InvoiceFeatures_supports_variable_length_onion(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_variable_length_onion(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_variable_length_onion(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InvoiceFeatures_requires_variable_length_onion(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_static_remote_key_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_static_remote_key_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_static_remote_key(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_static_remote_key_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_static_remote_key_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_static_remote_key(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_static_remote_key_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_static_remote_key_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_static_remote_key(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_static_remote_key(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_static_remote_key(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_static_remote_key(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_payment_secret_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_payment_secret_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_payment_secret(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_payment_secret_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_payment_secret_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_payment_secret(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InvoiceFeatures_set_payment_secret_optional(struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InvoiceFeatures_set_payment_secret_required(struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InvoiceFeatures_supports_payment_secret(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_payment_secret(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_payment_secret(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InvoiceFeatures_requires_payment_secret(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_basic_mpp_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_basic_mpp_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_basic_mpp(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_basic_mpp_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_basic_mpp_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_basic_mpp(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InvoiceFeatures_set_basic_mpp_optional(struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InvoiceFeatures_set_basic_mpp_required(struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InvoiceFeatures_supports_basic_mpp(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_basic_mpp(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_basic_mpp(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InvoiceFeatures_requires_basic_mpp(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_wumbo_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_wumbo_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_wumbo(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_wumbo_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_wumbo_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_wumbo(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_wumbo(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_wumbo(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_shutdown_any_segwit_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_shutdown_any_segwit_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_shutdown_anysegwit(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_shutdown_any_segwit_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_shutdown_any_segwit_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_shutdown_anysegwit(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_shutdown_anysegwit(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_shutdown_anysegwit(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_onion_messages_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_onion_messages_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_onion_messages(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_onion_messages_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_onion_messages_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_onion_messages(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_onion_messages(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_onion_messages(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_channel_type_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_channel_type_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_channel_type(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_channel_type_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_channel_type_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_channel_type(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_channel_type(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_channel_type(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_scid_privacy_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_scid_privacy_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_scid_privacy(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_scid_privacy_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_scid_privacy_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_scid_privacy(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_scid_privacy_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_scid_privacy_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_scid_privacy(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_scid_privacy(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_scid_privacy(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_scid_privacy(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_zero_conf_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_zero_conf_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_zero_conf(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_zero_conf_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_zero_conf_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_zero_conf(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_zero_conf_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_zero_conf_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_zero_conf(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_zero_conf(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_zero_conf(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_zero_conf(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_keysend_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_keysend_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_keysend(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_keysend(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ShutdownScript, if is_owned is set and inner is non-NULL.
 */
void ShutdownScript_free(struct LDKShutdownScript this_obj);

/**
 * Creates a copy of the ShutdownScript
 */
struct LDKShutdownScript ShutdownScript_clone(const struct LDKShutdownScript *NONNULL_PTR orig);

/**
 * Checks if two ShutdownScripts contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ShutdownScript_eq(const struct LDKShutdownScript *NONNULL_PTR a, const struct LDKShutdownScript *NONNULL_PTR b);

/**
 * Frees any resources used by the InvalidShutdownScript, if is_owned is set and inner is non-NULL.
 */
void InvalidShutdownScript_free(struct LDKInvalidShutdownScript this_obj);

/**
 * The script that did not meet the requirements from [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
 */
struct LDKu8slice InvalidShutdownScript_get_script(const struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr);

/**
 * The script that did not meet the requirements from [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
 */
void InvalidShutdownScript_set_script(struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new InvalidShutdownScript given each field
 */
MUST_USE_RES struct LDKInvalidShutdownScript InvalidShutdownScript_new(struct LDKCVec_u8Z script_arg);

/**
 * Creates a copy of the InvalidShutdownScript
 */
struct LDKInvalidShutdownScript InvalidShutdownScript_clone(const struct LDKInvalidShutdownScript *NONNULL_PTR orig);

/**
 * Serialize the ShutdownScript object into a byte array which can be read by ShutdownScript_read
 */
struct LDKCVec_u8Z ShutdownScript_write(const struct LDKShutdownScript *NONNULL_PTR obj);

/**
 * Read a ShutdownScript from a byte array, created by ShutdownScript_write
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ ShutdownScript_read(struct LDKu8slice ser);

/**
 * Generates a P2WPKH script pubkey from the given [`WPubkeyHash`].
 */
MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wpkh(const uint8_t (*pubkey_hash)[20]);

/**
 * Generates a P2WSH script pubkey from the given [`WScriptHash`].
 */
MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wsh(const uint8_t (*script_hash)[32]);

/**
 * Generates a witness script pubkey from the given segwit version and program.
 *
 * Note for version-zero witness scripts you must use [`ShutdownScript::new_p2wpkh`] or
 * [`ShutdownScript::new_p2wsh`] instead.
 *
 * # Errors
 *
 * This function may return an error if `program` is invalid for the segwit `version`.
 */
MUST_USE_RES struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ ShutdownScript_new_witness_program(struct LDKWitnessVersion version, struct LDKu8slice program);

/**
 * Converts the shutdown script into the underlying [`Script`].
 */
MUST_USE_RES struct LDKCVec_u8Z ShutdownScript_into_inner(struct LDKShutdownScript this_arg);

/**
 * Returns the [`PublicKey`] used for a P2WPKH shutdown script if constructed directly from it.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPublicKey ShutdownScript_as_legacy_pubkey(const struct LDKShutdownScript *NONNULL_PTR this_arg);

/**
 * Returns whether the shutdown script is compatible with the features as defined by BOLT #2.
 *
 * Specifically, checks for compliance with feature `option_shutdown_anysegwit`.
 */
MUST_USE_RES bool ShutdownScript_is_compatible(const struct LDKShutdownScript *NONNULL_PTR this_arg, const struct LDKInitFeatures *NONNULL_PTR features);

/**
 * Calls the free function if one is set
 */
void CustomMessageReader_free(struct LDKCustomMessageReader this_ptr);

/**
 * Creates a copy of a Type
 */
struct LDKType Type_clone(const struct LDKType *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Type_free(struct LDKType this_ptr);

/**
 * Frees any resources used by the NodeId, if is_owned is set and inner is non-NULL.
 */
void NodeId_free(struct LDKNodeId this_obj);

/**
 * Creates a copy of the NodeId
 */
struct LDKNodeId NodeId_clone(const struct LDKNodeId *NONNULL_PTR orig);

/**
 * Create a new NodeId from a public key
 */
MUST_USE_RES struct LDKNodeId NodeId_from_pubkey(struct LDKPublicKey pubkey);

/**
 * Get the public key slice from this NodeId
 */
MUST_USE_RES struct LDKu8slice NodeId_as_slice(const struct LDKNodeId *NONNULL_PTR this_arg);

/**
 * Checks if two NodeIds contain equal inner contents.
 */
uint64_t NodeId_hash(const struct LDKNodeId *NONNULL_PTR o);

/**
 * Serialize the NodeId object into a byte array which can be read by NodeId_read
 */
struct LDKCVec_u8Z NodeId_write(const struct LDKNodeId *NONNULL_PTR obj);

/**
 * Read a NodeId from a byte array, created by NodeId_write
 */
struct LDKCResult_NodeIdDecodeErrorZ NodeId_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NetworkGraph, if is_owned is set and inner is non-NULL.
 */
void NetworkGraph_free(struct LDKNetworkGraph this_obj);

/**
 * Frees any resources used by the ReadOnlyNetworkGraph, if is_owned is set and inner is non-NULL.
 */
void ReadOnlyNetworkGraph_free(struct LDKReadOnlyNetworkGraph this_obj);

/**
 * Frees any resources used by the NetworkUpdate
 */
void NetworkUpdate_free(struct LDKNetworkUpdate this_ptr);

/**
 * Creates a copy of the NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_clone(const struct LDKNetworkUpdate *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ChannelUpdateMessage-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_channel_update_message(struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new ChannelFailure-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_channel_failure(uint64_t short_channel_id, bool is_permanent);

/**
 * Utility method to constructs a new NodeFailure-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_node_failure(struct LDKPublicKey node_id, bool is_permanent);

/**
 * Checks if two NetworkUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool NetworkUpdate_eq(const struct LDKNetworkUpdate *NONNULL_PTR a, const struct LDKNetworkUpdate *NONNULL_PTR b);

/**
 * Serialize the NetworkUpdate object into a byte array which can be read by NetworkUpdate_read
 */
struct LDKCVec_u8Z NetworkUpdate_write(const struct LDKNetworkUpdate *NONNULL_PTR obj);

/**
 * Read a NetworkUpdate from a byte array, created by NetworkUpdate_write
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ NetworkUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the P2PGossipSync, if is_owned is set and inner is non-NULL.
 */
void P2PGossipSync_free(struct LDKP2PGossipSync this_obj);

/**
 * Creates a new tracker of the actual state of the network of channels and nodes,
 * assuming an existing Network Graph.
 * Chain monitor is used to make sure announced channels exist on-chain,
 * channel data is correct, and that the announcement is signed with
 * channel owners' keys.
 */
MUST_USE_RES struct LDKP2PGossipSync P2PGossipSync_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCOption_AccessZ chain_access, struct LDKLogger logger);

/**
 * Adds a provider used to check new announcements. Does not affect
 * existing announcements unless they are updated.
 * Add, update or remove the provider would replace the current one.
 */
void P2PGossipSync_add_chain_access(struct LDKP2PGossipSync *NONNULL_PTR this_arg, struct LDKCOption_AccessZ chain_access);

/**
 * Handles any network updates originating from [`Event`]s.
 *
 * [`Event`]: crate::util::events::Event
 */
void NetworkGraph_handle_network_update(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNetworkUpdate *NONNULL_PTR network_update);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler P2PGossipSync_as_RoutingMessageHandler(const struct LDKP2PGossipSync *NONNULL_PTR this_arg);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider P2PGossipSync_as_MessageSendEventsProvider(const struct LDKP2PGossipSync *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelUpdateInfo, if is_owned is set and inner is non-NULL.
 */
void ChannelUpdateInfo_free(struct LDKChannelUpdateInfo this_obj);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t ChannelUpdateInfo_get_last_update(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
void ChannelUpdateInfo_set_last_update(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
bool ChannelUpdateInfo_get_enabled(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
void ChannelUpdateInfo_set_enabled(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, bool val);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
uint16_t ChannelUpdateInfo_get_cltv_expiry_delta(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
void ChannelUpdateInfo_set_cltv_expiry_delta(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
uint64_t ChannelUpdateInfo_get_htlc_minimum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
void ChannelUpdateInfo_set_htlc_minimum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum value which may be relayed to the next hop via the channel.
 */
uint64_t ChannelUpdateInfo_get_htlc_maximum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The maximum value which may be relayed to the next hop via the channel.
 */
void ChannelUpdateInfo_set_htlc_maximum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Fees charged when the channel is used for routing
 */
struct LDKRoutingFees ChannelUpdateInfo_get_fees(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Fees charged when the channel is used for routing
 */
void ChannelUpdateInfo_set_fees(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdate ChannelUpdateInfo_get_last_update_message(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelUpdateInfo_set_last_update_message(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdate val);

/**
 * Constructs a new ChannelUpdateInfo given each field
 */
MUST_USE_RES struct LDKChannelUpdateInfo ChannelUpdateInfo_new(uint32_t last_update_arg, bool enabled_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, uint64_t htlc_maximum_msat_arg, struct LDKRoutingFees fees_arg, struct LDKChannelUpdate last_update_message_arg);

/**
 * Creates a copy of the ChannelUpdateInfo
 */
struct LDKChannelUpdateInfo ChannelUpdateInfo_clone(const struct LDKChannelUpdateInfo *NONNULL_PTR orig);

/**
 * Checks if two ChannelUpdateInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelUpdateInfo_eq(const struct LDKChannelUpdateInfo *NONNULL_PTR a, const struct LDKChannelUpdateInfo *NONNULL_PTR b);

/**
 * Serialize the ChannelUpdateInfo object into a byte array which can be read by ChannelUpdateInfo_read
 */
struct LDKCVec_u8Z ChannelUpdateInfo_write(const struct LDKChannelUpdateInfo *NONNULL_PTR obj);

/**
 * Read a ChannelUpdateInfo from a byte array, created by ChannelUpdateInfo_write
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ ChannelUpdateInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelInfo, if is_owned is set and inner is non-NULL.
 */
void ChannelInfo_free(struct LDKChannelInfo this_obj);

/**
 * Protocol features of a channel communicated during its announcement
 */
struct LDKChannelFeatures ChannelInfo_get_features(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features of a channel communicated during its announcement
 */
void ChannelInfo_set_features(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * Source node of the first direction of a channel
 */
struct LDKNodeId ChannelInfo_get_node_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the first direction of a channel
 */
void ChannelInfo_set_node_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * Details about the first direction of a channel
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdateInfo ChannelInfo_get_one_to_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the first direction of a channel
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_one_to_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);

/**
 * Source node of the second direction of a channel
 */
struct LDKNodeId ChannelInfo_get_node_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the second direction of a channel
 */
void ChannelInfo_set_node_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * Details about the second direction of a channel
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdateInfo ChannelInfo_get_two_to_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the second direction of a channel
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_two_to_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);

/**
 * The channel capacity as seen on-chain, if chain lookup is available.
 */
struct LDKCOption_u64Z ChannelInfo_get_capacity_sats(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * The channel capacity as seen on-chain, if chain lookup is available.
 */
void ChannelInfo_set_capacity_sats(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelAnnouncement ChannelInfo_get_announcement_message(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_announcement_message(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelAnnouncement val);

/**
 * Creates a copy of the ChannelInfo
 */
struct LDKChannelInfo ChannelInfo_clone(const struct LDKChannelInfo *NONNULL_PTR orig);

/**
 * Checks if two ChannelInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelInfo_eq(const struct LDKChannelInfo *NONNULL_PTR a, const struct LDKChannelInfo *NONNULL_PTR b);

/**
 * Returns a [`ChannelUpdateInfo`] based on the direction implied by the channel_flag.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelUpdateInfo ChannelInfo_get_directional_info(const struct LDKChannelInfo *NONNULL_PTR this_arg, uint8_t channel_flags);

/**
 * Serialize the ChannelInfo object into a byte array which can be read by ChannelInfo_read
 */
struct LDKCVec_u8Z ChannelInfo_write(const struct LDKChannelInfo *NONNULL_PTR obj);

/**
 * Read a ChannelInfo from a byte array, created by ChannelInfo_write
 */
struct LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DirectedChannelInfo, if is_owned is set and inner is non-NULL.
 */
void DirectedChannelInfo_free(struct LDKDirectedChannelInfo this_obj);

/**
 * Creates a copy of the DirectedChannelInfo
 */
struct LDKDirectedChannelInfo DirectedChannelInfo_clone(const struct LDKDirectedChannelInfo *NONNULL_PTR orig);

/**
 * Returns information for the channel.
 */
MUST_USE_RES struct LDKChannelInfo DirectedChannelInfo_channel(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Returns the maximum HTLC amount allowed over the channel in the direction.
 */
MUST_USE_RES uint64_t DirectedChannelInfo_htlc_maximum_msat(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Returns the [`EffectiveCapacity`] of the channel in the direction.
 *
 * This is either the total capacity from the funding transaction, if known, or the
 * `htlc_maximum_msat` for the direction as advertised by the gossip network, if known,
 * otherwise.
 */
MUST_USE_RES struct LDKEffectiveCapacity DirectedChannelInfo_effective_capacity(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the EffectiveCapacity
 */
void EffectiveCapacity_free(struct LDKEffectiveCapacity this_ptr);

/**
 * Creates a copy of the EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_clone(const struct LDKEffectiveCapacity *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ExactLiquidity-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_exact_liquidity(uint64_t liquidity_msat);

/**
 * Utility method to constructs a new MaximumHTLC-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_maximum_htlc(uint64_t amount_msat);

/**
 * Utility method to constructs a new Total-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_total(uint64_t capacity_msat, uint64_t htlc_maximum_msat);

/**
 * Utility method to constructs a new Infinite-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_infinite(void);

/**
 * Utility method to constructs a new Unknown-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_unknown(void);

/**
 * Returns the effective capacity denominated in millisatoshi.
 */
MUST_USE_RES uint64_t EffectiveCapacity_as_msat(const struct LDKEffectiveCapacity *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the RoutingFees, if is_owned is set and inner is non-NULL.
 */
void RoutingFees_free(struct LDKRoutingFees this_obj);

/**
 * Flat routing fee in satoshis
 */
uint32_t RoutingFees_get_base_msat(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Flat routing fee in satoshis
 */
void RoutingFees_set_base_msat(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
uint32_t RoutingFees_get_proportional_millionths(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
void RoutingFees_set_proportional_millionths(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RoutingFees given each field
 */
MUST_USE_RES struct LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);

/**
 * Checks if two RoutingFeess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RoutingFees_eq(const struct LDKRoutingFees *NONNULL_PTR a, const struct LDKRoutingFees *NONNULL_PTR b);

/**
 * Creates a copy of the RoutingFees
 */
struct LDKRoutingFees RoutingFees_clone(const struct LDKRoutingFees *NONNULL_PTR orig);

/**
 * Checks if two RoutingFeess contain equal inner contents.
 */
uint64_t RoutingFees_hash(const struct LDKRoutingFees *NONNULL_PTR o);

/**
 * Serialize the RoutingFees object into a byte array which can be read by RoutingFees_read
 */
struct LDKCVec_u8Z RoutingFees_write(const struct LDKRoutingFees *NONNULL_PTR obj);

/**
 * Read a RoutingFees from a byte array, created by RoutingFees_write
 */
struct LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeAnnouncementInfo, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncementInfo_free(struct LDKNodeAnnouncementInfo this_obj);

/**
 * Protocol features the node announced support for
 */
struct LDKNodeFeatures NodeAnnouncementInfo_get_features(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features the node announced support for
 */
void NodeAnnouncementInfo_set_features(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t NodeAnnouncementInfo_get_last_update(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
void NodeAnnouncementInfo_set_last_update(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Color assigned to the node
 */
const uint8_t (*NodeAnnouncementInfo_get_rgb(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[3];

/**
 * Color assigned to the node
 */
void NodeAnnouncementInfo_set_rgb(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
struct LDKNodeAlias NodeAnnouncementInfo_get_alias(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
void NodeAnnouncementInfo_set_alias(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAlias val);

/**
 * Internet-level addresses via which one can connect to the node
 *
 * Returns a copy of the field.
 */
struct LDKCVec_NetAddressZ NodeAnnouncementInfo_get_addresses(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * Internet-level addresses via which one can connect to the node
 */
void NodeAnnouncementInfo_set_addresses(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void NodeAnnouncementInfo_set_announcement_message(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncementInfo given each field
 */
MUST_USE_RES struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(struct LDKNodeFeatures features_arg, uint32_t last_update_arg, struct LDKThreeBytes rgb_arg, struct LDKNodeAlias alias_arg, struct LDKCVec_NetAddressZ addresses_arg, struct LDKNodeAnnouncement announcement_message_arg);

/**
 * Creates a copy of the NodeAnnouncementInfo
 */
struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(const struct LDKNodeAnnouncementInfo *NONNULL_PTR orig);

/**
 * Checks if two NodeAnnouncementInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeAnnouncementInfo_eq(const struct LDKNodeAnnouncementInfo *NONNULL_PTR a, const struct LDKNodeAnnouncementInfo *NONNULL_PTR b);

/**
 * Serialize the NodeAnnouncementInfo object into a byte array which can be read by NodeAnnouncementInfo_read
 */
struct LDKCVec_u8Z NodeAnnouncementInfo_write(const struct LDKNodeAnnouncementInfo *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncementInfo from a byte array, created by NodeAnnouncementInfo_write
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeAlias, if is_owned is set and inner is non-NULL.
 */
void NodeAlias_free(struct LDKNodeAlias this_obj);

const uint8_t (*NodeAlias_get_a(const struct LDKNodeAlias *NONNULL_PTR this_ptr))[32];

void NodeAlias_set_a(struct LDKNodeAlias *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new NodeAlias given each field
 */
MUST_USE_RES struct LDKNodeAlias NodeAlias_new(struct LDKThirtyTwoBytes a_arg);

/**
 * Creates a copy of the NodeAlias
 */
struct LDKNodeAlias NodeAlias_clone(const struct LDKNodeAlias *NONNULL_PTR orig);

/**
 * Checks if two NodeAliass contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeAlias_eq(const struct LDKNodeAlias *NONNULL_PTR a, const struct LDKNodeAlias *NONNULL_PTR b);

/**
 * Serialize the NodeAlias object into a byte array which can be read by NodeAlias_read
 */
struct LDKCVec_u8Z NodeAlias_write(const struct LDKNodeAlias *NONNULL_PTR obj);

/**
 * Read a NodeAlias from a byte array, created by NodeAlias_write
 */
struct LDKCResult_NodeAliasDecodeErrorZ NodeAlias_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeInfo, if is_owned is set and inner is non-NULL.
 */
void NodeInfo_free(struct LDKNodeInfo this_obj);

/**
 * All valid channels a node has announced
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u64Z NodeInfo_get_channels(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * All valid channels a node has announced
 */
void NodeInfo_set_channels(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Lowest fees enabling routing via any of the enabled, known channels to a node.
 * The two fields (flat and proportional fee) are independent,
 * meaning they don't have to refer to the same channel.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKRoutingFees NodeInfo_get_lowest_inbound_channel_fees(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * Lowest fees enabling routing via any of the enabled, known channels to a node.
 * The two fields (flat and proportional fee) are independent,
 * meaning they don't have to refer to the same channel.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void NodeInfo_set_lowest_inbound_channel_fees(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void NodeInfo_set_announcement_info(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncementInfo val);

/**
 * Constructs a new NodeInfo given each field
 */
MUST_USE_RES struct LDKNodeInfo NodeInfo_new(struct LDKCVec_u64Z channels_arg, struct LDKRoutingFees lowest_inbound_channel_fees_arg, struct LDKNodeAnnouncementInfo announcement_info_arg);

/**
 * Creates a copy of the NodeInfo
 */
struct LDKNodeInfo NodeInfo_clone(const struct LDKNodeInfo *NONNULL_PTR orig);

/**
 * Checks if two NodeInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeInfo_eq(const struct LDKNodeInfo *NONNULL_PTR a, const struct LDKNodeInfo *NONNULL_PTR b);

/**
 * Serialize the NodeInfo object into a byte array which can be read by NodeInfo_read
 */
struct LDKCVec_u8Z NodeInfo_write(const struct LDKNodeInfo *NONNULL_PTR obj);

/**
 * Read a NodeInfo from a byte array, created by NodeInfo_write
 */
struct LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(struct LDKu8slice ser);

/**
 * Serialize the NetworkGraph object into a byte array which can be read by NetworkGraph_read
 */
struct LDKCVec_u8Z NetworkGraph_write(const struct LDKNetworkGraph *NONNULL_PTR obj);

/**
 * Read a NetworkGraph from a byte array, created by NetworkGraph_write
 */
struct LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(struct LDKu8slice ser, struct LDKLogger arg);

/**
 * Creates a new, empty, network graph.
 */
MUST_USE_RES struct LDKNetworkGraph NetworkGraph_new(struct LDKThirtyTwoBytes genesis_hash, struct LDKLogger logger);

/**
 * Returns a read-only view of the network graph.
 */
MUST_USE_RES struct LDKReadOnlyNetworkGraph NetworkGraph_read_only(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * The unix timestamp provided by the most recent rapid gossip sync.
 * It will be set by the rapid sync process after every sync completion.
 */
MUST_USE_RES struct LDKCOption_u32Z NetworkGraph_get_last_rapid_gossip_sync_timestamp(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * Update the unix timestamp provided by the most recent rapid gossip sync.
 * This should be done automatically by the rapid sync process after every sync completion.
 */
void NetworkGraph_set_last_rapid_gossip_sync_timestamp(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint32_t last_rapid_gossip_sync_timestamp);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement.
 *
 * You probably don't want to call this directly, instead relying on a P2PGossipSync's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement without verifying the associated signatures. Because we aren't
 * given the associated signatures here we cannot relay the node announcement to any of our
 * peers.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR msg);

/**
 * Store or update channel info from a channel announcement.
 *
 * You probably don't want to call this directly, instead relying on a P2PGossipSync's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_AccessZ chain_access);

/**
 * Store or update channel info from a channel announcement without verifying the associated
 * signatures. Because we aren't given the associated signatures here we cannot relay the
 * channel announcement to any of our peers.
 *
 * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_AccessZ chain_access);

/**
 * Update channel from partial announcement data received via rapid gossip sync
 *
 * `timestamp: u64`: Timestamp emulating the backdated original announcement receipt (by the
 * rapid gossip sync server)
 *
 * All other parameters as used in [`msgs::UnsignedChannelAnnouncement`] fields.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_add_channel_from_partial_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, uint64_t timestamp, struct LDKChannelFeatures features, struct LDKPublicKey node_id_1, struct LDKPublicKey node_id_2);

/**
 * Marks a channel in the graph as failed if a corresponding HTLC fail was sent.
 * If permanent, removes a channel from the local storage.
 * May cause the removal of nodes too, if this was their last channel.
 * If not permanent, makes channels unavailable for routing.
 */
void NetworkGraph_channel_failed(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, bool is_permanent);

/**
 * Marks a node in the graph as permanently failed, effectively removing it and its channels
 * from local storage.
 */
void NetworkGraph_node_failed_permanent(const struct LDKNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey node_id);

/**
 * Removes information about channels that we haven't heard any updates about in some time.
 * This can be used regularly to prune the network graph of channels that likely no longer
 * exist.
 *
 * While there is no formal requirement that nodes regularly re-broadcast their channel
 * updates every two weeks, the non-normative section of BOLT 7 currently suggests that
 * pruning occur for updates which are at least two weeks old, which we implement here.
 *
 * Note that for users of the `lightning-background-processor` crate this method may be
 * automatically called regularly for you.
 *
 * This method will also cause us to stop tracking removed nodes and channels if they have been
 * in the map for a while so that these can be resynced from gossip in the future.
 *
 * This method is only available with the `std` feature. See
 * [`NetworkGraph::remove_stale_channels_and_tracking_with_time`] for `no-std` use.
 */
void NetworkGraph_remove_stale_channels_and_tracking(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * Removes information about channels that we haven't heard any updates about in some time.
 * This can be used regularly to prune the network graph of channels that likely no longer
 * exist.
 *
 * While there is no formal requirement that nodes regularly re-broadcast their channel
 * updates every two weeks, the non-normative section of BOLT 7 currently suggests that
 * pruning occur for updates which are at least two weeks old, which we implement here.
 *
 * This method will also cause us to stop tracking removed nodes and channels if they have been
 * in the map for a while so that these can be resynced from gossip in the future.
 *
 * This function takes the current unix time as an argument. For users with the `std` feature
 * enabled, [`NetworkGraph::remove_stale_channels_and_tracking`] may be preferable.
 */
void NetworkGraph_remove_stale_channels_and_tracking_with_time(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t current_time_unix);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel.
 *
 * You probably don't want to call this directly, instead relying on a P2PGossipSync's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * If built with `no-std`, any updates with a timestamp more than two weeks in the past or
 * materially in the future will be rejected.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel without verifying the associated signatures. Because we aren't given the
 * associated signatures here we cannot relay the channel update to any of our peers.
 *
 * If built with `no-std`, any updates with a timestamp more than two weeks in the past or
 * materially in the future will be rejected.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelUpdate *NONNULL_PTR msg);

/**
 * Returns information on a channel with the given id.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelInfo ReadOnlyNetworkGraph_channel(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id);

/**
 * Returns the list of channels in the graph
 */
MUST_USE_RES struct LDKCVec_u64Z ReadOnlyNetworkGraph_list_channels(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg);

/**
 * Returns information on a node with the given id.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKNodeInfo ReadOnlyNetworkGraph_node(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);

/**
 * Returns the list of nodes in the graph
 */
MUST_USE_RES struct LDKCVec_NodeIdZ ReadOnlyNetworkGraph_list_nodes(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg);

/**
 * Get network addresses by node id.
 * Returns None if the requested node is completely unknown,
 * or if node announcement for the node was never received.
 */
MUST_USE_RES struct LDKCOption_CVec_NetAddressZZ ReadOnlyNetworkGraph_get_addresses(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey pubkey);

/**
 * Frees any resources used by the DefaultRouter, if is_owned is set and inner is non-NULL.
 */
void DefaultRouter_free(struct LDKDefaultRouter this_obj);

/**
 * Creates a new router.
 */
MUST_USE_RES struct LDKDefaultRouter DefaultRouter_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger, struct LDKThirtyTwoBytes random_seed_bytes, struct LDKLockableScore scorer);

/**
 * Constructs a new Router which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Router must be freed before this_arg is
 */
struct LDKRouter DefaultRouter_as_Router(const struct LDKDefaultRouter *NONNULL_PTR this_arg);

/**
 * Calls the free function if one is set
 */
void Router_free(struct LDKRouter this_ptr);

/**
 * Frees any resources used by the ScorerAccountingForInFlightHtlcs, if is_owned is set and inner is non-NULL.
 */
void ScorerAccountingForInFlightHtlcs_free(struct LDKScorerAccountingForInFlightHtlcs this_obj);

/**
 * Initialize a new `ScorerAccountingForInFlightHtlcs`.
 */
MUST_USE_RES struct LDKScorerAccountingForInFlightHtlcs ScorerAccountingForInFlightHtlcs_new(struct LDKScore scorer, struct LDKInFlightHtlcs inflight_htlcs);

/**
 * Serialize the ScorerAccountingForInFlightHtlcs object into a byte array which can be read by ScorerAccountingForInFlightHtlcs_read
 */
struct LDKCVec_u8Z ScorerAccountingForInFlightHtlcs_write(const struct LDKScorerAccountingForInFlightHtlcs *NONNULL_PTR obj);

/**
 * Constructs a new Score which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
 */
struct LDKScore ScorerAccountingForInFlightHtlcs_as_Score(const struct LDKScorerAccountingForInFlightHtlcs *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the InFlightHtlcs, if is_owned is set and inner is non-NULL.
 */
void InFlightHtlcs_free(struct LDKInFlightHtlcs this_obj);

/**
 * Creates a copy of the InFlightHtlcs
 */
struct LDKInFlightHtlcs InFlightHtlcs_clone(const struct LDKInFlightHtlcs *NONNULL_PTR orig);

/**
 * Constructs an empty `InFlightHtlcs`.
 */
MUST_USE_RES struct LDKInFlightHtlcs InFlightHtlcs_new(void);

/**
 * Returns liquidity in msat given the public key of the HTLC source, target, and short channel
 * id.
 */
MUST_USE_RES struct LDKCOption_u64Z InFlightHtlcs_used_liquidity_msat(const struct LDKInFlightHtlcs *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target, uint64_t channel_scid);

/**
 * Serialize the InFlightHtlcs object into a byte array which can be read by InFlightHtlcs_read
 */
struct LDKCVec_u8Z InFlightHtlcs_write(const struct LDKInFlightHtlcs *NONNULL_PTR obj);

/**
 * Read a InFlightHtlcs from a byte array, created by InFlightHtlcs_write
 */
struct LDKCResult_InFlightHtlcsDecodeErrorZ InFlightHtlcs_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHop, if is_owned is set and inner is non-NULL.
 */
void RouteHop_free(struct LDKRouteHop this_obj);

/**
 * The node_id of the node at this hop.
 */
struct LDKPublicKey RouteHop_get_pubkey(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the node at this hop.
 */
void RouteHop_set_pubkey(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
struct LDKNodeFeatures RouteHop_get_node_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
void RouteHop_set_node_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
uint64_t RouteHop_get_short_channel_id(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
void RouteHop_set_short_channel_id(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
struct LDKChannelFeatures RouteHop_get_channel_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
void RouteHop_set_channel_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * For the last hop, this should be the full value of the payment (might be more than
 * requested if we had to match htlc_minimum_msat).
 */
uint64_t RouteHop_get_fee_msat(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * For the last hop, this should be the full value of the payment (might be more than
 * requested if we had to match htlc_minimum_msat).
 */
void RouteHop_set_fee_msat(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
 * expected at the destination, in excess of the current block height.
 */
uint32_t RouteHop_get_cltv_expiry_delta(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
 * expected at the destination, in excess of the current block height.
 */
void RouteHop_set_cltv_expiry_delta(struct LDKRouteHop *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RouteHop given each field
 */
MUST_USE_RES struct LDKRouteHop RouteHop_new(struct LDKPublicKey pubkey_arg, struct LDKNodeFeatures node_features_arg, uint64_t short_channel_id_arg, struct LDKChannelFeatures channel_features_arg, uint64_t fee_msat_arg, uint32_t cltv_expiry_delta_arg);

/**
 * Creates a copy of the RouteHop
 */
struct LDKRouteHop RouteHop_clone(const struct LDKRouteHop *NONNULL_PTR orig);

/**
 * Checks if two RouteHops contain equal inner contents.
 */
uint64_t RouteHop_hash(const struct LDKRouteHop *NONNULL_PTR o);

/**
 * Checks if two RouteHops contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHop_eq(const struct LDKRouteHop *NONNULL_PTR a, const struct LDKRouteHop *NONNULL_PTR b);

/**
 * Serialize the RouteHop object into a byte array which can be read by RouteHop_read
 */
struct LDKCVec_u8Z RouteHop_write(const struct LDKRouteHop *NONNULL_PTR obj);

/**
 * Read a RouteHop from a byte array, created by RouteHop_write
 */
struct LDKCResult_RouteHopDecodeErrorZ RouteHop_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Route, if is_owned is set and inner is non-NULL.
 */
void Route_free(struct LDKRoute this_obj);

/**
 * The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
 * last RouteHop in each path must be the same. Each entry represents a list of hops, NOT
 * INCLUDING our own, where the last hop is the destination. Thus, this must always be at
 * least length one. While the maximum length of any given path is variable, keeping the length
 * of any path less or equal to 19 should currently ensure it is viable.
 */
struct LDKCVec_CVec_RouteHopZZ Route_get_paths(const struct LDKRoute *NONNULL_PTR this_ptr);

/**
 * The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
 * last RouteHop in each path must be the same. Each entry represents a list of hops, NOT
 * INCLUDING our own, where the last hop is the destination. Thus, this must always be at
 * least length one. While the maximum length of any given path is variable, keeping the length
 * of any path less or equal to 19 should currently ensure it is viable.
 */
void Route_set_paths(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKCVec_CVec_RouteHopZZ val);

/**
 * The `payment_params` parameter passed to [`find_route`].
 * This is used by `ChannelManager` to track information which may be required for retries,
 * provided back to you via [`Event::PaymentPathFailed`].
 *
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKPaymentParameters Route_get_payment_params(const struct LDKRoute *NONNULL_PTR this_ptr);

/**
 * The `payment_params` parameter passed to [`find_route`].
 * This is used by `ChannelManager` to track information which may be required for retries,
 * provided back to you via [`Event::PaymentPathFailed`].
 *
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void Route_set_payment_params(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);

/**
 * Constructs a new Route given each field
 */
MUST_USE_RES struct LDKRoute Route_new(struct LDKCVec_CVec_RouteHopZZ paths_arg, struct LDKPaymentParameters payment_params_arg);

/**
 * Creates a copy of the Route
 */
struct LDKRoute Route_clone(const struct LDKRoute *NONNULL_PTR orig);

/**
 * Checks if two Routes contain equal inner contents.
 */
uint64_t Route_hash(const struct LDKRoute *NONNULL_PTR o);

/**
 * Checks if two Routes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Route_eq(const struct LDKRoute *NONNULL_PTR a, const struct LDKRoute *NONNULL_PTR b);

/**
 * Returns the total amount of fees paid on this [`Route`].
 *
 * This doesn't include any extra payment made to the recipient, which can happen in excess of
 * the amount passed to [`find_route`]'s `params.final_value_msat`.
 */
MUST_USE_RES uint64_t Route_get_total_fees(const struct LDKRoute *NONNULL_PTR this_arg);

/**
 * Returns the total amount paid on this [`Route`], excluding the fees.
 */
MUST_USE_RES uint64_t Route_get_total_amount(const struct LDKRoute *NONNULL_PTR this_arg);

/**
 * Serialize the Route object into a byte array which can be read by Route_read
 */
struct LDKCVec_u8Z Route_write(const struct LDKRoute *NONNULL_PTR obj);

/**
 * Read a Route from a byte array, created by Route_write
 */
struct LDKCResult_RouteDecodeErrorZ Route_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteParameters, if is_owned is set and inner is non-NULL.
 */
void RouteParameters_free(struct LDKRouteParameters this_obj);

/**
 * The parameters of the failed payment path.
 */
struct LDKPaymentParameters RouteParameters_get_payment_params(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The parameters of the failed payment path.
 */
void RouteParameters_set_payment_params(struct LDKRouteParameters *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);

/**
 * The amount in msats sent on the failed payment path.
 */
uint64_t RouteParameters_get_final_value_msat(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The amount in msats sent on the failed payment path.
 */
void RouteParameters_set_final_value_msat(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV on the final hop of the failed payment path.
 */
uint32_t RouteParameters_get_final_cltv_expiry_delta(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The CLTV on the final hop of the failed payment path.
 */
void RouteParameters_set_final_cltv_expiry_delta(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RouteParameters given each field
 */
MUST_USE_RES struct LDKRouteParameters RouteParameters_new(struct LDKPaymentParameters payment_params_arg, uint64_t final_value_msat_arg, uint32_t final_cltv_expiry_delta_arg);

/**
 * Creates a copy of the RouteParameters
 */
struct LDKRouteParameters RouteParameters_clone(const struct LDKRouteParameters *NONNULL_PTR orig);

/**
 * Serialize the RouteParameters object into a byte array which can be read by RouteParameters_read
 */
struct LDKCVec_u8Z RouteParameters_write(const struct LDKRouteParameters *NONNULL_PTR obj);

/**
 * Read a RouteParameters from a byte array, created by RouteParameters_write
 */
struct LDKCResult_RouteParametersDecodeErrorZ RouteParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the PaymentParameters, if is_owned is set and inner is non-NULL.
 */
void PaymentParameters_free(struct LDKPaymentParameters this_obj);

/**
 * The node id of the payee.
 */
struct LDKPublicKey PaymentParameters_get_payee_pubkey(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * The node id of the payee.
 */
void PaymentParameters_set_payee_pubkey(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Features supported by the payee.
 *
 * May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
 * does not contain any features.
 *
 * [`for_keysend`]: Self::for_keysend
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKInvoiceFeatures PaymentParameters_get_features(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Features supported by the payee.
 *
 * May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
 * does not contain any features.
 *
 * [`for_keysend`]: Self::for_keysend
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void PaymentParameters_set_features(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKInvoiceFeatures val);

/**
 * Hints for routing to the payee, containing channels connecting the payee to public nodes.
 */
struct LDKCVec_RouteHintZ PaymentParameters_get_route_hints(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Hints for routing to the payee, containing channels connecting the payee to public nodes.
 */
void PaymentParameters_set_route_hints(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintZ val);

/**
 * Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
 */
struct LDKCOption_u64Z PaymentParameters_get_expiry_time(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
 */
void PaymentParameters_set_expiry_time(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The maximum total CLTV delta we accept for the route.
 * Defaults to [`DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA`].
 */
uint32_t PaymentParameters_get_max_total_cltv_expiry_delta(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * The maximum total CLTV delta we accept for the route.
 * Defaults to [`DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA`].
 */
void PaymentParameters_set_max_total_cltv_expiry_delta(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The maximum number of paths that may be used by (MPP) payments.
 * Defaults to [`DEFAULT_MAX_PATH_COUNT`].
 */
uint8_t PaymentParameters_get_max_path_count(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * The maximum number of paths that may be used by (MPP) payments.
 * Defaults to [`DEFAULT_MAX_PATH_COUNT`].
 */
void PaymentParameters_set_max_path_count(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint8_t val);

/**
 * Selects the maximum share of a channel's total capacity which will be sent over a channel,
 * as a power of 1/2. A higher value prefers to send the payment using more MPP parts whereas
 * a lower value prefers to send larger MPP parts, potentially saturating channels and
 * increasing failure probability for those paths.
 *
 * Note that this restriction will be relaxed during pathfinding after paths which meet this
 * restriction have been found. While paths which meet this criteria will be searched for, it
 * is ultimately up to the scorer to select them over other paths.
 *
 * A value of 0 will allow payments up to and including a channel's total announced usable
 * capacity, a value of one will only use up to half its capacity, two 1/4, etc.
 *
 * Default value: 2
 */
uint8_t PaymentParameters_get_max_channel_saturation_power_of_half(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Selects the maximum share of a channel's total capacity which will be sent over a channel,
 * as a power of 1/2. A higher value prefers to send the payment using more MPP parts whereas
 * a lower value prefers to send larger MPP parts, potentially saturating channels and
 * increasing failure probability for those paths.
 *
 * Note that this restriction will be relaxed during pathfinding after paths which meet this
 * restriction have been found. While paths which meet this criteria will be searched for, it
 * is ultimately up to the scorer to select them over other paths.
 *
 * A value of 0 will allow payments up to and including a channel's total announced usable
 * capacity, a value of one will only use up to half its capacity, two 1/4, etc.
 *
 * Default value: 2
 */
void PaymentParameters_set_max_channel_saturation_power_of_half(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint8_t val);

/**
 * A list of SCIDs which this payment was previously attempted over and which caused the
 * payment to fail. Future attempts for the same payment shouldn't be relayed through any of
 * these SCIDs.
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u64Z PaymentParameters_get_previously_failed_channels(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * A list of SCIDs which this payment was previously attempted over and which caused the
 * payment to fail. Future attempts for the same payment shouldn't be relayed through any of
 * these SCIDs.
 */
void PaymentParameters_set_previously_failed_channels(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new PaymentParameters given each field
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_new(struct LDKPublicKey payee_pubkey_arg, struct LDKInvoiceFeatures features_arg, struct LDKCVec_RouteHintZ route_hints_arg, struct LDKCOption_u64Z expiry_time_arg, uint32_t max_total_cltv_expiry_delta_arg, uint8_t max_path_count_arg, uint8_t max_channel_saturation_power_of_half_arg, struct LDKCVec_u64Z previously_failed_channels_arg);

/**
 * Creates a copy of the PaymentParameters
 */
struct LDKPaymentParameters PaymentParameters_clone(const struct LDKPaymentParameters *NONNULL_PTR orig);

/**
 * Checks if two PaymentParameterss contain equal inner contents.
 */
uint64_t PaymentParameters_hash(const struct LDKPaymentParameters *NONNULL_PTR o);

/**
 * Checks if two PaymentParameterss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PaymentParameters_eq(const struct LDKPaymentParameters *NONNULL_PTR a, const struct LDKPaymentParameters *NONNULL_PTR b);

/**
 * Serialize the PaymentParameters object into a byte array which can be read by PaymentParameters_read
 */
struct LDKCVec_u8Z PaymentParameters_write(const struct LDKPaymentParameters *NONNULL_PTR obj);

/**
 * Read a PaymentParameters from a byte array, created by PaymentParameters_write
 */
struct LDKCResult_PaymentParametersDecodeErrorZ PaymentParameters_read(struct LDKu8slice ser);

/**
 * Creates a payee with the node id of the given `pubkey`.
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_from_node_id(struct LDKPublicKey payee_pubkey);

/**
 * Creates a payee with the node id of the given `pubkey` to use for keysend payments.
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_for_keysend(struct LDKPublicKey payee_pubkey);

/**
 * Frees any resources used by the RouteHint, if is_owned is set and inner is non-NULL.
 */
void RouteHint_free(struct LDKRouteHint this_obj);

struct LDKCVec_RouteHintHopZ RouteHint_get_a(const struct LDKRouteHint *NONNULL_PTR this_ptr);

void RouteHint_set_a(struct LDKRouteHint *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintHopZ val);

/**
 * Constructs a new RouteHint given each field
 */
MUST_USE_RES struct LDKRouteHint RouteHint_new(struct LDKCVec_RouteHintHopZ a_arg);

/**
 * Creates a copy of the RouteHint
 */
struct LDKRouteHint RouteHint_clone(const struct LDKRouteHint *NONNULL_PTR orig);

/**
 * Checks if two RouteHints contain equal inner contents.
 */
uint64_t RouteHint_hash(const struct LDKRouteHint *NONNULL_PTR o);

/**
 * Checks if two RouteHints contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHint_eq(const struct LDKRouteHint *NONNULL_PTR a, const struct LDKRouteHint *NONNULL_PTR b);

/**
 * Serialize the RouteHint object into a byte array which can be read by RouteHint_read
 */
struct LDKCVec_u8Z RouteHint_write(const struct LDKRouteHint *NONNULL_PTR obj);

/**
 * Read a RouteHint from a byte array, created by RouteHint_write
 */
struct LDKCResult_RouteHintDecodeErrorZ RouteHint_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHintHop, if is_owned is set and inner is non-NULL.
 */
void RouteHintHop_free(struct LDKRouteHintHop this_obj);

/**
 * The node_id of the non-target end of the route
 */
struct LDKPublicKey RouteHintHop_get_src_node_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the non-target end of the route
 */
void RouteHintHop_set_src_node_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The short_channel_id of this channel
 */
uint64_t RouteHintHop_get_short_channel_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The short_channel_id of this channel
 */
void RouteHintHop_set_short_channel_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The fees which must be paid to use this channel
 */
struct LDKRoutingFees RouteHintHop_get_fees(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The fees which must be paid to use this channel
 */
void RouteHintHop_set_fees(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * The difference in CLTV values between this node and the next node.
 */
uint16_t RouteHintHop_get_cltv_expiry_delta(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values between this node and the next node.
 */
void RouteHintHop_set_cltv_expiry_delta(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, in msat, which must be relayed to the next hop.
 */
struct LDKCOption_u64Z RouteHintHop_get_htlc_minimum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The minimum value, in msat, which must be relayed to the next hop.
 */
void RouteHintHop_set_htlc_minimum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The maximum value in msat available for routing with a single HTLC.
 */
struct LDKCOption_u64Z RouteHintHop_get_htlc_maximum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The maximum value in msat available for routing with a single HTLC.
 */
void RouteHintHop_set_htlc_maximum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new RouteHintHop given each field
 */
MUST_USE_RES struct LDKRouteHintHop RouteHintHop_new(struct LDKPublicKey src_node_id_arg, uint64_t short_channel_id_arg, struct LDKRoutingFees fees_arg, uint16_t cltv_expiry_delta_arg, struct LDKCOption_u64Z htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg);

/**
 * Creates a copy of the RouteHintHop
 */
struct LDKRouteHintHop RouteHintHop_clone(const struct LDKRouteHintHop *NONNULL_PTR orig);

/**
 * Checks if two RouteHintHops contain equal inner contents.
 */
uint64_t RouteHintHop_hash(const struct LDKRouteHintHop *NONNULL_PTR o);

/**
 * Checks if two RouteHintHops contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHintHop_eq(const struct LDKRouteHintHop *NONNULL_PTR a, const struct LDKRouteHintHop *NONNULL_PTR b);

/**
 * Serialize the RouteHintHop object into a byte array which can be read by RouteHintHop_read
 */
struct LDKCVec_u8Z RouteHintHop_write(const struct LDKRouteHintHop *NONNULL_PTR obj);

/**
 * Read a RouteHintHop from a byte array, created by RouteHintHop_write
 */
struct LDKCResult_RouteHintHopDecodeErrorZ RouteHintHop_read(struct LDKu8slice ser);

/**
 * Finds a route from us (payer) to the given target node (payee).
 *
 * If the payee provided features in their invoice, they should be provided via `params.payee`.
 * Without this, MPP will only be used if the payee's features are available in the network graph.
 *
 * Private routing paths between a public node and the target may be included in `params.payee`.
 *
 * If some channels aren't announced, it may be useful to fill in `first_hops` with the results
 * from [`ChannelManager::list_usable_channels`]. If it is filled in, the view of these channels
 * from `network_graph` will be ignored, and only those in `first_hops` will be used.
 *
 * The fees on channels from us to the next hop are ignored as they are assumed to all be equal.
 * However, the enabled/disabled bit on such channels as well as the `htlc_minimum_msat` /
 * `htlc_maximum_msat` *are* checked as they may change based on the receiving node.
 *
 * # Note
 *
 * May be used to re-compute a [`Route`] when handling a [`Event::PaymentPathFailed`]. Any
 * adjustments to the [`NetworkGraph`] and channel scores should be made prior to calling this
 * function.
 *
 * # Panics
 *
 * Panics if first_hops contains channels without short_channel_ids;
 * [`ChannelManager::list_usable_channels`] will never include such channels.
 *
 * [`ChannelManager::list_usable_channels`]: crate::ln::channelmanager::ChannelManager::list_usable_channels
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
 *
 * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCResult_RouteLightningErrorZ find_route(struct LDKPublicKey our_node_pubkey, const struct LDKRouteParameters *NONNULL_PTR route_params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKLogger logger, const struct LDKScore *NONNULL_PTR scorer, const uint8_t (*random_seed_bytes)[32]);

/**
 * Construct a route from us (payer) to the target node (payee) via the given hops (which should
 * exclude the payer, but include the payee). This may be useful, e.g., for probing the chosen path.
 *
 * Re-uses logic from `find_route`, so the restrictions described there also apply here.
 */
struct LDKCResult_RouteLightningErrorZ build_route_from_hops(struct LDKPublicKey our_node_pubkey, struct LDKCVec_PublicKeyZ hops, const struct LDKRouteParameters *NONNULL_PTR route_params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger, const uint8_t (*random_seed_bytes)[32]);

/**
 * Calls the free function if one is set
 */
void Score_free(struct LDKScore this_ptr);

/**
 * Calls the free function if one is set
 */
void LockableScore_free(struct LDKLockableScore this_ptr);

/**
 * Calls the free function if one is set
 */
void WriteableScore_free(struct LDKWriteableScore this_ptr);

/**
 * Frees any resources used by the MultiThreadedLockableScore, if is_owned is set and inner is non-NULL.
 */
void MultiThreadedLockableScore_free(struct LDKMultiThreadedLockableScore this_obj);

/**
 * Frees any resources used by the MultiThreadedScoreLock, if is_owned is set and inner is non-NULL.
 */
void MultiThreadedScoreLock_free(struct LDKMultiThreadedScoreLock this_obj);

/**
 * Constructs a new Score which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
 */
struct LDKScore MultiThreadedScoreLock_as_Score(const struct LDKMultiThreadedScoreLock *NONNULL_PTR this_arg);

/**
 * Serialize the MultiThreadedScoreLock object into a byte array which can be read by MultiThreadedScoreLock_read
 */
struct LDKCVec_u8Z MultiThreadedScoreLock_write(const struct LDKMultiThreadedScoreLock *NONNULL_PTR obj);

/**
 * Constructs a new LockableScore which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned LockableScore must be freed before this_arg is
 */
struct LDKLockableScore MultiThreadedLockableScore_as_LockableScore(const struct LDKMultiThreadedLockableScore *NONNULL_PTR this_arg);

/**
 * Serialize the MultiThreadedLockableScore object into a byte array which can be read by MultiThreadedLockableScore_read
 */
struct LDKCVec_u8Z MultiThreadedLockableScore_write(const struct LDKMultiThreadedLockableScore *NONNULL_PTR obj);

/**
 * Constructs a new WriteableScore which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned WriteableScore must be freed before this_arg is
 */
struct LDKWriteableScore MultiThreadedLockableScore_as_WriteableScore(const struct LDKMultiThreadedLockableScore *NONNULL_PTR this_arg);

/**
 * Creates a new [`MultiThreadedLockableScore`] given an underlying [`Score`].
 */
MUST_USE_RES struct LDKMultiThreadedLockableScore MultiThreadedLockableScore_new(struct LDKScore score);

/**
 * Frees any resources used by the ChannelUsage, if is_owned is set and inner is non-NULL.
 */
void ChannelUsage_free(struct LDKChannelUsage this_obj);

/**
 * The amount to send through the channel, denominated in millisatoshis.
 */
uint64_t ChannelUsage_get_amount_msat(const struct LDKChannelUsage *NONNULL_PTR this_ptr);

/**
 * The amount to send through the channel, denominated in millisatoshis.
 */
void ChannelUsage_set_amount_msat(struct LDKChannelUsage *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Total amount, denominated in millisatoshis, already allocated to send through the channel
 * as part of a multi-path payment.
 */
uint64_t ChannelUsage_get_inflight_htlc_msat(const struct LDKChannelUsage *NONNULL_PTR this_ptr);

/**
 * Total amount, denominated in millisatoshis, already allocated to send through the channel
 * as part of a multi-path payment.
 */
void ChannelUsage_set_inflight_htlc_msat(struct LDKChannelUsage *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The effective capacity of the channel.
 */
struct LDKEffectiveCapacity ChannelUsage_get_effective_capacity(const struct LDKChannelUsage *NONNULL_PTR this_ptr);

/**
 * The effective capacity of the channel.
 */
void ChannelUsage_set_effective_capacity(struct LDKChannelUsage *NONNULL_PTR this_ptr, struct LDKEffectiveCapacity val);

/**
 * Constructs a new ChannelUsage given each field
 */
MUST_USE_RES struct LDKChannelUsage ChannelUsage_new(uint64_t amount_msat_arg, uint64_t inflight_htlc_msat_arg, struct LDKEffectiveCapacity effective_capacity_arg);

/**
 * Creates a copy of the ChannelUsage
 */
struct LDKChannelUsage ChannelUsage_clone(const struct LDKChannelUsage *NONNULL_PTR orig);

/**
 * Frees any resources used by the FixedPenaltyScorer, if is_owned is set and inner is non-NULL.
 */
void FixedPenaltyScorer_free(struct LDKFixedPenaltyScorer this_obj);

/**
 * Creates a copy of the FixedPenaltyScorer
 */
struct LDKFixedPenaltyScorer FixedPenaltyScorer_clone(const struct LDKFixedPenaltyScorer *NONNULL_PTR orig);

/**
 * Creates a new scorer using `penalty_msat`.
 */
MUST_USE_RES struct LDKFixedPenaltyScorer FixedPenaltyScorer_with_penalty(uint64_t penalty_msat);

/**
 * Constructs a new Score which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
 */
struct LDKScore FixedPenaltyScorer_as_Score(const struct LDKFixedPenaltyScorer *NONNULL_PTR this_arg);

/**
 * Serialize the FixedPenaltyScorer object into a byte array which can be read by FixedPenaltyScorer_read
 */
struct LDKCVec_u8Z FixedPenaltyScorer_write(const struct LDKFixedPenaltyScorer *NONNULL_PTR obj);

/**
 * Read a FixedPenaltyScorer from a byte array, created by FixedPenaltyScorer_write
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ FixedPenaltyScorer_read(struct LDKu8slice ser, uint64_t arg);

/**
 * Frees any resources used by the ProbabilisticScorer, if is_owned is set and inner is non-NULL.
 */
void ProbabilisticScorer_free(struct LDKProbabilisticScorer this_obj);

/**
 * Frees any resources used by the ProbabilisticScoringParameters, if is_owned is set and inner is non-NULL.
 */
void ProbabilisticScoringParameters_free(struct LDKProbabilisticScoringParameters this_obj);

/**
 * A fixed penalty in msats to apply to each channel.
 *
 * Default value: 500 msat
 */
uint64_t ProbabilisticScoringParameters_get_base_penalty_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A fixed penalty in msats to apply to each channel.
 *
 * Default value: 500 msat
 */
void ProbabilisticScoringParameters_set_base_penalty_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used with the payment amount to calculate a fixed penalty applied to each
 * channel, in excess of the [`base_penalty_msat`].
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^30`ths of the payment amount.
 *
 * ie `base_penalty_amount_multiplier_msat * amount_msat / 2^30`
 *
 * Default value: 8,192 msat
 *
 * [`base_penalty_msat`]: Self::base_penalty_msat
 */
uint64_t ProbabilisticScoringParameters_get_base_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used with the payment amount to calculate a fixed penalty applied to each
 * channel, in excess of the [`base_penalty_msat`].
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^30`ths of the payment amount.
 *
 * ie `base_penalty_amount_multiplier_msat * amount_msat / 2^30`
 *
 * Default value: 8,192 msat
 *
 * [`base_penalty_msat`]: Self::base_penalty_msat
 */
void ProbabilisticScoringParameters_set_base_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for a payment, as determined by our latest estimates of the channel's
 * liquidity, to determine the liquidity penalty.
 *
 * The penalty is based in part on the knowledge learned from prior successful and unsuccessful
 * payments. This knowledge is decayed over time based on [`liquidity_offset_half_life`]. The
 * penalty is effectively limited to `2 * liquidity_penalty_multiplier_msat` (corresponding to
 * lower bounding the success probability to `0.01`) when the amount falls within the
 * uncertainty bounds of the channel liquidity balance. Amounts above the upper bound will
 * result in a `u64::max_value` penalty, however.
 *
 * `-log10(success_probability) * liquidity_penalty_multiplier_msat`
 *
 * Default value: 30,000 msat
 *
 * [`liquidity_offset_half_life`]: Self::liquidity_offset_half_life
 */
uint64_t ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for a payment, as determined by our latest estimates of the channel's
 * liquidity, to determine the liquidity penalty.
 *
 * The penalty is based in part on the knowledge learned from prior successful and unsuccessful
 * payments. This knowledge is decayed over time based on [`liquidity_offset_half_life`]. The
 * penalty is effectively limited to `2 * liquidity_penalty_multiplier_msat` (corresponding to
 * lower bounding the success probability to `0.01`) when the amount falls within the
 * uncertainty bounds of the channel liquidity balance. Amounts above the upper bound will
 * result in a `u64::max_value` penalty, however.
 *
 * `-log10(success_probability) * liquidity_penalty_multiplier_msat`
 *
 * Default value: 30,000 msat
 *
 * [`liquidity_offset_half_life`]: Self::liquidity_offset_half_life
 */
void ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Whenever this amount of time elapses since the last update to a channel's liquidity bounds,
 * the distance from the bounds to \"zero\" is cut in half. In other words, the lower-bound on
 * the available liquidity is halved and the upper-bound moves half-way to the channel's total
 * capacity.
 *
 * Because halving the liquidity bounds grows the uncertainty on the channel's liquidity,
 * the penalty for an amount within the new bounds may change. See the [`ProbabilisticScorer`]
 * struct documentation for more info on the way the liquidity bounds are used.
 *
 * For example, if the channel's capacity is 1 million sats, and the current upper and lower
 * liquidity bounds are 200,000 sats and 600,000 sats, after this amount of time the upper
 * and lower liquidity bounds will be decayed to 100,000 and 800,000 sats.
 *
 * Default value: 6 hours
 *
 * # Note
 *
 * When built with the `no-std` feature, time will never elapse. Therefore, the channel
 * liquidity knowledge will never decay except when the bounds cross.
 */
uint64_t ProbabilisticScoringParameters_get_liquidity_offset_half_life(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * Whenever this amount of time elapses since the last update to a channel's liquidity bounds,
 * the distance from the bounds to \"zero\" is cut in half. In other words, the lower-bound on
 * the available liquidity is halved and the upper-bound moves half-way to the channel's total
 * capacity.
 *
 * Because halving the liquidity bounds grows the uncertainty on the channel's liquidity,
 * the penalty for an amount within the new bounds may change. See the [`ProbabilisticScorer`]
 * struct documentation for more info on the way the liquidity bounds are used.
 *
 * For example, if the channel's capacity is 1 million sats, and the current upper and lower
 * liquidity bounds are 200,000 sats and 600,000 sats, after this amount of time the upper
 * and lower liquidity bounds will be decayed to 100,000 and 800,000 sats.
 *
 * Default value: 6 hours
 *
 * # Note
 *
 * When built with the `no-std` feature, time will never elapse. Therefore, the channel
 * liquidity knowledge will never decay except when the bounds cross.
 */
void ProbabilisticScoringParameters_set_liquidity_offset_half_life(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with a payment amount and the negative `log10` of the
 * channel's success probability for the payment, as determined by our latest estimates of the
 * channel's liquidity, to determine the amount penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^20`ths of the payment amount, weighted by the negative `log10` of the
 * success probability.
 *
 * `-log10(success_probability) * liquidity_penalty_amount_multiplier_msat * amount_msat / 2^20`
 *
 * In practice, this means for 0.1 success probability (`-log10(0.1) == 1`) each `2^20`th of
 * the amount will result in a penalty of the multiplier. And, as the success probability
 * decreases, the negative `log10` weighting will increase dramatically. For higher success
 * probabilities, the multiplier will have a decreasing effect as the negative `log10` will
 * fall below `1`.
 *
 * Default value: 192 msat
 */
uint64_t ProbabilisticScoringParameters_get_liquidity_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with a payment amount and the negative `log10` of the
 * channel's success probability for the payment, as determined by our latest estimates of the
 * channel's liquidity, to determine the amount penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^20`ths of the payment amount, weighted by the negative `log10` of the
 * success probability.
 *
 * `-log10(success_probability) * liquidity_penalty_amount_multiplier_msat * amount_msat / 2^20`
 *
 * In practice, this means for 0.1 success probability (`-log10(0.1) == 1`) each `2^20`th of
 * the amount will result in a penalty of the multiplier. And, as the success probability
 * decreases, the negative `log10` weighting will increase dramatically. For higher success
 * probabilities, the multiplier will have a decreasing effect as the negative `log10` will
 * fall below `1`.
 *
 * Default value: 192 msat
 */
void ProbabilisticScoringParameters_set_liquidity_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for the payment, as determined based on the history of our estimates of the
 * channel's available liquidity, to determine a penalty.
 *
 * This penalty is similar to [`liquidity_penalty_multiplier_msat`], however, instead of using
 * only our latest estimate for the current liquidity available in the channel, it estimates
 * success probability based on the estimated liquidity available in the channel through
 * history. Specifically, every time we update our liquidity bounds on a given channel, we
 * track which of several buckets those bounds fall into, exponentially decaying the
 * probability of each bucket as new samples are added.
 *
 * Default value: 10,000 msat
 *
 * [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
 */
uint64_t ProbabilisticScoringParameters_get_historical_liquidity_penalty_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for the payment, as determined based on the history of our estimates of the
 * channel's available liquidity, to determine a penalty.
 *
 * This penalty is similar to [`liquidity_penalty_multiplier_msat`], however, instead of using
 * only our latest estimate for the current liquidity available in the channel, it estimates
 * success probability based on the estimated liquidity available in the channel through
 * history. Specifically, every time we update our liquidity bounds on a given channel, we
 * track which of several buckets those bounds fall into, exponentially decaying the
 * probability of each bucket as new samples are added.
 *
 * Default value: 10,000 msat
 *
 * [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
 */
void ProbabilisticScoringParameters_set_historical_liquidity_penalty_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with the payment amount and the negative `log10` of the
 * channel's success probability for the payment, as determined based on the history of our
 * estimates of the channel's available liquidity, to determine a penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost for
 * large payments. The penalty is computed as the product of this multiplier and the `2^20`ths
 * of the payment amount, weighted by the negative `log10` of the success probability.
 *
 * This penalty is similar to [`liquidity_penalty_amount_multiplier_msat`], however, instead
 * of using only our latest estimate for the current liquidity available in the channel, it
 * estimates success probability based on the estimated liquidity available in the channel
 * through history. Specifically, every time we update our liquidity bounds on a given
 * channel, we track which of several buckets those bounds fall into, exponentially decaying
 * the probability of each bucket as new samples are added.
 *
 * Default value: 64 msat
 *
 * [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
 */
uint64_t ProbabilisticScoringParameters_get_historical_liquidity_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with the payment amount and the negative `log10` of the
 * channel's success probability for the payment, as determined based on the history of our
 * estimates of the channel's available liquidity, to determine a penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost for
 * large payments. The penalty is computed as the product of this multiplier and the `2^20`ths
 * of the payment amount, weighted by the negative `log10` of the success probability.
 *
 * This penalty is similar to [`liquidity_penalty_amount_multiplier_msat`], however, instead
 * of using only our latest estimate for the current liquidity available in the channel, it
 * estimates success probability based on the estimated liquidity available in the channel
 * through history. Specifically, every time we update our liquidity bounds on a given
 * channel, we track which of several buckets those bounds fall into, exponentially decaying
 * the probability of each bucket as new samples are added.
 *
 * Default value: 64 msat
 *
 * [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
 */
void ProbabilisticScoringParameters_set_historical_liquidity_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * If we aren't learning any new datapoints for a channel, the historical liquidity bounds
 * tracking can simply live on with increasingly stale data. Instead, when a channel has not
 * seen a liquidity estimate update for this amount of time, the historical datapoints are
 * decayed by half.
 *
 * Note that after 16 or more half lives all historical data will be completely gone.
 *
 * Default value: 14 days
 */
uint64_t ProbabilisticScoringParameters_get_historical_no_updates_half_life(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * If we aren't learning any new datapoints for a channel, the historical liquidity bounds
 * tracking can simply live on with increasingly stale data. Instead, when a channel has not
 * seen a liquidity estimate update for this amount of time, the historical datapoints are
 * decayed by half.
 *
 * Note that after 16 or more half lives all historical data will be completely gone.
 *
 * Default value: 14 days
 */
void ProbabilisticScoringParameters_set_historical_no_updates_half_life(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * This penalty is applied when `htlc_maximum_msat` is equal to or larger than half of the
 * channel's capacity, which makes us prefer nodes with a smaller `htlc_maximum_msat`. We
 * treat such nodes preferentially as this makes balance discovery attacks harder to execute,
 * thereby creating an incentive to restrict `htlc_maximum_msat` and improve privacy.
 *
 * Default value: 250 msat
 */
uint64_t ProbabilisticScoringParameters_get_anti_probing_penalty_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * This penalty is applied when `htlc_maximum_msat` is equal to or larger than half of the
 * channel's capacity, which makes us prefer nodes with a smaller `htlc_maximum_msat`. We
 * treat such nodes preferentially as this makes balance discovery attacks harder to execute,
 * thereby creating an incentive to restrict `htlc_maximum_msat` and improve privacy.
 *
 * Default value: 250 msat
 */
void ProbabilisticScoringParameters_set_anti_probing_penalty_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * This penalty is applied when the amount we're attempting to send over a channel exceeds our
 * current estimate of the channel's available liquidity.
 *
 * Note that in this case all other penalties, including the
 * [`liquidity_penalty_multiplier_msat`] and [`liquidity_penalty_amount_multiplier_msat`]-based
 * penalties, as well as the [`base_penalty_msat`] and the [`anti_probing_penalty_msat`], if
 * applicable, are still included in the overall penalty.
 *
 * If you wish to avoid creating paths with such channels entirely, setting this to a value of
 * `u64::max_value()` will guarantee that.
 *
 * Default value: 1_0000_0000_000 msat (1 Bitcoin)
 *
 * [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
 * [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
 * [`base_penalty_msat`]: Self::base_penalty_msat
 * [`anti_probing_penalty_msat`]: Self::anti_probing_penalty_msat
 */
uint64_t ProbabilisticScoringParameters_get_considered_impossible_penalty_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * This penalty is applied when the amount we're attempting to send over a channel exceeds our
 * current estimate of the channel's available liquidity.
 *
 * Note that in this case all other penalties, including the
 * [`liquidity_penalty_multiplier_msat`] and [`liquidity_penalty_amount_multiplier_msat`]-based
 * penalties, as well as the [`base_penalty_msat`] and the [`anti_probing_penalty_msat`], if
 * applicable, are still included in the overall penalty.
 *
 * If you wish to avoid creating paths with such channels entirely, setting this to a value of
 * `u64::max_value()` will guarantee that.
 *
 * Default value: 1_0000_0000_000 msat (1 Bitcoin)
 *
 * [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
 * [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
 * [`base_penalty_msat`]: Self::base_penalty_msat
 * [`anti_probing_penalty_msat`]: Self::anti_probing_penalty_msat
 */
void ProbabilisticScoringParameters_set_considered_impossible_penalty_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ProbabilisticScoringParameters
 */
struct LDKProbabilisticScoringParameters ProbabilisticScoringParameters_clone(const struct LDKProbabilisticScoringParameters *NONNULL_PTR orig);

/**
 * Creates a new scorer using the given scoring parameters for sending payments from a node
 * through a network graph.
 */
MUST_USE_RES struct LDKProbabilisticScorer ProbabilisticScorer_new(struct LDKProbabilisticScoringParameters params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger);

/**
 * Dump the contents of this scorer into the configured logger.
 *
 * Note that this writes roughly one line per channel for which we have a liquidity estimate,
 * which may be a substantial amount of log output.
 */
void ProbabilisticScorer_debug_log_liquidity_stats(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);

/**
 * Query the estimated minimum and maximum liquidity available for sending a payment over the
 * channel with `scid` towards the given `target` node.
 */
MUST_USE_RES struct LDKCOption_C2Tuple_u64u64ZZ ProbabilisticScorer_estimated_channel_liquidity_range(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg, uint64_t scid, const struct LDKNodeId *NONNULL_PTR target);

/**
 * Marks the node with the given `node_id` as banned, i.e.,
 * it will be avoided during path finding.
 */
void ProbabilisticScorer_add_banned(struct LDKProbabilisticScorer *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);

/**
 * Removes the node with the given `node_id` from the list of nodes to avoid.
 */
void ProbabilisticScorer_remove_banned(struct LDKProbabilisticScorer *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);

/**
 * Sets a manual penalty for the given node.
 */
void ProbabilisticScorer_set_manual_penalty(struct LDKProbabilisticScorer *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id, uint64_t penalty);

/**
 * Removes the node with the given `node_id` from the list of manual penalties.
 */
void ProbabilisticScorer_remove_manual_penalty(struct LDKProbabilisticScorer *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);

/**
 * Clears the list of manual penalties that are applied during path finding.
 */
void ProbabilisticScorer_clear_manual_penalties(struct LDKProbabilisticScorer *NONNULL_PTR this_arg);

/**
 * Marks all nodes in the given list as banned, i.e.,
 * they will be avoided during path finding.
 */
void ProbabilisticScoringParameters_add_banned_from_list(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_arg, struct LDKCVec_NodeIdZ node_ids);

/**
 * Creates a "default" ProbabilisticScoringParameters. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKProbabilisticScoringParameters ProbabilisticScoringParameters_default(void);

/**
 * Constructs a new Score which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
 */
struct LDKScore ProbabilisticScorer_as_Score(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);

/**
 * Serialize the ProbabilisticScorer object into a byte array which can be read by ProbabilisticScorer_read
 */
struct LDKCVec_u8Z ProbabilisticScorer_write(const struct LDKProbabilisticScorer *NONNULL_PTR obj);

/**
 * Read a ProbabilisticScorer from a byte array, created by ProbabilisticScorer_write
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ ProbabilisticScorer_read(struct LDKu8slice ser, struct LDKProbabilisticScoringParameters arg_a, const struct LDKNetworkGraph *NONNULL_PTR arg_b, struct LDKLogger arg_c);

/**
 * Frees any resources used by the BlindedPath, if is_owned is set and inner is non-NULL.
 */
void BlindedPath_free(struct LDKBlindedPath this_obj);

/**
 * Creates a copy of the BlindedPath
 */
struct LDKBlindedPath BlindedPath_clone(const struct LDKBlindedPath *NONNULL_PTR orig);

/**
 * Frees any resources used by the BlindedHop, if is_owned is set and inner is non-NULL.
 */
void BlindedHop_free(struct LDKBlindedHop this_obj);

/**
 * Creates a copy of the BlindedHop
 */
struct LDKBlindedHop BlindedHop_clone(const struct LDKBlindedHop *NONNULL_PTR orig);

/**
 * Create a blinded path to be forwarded along `node_pks`. The last node pubkey in `node_pks`
 * will be the destination node.
 *
 * Errors if less than two hops are provided or if `node_pk`(s) are invalid.
 */
MUST_USE_RES struct LDKCResult_BlindedPathNoneZ BlindedPath_new(struct LDKCVec_PublicKeyZ node_pks, const struct LDKKeysInterface *NONNULL_PTR keys_manager);

/**
 * Serialize the BlindedPath object into a byte array which can be read by BlindedPath_read
 */
struct LDKCVec_u8Z BlindedPath_write(const struct LDKBlindedPath *NONNULL_PTR obj);

/**
 * Read a BlindedPath from a byte array, created by BlindedPath_write
 */
struct LDKCResult_BlindedPathDecodeErrorZ BlindedPath_read(struct LDKu8slice ser);

/**
 * Serialize the BlindedHop object into a byte array which can be read by BlindedHop_read
 */
struct LDKCVec_u8Z BlindedHop_write(const struct LDKBlindedHop *NONNULL_PTR obj);

/**
 * Read a BlindedHop from a byte array, created by BlindedHop_write
 */
struct LDKCResult_BlindedHopDecodeErrorZ BlindedHop_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the OnionMessenger, if is_owned is set and inner is non-NULL.
 */
void OnionMessenger_free(struct LDKOnionMessenger this_obj);

/**
 * Frees any resources used by the Destination
 */
void Destination_free(struct LDKDestination this_ptr);

/**
 * Creates a copy of the Destination
 */
struct LDKDestination Destination_clone(const struct LDKDestination *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Node-variant Destination
 */
struct LDKDestination Destination_node(struct LDKPublicKey a);

/**
 * Utility method to constructs a new BlindedPath-variant Destination
 */
struct LDKDestination Destination_blinded_path(struct LDKBlindedPath a);

/**
 * Frees any resources used by the SendError
 */
void SendError_free(struct LDKSendError this_ptr);

/**
 * Creates a copy of the SendError
 */
struct LDKSendError SendError_clone(const struct LDKSendError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Secp256k1-variant SendError
 */
struct LDKSendError SendError_secp256k1(enum LDKSecp256k1Error a);

/**
 * Utility method to constructs a new TooBigPacket-variant SendError
 */
struct LDKSendError SendError_too_big_packet(void);

/**
 * Utility method to constructs a new TooFewBlindedHops-variant SendError
 */
struct LDKSendError SendError_too_few_blinded_hops(void);

/**
 * Utility method to constructs a new InvalidFirstHop-variant SendError
 */
struct LDKSendError SendError_invalid_first_hop(void);

/**
 * Utility method to constructs a new InvalidMessage-variant SendError
 */
struct LDKSendError SendError_invalid_message(void);

/**
 * Utility method to constructs a new BufferFull-variant SendError
 */
struct LDKSendError SendError_buffer_full(void);

/**
 * Utility method to constructs a new GetNodeIdFailed-variant SendError
 */
struct LDKSendError SendError_get_node_id_failed(void);

/**
 * Utility method to constructs a new BlindedPathAdvanceFailed-variant SendError
 */
struct LDKSendError SendError_blinded_path_advance_failed(void);

/**
 * Checks if two SendErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SendError_eq(const struct LDKSendError *NONNULL_PTR a, const struct LDKSendError *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void CustomOnionMessageHandler_free(struct LDKCustomOnionMessageHandler this_ptr);

/**
 * Constructs a new `OnionMessenger` to send, forward, and delegate received onion messages to
 * their respective handlers.
 */
MUST_USE_RES struct LDKOnionMessenger OnionMessenger_new(struct LDKKeysInterface keys_manager, struct LDKLogger logger, struct LDKCustomOnionMessageHandler custom_handler);

/**
 * Send an onion message with contents `message` to `destination`, routing it through `intermediate_nodes`.
 * See [`OnionMessenger`] for example usage.
 *
 * Note that reply_path (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult_NoneSendErrorZ OnionMessenger_send_onion_message(const struct LDKOnionMessenger *NONNULL_PTR this_arg, struct LDKCVec_PublicKeyZ intermediate_nodes, struct LDKDestination destination, struct LDKOnionMessageContents message, struct LDKBlindedPath reply_path);

/**
 * Constructs a new OnionMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OnionMessageHandler must be freed before this_arg is
 */
struct LDKOnionMessageHandler OnionMessenger_as_OnionMessageHandler(const struct LDKOnionMessenger *NONNULL_PTR this_arg);

/**
 * Constructs a new OnionMessageProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OnionMessageProvider must be freed before this_arg is
 */
struct LDKOnionMessageProvider OnionMessenger_as_OnionMessageProvider(const struct LDKOnionMessenger *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the OnionMessageContents
 */
void OnionMessageContents_free(struct LDKOnionMessageContents this_ptr);

/**
 * Creates a copy of the OnionMessageContents
 */
struct LDKOnionMessageContents OnionMessageContents_clone(const struct LDKOnionMessageContents *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Custom-variant OnionMessageContents
 */
struct LDKOnionMessageContents OnionMessageContents_custom(struct LDKCustomOnionMessageContents a);

/**
 * Creates a copy of a CustomOnionMessageContents
 */
struct LDKCustomOnionMessageContents CustomOnionMessageContents_clone(const struct LDKCustomOnionMessageContents *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void CustomOnionMessageContents_free(struct LDKCustomOnionMessageContents this_ptr);

/**
 * Frees any resources used by the FilesystemPersister, if is_owned is set and inner is non-NULL.
 */
void FilesystemPersister_free(struct LDKFilesystemPersister this_obj);

/**
 * Initialize a new FilesystemPersister and set the path to the individual channels'
 * files.
 */
MUST_USE_RES struct LDKFilesystemPersister FilesystemPersister_new(struct LDKStr path_to_channel_data);

/**
 * Get the directory which was provided when this persister was initialized.
 */
MUST_USE_RES struct LDKStr FilesystemPersister_get_data_dir(const struct LDKFilesystemPersister *NONNULL_PTR this_arg);

/**
 * Read `ChannelMonitor`s from disk.
 */
MUST_USE_RES struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ FilesystemPersister_read_channelmonitors(const struct LDKFilesystemPersister *NONNULL_PTR this_arg, struct LDKKeysInterface keys_manager);

/**
 * Frees any resources used by the BackgroundProcessor, if is_owned is set and inner is non-NULL.
 */
void BackgroundProcessor_free(struct LDKBackgroundProcessor this_obj);

/**
 * Frees any resources used by the GossipSync
 */
void GossipSync_free(struct LDKGossipSync this_ptr);

/**
 * Utility method to constructs a new P2P-variant GossipSync
 */
struct LDKGossipSync GossipSync_p2_p(const struct LDKP2PGossipSync *NONNULL_PTR a);

/**
 * Utility method to constructs a new Rapid-variant GossipSync
 */
struct LDKGossipSync GossipSync_rapid(const struct LDKRapidGossipSync *NONNULL_PTR a);

/**
 * Utility method to constructs a new None-variant GossipSync
 */
struct LDKGossipSync GossipSync_none(void);

/**
 * Start a background thread that takes care of responsibilities enumerated in the [top-level
 * documentation].
 *
 * The thread runs indefinitely unless the object is dropped, [`stop`] is called, or
 * [`Persister::persist_manager`] returns an error. In case of an error, the error is retrieved by calling
 * either [`join`] or [`stop`].
 *
 * # Data Persistence
 *
 * [`Persister::persist_manager`] is responsible for writing out the [`ChannelManager`] to disk, and/or
 * uploading to one or more backup services. See [`ChannelManager::write`] for writing out a
 * [`ChannelManager`]. See the `lightning-persister` crate for LDK's
 * provided implementation.
 *
 * [`Persister::persist_graph`] is responsible for writing out the [`NetworkGraph`] to disk, if
 * [`GossipSync`] is supplied. See [`NetworkGraph::write`] for writing out a [`NetworkGraph`].
 * See the `lightning-persister` crate for LDK's provided implementation.
 *
 * Typically, users should either implement [`Persister::persist_manager`] to never return an
 * error or call [`join`] and handle any error that may arise. For the latter case,
 * `BackgroundProcessor` must be restarted by calling `start` again after handling the error.
 *
 * # Event Handling
 *
 * `event_handler` is responsible for handling events that users should be notified of (e.g.,
 * payment failed). [`BackgroundProcessor`] may decorate the given [`EventHandler`] with common
 * functionality implemented by other handlers.
 * * [`P2PGossipSync`] if given will update the [`NetworkGraph`] based on payment failures.
 *
 * # Rapid Gossip Sync
 *
 * If rapid gossip sync is meant to run at startup, pass [`RapidGossipSync`] via `gossip_sync`
 * to indicate that the [`BackgroundProcessor`] should not prune the [`NetworkGraph`] instance
 * until the [`RapidGossipSync`] instance completes its first sync.
 *
 * [top-level documentation]: BackgroundProcessor
 * [`join`]: Self::join
 * [`stop`]: Self::stop
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 * [`ChannelManager::write`]: lightning::ln::channelmanager::ChannelManager#impl-Writeable
 * [`Persister::persist_manager`]: lightning::util::persist::Persister::persist_manager
 * [`Persister::persist_graph`]: lightning::util::persist::Persister::persist_graph
 * [`NetworkGraph`]: lightning::routing::gossip::NetworkGraph
 * [`NetworkGraph::write`]: lightning::routing::gossip::NetworkGraph#impl-Writeable
 */
MUST_USE_RES struct LDKBackgroundProcessor BackgroundProcessor_start(struct LDKPersister persister, struct LDKEventHandler event_handler, const struct LDKChainMonitor *NONNULL_PTR chain_monitor, const struct LDKChannelManager *NONNULL_PTR channel_manager, struct LDKGossipSync gossip_sync, const struct LDKPeerManager *NONNULL_PTR peer_manager, struct LDKLogger logger, struct LDKCOption_WriteableScoreZ scorer);

/**
 * Join `BackgroundProcessor`'s thread, returning any error that occurred while persisting
 * [`ChannelManager`].
 *
 * # Panics
 *
 * This function panics if the background thread has panicked such as while persisting or
 * handling events.
 *
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 */
MUST_USE_RES struct LDKCResult_NoneErrorZ BackgroundProcessor_join(struct LDKBackgroundProcessor this_arg);

/**
 * Stop `BackgroundProcessor`'s thread, returning any error that occurred while persisting
 * [`ChannelManager`].
 *
 * # Panics
 *
 * This function panics if the background thread has panicked such as while persisting or
 * handling events.
 *
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 */
MUST_USE_RES struct LDKCResult_NoneErrorZ BackgroundProcessor_stop(struct LDKBackgroundProcessor this_arg);

/**
 * Frees any resources used by the ParseError
 */
void ParseError_free(struct LDKParseError this_ptr);

/**
 * Creates a copy of the ParseError
 */
struct LDKParseError ParseError_clone(const struct LDKParseError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Bech32Error-variant ParseError
 */
struct LDKParseError ParseError_bech32_error(struct LDKBech32Error a);

/**
 * Utility method to constructs a new ParseAmountError-variant ParseError
 */
struct LDKParseError ParseError_parse_amount_error(struct LDKError a);

/**
 * Utility method to constructs a new MalformedSignature-variant ParseError
 */
struct LDKParseError ParseError_malformed_signature(enum LDKSecp256k1Error a);

/**
 * Utility method to constructs a new BadPrefix-variant ParseError
 */
struct LDKParseError ParseError_bad_prefix(void);

/**
 * Utility method to constructs a new UnknownCurrency-variant ParseError
 */
struct LDKParseError ParseError_unknown_currency(void);

/**
 * Utility method to constructs a new UnknownSiPrefix-variant ParseError
 */
struct LDKParseError ParseError_unknown_si_prefix(void);

/**
 * Utility method to constructs a new MalformedHRP-variant ParseError
 */
struct LDKParseError ParseError_malformed_hrp(void);

/**
 * Utility method to constructs a new TooShortDataPart-variant ParseError
 */
struct LDKParseError ParseError_too_short_data_part(void);

/**
 * Utility method to constructs a new UnexpectedEndOfTaggedFields-variant ParseError
 */
struct LDKParseError ParseError_unexpected_end_of_tagged_fields(void);

/**
 * Utility method to constructs a new DescriptionDecodeError-variant ParseError
 */
struct LDKParseError ParseError_description_decode_error(struct LDKError a);

/**
 * Utility method to constructs a new PaddingError-variant ParseError
 */
struct LDKParseError ParseError_padding_error(void);

/**
 * Utility method to constructs a new IntegerOverflowError-variant ParseError
 */
struct LDKParseError ParseError_integer_overflow_error(void);

/**
 * Utility method to constructs a new InvalidSegWitProgramLength-variant ParseError
 */
struct LDKParseError ParseError_invalid_seg_wit_program_length(void);

/**
 * Utility method to constructs a new InvalidPubKeyHashLength-variant ParseError
 */
struct LDKParseError ParseError_invalid_pub_key_hash_length(void);

/**
 * Utility method to constructs a new InvalidScriptHashLength-variant ParseError
 */
struct LDKParseError ParseError_invalid_script_hash_length(void);

/**
 * Utility method to constructs a new InvalidRecoveryId-variant ParseError
 */
struct LDKParseError ParseError_invalid_recovery_id(void);

/**
 * Utility method to constructs a new InvalidSliceLength-variant ParseError
 */
struct LDKParseError ParseError_invalid_slice_length(struct LDKStr a);

/**
 * Utility method to constructs a new Skip-variant ParseError
 */
struct LDKParseError ParseError_skip(void);

/**
 * Checks if two ParseErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ParseError_eq(const struct LDKParseError *NONNULL_PTR a, const struct LDKParseError *NONNULL_PTR b);

/**
 * Frees any resources used by the ParseOrSemanticError
 */
void ParseOrSemanticError_free(struct LDKParseOrSemanticError this_ptr);

/**
 * Creates a copy of the ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_clone(const struct LDKParseOrSemanticError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ParseError-variant ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_parse_error(struct LDKParseError a);

/**
 * Utility method to constructs a new SemanticError-variant ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_semantic_error(enum LDKSemanticError a);

/**
 * Checks if two ParseOrSemanticErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ParseOrSemanticError_eq(const struct LDKParseOrSemanticError *NONNULL_PTR a, const struct LDKParseOrSemanticError *NONNULL_PTR b);

/**
 * Frees any resources used by the Invoice, if is_owned is set and inner is non-NULL.
 */
void Invoice_free(struct LDKInvoice this_obj);

/**
 * Checks if two Invoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Invoice_eq(const struct LDKInvoice *NONNULL_PTR a, const struct LDKInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the Invoice
 */
struct LDKInvoice Invoice_clone(const struct LDKInvoice *NONNULL_PTR orig);

/**
 * Checks if two Invoices contain equal inner contents.
 */
uint64_t Invoice_hash(const struct LDKInvoice *NONNULL_PTR o);

/**
 * Frees any resources used by the SignedRawInvoice, if is_owned is set and inner is non-NULL.
 */
void SignedRawInvoice_free(struct LDKSignedRawInvoice this_obj);

/**
 * Checks if two SignedRawInvoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool SignedRawInvoice_eq(const struct LDKSignedRawInvoice *NONNULL_PTR a, const struct LDKSignedRawInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the SignedRawInvoice
 */
struct LDKSignedRawInvoice SignedRawInvoice_clone(const struct LDKSignedRawInvoice *NONNULL_PTR orig);

/**
 * Checks if two SignedRawInvoices contain equal inner contents.
 */
uint64_t SignedRawInvoice_hash(const struct LDKSignedRawInvoice *NONNULL_PTR o);

/**
 * Frees any resources used by the RawInvoice, if is_owned is set and inner is non-NULL.
 */
void RawInvoice_free(struct LDKRawInvoice this_obj);

/**
 * data part
 */
struct LDKRawDataPart RawInvoice_get_data(const struct LDKRawInvoice *NONNULL_PTR this_ptr);

/**
 * data part
 */
void RawInvoice_set_data(struct LDKRawInvoice *NONNULL_PTR this_ptr, struct LDKRawDataPart val);

/**
 * Checks if two RawInvoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RawInvoice_eq(const struct LDKRawInvoice *NONNULL_PTR a, const struct LDKRawInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the RawInvoice
 */
struct LDKRawInvoice RawInvoice_clone(const struct LDKRawInvoice *NONNULL_PTR orig);

/**
 * Checks if two RawInvoices contain equal inner contents.
 */
uint64_t RawInvoice_hash(const struct LDKRawInvoice *NONNULL_PTR o);

/**
 * Frees any resources used by the RawDataPart, if is_owned is set and inner is non-NULL.
 */
void RawDataPart_free(struct LDKRawDataPart this_obj);

/**
 * generation time of the invoice
 */
struct LDKPositiveTimestamp RawDataPart_get_timestamp(const struct LDKRawDataPart *NONNULL_PTR this_ptr);

/**
 * generation time of the invoice
 */
void RawDataPart_set_timestamp(struct LDKRawDataPart *NONNULL_PTR this_ptr, struct LDKPositiveTimestamp val);

/**
 * Checks if two RawDataParts contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RawDataPart_eq(const struct LDKRawDataPart *NONNULL_PTR a, const struct LDKRawDataPart *NONNULL_PTR b);

/**
 * Creates a copy of the RawDataPart
 */
struct LDKRawDataPart RawDataPart_clone(const struct LDKRawDataPart *NONNULL_PTR orig);

/**
 * Checks if two RawDataParts contain equal inner contents.
 */
uint64_t RawDataPart_hash(const struct LDKRawDataPart *NONNULL_PTR o);

/**
 * Frees any resources used by the PositiveTimestamp, if is_owned is set and inner is non-NULL.
 */
void PositiveTimestamp_free(struct LDKPositiveTimestamp this_obj);

/**
 * Checks if two PositiveTimestamps contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PositiveTimestamp_eq(const struct LDKPositiveTimestamp *NONNULL_PTR a, const struct LDKPositiveTimestamp *NONNULL_PTR b);

/**
 * Creates a copy of the PositiveTimestamp
 */
struct LDKPositiveTimestamp PositiveTimestamp_clone(const struct LDKPositiveTimestamp *NONNULL_PTR orig);

/**
 * Checks if two PositiveTimestamps contain equal inner contents.
 */
uint64_t PositiveTimestamp_hash(const struct LDKPositiveTimestamp *NONNULL_PTR o);

/**
 * Creates a copy of the SiPrefix
 */
enum LDKSiPrefix SiPrefix_clone(const enum LDKSiPrefix *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Milli-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_milli(void);

/**
 * Utility method to constructs a new Micro-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_micro(void);

/**
 * Utility method to constructs a new Nano-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_nano(void);

/**
 * Utility method to constructs a new Pico-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_pico(void);

/**
 * Checks if two SiPrefixs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SiPrefix_eq(const enum LDKSiPrefix *NONNULL_PTR a, const enum LDKSiPrefix *NONNULL_PTR b);

/**
 * Checks if two SiPrefixs contain equal inner contents.
 */
uint64_t SiPrefix_hash(const enum LDKSiPrefix *NONNULL_PTR o);

/**
 * Returns the multiplier to go from a BTC value to picoBTC implied by this SiPrefix.
 * This is effectively 10^12 * the prefix multiplier
 */
MUST_USE_RES uint64_t SiPrefix_multiplier(const enum LDKSiPrefix *NONNULL_PTR this_arg);

/**
 * Creates a copy of the Currency
 */
enum LDKCurrency Currency_clone(const enum LDKCurrency *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Bitcoin-variant Currency
 */
enum LDKCurrency Currency_bitcoin(void);

/**
 * Utility method to constructs a new BitcoinTestnet-variant Currency
 */
enum LDKCurrency Currency_bitcoin_testnet(void);

/**
 * Utility method to constructs a new Regtest-variant Currency
 */
enum LDKCurrency Currency_regtest(void);

/**
 * Utility method to constructs a new Simnet-variant Currency
 */
enum LDKCurrency Currency_simnet(void);

/**
 * Utility method to constructs a new Signet-variant Currency
 */
enum LDKCurrency Currency_signet(void);

/**
 * Checks if two Currencys contain equal inner contents.
 */
uint64_t Currency_hash(const enum LDKCurrency *NONNULL_PTR o);

/**
 * Checks if two Currencys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Currency_eq(const enum LDKCurrency *NONNULL_PTR a, const enum LDKCurrency *NONNULL_PTR b);

/**
 * Frees any resources used by the Sha256, if is_owned is set and inner is non-NULL.
 */
void Sha256_free(struct LDKSha256 this_obj);

/**
 * Creates a copy of the Sha256
 */
struct LDKSha256 Sha256_clone(const struct LDKSha256 *NONNULL_PTR orig);

/**
 * Checks if two Sha256s contain equal inner contents.
 */
uint64_t Sha256_hash(const struct LDKSha256 *NONNULL_PTR o);

/**
 * Checks if two Sha256s contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Sha256_eq(const struct LDKSha256 *NONNULL_PTR a, const struct LDKSha256 *NONNULL_PTR b);

/**
 * Frees any resources used by the Description, if is_owned is set and inner is non-NULL.
 */
void Description_free(struct LDKDescription this_obj);

/**
 * Creates a copy of the Description
 */
struct LDKDescription Description_clone(const struct LDKDescription *NONNULL_PTR orig);

/**
 * Checks if two Descriptions contain equal inner contents.
 */
uint64_t Description_hash(const struct LDKDescription *NONNULL_PTR o);

/**
 * Checks if two Descriptions contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Description_eq(const struct LDKDescription *NONNULL_PTR a, const struct LDKDescription *NONNULL_PTR b);

/**
 * Frees any resources used by the PayeePubKey, if is_owned is set and inner is non-NULL.
 */
void PayeePubKey_free(struct LDKPayeePubKey this_obj);

struct LDKPublicKey PayeePubKey_get_a(const struct LDKPayeePubKey *NONNULL_PTR this_ptr);

void PayeePubKey_set_a(struct LDKPayeePubKey *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new PayeePubKey given each field
 */
MUST_USE_RES struct LDKPayeePubKey PayeePubKey_new(struct LDKPublicKey a_arg);

/**
 * Creates a copy of the PayeePubKey
 */
struct LDKPayeePubKey PayeePubKey_clone(const struct LDKPayeePubKey *NONNULL_PTR orig);

/**
 * Checks if two PayeePubKeys contain equal inner contents.
 */
uint64_t PayeePubKey_hash(const struct LDKPayeePubKey *NONNULL_PTR o);

/**
 * Checks if two PayeePubKeys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PayeePubKey_eq(const struct LDKPayeePubKey *NONNULL_PTR a, const struct LDKPayeePubKey *NONNULL_PTR b);

/**
 * Frees any resources used by the ExpiryTime, if is_owned is set and inner is non-NULL.
 */
void ExpiryTime_free(struct LDKExpiryTime this_obj);

/**
 * Creates a copy of the ExpiryTime
 */
struct LDKExpiryTime ExpiryTime_clone(const struct LDKExpiryTime *NONNULL_PTR orig);

/**
 * Checks if two ExpiryTimes contain equal inner contents.
 */
uint64_t ExpiryTime_hash(const struct LDKExpiryTime *NONNULL_PTR o);

/**
 * Checks if two ExpiryTimes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ExpiryTime_eq(const struct LDKExpiryTime *NONNULL_PTR a, const struct LDKExpiryTime *NONNULL_PTR b);

/**
 * Frees any resources used by the MinFinalCltvExpiry, if is_owned is set and inner is non-NULL.
 */
void MinFinalCltvExpiry_free(struct LDKMinFinalCltvExpiry this_obj);

uint64_t MinFinalCltvExpiry_get_a(const struct LDKMinFinalCltvExpiry *NONNULL_PTR this_ptr);

void MinFinalCltvExpiry_set_a(struct LDKMinFinalCltvExpiry *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new MinFinalCltvExpiry given each field
 */
MUST_USE_RES struct LDKMinFinalCltvExpiry MinFinalCltvExpiry_new(uint64_t a_arg);

/**
 * Creates a copy of the MinFinalCltvExpiry
 */
struct LDKMinFinalCltvExpiry MinFinalCltvExpiry_clone(const struct LDKMinFinalCltvExpiry *NONNULL_PTR orig);

/**
 * Checks if two MinFinalCltvExpirys contain equal inner contents.
 */
uint64_t MinFinalCltvExpiry_hash(const struct LDKMinFinalCltvExpiry *NONNULL_PTR o);

/**
 * Checks if two MinFinalCltvExpirys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool MinFinalCltvExpiry_eq(const struct LDKMinFinalCltvExpiry *NONNULL_PTR a, const struct LDKMinFinalCltvExpiry *NONNULL_PTR b);

/**
 * Frees any resources used by the Fallback
 */
void Fallback_free(struct LDKFallback this_ptr);

/**
 * Creates a copy of the Fallback
 */
struct LDKFallback Fallback_clone(const struct LDKFallback *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SegWitProgram-variant Fallback
 */
struct LDKFallback Fallback_seg_wit_program(struct LDKU5 version, struct LDKCVec_u8Z program);

/**
 * Utility method to constructs a new PubKeyHash-variant Fallback
 */
struct LDKFallback Fallback_pub_key_hash(struct LDKTwentyBytes a);

/**
 * Utility method to constructs a new ScriptHash-variant Fallback
 */
struct LDKFallback Fallback_script_hash(struct LDKTwentyBytes a);

/**
 * Checks if two Fallbacks contain equal inner contents.
 */
uint64_t Fallback_hash(const struct LDKFallback *NONNULL_PTR o);

/**
 * Checks if two Fallbacks contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Fallback_eq(const struct LDKFallback *NONNULL_PTR a, const struct LDKFallback *NONNULL_PTR b);

/**
 * Frees any resources used by the InvoiceSignature, if is_owned is set and inner is non-NULL.
 */
void InvoiceSignature_free(struct LDKInvoiceSignature this_obj);

/**
 * Creates a copy of the InvoiceSignature
 */
struct LDKInvoiceSignature InvoiceSignature_clone(const struct LDKInvoiceSignature *NONNULL_PTR orig);

/**
 * Checks if two InvoiceSignatures contain equal inner contents.
 */
uint64_t InvoiceSignature_hash(const struct LDKInvoiceSignature *NONNULL_PTR o);

/**
 * Checks if two InvoiceSignatures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InvoiceSignature_eq(const struct LDKInvoiceSignature *NONNULL_PTR a, const struct LDKInvoiceSignature *NONNULL_PTR b);

/**
 * Frees any resources used by the PrivateRoute, if is_owned is set and inner is non-NULL.
 */
void PrivateRoute_free(struct LDKPrivateRoute this_obj);

/**
 * Creates a copy of the PrivateRoute
 */
struct LDKPrivateRoute PrivateRoute_clone(const struct LDKPrivateRoute *NONNULL_PTR orig);

/**
 * Checks if two PrivateRoutes contain equal inner contents.
 */
uint64_t PrivateRoute_hash(const struct LDKPrivateRoute *NONNULL_PTR o);

/**
 * Checks if two PrivateRoutes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PrivateRoute_eq(const struct LDKPrivateRoute *NONNULL_PTR a, const struct LDKPrivateRoute *NONNULL_PTR b);

/**
 * Disassembles the `SignedRawInvoice` into its three parts:
 *  1. raw invoice
 *  2. hash of the raw invoice
 *  3. signature
 */
MUST_USE_RES struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ SignedRawInvoice_into_parts(struct LDKSignedRawInvoice this_arg);

/**
 * The `RawInvoice` which was signed.
 */
MUST_USE_RES struct LDKRawInvoice SignedRawInvoice_raw_invoice(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * The hash of the `RawInvoice` that was signed.
 */
MUST_USE_RES const uint8_t (*SignedRawInvoice_signable_hash(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg))[32];

/**
 * InvoiceSignature for the invoice.
 */
MUST_USE_RES struct LDKInvoiceSignature SignedRawInvoice_signature(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Recovers the public key used for signing the invoice from the recoverable signature.
 */
MUST_USE_RES struct LDKCResult_PayeePubKeyErrorZ SignedRawInvoice_recover_payee_pub_key(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Checks if the signature is valid for the included payee public key or if none exists if it's
 * valid for the recovered signature (which should always be true?).
 */
MUST_USE_RES bool SignedRawInvoice_check_signature(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Calculate the hash of the encoded `RawInvoice` which should be signed.
 */
MUST_USE_RES struct LDKThirtyTwoBytes RawInvoice_signable_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKSha256 RawInvoice_payment_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKDescription RawInvoice_description(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPayeePubKey RawInvoice_payee_pub_key(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKSha256 RawInvoice_description_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKExpiryTime RawInvoice_expiry_time(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKMinFinalCltvExpiry RawInvoice_min_final_cltv_expiry(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKThirtyTwoBytes RawInvoice_payment_secret(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKInvoiceFeatures RawInvoice_features(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCVec_PrivateRouteZ RawInvoice_private_routes(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCOption_u64Z RawInvoice_amount_pico_btc(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES enum LDKCurrency RawInvoice_currency(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 * Creates a `PositiveTimestamp` from a Unix timestamp in the range `0..=MAX_TIMESTAMP`.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_unix_timestamp(uint64_t unix_seconds);

/**
 * Creates a `PositiveTimestamp` from a [`SystemTime`] with a corresponding Unix timestamp in
 * the range `0..=MAX_TIMESTAMP`.
 *
 * Note that the subsecond part is dropped as it is not representable in BOLT 11 invoices.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_system_time(uint64_t time);

/**
 * Creates a `PositiveTimestamp` from a [`Duration`] since the Unix epoch in the range
 * `0..=MAX_TIMESTAMP`.
 *
 * Note that the subsecond part is dropped as it is not representable in BOLT 11 invoices.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_duration_since_epoch(uint64_t duration);

/**
 * Returns the Unix timestamp representing the stored time
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_unix_timestamp(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Returns the duration of the stored time since the Unix epoch
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_duration_since_epoch(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Returns the [`SystemTime`] representing the stored time
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_time(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Transform the `Invoice` into it's unchecked version
 */
MUST_USE_RES struct LDKSignedRawInvoice Invoice_into_signed_raw(struct LDKInvoice this_arg);

/**
 * Check that the invoice is signed correctly and that key recovery works
 */
MUST_USE_RES struct LDKCResult_NoneSemanticErrorZ Invoice_check_signature(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Constructs an `Invoice` from a `SignedRawInvoice` by checking all its invariants.
 * ```
 * use lightning_invoice::*;
 *
 * let invoice = \"lnbc100p1psj9jhxdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4q0d3p2sfluzdx45tqcs\\
 * h2pu5qc7lgq0xs578ngs6s0s68ua4h7cvspp5q6rmq35js88zp5dvwrv9m459tnk2zunwj5jalqtyxqulh0l\\
 * 5gflssp5nf55ny5gcrfl30xuhzj3nphgj27rstekmr9fw3ny5989s300gyus9qyysgqcqpcrzjqw2sxwe993\\
 * h5pcm4dxzpvttgza8zhkqxpgffcrf5v25nwpr3cmfg7z54kuqq8rgqqqqqqqq2qqqqq9qq9qrzjqd0ylaqcl\\
 * j9424x9m8h2vcukcgnm6s56xfgu3j78zyqzhgs4hlpzvznlugqq9vsqqqqqqqlgqqqqqeqq9qrzjqwldmj9d\\
 * ha74df76zhx6l9we0vjdquygcdt3kssupehe64g6yyp5yz5rhuqqwccqqyqqqqlgqqqqjcqq9qrzjqf9e58a\\
 * guqr0rcun0ajlvmzq3ek63cw2w282gv3z5uupmuwvgjtq2z55qsqqg6qqqyqqqrtnqqqzq3cqygrzjqvphms\\
 * ywntrrhqjcraumvc4y6r8v4z5v593trte429v4hredj7ms5z52usqq9ngqqqqqqqlgqqqqqqgq9qrzjq2v0v\\
 * p62g49p7569ev48cmulecsxe59lvaw3wlxm7r982zxa9zzj7z5l0cqqxusqqyqqqqlgqqqqqzsqygarl9fh3\\
 * 8s0gyuxjjgux34w75dnc6xp2l35j7es3jd4ugt3lu0xzre26yg5m7ke54n2d5sym4xcmxtl8238xxvw5h5h5\\
 * j5r6drg6k6zcqj0fcwg\";
 *
 * let signed = invoice.parse::<SignedRawInvoice>().unwrap();
 *
 * assert!(Invoice::from_signed(signed).is_ok());
 * ```
 */
MUST_USE_RES struct LDKCResult_InvoiceSemanticErrorZ Invoice_from_signed(struct LDKSignedRawInvoice signed_invoice);

/**
 * Returns the `Invoice`'s timestamp (should equal its creation time)
 */
MUST_USE_RES uint64_t Invoice_timestamp(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the `Invoice`'s timestamp as a duration since the Unix epoch
 */
MUST_USE_RES uint64_t Invoice_duration_since_epoch(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the hash to which we will receive the preimage on completion of the payment
 */
MUST_USE_RES const uint8_t (*Invoice_payment_hash(const struct LDKInvoice *NONNULL_PTR this_arg))[32];

/**
 * Get the payee's public key if one was included in the invoice
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPublicKey Invoice_payee_pub_key(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Get the payment secret if one was included in the invoice
 */
MUST_USE_RES const uint8_t (*Invoice_payment_secret(const struct LDKInvoice *NONNULL_PTR this_arg))[32];

/**
 * Get the invoice features if they were included in the invoice
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKInvoiceFeatures Invoice_features(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Recover the payee's public key (only to be used if none was included in the invoice)
 */
MUST_USE_RES struct LDKPublicKey Invoice_recover_payee_pub_key(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the invoice's expiry time, if present, otherwise [`DEFAULT_EXPIRY_TIME`].
 */
MUST_USE_RES uint64_t Invoice_expiry_time(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns whether the invoice has expired.
 */
MUST_USE_RES bool Invoice_is_expired(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns whether the expiry time would pass at the given point in time.
 * `at_time` is the timestamp as a duration since the Unix epoch.
 */
MUST_USE_RES bool Invoice_would_expire(const struct LDKInvoice *NONNULL_PTR this_arg, uint64_t at_time);

/**
 * Returns the invoice's `min_final_cltv_expiry` time, if present, otherwise
 * [`DEFAULT_MIN_FINAL_CLTV_EXPIRY`].
 */
MUST_USE_RES uint64_t Invoice_min_final_cltv_expiry(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all routes included in the invoice
 */
MUST_USE_RES struct LDKCVec_PrivateRouteZ Invoice_private_routes(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all routes included in the invoice as the underlying hints
 */
MUST_USE_RES struct LDKCVec_RouteHintZ Invoice_route_hints(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the currency for which the invoice was issued
 */
MUST_USE_RES enum LDKCurrency Invoice_currency(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the amount if specified in the invoice as millisatoshis.
 */
MUST_USE_RES struct LDKCOption_u64Z Invoice_amount_milli_satoshis(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Creates a new `Description` if `description` is at most 1023 __bytes__ long,
 * returns `CreationError::DescriptionTooLong` otherwise
 *
 * Please note that single characters may use more than one byte due to UTF8 encoding.
 */
MUST_USE_RES struct LDKCResult_DescriptionCreationErrorZ Description_new(struct LDKStr description);

/**
 * Returns the underlying description `String`
 */
MUST_USE_RES struct LDKStr Description_into_inner(struct LDKDescription this_arg);

/**
 * Construct an `ExpiryTime` from seconds.
 */
MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_seconds(uint64_t seconds);

/**
 * Construct an `ExpiryTime` from a `Duration`, dropping the sub-second part.
 */
MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_duration(uint64_t duration);

/**
 * Returns the expiry time in seconds
 */
MUST_USE_RES uint64_t ExpiryTime_as_seconds(const struct LDKExpiryTime *NONNULL_PTR this_arg);

/**
 * Returns a reference to the underlying `Duration` (=expiry time)
 */
MUST_USE_RES uint64_t ExpiryTime_as_duration(const struct LDKExpiryTime *NONNULL_PTR this_arg);

/**
 * Creates a new (partial) route from a list of hops
 */
MUST_USE_RES struct LDKCResult_PrivateRouteCreationErrorZ PrivateRoute_new(struct LDKRouteHint hops);

/**
 * Returns the underlying list of hops
 */
MUST_USE_RES struct LDKRouteHint PrivateRoute_into_inner(struct LDKPrivateRoute this_arg);

/**
 * Creates a copy of the CreationError
 */
enum LDKCreationError CreationError_clone(const enum LDKCreationError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new DescriptionTooLong-variant CreationError
 */
enum LDKCreationError CreationError_description_too_long(void);

/**
 * Utility method to constructs a new RouteTooLong-variant CreationError
 */
enum LDKCreationError CreationError_route_too_long(void);

/**
 * Utility method to constructs a new TimestampOutOfBounds-variant CreationError
 */
enum LDKCreationError CreationError_timestamp_out_of_bounds(void);

/**
 * Utility method to constructs a new InvalidAmount-variant CreationError
 */
enum LDKCreationError CreationError_invalid_amount(void);

/**
 * Utility method to constructs a new MissingRouteHints-variant CreationError
 */
enum LDKCreationError CreationError_missing_route_hints(void);

/**
 * Checks if two CreationErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool CreationError_eq(const enum LDKCreationError *NONNULL_PTR a, const enum LDKCreationError *NONNULL_PTR b);

/**
 * Get the string representation of a CreationError object
 */
struct LDKStr CreationError_to_str(const enum LDKCreationError *NONNULL_PTR o);

/**
 * Creates a copy of the SemanticError
 */
enum LDKSemanticError SemanticError_clone(const enum LDKSemanticError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new NoPaymentHash-variant SemanticError
 */
enum LDKSemanticError SemanticError_no_payment_hash(void);

/**
 * Utility method to constructs a new MultiplePaymentHashes-variant SemanticError
 */
enum LDKSemanticError SemanticError_multiple_payment_hashes(void);

/**
 * Utility method to constructs a new NoDescription-variant SemanticError
 */
enum LDKSemanticError SemanticError_no_description(void);

/**
 * Utility method to constructs a new MultipleDescriptions-variant SemanticError
 */
enum LDKSemanticError SemanticError_multiple_descriptions(void);

/**
 * Utility method to constructs a new NoPaymentSecret-variant SemanticError
 */
enum LDKSemanticError SemanticError_no_payment_secret(void);

/**
 * Utility method to constructs a new MultiplePaymentSecrets-variant SemanticError
 */
enum LDKSemanticError SemanticError_multiple_payment_secrets(void);

/**
 * Utility method to constructs a new InvalidFeatures-variant SemanticError
 */
enum LDKSemanticError SemanticError_invalid_features(void);

/**
 * Utility method to constructs a new InvalidRecoveryId-variant SemanticError
 */
enum LDKSemanticError SemanticError_invalid_recovery_id(void);

/**
 * Utility method to constructs a new InvalidSignature-variant SemanticError
 */
enum LDKSemanticError SemanticError_invalid_signature(void);

/**
 * Utility method to constructs a new ImpreciseAmount-variant SemanticError
 */
enum LDKSemanticError SemanticError_imprecise_amount(void);

/**
 * Checks if two SemanticErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SemanticError_eq(const enum LDKSemanticError *NONNULL_PTR a, const enum LDKSemanticError *NONNULL_PTR b);

/**
 * Get the string representation of a SemanticError object
 */
struct LDKStr SemanticError_to_str(const enum LDKSemanticError *NONNULL_PTR o);

/**
 * Frees any resources used by the SignOrCreationError
 */
void SignOrCreationError_free(struct LDKSignOrCreationError this_ptr);

/**
 * Creates a copy of the SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_clone(const struct LDKSignOrCreationError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SignError-variant SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_sign_error(void);

/**
 * Utility method to constructs a new CreationError-variant SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_creation_error(enum LDKCreationError a);

/**
 * Checks if two SignOrCreationErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SignOrCreationError_eq(const struct LDKSignOrCreationError *NONNULL_PTR a, const struct LDKSignOrCreationError *NONNULL_PTR b);

/**
 * Get the string representation of a SignOrCreationError object
 */
struct LDKStr SignOrCreationError_to_str(const struct LDKSignOrCreationError *NONNULL_PTR o);

/**
 * Frees any resources used by the InvoicePayer, if is_owned is set and inner is non-NULL.
 */
void InvoicePayer_free(struct LDKInvoicePayer this_obj);

/**
 * Calls the free function if one is set
 */
void Payer_free(struct LDKPayer this_ptr);

/**
 * Frees any resources used by the Retry
 */
void Retry_free(struct LDKRetry this_ptr);

/**
 * Creates a copy of the Retry
 */
struct LDKRetry Retry_clone(const struct LDKRetry *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Attempts-variant Retry
 */
struct LDKRetry Retry_attempts(uintptr_t a);

/**
 * Utility method to constructs a new Timeout-variant Retry
 */
struct LDKRetry Retry_timeout(uint64_t a);

/**
 * Checks if two Retrys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Retry_eq(const struct LDKRetry *NONNULL_PTR a, const struct LDKRetry *NONNULL_PTR b);

/**
 * Checks if two Retrys contain equal inner contents.
 */
uint64_t Retry_hash(const struct LDKRetry *NONNULL_PTR o);

/**
 * Frees any resources used by the PaymentError
 */
void PaymentError_free(struct LDKPaymentError this_ptr);

/**
 * Creates a copy of the PaymentError
 */
struct LDKPaymentError PaymentError_clone(const struct LDKPaymentError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Invoice-variant PaymentError
 */
struct LDKPaymentError PaymentError_invoice(struct LDKStr a);

/**
 * Utility method to constructs a new Routing-variant PaymentError
 */
struct LDKPaymentError PaymentError_routing(struct LDKLightningError a);

/**
 * Utility method to constructs a new Sending-variant PaymentError
 */
struct LDKPaymentError PaymentError_sending(struct LDKPaymentSendFailure a);

/**
 * Creates an invoice payer that retries failed payment paths.
 *
 * Will forward any [`Event::PaymentPathFailed`] events to the decorated `event_handler` once
 * `retry` has been exceeded for a given [`Invoice`].
 */
MUST_USE_RES struct LDKInvoicePayer InvoicePayer_new(struct LDKPayer payer, struct LDKRouter router, struct LDKLogger logger, struct LDKEventHandler event_handler, struct LDKRetry retry);

/**
 * Pays the given [`Invoice`], caching it for later use in case a retry is needed.
 *
 * [`Invoice::payment_hash`] is used as the [`PaymentId`], which ensures idempotency as long
 * as the payment is still pending. Once the payment completes or fails, you must ensure that
 * a second payment with the same [`PaymentHash`] is never sent.
 *
 * If you wish to use a different payment idempotency token, see
 * [`Self::pay_invoice_with_id`].
 */
MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_invoice(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const struct LDKInvoice *NONNULL_PTR invoice);

/**
 * Pays the given [`Invoice`] with a custom idempotency key, caching the invoice for later use
 * in case a retry is needed.
 *
 * Note that idempotency is only guaranteed as long as the payment is still pending. Once the
 * payment completes or fails, no idempotency guarantees are made.
 *
 * You should ensure that the [`Invoice::payment_hash`] is unique and the same [`PaymentHash`]
 * has never been paid before.
 *
 * See [`Self::pay_invoice`] for a variant which uses the [`PaymentHash`] for the idempotency
 * token.
 */
MUST_USE_RES struct LDKCResult_NonePaymentErrorZ InvoicePayer_pay_invoice_with_id(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const struct LDKInvoice *NONNULL_PTR invoice, struct LDKThirtyTwoBytes payment_id);

/**
 * Pays the given zero-value [`Invoice`] using the given amount, caching it for later use in
 * case a retry is needed.
 *
 * [`Invoice::payment_hash`] is used as the [`PaymentId`], which ensures idempotency as long
 * as the payment is still pending. Once the payment completes or fails, you must ensure that
 * a second payment with the same [`PaymentHash`] is never sent.
 *
 * If you wish to use a different payment idempotency token, see
 * [`Self::pay_zero_value_invoice_with_id`].
 */
MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_zero_value_invoice(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const struct LDKInvoice *NONNULL_PTR invoice, uint64_t amount_msats);

/**
 * Pays the given zero-value [`Invoice`] using the given amount and custom idempotency key,
 * caching the invoice for later use in case a retry is needed.
 *
 * Note that idempotency is only guaranteed as long as the payment is still pending. Once the
 * payment completes or fails, no idempotency guarantees are made.
 *
 * You should ensure that the [`Invoice::payment_hash`] is unique and the same [`PaymentHash`]
 * has never been paid before.
 *
 * See [`Self::pay_zero_value_invoice`] for a variant which uses the [`PaymentHash`] for the
 * idempotency token.
 */
MUST_USE_RES struct LDKCResult_NonePaymentErrorZ InvoicePayer_pay_zero_value_invoice_with_id(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const struct LDKInvoice *NONNULL_PTR invoice, uint64_t amount_msats, struct LDKThirtyTwoBytes payment_id);

/**
 * Pays `pubkey` an amount using the hash of the given preimage, caching it for later use in
 * case a retry is needed.
 *
 * The hash of the [`PaymentPreimage`] is used as the [`PaymentId`], which ensures idempotency
 * as long as the payment is still pending. Once the payment completes or fails, you must
 * ensure that a second payment with the same [`PaymentPreimage`] is never sent.
 */
MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_pubkey(const struct LDKInvoicePayer *NONNULL_PTR this_arg, struct LDKPublicKey pubkey, struct LDKThirtyTwoBytes payment_preimage, uint64_t amount_msats, uint32_t final_cltv_expiry_delta);

/**
 * Pays `pubkey` an amount using the hash of the given preimage and a custom idempotency key,
 * caching the invoice for later use in case a retry is needed.
 *
 * Note that idempotency is only guaranteed as long as the payment is still pending. Once the
 * payment completes or fails, no idempotency guarantees are made.
 *
 * You should ensure that the [`PaymentPreimage`] is unique and the corresponding
 * [`PaymentHash`] has never been paid before.
 */
MUST_USE_RES struct LDKCResult_NonePaymentErrorZ InvoicePayer_pay_pubkey_with_id(const struct LDKInvoicePayer *NONNULL_PTR this_arg, struct LDKPublicKey pubkey, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_id, uint64_t amount_msats, uint32_t final_cltv_expiry_delta);

/**
 * Removes the payment cached by the given payment hash.
 *
 * Should be called once a payment has failed or succeeded if not using [`InvoicePayer`] as an
 * [`EventHandler`]. Otherwise, calling this method is unnecessary.
 */
void InvoicePayer_remove_cached_payment(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);

/**
 * Constructs a new EventHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventHandler must be freed before this_arg is
 */
struct LDKEventHandler InvoicePayer_as_EventHandler(const struct LDKInvoicePayer *NONNULL_PTR this_arg);

/**
 * Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
 * See [`PhantomKeysManager`] for more information on phantom node payments.
 *
 * `phantom_route_hints` parameter:
 * * Contains channel info for all nodes participating in the phantom invoice
 * * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
 *   participating node
 * * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
 *   updated when a channel becomes disabled or closes
 * * Note that if too many channels are included in [`PhantomRouteHints::channels`], the invoice
 *   may be too long for QR code scanning. To fix this, `PhantomRouteHints::channels` may be pared
 *   down
 *
 * `payment_hash` can be specified if you have a specific need for a custom payment hash (see the difference
 * between [`ChannelManager::create_inbound_payment`] and [`ChannelManager::create_inbound_payment_for_hash`]).
 * If `None` is provided for `payment_hash`, then one will be created.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time.
 *
 * Note that the provided `keys_manager`'s `KeysInterface` implementation must support phantom
 * invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
 * requirement).
 *
 * [`PhantomKeysManager`]: lightning::chain::keysinterface::PhantomKeysManager
 * [`ChannelManager::get_phantom_route_hints`]: lightning::ln::channelmanager::ChannelManager::get_phantom_route_hints
 * [`ChannelManager::create_inbound_payment`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment
 * [`ChannelManager::create_inbound_payment_for_hash`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
 * [`PhantomRouteHints::channels`]: lightning::ln::channelmanager::PhantomRouteHints::channels
 *
 * Note that payment_hash (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_phantom_invoice(struct LDKCOption_u64Z amt_msat, struct LDKThirtyTwoBytes payment_hash, struct LDKStr description, uint32_t invoice_expiry_delta_secs, struct LDKCVec_PhantomRouteHintsZ phantom_route_hints, struct LDKKeysInterface keys_manager, struct LDKLogger logger, enum LDKCurrency network);

/**
 * Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
 * See [`PhantomKeysManager`] for more information on phantom node payments.
 *
 * `phantom_route_hints` parameter:
 * * Contains channel info for all nodes participating in the phantom invoice
 * * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
 *   participating node
 * * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
 *   updated when a channel becomes disabled or closes
 * * Note that if too many channels are included in [`PhantomRouteHints::channels`], the invoice
 *   may be too long for QR code scanning. To fix this, `PhantomRouteHints::channels` may be pared
 *   down
 *
 * `description_hash` is a SHA-256 hash of the description text
 *
 * `payment_hash` can be specified if you have a specific need for a custom payment hash (see the difference
 * between [`ChannelManager::create_inbound_payment`] and [`ChannelManager::create_inbound_payment_for_hash`]).
 * If `None` is provided for `payment_hash`, then one will be created.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time.
 *
 * Note that the provided `keys_manager`'s `KeysInterface` implementation must support phantom
 * invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
 * requirement).
 *
 * [`PhantomKeysManager`]: lightning::chain::keysinterface::PhantomKeysManager
 * [`ChannelManager::get_phantom_route_hints`]: lightning::ln::channelmanager::ChannelManager::get_phantom_route_hints
 * [`ChannelManager::create_inbound_payment`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment
 * [`ChannelManager::create_inbound_payment_for_hash`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
 * [`PhantomRouteHints::channels`]: lightning::ln::channelmanager::PhantomRouteHints::channels
 *
 * Note that payment_hash (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_phantom_invoice_with_description_hash(struct LDKCOption_u64Z amt_msat, struct LDKThirtyTwoBytes payment_hash, uint32_t invoice_expiry_delta_secs, struct LDKSha256 description_hash, struct LDKCVec_PhantomRouteHintsZ phantom_route_hints, struct LDKKeysInterface keys_manager, struct LDKLogger logger, enum LDKCurrency network);

/**
 * Utility to construct an invoice. Generally, unless you want to do something like a custom
 * cltv_expiry, this is what you should be using to create an invoice. The reason being, this
 * method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
 * doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
 * that the payment secret is valid when the invoice is paid.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint32_t invoice_expiry_delta_secs);

/**
 * Utility to construct an invoice. Generally, unless you want to do something like a custom
 * cltv_expiry, this is what you should be using to create an invoice. The reason being, this
 * method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
 * doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
 * that the payment secret is valid when the invoice is paid.
 * Use this variant if you want to pass the `description_hash` to the invoice.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_with_description_hash(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash, uint32_t invoice_expiry_delta_secs);

/**
 * See [`create_invoice_from_channelmanager_with_description_hash`]
 * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
 * available and the current time is supplied by the caller.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs);

/**
 * See [`create_invoice_from_channelmanager`]
 * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
 * available and the current time is supplied by the caller.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs);

/**
 * See [`create_invoice_from_channelmanager_and_duration_since_epoch`]
 * This version allows for providing a custom [`PaymentHash`] for the invoice.
 * This may be useful if you're building an on-chain swap or involving another protocol where
 * the payment hash is also involved outside the scope of lightning.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_and_duration_since_epoch_with_payment_hash(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs, struct LDKThirtyTwoBytes payment_hash);

/**
 * Constructs a new Payer which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Payer must be freed before this_arg is
 */
struct LDKPayer ChannelManager_as_Payer(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Read a SiPrefix object from a string
 */
struct LDKCResult_SiPrefixParseErrorZ SiPrefix_from_str(struct LDKStr s);

/**
 * Read a Invoice object from a string
 */
struct LDKCResult_InvoiceParseOrSemanticErrorZ Invoice_from_str(struct LDKStr s);

/**
 * Read a SignedRawInvoice object from a string
 */
struct LDKCResult_SignedRawInvoiceParseErrorZ SignedRawInvoice_from_str(struct LDKStr s);

/**
 * Get the string representation of a ParseError object
 */
struct LDKStr ParseError_to_str(const struct LDKParseError *NONNULL_PTR o);

/**
 * Get the string representation of a ParseOrSemanticError object
 */
struct LDKStr ParseOrSemanticError_to_str(const struct LDKParseOrSemanticError *NONNULL_PTR o);

/**
 * Get the string representation of a Invoice object
 */
struct LDKStr Invoice_to_str(const struct LDKInvoice *NONNULL_PTR o);

/**
 * Get the string representation of a SignedRawInvoice object
 */
struct LDKStr SignedRawInvoice_to_str(const struct LDKSignedRawInvoice *NONNULL_PTR o);

/**
 * Get the string representation of a Currency object
 */
struct LDKStr Currency_to_str(const enum LDKCurrency *NONNULL_PTR o);

/**
 * Get the string representation of a SiPrefix object
 */
struct LDKStr SiPrefix_to_str(const enum LDKSiPrefix *NONNULL_PTR o);

/**
 * Frees any resources used by the RapidGossipSync, if is_owned is set and inner is non-NULL.
 */
void RapidGossipSync_free(struct LDKRapidGossipSync this_obj);

/**
 * Instantiate a new [`RapidGossipSync`] instance.
 */
MUST_USE_RES struct LDKRapidGossipSync RapidGossipSync_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph);

/**
 * Update network graph from binary data.
 * Returns the last sync timestamp to be used the next time rapid sync data is queried.
 *
 * `network_graph`: network graph to be updated
 *
 * `update_data`: `&[u8]` binary stream that comprises the update data
 */
MUST_USE_RES struct LDKCResult_u32GraphSyncErrorZ RapidGossipSync_update_network_graph(const struct LDKRapidGossipSync *NONNULL_PTR this_arg, struct LDKu8slice update_data);

/**
 * Returns whether a rapid gossip sync has completed at least once.
 */
MUST_USE_RES bool RapidGossipSync_is_initial_sync_complete(const struct LDKRapidGossipSync *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the GraphSyncError
 */
void GraphSyncError_free(struct LDKGraphSyncError this_ptr);

/**
 * Creates a copy of the GraphSyncError
 */
struct LDKGraphSyncError GraphSyncError_clone(const struct LDKGraphSyncError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new DecodeError-variant GraphSyncError
 */
struct LDKGraphSyncError GraphSyncError_decode_error(struct LDKDecodeError a);

/**
 * Utility method to constructs a new LightningError-variant GraphSyncError
 */
struct LDKGraphSyncError GraphSyncError_lightning_error(struct LDKLightningError a);

#endif /* LDK_C_BINDINGS_H */

#include "ldk_ver.h"
