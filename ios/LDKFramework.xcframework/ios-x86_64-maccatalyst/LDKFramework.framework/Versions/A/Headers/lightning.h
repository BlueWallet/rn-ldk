#ifndef LDK_C_BINDINGS_H
#define LDK_C_BINDINGS_H

/* Generated with cbindgen:0.19.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include "ldk_rust_types.h"

/**
 * An error when accessing the chain via [`Access`].
 */
typedef enum LDKAccessError {
   /**
    * The requested chain is unknown.
    */
   LDKAccessError_UnknownChain,
   /**
    * The requested transaction doesn't exist or hasn't confirmed.
    */
   LDKAccessError_UnknownTx,
   /**
    * Must be last for serialization purposes
    */
   LDKAccessError_Sentinel,
} LDKAccessError;

/**
 * An error enum representing a failure to persist a channel monitor update.
 */
typedef enum LDKChannelMonitorUpdateErr {
   /**
    * Used to indicate a temporary failure (eg connection to a watchtower or remote backup of
    * our state failed, but is expected to succeed at some point in the future).
    *
    * Such a failure will \"freeze\" a channel, preventing us from revoking old states or
    * submitting new commitment transactions to the counterparty. Once the update(s) which failed
    * have been successfully applied, ChannelManager::channel_monitor_updated can be used to
    * restore the channel to an operational state.
    *
    * Note that a given ChannelManager will *never* re-generate a given ChannelMonitorUpdate. If
    * you return a TemporaryFailure you must ensure that it is written to disk safely before
    * writing out the latest ChannelManager state.
    *
    * Even when a channel has been \"frozen\" updates to the ChannelMonitor can continue to occur
    * (eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting
    * to claim it on this channel) and those updates must be applied wherever they can be. At
    * least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should
    * be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to
    * the channel which would invalidate previous ChannelMonitors are not made when a channel has
    * been \"frozen\".
    *
    * Note that even if updates made after TemporaryFailure succeed you must still call
    * channel_monitor_updated to ensure you have the latest monitor and re-enable normal channel
    * operation.
    *
    * Note that the update being processed here will not be replayed for you when you call
    * ChannelManager::channel_monitor_updated, so you must store the update itself along
    * with the persisted ChannelMonitor on your own local disk prior to returning a
    * TemporaryFailure. You may, of course, employ a journaling approach, storing only the
    * ChannelMonitorUpdate on disk without updating the monitor itself, replaying the journal at
    * reload-time.
    *
    * For deployments where a copy of ChannelMonitors and other local state are backed up in a
    * remote location (with local copies persisted immediately), it is anticipated that all
    * updates will return TemporaryFailure until the remote copies could be updated.
    */
   LDKChannelMonitorUpdateErr_TemporaryFailure,
   /**
    * Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a
    * different watchtower and cannot update with all watchtowers that were previously informed
    * of this channel).
    *
    * At reception of this error, ChannelManager will force-close the channel and return at
    * least a final ChannelMonitorUpdate::ChannelForceClosed which must be delivered to at
    * least one ChannelMonitor copy. Revocation secret MUST NOT be released and offchain channel
    * update must be rejected.
    *
    * This failure may also signal a failure to update the local persisted copy of one of
    * the channel monitor instance.
    *
    * Note that even when you fail a holder commitment transaction update, you must store the
    * update to ensure you can claim from it in case of a duplicate copy of this ChannelMonitor
    * broadcasts it (e.g distributed channel-monitor deployment)
    *
    * In case of distributed watchtowers deployment, the new version must be written to disk, as
    * state may have been stored but rejected due to a block forcing a commitment broadcast. This
    * storage is used to claim outputs of rejected state confirmed onchain by another watchtower,
    * lagging behind on block processing.
    */
   LDKChannelMonitorUpdateErr_PermanentFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKChannelMonitorUpdateErr_Sentinel,
} LDKChannelMonitorUpdateErr;

/**
 * An enum that represents the speed at which we want a transaction to confirm used for feerate
 * estimation.
 */
typedef enum LDKConfirmationTarget {
   /**
    * We are happy with this transaction confirming slowly when feerate drops some.
    */
   LDKConfirmationTarget_Background,
   /**
    * We'd like this transaction to confirm without major delay, but 12-18 blocks is fine.
    */
   LDKConfirmationTarget_Normal,
   /**
    * We'd like this transaction to confirm in the next few blocks.
    */
   LDKConfirmationTarget_HighPriority,
   /**
    * Must be last for serialization purposes
    */
   LDKConfirmationTarget_Sentinel,
} LDKConfirmationTarget;

/**
 * Errors that may occur when constructing a new `RawInvoice` or `Invoice`
 */
typedef enum LDKCreationError {
   /**
    * The supplied description string was longer than 639 __bytes__ (see [`Description::new(â€¦)`](./struct.Description.html#method.new))
    */
   LDKCreationError_DescriptionTooLong,
   /**
    * The specified route has too many hops and can't be encoded
    */
   LDKCreationError_RouteTooLong,
   /**
    * The unix timestamp of the supplied date is <0 or can't be represented as `SystemTime`
    */
   LDKCreationError_TimestampOutOfBounds,
   /**
    * The supplied expiry time could cause an overflow if added to a `PositiveTimestamp`
    */
   LDKCreationError_ExpiryTimeOutOfBounds,
   /**
    * Must be last for serialization purposes
    */
   LDKCreationError_Sentinel,
} LDKCreationError;

/**
 * Enum representing the crypto currencies (or networks) supported by this library
 */
typedef enum LDKCurrency {
   /**
    * Bitcoin mainnet
    */
   LDKCurrency_Bitcoin,
   /**
    * Bitcoin testnet
    */
   LDKCurrency_BitcoinTestnet,
   /**
    * Bitcoin regtest
    */
   LDKCurrency_Regtest,
   /**
    * Bitcoin simnet
    */
   LDKCurrency_Simnet,
   /**
    * Bitcoin signet
    */
   LDKCurrency_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKCurrency_Sentinel,
} LDKCurrency;

/**
 * Represents an IO Error. Note that some information is lost in the conversion from Rust.
 */
typedef enum LDKIOError {
   LDKIOError_NotFound,
   LDKIOError_PermissionDenied,
   LDKIOError_ConnectionRefused,
   LDKIOError_ConnectionReset,
   LDKIOError_ConnectionAborted,
   LDKIOError_NotConnected,
   LDKIOError_AddrInUse,
   LDKIOError_AddrNotAvailable,
   LDKIOError_BrokenPipe,
   LDKIOError_AlreadyExists,
   LDKIOError_WouldBlock,
   LDKIOError_InvalidInput,
   LDKIOError_InvalidData,
   LDKIOError_TimedOut,
   LDKIOError_WriteZero,
   LDKIOError_Interrupted,
   LDKIOError_Other,
   LDKIOError_UnexpectedEof,
   /**
    * Must be last for serialization purposes
    */
   LDKIOError_Sentinel,
} LDKIOError;

/**
 * An enum representing the available verbosity levels of the logger.
 */
typedef enum LDKLevel {
   /**
    * Designates very low priority, often extremely verbose, information
    */
   LDKLevel_Trace,
   /**
    * Designates lower priority information
    */
   LDKLevel_Debug,
   /**
    * Designates useful information
    */
   LDKLevel_Info,
   /**
    * Designates hazardous situations
    */
   LDKLevel_Warn,
   /**
    * Designates very serious errors
    */
   LDKLevel_Error,
   /**
    * Must be last for serialization purposes
    */
   LDKLevel_Sentinel,
} LDKLevel;

/**
 * An enum representing the possible Bitcoin or test networks which we can run on
 */
typedef enum LDKNetwork {
   /**
    * The main Bitcoin blockchain.
    */
   LDKNetwork_Bitcoin,
   /**
    * The testnet3 blockchain.
    */
   LDKNetwork_Testnet,
   /**
    * A local test blockchain.
    */
   LDKNetwork_Regtest,
   /**
    * A blockchain on which blocks are signed instead of mined.
    */
   LDKNetwork_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKNetwork_Sentinel,
} LDKNetwork;

/**
 * Represents an error returned from libsecp256k1 during validation of some secp256k1 data
 */
typedef enum LDKSecp256k1Error {
   /**
    * Signature failed verification
    */
   LDKSecp256k1Error_IncorrectSignature,
   /**
    * Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
    */
   LDKSecp256k1Error_InvalidMessage,
   /**
    * Bad public key
    */
   LDKSecp256k1Error_InvalidPublicKey,
   /**
    * Bad signature
    */
   LDKSecp256k1Error_InvalidSignature,
   /**
    * Bad secret key
    */
   LDKSecp256k1Error_InvalidSecretKey,
   /**
    * Bad recovery id
    */
   LDKSecp256k1Error_InvalidRecoveryId,
   /**
    * Invalid tweak for add_assign or mul_assign
    */
   LDKSecp256k1Error_InvalidTweak,
   /**
    * tweak_add_check failed on an xonly public key
    */
   LDKSecp256k1Error_TweakCheckFailed,
   /**
    * Didn't pass enough memory to context creation with preallocated memory
    */
   LDKSecp256k1Error_NotEnoughMemory,
   /**
    * Must be last for serialization purposes
    */
   LDKSecp256k1Error_Sentinel,
} LDKSecp256k1Error;

/**
 * Errors that may occur when converting a `RawInvoice` to an `Invoice`. They relate to the
 * requirements sections in BOLT #11
 */
typedef enum LDKSemanticError {
   /**
    * The invoice is missing the mandatory payment hash
    */
   LDKSemanticError_NoPaymentHash,
   /**
    * The invoice has multiple payment hashes which isn't allowed
    */
   LDKSemanticError_MultiplePaymentHashes,
   /**
    * No description or description hash are part of the invoice
    */
   LDKSemanticError_NoDescription,
   /**
    * The invoice contains multiple descriptions and/or description hashes which isn't allowed
    */
   LDKSemanticError_MultipleDescriptions,
   /**
    * The invoice contains multiple payment secrets
    */
   LDKSemanticError_MultiplePaymentSecrets,
   /**
    * The invoice's features are invalid
    */
   LDKSemanticError_InvalidFeatures,
   /**
    * The recovery id doesn't fit the signature/pub key
    */
   LDKSemanticError_InvalidRecoveryId,
   /**
    * The invoice's signature is invalid
    */
   LDKSemanticError_InvalidSignature,
   /**
    * Must be last for serialization purposes
    */
   LDKSemanticError_Sentinel,
} LDKSemanticError;

/**
 * SI prefixes for the human readable part
 */
typedef enum LDKSiPrefix {
   /**
    * 10^-3
    */
   LDKSiPrefix_Milli,
   /**
    * 10^-6
    */
   LDKSiPrefix_Micro,
   /**
    * 10^-9
    */
   LDKSiPrefix_Nano,
   /**
    * 10^-12
    */
   LDKSiPrefix_Pico,
   /**
    * Must be last for serialization purposes
    */
   LDKSiPrefix_Sentinel,
} LDKSiPrefix;

/**
 * A Rust str object, ie a reference to a UTF8-valid string.
 * This is *not* null-terminated so cannot be used directly as a C string!
 */
typedef struct LDKStr {
   /**
    * A pointer to the string's bytes, in UTF8 encoding
    */
   const uint8_t *chars;
   /**
    * The number of bytes (not characters!) pointed to by `chars`
    */
   uintptr_t len;
   /**
    * Whether the data pointed to by `chars` should be freed or not.
    */
   bool chars_is_owned;
} LDKStr;

/**
 * A serialized transaction, in (pointer, length) form.
 *
 * This type optionally owns its own memory, and thus the semantics around access change based on
 * the `data_is_owned` flag. If `data_is_owned` is set, you must call `Transaction_free` to free
 * the underlying buffer before the object goes out of scope. If `data_is_owned` is not set, any
 * access to the buffer after the scope in which the object was provided to you is invalid. eg,
 * access after you return from the call in which a `!data_is_owned` `Transaction` is provided to
 * you would be invalid.
 *
 * Note that, while it may change in the future, because transactions on the Rust side are stored
 * in a deserialized form, all `Transaction`s generated on the Rust side will have `data_is_owned`
 * set. Similarly, while it may change in the future, all `Transaction`s you pass to Rust may have
 * `data_is_owned` either set or unset at your discretion.
 */
typedef struct LDKTransaction {
   /**
    * The serialized transaction data.
    *
    * This is non-const for your convenience, an object passed to Rust is never written to.
    */
   uint8_t *data;
   /**
    * The length of the serialized transaction
    */
   uintptr_t datalen;
   /**
    * Whether the data pointed to by `data` should be freed or not.
    */
   bool data_is_owned;
} LDKTransaction;

/**
 * A dynamically-allocated array of u8s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u8Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   uint8_t *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u8Z;

/**
 * A transaction output including a scriptPubKey and value.
 * This type *does* own its own memory, so must be free'd appropriately.
 */
typedef struct LDKTxOut {
   /**
    * The script_pubkey in this output
    */
   struct LDKCVec_u8Z script_pubkey;
   /**
    * The value, in satoshis, of this output
    */
   uint64_t value;
} LDKTxOut;

/**
 * Represents a valid secp256k1 secret key serialized as a 32 byte array.
 */
typedef struct LDKSecretKey {
   /**
    * The bytes of the secret key
    */
   uint8_t bytes[32];
} LDKSecretKey;

/**
 * The contents of CResult_SecretKeyErrorZ
 */
typedef union LDKCResult_SecretKeyErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSecretKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_SecretKeyErrorZPtr;

/**
 * A CResult_SecretKeyErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::SecretKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SecretKeyErrorZ {
   /**
    * The contents of this CResult_SecretKeyErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SecretKeyErrorZPtr contents;
   /**
    * Whether this CResult_SecretKeyErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SecretKeyErrorZ;

/**
 * Represents a valid secp256k1 public key serialized in "compressed form" as a 33 byte array.
 */
typedef struct LDKPublicKey {
   /**
    * The bytes of the public key
    */
   uint8_t compressed_form[33];
} LDKPublicKey;

/**
 * The contents of CResult_PublicKeyErrorZ
 */
typedef union LDKCResult_PublicKeyErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPublicKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_PublicKeyErrorZPtr;

/**
 * A CResult_PublicKeyErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::PublicKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PublicKeyErrorZ {
   /**
    * The contents of this CResult_PublicKeyErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PublicKeyErrorZPtr contents;
   /**
    * Whether this CResult_PublicKeyErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PublicKeyErrorZ;



/**
 * The set of public keys which are used in the creation of one commitment transaction.
 * These are derived from the channel base keys and per-commitment data.
 *
 * A broadcaster key is provided from potential broadcaster of the computed transaction.
 * A countersignatory key is coming from a protocol participant unable to broadcast the
 * transaction.
 *
 * These keys are assumed to be good, either because the code derived them from
 * channel basepoints via the new function, or they were obtained via
 * CommitmentTransaction.trust().keys() because we trusted the source of the
 * pre-calculated keys.
 */
typedef struct MUST_USE_STRUCT LDKTxCreationKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxCreationKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxCreationKeys;



/**
 * An error in decoding a message or struct.
 */
typedef struct MUST_USE_STRUCT LDKDecodeError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDecodeError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDecodeError;

/**
 * The contents of CResult_TxCreationKeysDecodeErrorZ
 */
typedef union LDKCResult_TxCreationKeysDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxCreationKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxCreationKeysDecodeErrorZPtr;

/**
 * A CResult_TxCreationKeysDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxCreationKeysDecodeErrorZ {
   /**
    * The contents of this CResult_TxCreationKeysDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxCreationKeysDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxCreationKeysDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxCreationKeysDecodeErrorZ;



/**
 * One counterparty's public keys which do not change over the life of a channel.
 */
typedef struct MUST_USE_STRUCT LDKChannelPublicKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelPublicKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelPublicKeys;

/**
 * The contents of CResult_ChannelPublicKeysDecodeErrorZ
 */
typedef union LDKCResult_ChannelPublicKeysDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelPublicKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelPublicKeysDecodeErrorZPtr;

/**
 * A CResult_ChannelPublicKeysDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::ChannelPublicKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelPublicKeysDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelPublicKeysDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelPublicKeysDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelPublicKeysDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelPublicKeysDecodeErrorZ;

/**
 * The contents of CResult_TxCreationKeysErrorZ
 */
typedef union LDKCResult_TxCreationKeysErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxCreationKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_TxCreationKeysErrorZPtr;

/**
 * A CResult_TxCreationKeysErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxCreationKeysErrorZ {
   /**
    * The contents of this CResult_TxCreationKeysErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxCreationKeysErrorZPtr contents;
   /**
    * Whether this CResult_TxCreationKeysErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxCreationKeysErrorZ;

/**
 * An enum which can either contain a u32 or not
 */
typedef enum LDKCOption_u32Z_Tag {
   /**
    * When we're in this state, this COption_u32Z contains a u32
    */
   LDKCOption_u32Z_Some,
   /**
    * When we're in this state, this COption_u32Z contains nothing
    */
   LDKCOption_u32Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u32Z_Sentinel,
} LDKCOption_u32Z_Tag;

typedef struct LDKCOption_u32Z {
   LDKCOption_u32Z_Tag tag;
   union {
      struct {
         uint32_t some;
      };
   };
} LDKCOption_u32Z;



/**
 * Information about an HTLC as it appears in a commitment transaction
 */
typedef struct MUST_USE_STRUCT LDKHTLCOutputInCommitment {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCOutputInCommitment *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCOutputInCommitment;

/**
 * The contents of CResult_HTLCOutputInCommitmentDecodeErrorZ
 */
typedef union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCOutputInCommitment *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr;

/**
 * A CResult_HTLCOutputInCommitmentDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::HTLCOutputInCommitment on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCOutputInCommitmentDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCOutputInCommitmentDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZ;



/**
 * Late-bound per-channel counterparty data used to build transactions.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyChannelTransactionParameters;

/**
 * The contents of CResult_CounterpartyChannelTransactionParametersDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyChannelTransactionParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr;

/**
 * A CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ;



/**
 * Per-channel data used to build transactions in conjunction with the per-commitment data (CommitmentTransaction).
 * The fields are organized by holder/counterparty.
 *
 * Normally, this is converted to the broadcaster/countersignatory-organized DirectedChannelTransactionParameters
 * before use, via the as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelTransactionParameters;

/**
 * The contents of CResult_ChannelTransactionParametersDecodeErrorZ
 */
typedef union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelTransactionParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelTransactionParametersDecodeErrorZPtr;

/**
 * A CResult_ChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::ChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelTransactionParametersDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelTransactionParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelTransactionParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelTransactionParametersDecodeErrorZ;

/**
 * Represents a secp256k1 signature serialized as two 32-byte numbers
 */
typedef struct LDKSignature {
   /**
    * The bytes of the signature in "compact" form
    */
   uint8_t compact_form[64];
} LDKSignature;

/**
 * A dynamically-allocated array of crate::c_types::Signatures of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_SignatureZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKSignature *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_SignatureZ;



/**
 * Information needed to build and sign a holder's commitment transaction.
 *
 * The transaction is only signed once we are ready to broadcast.
 */
typedef struct MUST_USE_STRUCT LDKHolderCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHolderCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHolderCommitmentTransaction;

/**
 * The contents of CResult_HolderCommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHolderCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_HolderCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::HolderCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_HolderCommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HolderCommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZ;



/**
 * A pre-built Bitcoin commitment transaction and its txid.
 */
typedef struct MUST_USE_STRUCT LDKBuiltCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBuiltCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBuiltCommitmentTransaction;

/**
 * The contents of CResult_BuiltCommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBuiltCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_BuiltCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::BuiltCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_BuiltCommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BuiltCommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZ;



/**
 * This class tracks the per-transaction information needed to build a commitment transaction and to
 * actually build it and sign.  It is used for holder transactions that we sign only when needed
 * and for transactions we sign for the counterparty.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentTransaction;

/**
 * The contents of CResult_CommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_CommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_CommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_CommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CommitmentTransactionDecodeErrorZ;



/**
 * A wrapper on CommitmentTransaction indicating that the derived fields (the built bitcoin
 * transaction and the transaction creation keys) are trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */
typedef struct MUST_USE_STRUCT LDKTrustedCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTrustedCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTrustedCommitmentTransaction;

/**
 * The contents of CResult_TrustedCommitmentTransactionNoneZ
 */
typedef union LDKCResult_TrustedCommitmentTransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTrustedCommitmentTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TrustedCommitmentTransactionNoneZPtr;

/**
 * A CResult_TrustedCommitmentTransactionNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TrustedCommitmentTransaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TrustedCommitmentTransactionNoneZ {
   /**
    * The contents of this CResult_TrustedCommitmentTransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TrustedCommitmentTransactionNoneZPtr contents;
   /**
    * Whether this CResult_TrustedCommitmentTransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TrustedCommitmentTransactionNoneZ;

/**
 * The contents of CResult_CVec_SignatureZNoneZ
 */
typedef union LDKCResult_CVec_SignatureZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_SignatureZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_SignatureZNoneZPtr;

/**
 * A CResult_CVec_SignatureZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_SignatureZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_SignatureZNoneZ {
   /**
    * The contents of this CResult_CVec_SignatureZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_SignatureZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_SignatureZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_SignatureZNoneZ;

/**
 * The contents of CResult_NoneErrorZ
 */
typedef union LDKCResult_NoneErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_NoneErrorZPtr;

/**
 * A CResult_NoneErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneErrorZ {
   /**
    * The contents of this CResult_NoneErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneErrorZPtr contents;
   /**
    * Whether this CResult_NoneErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneErrorZ;



/**
 * A hop in a route
 */
typedef struct MUST_USE_STRUCT LDKRouteHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHop;

/**
 * The contents of CResult_RouteHopDecodeErrorZ
 */
typedef union LDKCResult_RouteHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHopDecodeErrorZPtr;

/**
 * A CResult_RouteHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHopDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHopDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHops of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHopZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHop *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHopZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CVec_RouteHopZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CVec_RouteHopZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCVec_RouteHopZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CVec_RouteHopZZ;



/**
 * A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,
 * it can take multiple paths. Each path is composed of one or more hops through the network.
 */
typedef struct MUST_USE_STRUCT LDKRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoute;

/**
 * The contents of CResult_RouteDecodeErrorZ
 */
typedef union LDKCResult_RouteDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteDecodeErrorZPtr;

/**
 * A CResult_RouteDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteDecodeErrorZ {
   /**
    * The contents of this CResult_RouteDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteDecodeErrorZ;

/**
 * An enum which can either contain a u64 or not
 */
typedef enum LDKCOption_u64Z_Tag {
   /**
    * When we're in this state, this COption_u64Z contains a u64
    */
   LDKCOption_u64Z_Some,
   /**
    * When we're in this state, this COption_u64Z contains nothing
    */
   LDKCOption_u64Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u64Z_Sentinel,
} LDKCOption_u64Z_Tag;

typedef struct LDKCOption_u64Z {
   LDKCOption_u64Z_Tag tag;
   union {
      struct {
         uint64_t some;
      };
   };
} LDKCOption_u64Z;



/**
 * Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels
 */
typedef struct MUST_USE_STRUCT LDKChannelDetails {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelDetails *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelDetails;

/**
 * A dynamically-allocated array of crate::lightning::ln::channelmanager::ChannelDetailss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ChannelDetailsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKChannelDetails *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ChannelDetailsZ;



/**
 * A list of hops along a payment path terminating with a channel to the recipient.
 */
typedef struct MUST_USE_STRUCT LDKRouteHint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHint;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHints of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHintZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHint *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHintZ;



/**
 * An Err type for failure to process messages.
 */
typedef struct MUST_USE_STRUCT LDKLightningError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLightningError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLightningError;

/**
 * The contents of CResult_RouteLightningErrorZ
 */
typedef union LDKCResult_RouteLightningErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_RouteLightningErrorZPtr;

/**
 * A CResult_RouteLightningErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteLightningErrorZ {
   /**
    * The contents of this CResult_RouteLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteLightningErrorZPtr contents;
   /**
    * Whether this CResult_RouteLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteLightningErrorZ;

/**
 * The contents of CResult_TxOutAccessErrorZ
 */
typedef union LDKCResult_TxOutAccessErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxOut *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKAccessError *err;
} LDKCResult_TxOutAccessErrorZPtr;

/**
 * A CResult_TxOutAccessErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::TxOut on success and a crate::lightning::chain::AccessError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxOutAccessErrorZ {
   /**
    * The contents of this CResult_TxOutAccessErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxOutAccessErrorZPtr contents;
   /**
    * Whether this CResult_TxOutAccessErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxOutAccessErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_usizeTransactionZ {
   /**
    * The element at position 0
    */
   uintptr_t a;
   /**
    * The element at position 1
    */
   struct LDKTransaction b;
} LDKC2Tuple_usizeTransactionZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_usizeTransactionZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_usizeTransactionZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_usizeTransactionZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_usizeTransactionZZ;

/**
 * Arbitrary 32 bytes, which could represent one of a few different things. You probably want to
 * look up the corresponding function in rust-lightning's docs.
 */
typedef struct LDKThirtyTwoBytes {
   /**
    * The thirty-two bytes
    */
   uint8_t data[32];
} LDKThirtyTwoBytes;

/**
 * A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TxidZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKThirtyTwoBytes *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TxidZ;

/**
 * The contents of CResult_NoneChannelMonitorUpdateErrZ
 */
typedef union LDKCResult_NoneChannelMonitorUpdateErrZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKChannelMonitorUpdateErr *err;
} LDKCResult_NoneChannelMonitorUpdateErrZPtr;

/**
 * A CResult_NoneChannelMonitorUpdateErrZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::chain::channelmonitor::ChannelMonitorUpdateErr on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneChannelMonitorUpdateErrZ {
   /**
    * The contents of this CResult_NoneChannelMonitorUpdateErrZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneChannelMonitorUpdateErrZPtr contents;
   /**
    * Whether this CResult_NoneChannelMonitorUpdateErrZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneChannelMonitorUpdateErrZ;



/**
 * Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
 * chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
 * preimage claim backward will lead to loss of funds.
 */
typedef struct MUST_USE_STRUCT LDKHTLCUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCUpdate;



/**
 * A reference to a transaction output.
 *
 * Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32
 * due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way.
 */
typedef struct MUST_USE_STRUCT LDKOutPoint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOutPoint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOutPoint;

/**
 * An event to be processed by the ChannelManager.
 */
typedef enum LDKMonitorEvent_Tag {
   /**
    * A monitor event containing an HTLCUpdate.
    */
   LDKMonitorEvent_HTLCEvent,
   /**
    * A monitor event that the Channel's commitment transaction was broadcasted.
    */
   LDKMonitorEvent_CommitmentTxBroadcasted,
   /**
    * Must be last for serialization purposes
    */
   LDKMonitorEvent_Sentinel,
} LDKMonitorEvent_Tag;

typedef struct MUST_USE_STRUCT LDKMonitorEvent {
   LDKMonitorEvent_Tag tag;
   union {
      struct {
         struct LDKHTLCUpdate htlc_event;
      };
      struct {
         struct LDKOutPoint commitment_tx_broadcasted;
      };
   };
} LDKMonitorEvent;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::MonitorEvents of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MonitorEventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMonitorEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MonitorEventZ;

/**
 * An enum which can either contain a crate::c_types::derived::C2Tuple_usizeTransactionZ or not
 */
typedef enum LDKCOption_C2Tuple_usizeTransactionZZ_Tag {
   /**
    * When we're in this state, this COption_C2Tuple_usizeTransactionZZ contains a crate::c_types::derived::C2Tuple_usizeTransactionZ
    */
   LDKCOption_C2Tuple_usizeTransactionZZ_Some,
   /**
    * When we're in this state, this COption_C2Tuple_usizeTransactionZZ contains nothing
    */
   LDKCOption_C2Tuple_usizeTransactionZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_C2Tuple_usizeTransactionZZ_Sentinel,
} LDKCOption_C2Tuple_usizeTransactionZZ_Tag;

typedef struct LDKCOption_C2Tuple_usizeTransactionZZ {
   LDKCOption_C2Tuple_usizeTransactionZZ_Tag tag;
   union {
      struct {
         struct LDKC2Tuple_usizeTransactionZ some;
      };
   };
} LDKCOption_C2Tuple_usizeTransactionZZ;



/**
 * Information about a spendable output to a P2WSH script. See
 * SpendableOutputDescriptor::DelayedPaymentOutput for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKDelayedPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDelayedPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDelayedPaymentOutputDescriptor;



/**
 * Information about a spendable output to our \"payment key\". See
 * SpendableOutputDescriptor::StaticPaymentOutput for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKStaticPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeStaticPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKStaticPaymentOutputDescriptor;

/**
 * When on-chain outputs are created by rust-lightning (which our counterparty is not able to
 * claim at any point in the future) an event is generated which you must track and be able to
 * spend on-chain. The information needed to do this is provided in this enum, including the
 * outpoint describing which txid and output index is available, the full output which exists at
 * that txid/index, and any keys or other information required to sign.
 */
typedef enum LDKSpendableOutputDescriptor_Tag {
   /**
    * An output to a script which was provided via KeysInterface directly, either from
    * `get_destination_script()` or `get_shutdown_pubkey()`, thus you should already know how to
    * spend it. No secret keys are provided as rust-lightning was never given any key.
    * These may include outputs from a transaction punishing our counterparty or claiming an HTLC
    * on-chain using the payment preimage or after it has timed out.
    */
   LDKSpendableOutputDescriptor_StaticOutput,
   /**
    * An output to a P2WSH script which can be spent with a single signature after a CSV delay.
    *
    * The witness in the spending input should be:
    * <BIP 143 signature> <empty vector> (MINIMALIF standard rule) <provided witnessScript>
    *
    * Note that the nSequence field in the spending input must be set to to_self_delay
    * (which means the transaction is not broadcastable until at least to_self_delay
    * blocks after the outpoint confirms).
    *
    * These are generally the result of a \"revocable\" output to us, spendable only by us unless
    * it is an output from an old state which we broadcast (which should never happen).
    *
    * To derive the delayed_payment key which is used to sign for this input, you must pass the
    * holder delayed_payment_base_key (ie the private key which corresponds to the pubkey in
    * Sign::pubkeys().delayed_payment_basepoint) and the provided per_commitment_point to
    * chan_utils::derive_private_key. The public key can be generated without the secret key
    * using chan_utils::derive_public_key and only the delayed_payment_basepoint which appears in
    * Sign::pubkeys().
    *
    * To derive the revocation_pubkey provided here (which is used in the witness
    * script generation), you must pass the counterparty revocation_basepoint (which appears in the
    * call to Sign::ready_channel) and the provided per_commitment point
    * to chan_utils::derive_public_revocation_key.
    *
    * The witness script which is hashed and included in the output script_pubkey may be
    * regenerated by passing the revocation_pubkey (derived as above), our delayed_payment pubkey
    * (derived as above), and the to_self_delay contained here to
    * chan_utils::get_revokeable_redeemscript.
    */
   LDKSpendableOutputDescriptor_DelayedPaymentOutput,
   /**
    * An output to a P2WPKH, spendable exclusively by our payment key (ie the private key which
    * corresponds to the public key in Sign::pubkeys().payment_point).
    * The witness in the spending input, is, thus, simply:
    * <BIP 143 signature> <payment key>
    *
    * These are generally the result of our counterparty having broadcast the current state,
    * allowing us to claim the non-HTLC-encumbered outputs immediately.
    */
   LDKSpendableOutputDescriptor_StaticPaymentOutput,
   /**
    * Must be last for serialization purposes
    */
   LDKSpendableOutputDescriptor_Sentinel,
} LDKSpendableOutputDescriptor_Tag;

typedef struct LDKSpendableOutputDescriptor_LDKStaticOutput_Body {
   /**
    * The outpoint which is spendable
    */
   struct LDKOutPoint outpoint;
   /**
    * The output which is referenced by the given outpoint.
    */
   struct LDKTxOut output;
} LDKSpendableOutputDescriptor_LDKStaticOutput_Body;

typedef struct MUST_USE_STRUCT LDKSpendableOutputDescriptor {
   LDKSpendableOutputDescriptor_Tag tag;
   union {
      LDKSpendableOutputDescriptor_LDKStaticOutput_Body static_output;
      struct {
         struct LDKDelayedPaymentOutputDescriptor delayed_payment_output;
      };
      struct {
         struct LDKStaticPaymentOutputDescriptor static_payment_output;
      };
   };
} LDKSpendableOutputDescriptor;

/**
 * A dynamically-allocated array of crate::lightning::chain::keysinterface::SpendableOutputDescriptors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_SpendableOutputDescriptorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKSpendableOutputDescriptor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_SpendableOutputDescriptorZ;



/**
 * An accept_channel message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKAcceptChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAcceptChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAcceptChannel;



/**
 * An open_channel message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKOpenChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOpenChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOpenChannel;



/**
 * A funding_created message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingCreated {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingCreated *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingCreated;



/**
 * A funding_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingSigned;



/**
 * A funding_locked message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingLocked {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingLocked *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingLocked;



/**
 * An announcement_signatures message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKAnnouncementSignatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAnnouncementSignatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAnnouncementSignatures;



/**
 * Struct used to return values from revoke_and_ack messages, containing a bunch of commitment
 * transaction updates if they were pending.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentUpdate;



/**
 * A revoke_and_ack message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKRevokeAndACK {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRevokeAndACK *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRevokeAndACK;



/**
 * A closing_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKClosingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingSigned;



/**
 * A shutdown message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKShutdown {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeShutdown *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKShutdown;



/**
 * A channel_reestablish message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelReestablish {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelReestablish *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelReestablish;



/**
 * A channel_announcement message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelAnnouncement;



/**
 * A channel_update message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUpdate;



/**
 * A node_announcement message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncement;



/**
 * An error message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKErrorMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErrorMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErrorMessage;

/**
 * Used to put an error message in a LightningError
 */
typedef enum LDKErrorAction_Tag {
   /**
    * The peer took some action which made us think they were useless. Disconnect them.
    */
   LDKErrorAction_DisconnectPeer,
   /**
    * The peer did something harmless that we weren't able to process, just log and ignore
    */
   LDKErrorAction_IgnoreError,
   /**
    * The peer did something harmless that we weren't able to meaningfully process.
    * If the error is logged, log it at the given level.
    */
   LDKErrorAction_IgnoreAndLog,
   /**
    * The peer did something incorrect. Tell them.
    */
   LDKErrorAction_SendErrorMessage,
   /**
    * Must be last for serialization purposes
    */
   LDKErrorAction_Sentinel,
} LDKErrorAction_Tag;

typedef struct LDKErrorAction_LDKDisconnectPeer_Body {
   /**
    * An error message which we should make an effort to send before we disconnect.
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKDisconnectPeer_Body;

typedef struct LDKErrorAction_LDKSendErrorMessage_Body {
   /**
    * The message to send.
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKSendErrorMessage_Body;

typedef struct MUST_USE_STRUCT LDKErrorAction {
   LDKErrorAction_Tag tag;
   union {
      LDKErrorAction_LDKDisconnectPeer_Body disconnect_peer;
      struct {
         enum LDKLevel ignore_and_log;
      };
      LDKErrorAction_LDKSendErrorMessage_Body send_error_message;
   };
} LDKErrorAction;

/**
 * The information we received from a peer along the route of a payment we originated. This is
 * returned by ChannelMessageHandler::handle_update_fail_htlc to be passed into
 * RoutingMessageHandler::handle_htlc_fail_channel_update to update our network map.
 */
typedef enum LDKHTLCFailChannelUpdate_Tag {
   /**
    * We received an error which included a full ChannelUpdate message.
    */
   LDKHTLCFailChannelUpdate_ChannelUpdateMessage,
   /**
    * We received an error which indicated only that a channel has been closed
    */
   LDKHTLCFailChannelUpdate_ChannelClosed,
   /**
    * We received an error which indicated only that a node has failed
    */
   LDKHTLCFailChannelUpdate_NodeFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKHTLCFailChannelUpdate_Sentinel,
} LDKHTLCFailChannelUpdate_Tag;

typedef struct LDKHTLCFailChannelUpdate_LDKChannelUpdateMessage_Body {
   /**
    * The unwrapped message we received
    */
   struct LDKChannelUpdate msg;
} LDKHTLCFailChannelUpdate_LDKChannelUpdateMessage_Body;

typedef struct LDKHTLCFailChannelUpdate_LDKChannelClosed_Body {
   /**
    * The short_channel_id which has now closed.
    */
   uint64_t short_channel_id;
   /**
    * when this true, this channel should be permanently removed from the
    * consideration. Otherwise, this channel can be restored as new channel_update is received
    */
   bool is_permanent;
} LDKHTLCFailChannelUpdate_LDKChannelClosed_Body;

typedef struct LDKHTLCFailChannelUpdate_LDKNodeFailure_Body {
   /**
    * The node_id that has failed.
    */
   struct LDKPublicKey node_id;
   /**
    * when this true, node should be permanently removed from the
    * consideration. Otherwise, the channels connected to this node can be
    * restored as new channel_update is received
    */
   bool is_permanent;
} LDKHTLCFailChannelUpdate_LDKNodeFailure_Body;

typedef struct MUST_USE_STRUCT LDKHTLCFailChannelUpdate {
   LDKHTLCFailChannelUpdate_Tag tag;
   union {
      LDKHTLCFailChannelUpdate_LDKChannelUpdateMessage_Body channel_update_message;
      LDKHTLCFailChannelUpdate_LDKChannelClosed_Body channel_closed;
      LDKHTLCFailChannelUpdate_LDKNodeFailure_Body node_failure;
   };
} LDKHTLCFailChannelUpdate;



/**
 * A query_channel_range message is used to query a peer for channel
 * UTXOs in a range of blocks. The recipient of a query makes a best
 * effort to reply to the query using one or more reply_channel_range
 * messages.
 */
typedef struct MUST_USE_STRUCT LDKQueryChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryChannelRange;



/**
 * A query_short_channel_ids message is used to query a peer for
 * routing gossip messages related to one or more short_channel_ids.
 * The query recipient will reply with the latest, if available,
 * channel_announcement, channel_update and node_announcement messages
 * it maintains for the requested short_channel_ids followed by a
 * reply_short_channel_ids_end message. The short_channel_ids sent in
 * this query are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */
typedef struct MUST_USE_STRUCT LDKQueryShortChannelIds {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryShortChannelIds *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryShortChannelIds;



/**
 * A reply_channel_range message is a reply to a query_channel_range
 * message. Multiple reply_channel_range messages can be sent in reply
 * to a single query_channel_range message. The query recipient makes a
 * best effort to respond based on their local network view which may
 * not be a perfect view of the network. The short_channel_ids in the
 * reply are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */
typedef struct MUST_USE_STRUCT LDKReplyChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyChannelRange;

/**
 * An event generated by ChannelManager which indicates a message should be sent to a peer (or
 * broadcast to most peers).
 * These events are handled by PeerManager::process_events if you are using a PeerManager.
 */
typedef enum LDKMessageSendEvent_Tag {
   /**
    * Used to indicate that we've accepted a channel open and should send the accept_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendAcceptChannel,
   /**
    * Used to indicate that we've initiated a channel open and should send the open_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendOpenChannel,
   /**
    * Used to indicate that a funding_created message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingCreated,
   /**
    * Used to indicate that a funding_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingSigned,
   /**
    * Used to indicate that a funding_locked message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingLocked,
   /**
    * Used to indicate that an announcement_signatures message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendAnnouncementSignatures,
   /**
    * Used to indicate that a series of HTLC update messages, as well as a commitment_signed
    * message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_UpdateHTLCs,
   /**
    * Used to indicate that a revoke_and_ack message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendRevokeAndACK,
   /**
    * Used to indicate that a closing_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendClosingSigned,
   /**
    * Used to indicate that a shutdown message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendShutdown,
   /**
    * Used to indicate that a channel_reestablish message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendChannelReestablish,
   /**
    * Used to indicate that a channel_announcement and channel_update should be broadcast to all
    * peers (except the peer with node_id either msg.contents.node_id_1 or msg.contents.node_id_2).
    *
    * Note that after doing so, you very likely (unless you did so very recently) want to call
    * ChannelManager::broadcast_node_announcement to trigger a BroadcastNodeAnnouncement event.
    * This ensures that any nodes which see our channel_announcement also have a relevant
    * node_announcement, including relevant feature flags which may be important for routing
    * through or to us.
    */
   LDKMessageSendEvent_BroadcastChannelAnnouncement,
   /**
    * Used to indicate that a node_announcement should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastNodeAnnouncement,
   /**
    * Used to indicate that a channel_update should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastChannelUpdate,
   /**
    * Used to indicate that a channel_update should be sent to a single peer.
    * In contrast to [`Self::BroadcastChannelUpdate`], this is used when the channel is a
    * private channel and we shouldn't be informing all of our peers of channel parameters.
    */
   LDKMessageSendEvent_SendChannelUpdate,
   /**
    * Broadcast an error downstream to be handled
    */
   LDKMessageSendEvent_HandleError,
   /**
    * When a payment fails we may receive updates back from the hop where it failed. In such
    * cases this event is generated so that we can inform the network graph of this information.
    */
   LDKMessageSendEvent_PaymentFailureNetworkUpdate,
   /**
    * Query a peer for channels with funding transaction UTXOs in a block range.
    */
   LDKMessageSendEvent_SendChannelRangeQuery,
   /**
    * Request routing gossip messages from a peer for a list of channels identified by
    * their short_channel_ids.
    */
   LDKMessageSendEvent_SendShortIdsQuery,
   /**
    * Sends a reply to a channel range query. This may be one of several SendReplyChannelRange events
    * emitted during processing of the query.
    */
   LDKMessageSendEvent_SendReplyChannelRange,
   /**
    * Must be last for serialization purposes
    */
   LDKMessageSendEvent_Sentinel,
} LDKMessageSendEvent_Tag;

typedef struct LDKMessageSendEvent_LDKSendAcceptChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKAcceptChannel msg;
} LDKMessageSendEvent_LDKSendAcceptChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendOpenChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKOpenChannel msg;
} LDKMessageSendEvent_LDKSendOpenChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingCreated_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingCreated msg;
} LDKMessageSendEvent_LDKSendFundingCreated_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingSigned msg;
} LDKMessageSendEvent_LDKSendFundingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingLocked_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The funding_locked message which should be sent.
    */
   struct LDKFundingLocked msg;
} LDKMessageSendEvent_LDKSendFundingLocked_Body;

typedef struct LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The announcement_signatures message which should be sent.
    */
   struct LDKAnnouncementSignatures msg;
} LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body;

typedef struct LDKMessageSendEvent_LDKUpdateHTLCs_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The update messages which should be sent. ALL messages in the struct should be sent!
    */
   struct LDKCommitmentUpdate updates;
} LDKMessageSendEvent_LDKUpdateHTLCs_Body;

typedef struct LDKMessageSendEvent_LDKSendRevokeAndACK_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKRevokeAndACK msg;
} LDKMessageSendEvent_LDKSendRevokeAndACK_Body;

typedef struct LDKMessageSendEvent_LDKSendClosingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKClosingSigned msg;
} LDKMessageSendEvent_LDKSendClosingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendShutdown_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKShutdown msg;
} LDKMessageSendEvent_LDKSendShutdown_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelReestablish_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKChannelReestablish msg;
} LDKMessageSendEvent_LDKSendChannelReestablish_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body {
   /**
    * The channel_announcement which should be sent.
    */
   struct LDKChannelAnnouncement msg;
   /**
    * The followup channel_update which should be sent.
    */
   struct LDKChannelUpdate update_msg;
} LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body {
   /**
    * The node_announcement which should be sent.
    */
   struct LDKNodeAnnouncement msg;
} LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body {
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelUpdate_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKSendChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKHandleError_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The action which should be taken.
    */
   struct LDKErrorAction action;
} LDKMessageSendEvent_LDKHandleError_Body;

typedef struct LDKMessageSendEvent_LDKPaymentFailureNetworkUpdate_Body {
   /**
    * The channel/node update which should be sent to NetGraphMsgHandler
    */
   struct LDKHTLCFailChannelUpdate update;
} LDKMessageSendEvent_LDKPaymentFailureNetworkUpdate_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelRangeQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_channel_range which should be sent.
    */
   struct LDKQueryChannelRange msg;
} LDKMessageSendEvent_LDKSendChannelRangeQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendShortIdsQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_short_channel_ids which should be sent.
    */
   struct LDKQueryShortChannelIds msg;
} LDKMessageSendEvent_LDKSendShortIdsQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendReplyChannelRange_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The reply_channel_range which should be sent.
    */
   struct LDKReplyChannelRange msg;
} LDKMessageSendEvent_LDKSendReplyChannelRange_Body;

typedef struct MUST_USE_STRUCT LDKMessageSendEvent {
   LDKMessageSendEvent_Tag tag;
   union {
      LDKMessageSendEvent_LDKSendAcceptChannel_Body send_accept_channel;
      LDKMessageSendEvent_LDKSendOpenChannel_Body send_open_channel;
      LDKMessageSendEvent_LDKSendFundingCreated_Body send_funding_created;
      LDKMessageSendEvent_LDKSendFundingSigned_Body send_funding_signed;
      LDKMessageSendEvent_LDKSendFundingLocked_Body send_funding_locked;
      LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body send_announcement_signatures;
      LDKMessageSendEvent_LDKUpdateHTLCs_Body update_htl_cs;
      LDKMessageSendEvent_LDKSendRevokeAndACK_Body send_revoke_and_ack;
      LDKMessageSendEvent_LDKSendClosingSigned_Body send_closing_signed;
      LDKMessageSendEvent_LDKSendShutdown_Body send_shutdown;
      LDKMessageSendEvent_LDKSendChannelReestablish_Body send_channel_reestablish;
      LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body broadcast_channel_announcement;
      LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body broadcast_node_announcement;
      LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body broadcast_channel_update;
      LDKMessageSendEvent_LDKSendChannelUpdate_Body send_channel_update;
      LDKMessageSendEvent_LDKHandleError_Body handle_error;
      LDKMessageSendEvent_LDKPaymentFailureNetworkUpdate_Body payment_failure_network_update;
      LDKMessageSendEvent_LDKSendChannelRangeQuery_Body send_channel_range_query;
      LDKMessageSendEvent_LDKSendShortIdsQuery_Body send_short_ids_query;
      LDKMessageSendEvent_LDKSendReplyChannelRange_Body send_reply_channel_range;
   };
} LDKMessageSendEvent;

/**
 * A dynamically-allocated array of crate::lightning::util::events::MessageSendEvents of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MessageSendEventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMessageSendEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MessageSendEventZ;



/**
 * Features used within an `init` message.
 */
typedef struct MUST_USE_STRUCT LDKInitFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInitFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInitFeatures;

/**
 * The contents of CResult_InitFeaturesDecodeErrorZ
 */
typedef union LDKCResult_InitFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInitFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InitFeaturesDecodeErrorZPtr;

/**
 * A CResult_InitFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::InitFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InitFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_InitFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InitFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InitFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InitFeaturesDecodeErrorZ;



/**
 * Features used within a `node_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKNodeFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeFeatures;

/**
 * The contents of CResult_NodeFeaturesDecodeErrorZ
 */
typedef union LDKCResult_NodeFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeFeaturesDecodeErrorZPtr;

/**
 * A CResult_NodeFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::NodeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_NodeFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeFeaturesDecodeErrorZ;



/**
 * Features used within a `channel_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKChannelFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelFeatures;

/**
 * The contents of CResult_ChannelFeaturesDecodeErrorZ
 */
typedef union LDKCResult_ChannelFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelFeaturesDecodeErrorZPtr;

/**
 * A CResult_ChannelFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::ChannelFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelFeaturesDecodeErrorZ;



/**
 * Features used within an invoice.
 */
typedef struct MUST_USE_STRUCT LDKInvoiceFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceFeatures;

/**
 * The contents of CResult_InvoiceFeaturesDecodeErrorZ
 */
typedef union LDKCResult_InvoiceFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoiceFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InvoiceFeaturesDecodeErrorZPtr;

/**
 * A CResult_InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_InvoiceFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceFeaturesDecodeErrorZ;

/**
 * The contents of CResult_DelayedPaymentOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDelayedPaymentOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::DelayedPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ;

/**
 * The contents of CResult_StaticPaymentOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKStaticPaymentOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::StaticPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_StaticPaymentOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ;

/**
 * The contents of CResult_SpendableOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSpendableOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_SpendableOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::SpendableOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_SpendableOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_SpendableOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_SignatureCVec_SignatureZZ {
   /**
    * The element at position 0
    */
   struct LDKSignature a;
   /**
    * The element at position 1
    */
   struct LDKCVec_SignatureZ b;
} LDKC2Tuple_SignatureCVec_SignatureZZ;

/**
 * The contents of CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ
 */
typedef union LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_SignatureCVec_SignatureZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr;

/**
 * A CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_SignatureCVec_SignatureZZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ;

/**
 * The contents of CResult_SignatureNoneZ
 */
typedef union LDKCResult_SignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SignatureNoneZPtr;

/**
 * A CResult_SignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::Signature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignatureNoneZ {
   /**
    * The contents of this CResult_SignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignatureNoneZPtr contents;
   /**
    * Whether this CResult_SignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignatureNoneZ;



/**
 * The unsigned part of a channel_announcement
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelAnnouncement;

/**
 * A trait to sign lightning channel transactions as described in BOLT 3.
 *
 * Signing services could be implemented on a hardware wallet. In this case,
 * the current Sign would be a front-end on top of a communication
 * channel connected to your secure device and lightning key material wouldn't
 * reside on a hot server. Nevertheless, a this deployment would still need
 * to trust the ChannelManager to avoid loss of funds as this latest component
 * could ask to sign commitment transaction with HTLCs paying to attacker pubkeys.
 *
 * A more secure iteration would be to use hashlock (or payment points) to pair
 * invoice/incoming HTLCs with outgoing HTLCs to implement a no-trust-ChannelManager
 * at the price of more state and computation on the hardware wallet side. In the future,
 * we are looking forward to design such interface.
 *
 * In any case, ChannelMonitor or fallback watchtowers are always going to be trusted
 * to act, as liveness and breach reply correctness are always going to be hard requirements
 * of LN security model, orthogonal of key management issues.
 */
typedef struct LDKBaseSign {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the per-commitment point for a specific commitment number
    *
    * Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
    */
   struct LDKPublicKey (*get_per_commitment_point)(const void *this_arg, uint64_t idx);
   /**
    * Gets the commitment secret for a specific commitment number as part of the revocation process
    *
    * An external signer implementation should error here if the commitment was already signed
    * and should refuse to sign it in the future.
    *
    * May be called more than once for the same index.
    *
    * Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
    */
   struct LDKThirtyTwoBytes (*release_commitment_secret)(const void *this_arg, uint64_t idx);
   /**
    * Gets the holder's channel public keys and basepoints
    */
   struct LDKChannelPublicKeys pubkeys;
   /**
    * Fill in the pubkeys field as a reference to it will be given to Rust after this returns
    * Note that this takes a pointer to this object, not the this_ptr like other methods do
    * This function pointer may be NULL if pubkeys is filled in when this object is created and never needs updating.
    */
   void (*set_pubkeys)(const struct LDKBaseSign*NONNULL_PTR );
   /**
    * Gets an arbitrary identifier describing the set of keys which are provided back to you in
    * some SpendableOutputDescriptor types. This should be sufficient to identify this
    * Sign object uniquely and lookup or re-derive its keys.
    */
   struct LDKThirtyTwoBytes (*channel_keys_id)(const void *this_arg);
   /**
    * Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
    *
    * Note that if signing fails or is rejected, the channel will be force-closed.
    */
   struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ (*sign_counterparty_commitment)(const void *this_arg, const struct LDKCommitmentTransaction *NONNULL_PTR commitment_tx);
   /**
    * Create a signatures for a holder's commitment transaction and its claiming HTLC transactions.
    * This will only ever be called with a non-revoked commitment_tx.  This will be called with the
    * latest commitment_tx when we initiate a force-close.
    * This will be called with the previous latest, just to get claiming HTLC signatures, if we are
    * reacting to a ChannelMonitor replica that decided to broadcast before it had been updated to
    * the latest.
    * This may be called multiple times for the same transaction.
    *
    * An external signer implementation should check that the commitment has not been revoked.
    *
    * May return Err if key derivation fails.  Callers, such as ChannelMonitor, will panic in such a case.
    */
   struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ (*sign_holder_commitment_and_htlcs)(const void *this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR commitment_tx);
   /**
    * Create a signature for the given input in a transaction spending an HTLC transaction output
    * or a commitment transaction `to_local` output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiple outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiple times for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * per_commitment_key is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder revocation_secret to do
    * so).
    */
   struct LDKCResult_SignatureNoneZ (*sign_justice_revoked_output)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32]);
   /**
    * Create a signature for the given input in a transaction spending a commitment transaction
    * HTLC output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiple outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiple times for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * per_commitment_key is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder revocation_secret to do
    * so).
    *
    * htlc holds HTLC elements (hash, timelock), thus changing the format of the witness script
    * (which is committed to in the BIP 143 signatures).
    */
   struct LDKCResult_SignatureNoneZ (*sign_justice_revoked_htlc)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32], const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
    * transaction, either offered or received.
    *
    * Such a transaction may claim multiples offered outputs at same time if we know the
    * preimage for each when we create it, but only the input at index `input` should be
    * signed for here. It may be called multiple times for same output(s) if a fee-bump is
    * needed with regards to an upcoming timelock expiration.
    *
    * Witness_script is either a offered or received script as defined in BOLT3 for HTLC
    * outputs.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * Per_commitment_point is the dynamic point corresponding to the channel state
    * detected onchain. It has been generated by our counterparty and is used to derive
    * channel state keys, which are then included in the witness script and committed to in the
    * BIP 143 signature.
    */
   struct LDKCResult_SignatureNoneZ (*sign_counterparty_htlc_transaction)(const void *this_arg, struct LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, struct LDKPublicKey per_commitment_point, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a (proposed) closing transaction.
    *
    * Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
    * chosen to forgo their output as dust.
    */
   struct LDKCResult_SignatureNoneZ (*sign_closing_transaction)(const void *this_arg, struct LDKTransaction closing_tx);
   /**
    * Signs a channel announcement message with our funding key, proving it comes from one
    * of the channel participants.
    *
    * Note that if this fails or is rejected, the channel will not be publicly announced and
    * our counterparty may (though likely will not) close the channel on us for violating the
    * protocol.
    */
   struct LDKCResult_SignatureNoneZ (*sign_channel_announcement)(const void *this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Set the counterparty static channel data, including basepoints,
    * counterparty_selected/holder_selected_contest_delay and funding outpoint.
    * This is done as soon as the funding outpoint is known.  Since these are static channel data,
    * they MUST NOT be allowed to change to different values once set.
    *
    * channel_parameters.is_populated() MUST be true.
    *
    * We bind holder_selected_contest_delay late here for API convenience.
    *
    * Will be called before any signatures are applied.
    */
   void (*ready_channel)(void *this_arg, const struct LDKChannelTransactionParameters *NONNULL_PTR channel_parameters);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKBaseSign;

/**
 * A cloneable signer.
 *
 * Although we require signers to be cloneable, it may be useful for developers to be able to use
 * signers in an un-sized way, for example as `dyn BaseSign`. Therefore we separate the Clone trait,
 * which implies Sized, into this derived trait.
 */
typedef struct LDKSign {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Implementation of BaseSign for this object.
    */
   struct LDKBaseSign BaseSign;
   /**
    * Creates a copy of the BaseSign, for a copy of this Sign.
    * Because BaseSign doesn't natively support copying itself, you have to provide a full copy implementation here.
    */
   struct LDKBaseSign (*BaseSign_clone)(const struct LDKBaseSign *NONNULL_PTR orig_BaseSign);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Creates a copy of the object pointed to by this_arg, for a copy of this Sign.
    * Note that the ultimate copy of the Sign will have all function pointers the same as the original.
    * May be NULL if no action needs to be taken, the this_arg pointer will be copied into the new Sign.
    */
   void *(*clone)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSign;

/**
 * The contents of CResult_SignDecodeErrorZ
 */
typedef union LDKCResult_SignDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSign *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_SignDecodeErrorZPtr;

/**
 * A CResult_SignDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::Sign on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignDecodeErrorZ {
   /**
    * The contents of this CResult_SignDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignDecodeErrorZPtr contents;
   /**
    * Whether this CResult_SignDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignDecodeErrorZ;

/**
 * Represents a secp256k1 signature serialized as two 32-byte numbers as well as a tag which
 * allows recovering the exact public key which created the signature given the message.
 */
typedef struct LDKRecoverableSignature {
   /**
    * The bytes of the signature in "compact" form plus a "Recovery ID" which allows for
    * recovery.
    */
   uint8_t serialized_form[68];
} LDKRecoverableSignature;

/**
 * The contents of CResult_RecoverableSignatureNoneZ
 */
typedef union LDKCResult_RecoverableSignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRecoverableSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_RecoverableSignatureNoneZPtr;

/**
 * A CResult_RecoverableSignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::RecoverableSignature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RecoverableSignatureNoneZ {
   /**
    * The contents of this CResult_RecoverableSignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RecoverableSignatureNoneZPtr contents;
   /**
    * Whether this CResult_RecoverableSignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RecoverableSignatureNoneZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CVec_u8Zs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CVec_u8ZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCVec_u8Z *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CVec_u8ZZ;

/**
 * The contents of CResult_CVec_CVec_u8ZZNoneZ
 */
typedef union LDKCResult_CVec_CVec_u8ZZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_CVec_u8ZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_CVec_u8ZZNoneZPtr;

/**
 * A CResult_CVec_CVec_u8ZZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_CVec_u8ZZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_CVec_u8ZZNoneZ {
   /**
    * The contents of this CResult_CVec_CVec_u8ZZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_CVec_u8ZZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_CVec_u8ZZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_CVec_u8ZZNoneZ;



/**
 * A simple implementation of Sign that just keeps the private keys in memory.
 *
 * This implementation performs no policy checks and is insufficient by itself as
 * a secure external signer.
 */
typedef struct MUST_USE_STRUCT LDKInMemorySigner {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInMemorySigner *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInMemorySigner;

/**
 * The contents of CResult_InMemorySignerDecodeErrorZ
 */
typedef union LDKCResult_InMemorySignerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInMemorySigner *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InMemorySignerDecodeErrorZPtr;

/**
 * A CResult_InMemorySignerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::InMemorySigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InMemorySignerDecodeErrorZ {
   /**
    * The contents of this CResult_InMemorySignerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InMemorySignerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InMemorySignerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InMemorySignerDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::TxOuts of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TxOutZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKTxOut *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TxOutZ;

/**
 * The contents of CResult_TransactionNoneZ
 */
typedef union LDKCResult_TransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TransactionNoneZPtr;

/**
 * A CResult_TransactionNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::Transaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TransactionNoneZ {
   /**
    * The contents of this CResult_TransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TransactionNoneZPtr contents;
   /**
    * Whether this CResult_TransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TransactionNoneZ;



/**
 * A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
 * on-chain transactions to ensure no loss of funds occurs.
 *
 * You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
 * information and are actively monitoring the chain.
 *
 * Pending Events or updated HTLCs which have not yet been read out by
 * get_and_clear_pending_monitor_events or get_and_clear_pending_events are serialized to disk and
 * reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events
 * gotten are fully handled before re-serializing the new state.
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
 * returned block hash and the the current chain and then reconnecting blocks to get to the
 * best chain) upon deserializing the object!
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitor;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_BlockHashChannelMonitorZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKChannelMonitor b;
} LDKC2Tuple_BlockHashChannelMonitorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_BlockHashChannelMonitorZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_BlockHashChannelMonitorZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_BlockHashChannelMonitorZZ;

/**
 * The contents of CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
 */
typedef union LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr;

/**
 * A CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_C2Tuple_BlockHashChannelMonitorZZ on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ {
   /**
    * The contents of this CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr contents;
   /**
    * Whether this CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ;

/**
 * An enum which can either contain a u16 or not
 */
typedef enum LDKCOption_u16Z_Tag {
   /**
    * When we're in this state, this COption_u16Z contains a u16
    */
   LDKCOption_u16Z_Some,
   /**
    * When we're in this state, this COption_u16Z contains nothing
    */
   LDKCOption_u16Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u16Z_Sentinel,
} LDKCOption_u16Z_Tag;

typedef struct LDKCOption_u16Z {
   LDKCOption_u16Z_Tag tag;
   union {
      struct {
         uint16_t some;
      };
   };
} LDKCOption_u16Z;

/**
 * Indicates an error on the client's part (usually some variant of attempting to use too-low or
 * too-high values)
 */
typedef enum LDKAPIError_Tag {
   /**
    * Indicates the API was wholly misused (see err for more). Cases where these can be returned
    * are documented, but generally indicates some precondition of a function was violated.
    */
   LDKAPIError_APIMisuseError,
   /**
    * Due to a high feerate, we were unable to complete the request.
    * For example, this may be returned if the feerate implies we cannot open a channel at the
    * requested value, but opening a larger channel would succeed.
    */
   LDKAPIError_FeeRateTooHigh,
   /**
    * A malformed Route was provided (eg overflowed value, node id mismatch, overly-looped route,
    * too-many-hops, etc).
    */
   LDKAPIError_RouteError,
   /**
    * We were unable to complete the request as the Channel required to do so is unable to
    * complete the request (or was not found). This can take many forms, including disconnected
    * peer, channel at capacity, channel shutting down, etc.
    */
   LDKAPIError_ChannelUnavailable,
   /**
    * An attempt to call watch/update_channel returned an Err (ie you did this!), causing the
    * attempted action to fail.
    */
   LDKAPIError_MonitorUpdateFailed,
   /**
    * Must be last for serialization purposes
    */
   LDKAPIError_Sentinel,
} LDKAPIError_Tag;

typedef struct LDKAPIError_LDKAPIMisuseError_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKAPIMisuseError_Body;

typedef struct LDKAPIError_LDKFeeRateTooHigh_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
   /**
    * The feerate which was too high.
    */
   uint32_t feerate;
} LDKAPIError_LDKFeeRateTooHigh_Body;

typedef struct LDKAPIError_LDKRouteError_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKRouteError_Body;

typedef struct LDKAPIError_LDKChannelUnavailable_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKChannelUnavailable_Body;

typedef struct MUST_USE_STRUCT LDKAPIError {
   LDKAPIError_Tag tag;
   union {
      LDKAPIError_LDKAPIMisuseError_Body api_misuse_error;
      LDKAPIError_LDKFeeRateTooHigh_Body fee_rate_too_high;
      LDKAPIError_LDKRouteError_Body route_error;
      LDKAPIError_LDKChannelUnavailable_Body channel_unavailable;
   };
} LDKAPIError;

/**
 * The contents of CResult_NoneAPIErrorZ
 */
typedef union LDKCResult_NoneAPIErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_NoneAPIErrorZPtr;

/**
 * A CResult_NoneAPIErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneAPIErrorZ {
   /**
    * The contents of this CResult_NoneAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneAPIErrorZPtr contents;
   /**
    * Whether this CResult_NoneAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneAPIErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CResult_NoneAPIErrorZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CResult_NoneAPIErrorZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCResult_NoneAPIErrorZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CResult_NoneAPIErrorZZ;

/**
 * A dynamically-allocated array of crate::lightning::util::errors::APIErrors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_APIErrorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKAPIError *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_APIErrorZ;

/**
 * If a payment fails to send, it can be in one of several states. This enum is returned as the
 * Err() type describing which state the payment is in, see the description of individual enum
 * states for more.
 */
typedef enum LDKPaymentSendFailure_Tag {
   /**
    * A parameter which was passed to send_payment was invalid, preventing us from attempting to
    * send the payment at all. No channel state has been changed or messages sent to peers, and
    * once you've changed the parameter at error, you can freely retry the payment in full.
    */
   LDKPaymentSendFailure_ParameterError,
   /**
    * A parameter in a single path which was passed to send_payment was invalid, preventing us
    * from attempting to send the payment at all. No channel state has been changed or messages
    * sent to peers, and once you've changed the parameter at error, you can freely retry the
    * payment in full.
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment.
    */
   LDKPaymentSendFailure_PathParameterError,
   /**
    * All paths which were attempted failed to send, with no channel state change taking place.
    * You can freely retry the payment in full (though you probably want to do so over different
    * paths than the ones selected).
    */
   LDKPaymentSendFailure_AllFailedRetrySafe,
   /**
    * Some paths which were attempted failed to send, though possibly not all. At least some
    * paths have irrevocably committed to the HTLC and retrying the payment in full would result
    * in over-/re-payment.
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment, and any Errs which are not APIError::MonitorUpdateFailed can be safely
    * retried (though there is currently no API with which to do so).
    *
    * Any entries which contain Err(APIError::MonitorUpdateFailed) or Ok(()) MUST NOT be retried
    * as they will result in over-/re-payment. These HTLCs all either successfully sent (in the
    * case of Ok(())) or will send once channel_monitor_updated is called on the next-hop channel
    * with the latest update_id.
    */
   LDKPaymentSendFailure_PartialFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentSendFailure_Sentinel,
} LDKPaymentSendFailure_Tag;

typedef struct MUST_USE_STRUCT LDKPaymentSendFailure {
   LDKPaymentSendFailure_Tag tag;
   union {
      struct {
         struct LDKAPIError parameter_error;
      };
      struct {
         struct LDKCVec_CResult_NoneAPIErrorZZ path_parameter_error;
      };
      struct {
         struct LDKCVec_APIErrorZ all_failed_retry_safe;
      };
      struct {
         struct LDKCVec_CResult_NoneAPIErrorZZ partial_failure;
      };
   };
} LDKPaymentSendFailure;

/**
 * The contents of CResult_NonePaymentSendFailureZ
 */
typedef union LDKCResult_NonePaymentSendFailureZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_NonePaymentSendFailureZPtr;

/**
 * A CResult_NonePaymentSendFailureZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePaymentSendFailureZ {
   /**
    * The contents of this CResult_NonePaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_NonePaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePaymentSendFailureZ;

/**
 * A 4-byte byte array.
 */
typedef struct LDKFourBytes {
   /**
    * The four bytes
    */
   uint8_t data[4];
} LDKFourBytes;

/**
 * A 16-byte byte array.
 */
typedef struct LDKSixteenBytes {
   /**
    * The sixteen bytes
    */
   uint8_t data[16];
} LDKSixteenBytes;

/**
 * A 10-byte byte array.
 */
typedef struct LDKTenBytes {
   /**
    * The ten bytes
    */
   uint8_t data[10];
} LDKTenBytes;

/**
 * An address which can be used to connect to a remote peer
 */
typedef enum LDKNetAddress_Tag {
   /**
    * An IPv4 address/port on which the peer is listening.
    */
   LDKNetAddress_IPv4,
   /**
    * An IPv6 address/port on which the peer is listening.
    */
   LDKNetAddress_IPv6,
   /**
    * An old-style Tor onion address/port on which the peer is listening.
    */
   LDKNetAddress_OnionV2,
   /**
    * A new-style Tor onion address/port on which the peer is listening.
    * To create the human-readable \"hostname\", concatenate ed25519_pubkey, checksum, and version,
    * wrap as base32 and append \".onion\".
    */
   LDKNetAddress_OnionV3,
   /**
    * Must be last for serialization purposes
    */
   LDKNetAddress_Sentinel,
} LDKNetAddress_Tag;

typedef struct LDKNetAddress_LDKIPv4_Body {
   /**
    * The 4-byte IPv4 address
    */
   struct LDKFourBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKIPv4_Body;

typedef struct LDKNetAddress_LDKIPv6_Body {
   /**
    * The 16-byte IPv6 address
    */
   struct LDKSixteenBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKIPv6_Body;

typedef struct LDKNetAddress_LDKOnionV2_Body {
   /**
    * The bytes (usually encoded in base32 with \".onion\" appended)
    */
   struct LDKTenBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKOnionV2_Body;

typedef struct LDKNetAddress_LDKOnionV3_Body {
   /**
    * The ed25519 long-term public key of the peer
    */
   struct LDKThirtyTwoBytes ed25519_pubkey;
   /**
    * The checksum of the pubkey and version, as included in the onion address
    */
   uint16_t checksum;
   /**
    * The version byte, as defined by the Tor Onion v3 spec.
    */
   uint8_t version;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKOnionV3_Body;

typedef struct MUST_USE_STRUCT LDKNetAddress {
   LDKNetAddress_Tag tag;
   union {
      LDKNetAddress_LDKIPv4_Body i_pv4;
      LDKNetAddress_LDKIPv6_Body i_pv6;
      LDKNetAddress_LDKOnionV2_Body onion_v2;
      LDKNetAddress_LDKOnionV3_Body onion_v3;
   };
} LDKNetAddress;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::NetAddresss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_NetAddressZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKNetAddress *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_NetAddressZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PaymentHashPaymentSecretZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
} LDKC2Tuple_PaymentHashPaymentSecretZ;

/**
 * The contents of CResult_PaymentSecretAPIErrorZ
 */
typedef union LDKCResult_PaymentSecretAPIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_PaymentSecretAPIErrorZPtr;

/**
 * A CResult_PaymentSecretAPIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentSecretAPIErrorZ {
   /**
    * The contents of this CResult_PaymentSecretAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentSecretAPIErrorZPtr contents;
   /**
    * Whether this CResult_PaymentSecretAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentSecretAPIErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::ChannelMonitors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ChannelMonitorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKChannelMonitor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ChannelMonitorZ;



/**
 * An update generated by the underlying Channel itself which contains some new information the
 * ChannelMonitor should be made aware of.
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitorUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitorUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitorUpdate;

/**
 * The `Watch` trait defines behavior for watching on-chain activity pertaining to channels as
 * blocks are connected and disconnected.
 *
 * Each channel is associated with a [`ChannelMonitor`]. Implementations of this trait are
 * responsible for maintaining a set of monitors such that they can be updated accordingly as
 * channel state changes and HTLCs are resolved. See method documentation for specific
 * requirements.
 *
 * Implementations **must** ensure that updates are successfully applied and persisted upon method
 * completion. If an update fails with a [`PermanentFailure`], then it must immediately shut down
 * without taking any further action such as persisting the current state.
 *
 * If an implementation maintains multiple instances of a channel's monitor (e.g., by storing
 * backup copies), then it must ensure that updates are applied across all instances. Otherwise, it
 * could result in a revoked transaction being broadcast, allowing the counterparty to claim all
 * funds in the channel. See [`ChannelMonitorUpdateErr`] for more details about how to handle
 * multiple instances.
 *
 * [`ChannelMonitor`]: channelmonitor::ChannelMonitor
 * [`ChannelMonitorUpdateErr`]: channelmonitor::ChannelMonitorUpdateErr
 * [`PermanentFailure`]: channelmonitor::ChannelMonitorUpdateErr::PermanentFailure
 */
typedef struct LDKWatch {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Watches a channel identified by `funding_txo` using `monitor`.
    *
    * Implementations are responsible for watching the chain for the funding transaction along
    * with any spends of outputs returned by [`get_outputs_to_watch`]. In practice, this means
    * calling [`block_connected`] and [`block_disconnected`] on the monitor.
    *
    * [`get_outputs_to_watch`]: channelmonitor::ChannelMonitor::get_outputs_to_watch
    * [`block_connected`]: channelmonitor::ChannelMonitor::block_connected
    * [`block_disconnected`]: channelmonitor::ChannelMonitor::block_disconnected
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*watch_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitor monitor);
   /**
    * Updates a channel identified by `funding_txo` by applying `update` to its monitor.
    *
    * Implementations must call [`update_monitor`] with the given update. See
    * [`ChannelMonitorUpdateErr`] for invariants around returning an error.
    *
    * [`update_monitor`]: channelmonitor::ChannelMonitor::update_monitor
    * [`ChannelMonitorUpdateErr`]: channelmonitor::ChannelMonitorUpdateErr
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*update_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitorUpdate update);
   /**
    * Returns any monitor events since the last call. Subsequent calls must only return new
    * events.
    */
   struct LDKCVec_MonitorEventZ (*release_pending_monitor_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWatch;

/**
 * An interface to send a transaction to the Bitcoin network.
 */
typedef struct LDKBroadcasterInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Sends a transaction out to (hopefully) be mined.
    */
   void (*broadcast_transaction)(const void *this_arg, struct LDKTransaction tx);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKBroadcasterInterface;

/**
 * A "slice" referencing some byte array. This is simply a length-tagged pointer which does not
 * own the memory pointed to by data.
 */
typedef struct LDKu8slice {
   /**
    * A pointer to the byte buffer
    */
   const uint8_t *data;
   /**
    * The number of bytes pointed to by `data`.
    */
   uintptr_t datalen;
} LDKu8slice;

/**
 * A trait to describe an object which can get user secrets and key material.
 */
typedef struct LDKKeysInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Get node secret key (aka node_id or network_key).
    *
    * This method must return the same value each time it is called.
    */
   struct LDKSecretKey (*get_node_secret)(const void *this_arg);
   /**
    * Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKCVec_u8Z (*get_destination_script)(const void *this_arg);
   /**
    * Get a public key which we will send funds to (in the form of a P2WPKH output) when closing
    * a channel.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKPublicKey (*get_shutdown_pubkey)(const void *this_arg);
   /**
    * Get a new set of Sign for per-channel secrets. These MUST be unique even if you
    * restarted with some stale data!
    *
    * This method must return a different value each time it is called.
    */
   struct LDKSign (*get_channel_signer)(const void *this_arg, bool inbound, uint64_t channel_value_satoshis);
   /**
    * Gets a unique, cryptographically-secure, random 32 byte value. This is used for encrypting
    * onion packets and for temporary channel IDs. There is no requirement that these be
    * persisted anywhere, though they must be unique across restarts.
    *
    * This method must return a different value each time it is called.
    */
   struct LDKThirtyTwoBytes (*get_secure_random_bytes)(const void *this_arg);
   /**
    * Reads a `Signer` for this `KeysInterface` from the given input stream.
    * This is only called during deserialization of other objects which contain
    * `Sign`-implementing objects (ie `ChannelMonitor`s and `ChannelManager`s).
    * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
    * contain no versioning scheme. You may wish to include your own version prefix and ensure
    * you've read all of the provided bytes to ensure no corruption occurred.
    */
   struct LDKCResult_SignDecodeErrorZ (*read_chan_signer)(const void *this_arg, struct LDKu8slice reader);
   /**
    * Sign an invoice's preimage (note that this is the preimage of the invoice, not the HTLC's
    * preimage). By parameterizing by the preimage instead of the hash, we allow implementors of
    * this trait to parse the invoice and make sure they're signing what they expect, rather than
    * blindly signing the hash.
    */
   struct LDKCResult_RecoverableSignatureNoneZ (*sign_invoice)(const void *this_arg, struct LDKCVec_u8Z invoice_preimage);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKKeysInterface;

/**
 * A trait which should be implemented to provide feerate information on a number of time
 * horizons.
 *
 * Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're
 * called from inside the library in response to chain events, P2P events, or timer events).
 */
typedef struct LDKFeeEstimator {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets estimated satoshis of fee required per 1000 Weight-Units.
    *
    * Must be no smaller than 253 (ie 1 satoshi-per-byte rounded up to ensure later round-downs
    * don't put us below 1 satoshi-per-byte).
    *
    * This translates to:
    *  * satoshis-per-byte * 250
    *  * ceil(satoshis-per-kbyte / 4)
    */
   uint32_t (*get_est_sat_per_1000_weight)(const void *this_arg, enum LDKConfirmationTarget confirmation_target);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFeeEstimator;

/**
 * A trait encapsulating the operations required of a logger
 */
typedef struct LDKLogger {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Logs the `Record`
    */
   void (*log)(const void *this_arg, const char *record);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKLogger;



/**
 * Manager which keeps track of a number of channels and sends messages to the appropriate
 * channel, also tracking HTLC preimages and forwarding onion packets appropriately.
 *
 * Implements ChannelMessageHandler, handling the multi-channel parts and passing things through
 * to individual Channels.
 *
 * Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for
 * all peers during write/read (though does not modify this instance, only the instance being
 * serialized). This will result in any channels which have not yet exchanged funding_created (ie
 * called funding_transaction_generated for outbound channels).
 *
 * Note that you can be a bit lazier about writing out ChannelManager than you can be with
 * ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before
 * returning from chain::Watch::watch_/update_channel, with ChannelManagers, writing updates
 * happens out-of-band (and will prevent any other ChannelManager operations from occurring during
 * the serialization process). If the deserialized version is out-of-date compared to the
 * ChannelMonitors passed by reference to read(), those channels will be force-closed based on the
 * ChannelMonitor state and no funds will be lost (mod on-chain transaction fees).
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelManager), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call
 * block_connected() to step towards your best block) upon deserialization before using the
 * object!
 *
 * Note that ChannelManager is responsible for tracking liveness of its channels and generating
 * ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid
 * spam due to quick disconnection/reconnection, updates are not sent until the channel has been
 * offline for a full minute. In order to track this, you must call
 * timer_tick_occurred roughly once per minute, though it doesn't have to be perfect.
 *
 * Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager
 * a SimpleRefChannelManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefChannelManager, and use a
 * SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 */
typedef struct MUST_USE_STRUCT LDKChannelManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManager;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_BlockHashChannelManagerZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKChannelManager b;
} LDKC2Tuple_BlockHashChannelManagerZ;

/**
 * The contents of CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
 */
typedef union LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_BlockHashChannelManagerZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr;

/**
 * A CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_BlockHashChannelManagerZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ {
   /**
    * The contents of this CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ;



/**
 * Options which apply on a per-channel basis and may change at runtime or based on negotiation
 * with our counterparty.
 */
typedef struct MUST_USE_STRUCT LDKChannelConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelConfig;

/**
 * The contents of CResult_ChannelConfigDecodeErrorZ
 */
typedef union LDKCResult_ChannelConfigDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelConfig *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelConfigDecodeErrorZPtr;

/**
 * A CResult_ChannelConfigDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::config::ChannelConfig on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelConfigDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelConfigDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelConfigDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelConfigDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelConfigDecodeErrorZ;

/**
 * The contents of CResult_OutPointDecodeErrorZ
 */
typedef union LDKCResult_OutPointDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOutPoint *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OutPointDecodeErrorZPtr;

/**
 * A CResult_OutPointDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::transaction::OutPoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OutPointDecodeErrorZ {
   /**
    * The contents of this CResult_OutPointDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OutPointDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OutPointDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OutPointDecodeErrorZ;

/**
 * The contents of CResult_SiPrefixNoneZ
 */
typedef union LDKCResult_SiPrefixNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   enum LDKSiPrefix *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SiPrefixNoneZPtr;

/**
 * A CResult_SiPrefixNoneZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::SiPrefix on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SiPrefixNoneZ {
   /**
    * The contents of this CResult_SiPrefixNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SiPrefixNoneZPtr contents;
   /**
    * Whether this CResult_SiPrefixNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SiPrefixNoneZ;



/**
 * Represents a syntactically and semantically correct lightning BOLT11 invoice.
 *
 * There are three ways to construct an `Invoice`:
 *  1. using `InvoiceBuilder`
 *  2. using `Invoice::from_signed(SignedRawInvoice)`
 *  3. using `str::parse::<Invoice>(&str)`
 */
typedef struct MUST_USE_STRUCT LDKInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoice;

/**
 * The contents of CResult_InvoiceNoneZ
 */
typedef union LDKCResult_InvoiceNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_InvoiceNoneZPtr;

/**
 * A CResult_InvoiceNoneZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceNoneZ {
   /**
    * The contents of this CResult_InvoiceNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceNoneZPtr contents;
   /**
    * Whether this CResult_InvoiceNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceNoneZ;



/**
 * Represents a signed `RawInvoice` with cached hash. The signature is not checked and may be
 * invalid.
 *
 * # Invariants
 * The hash has to be either from the deserialized invoice or from the serialized `raw_invoice`.
 */
typedef struct MUST_USE_STRUCT LDKSignedRawInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSignedRawInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSignedRawInvoice;

/**
 * The contents of CResult_SignedRawInvoiceNoneZ
 */
typedef union LDKCResult_SignedRawInvoiceNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSignedRawInvoice *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SignedRawInvoiceNoneZPtr;

/**
 * A CResult_SignedRawInvoiceNoneZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::SignedRawInvoice on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignedRawInvoiceNoneZ {
   /**
    * The contents of this CResult_SignedRawInvoiceNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignedRawInvoiceNoneZPtr contents;
   /**
    * Whether this CResult_SignedRawInvoiceNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignedRawInvoiceNoneZ;



/**
 * Represents an syntactically correct Invoice for a payment on the lightning network,
 * but without the signature information.
 * De- and encoding should not lead to information loss but may lead to different hashes.
 *
 * For methods without docs see the corresponding methods in `Invoice`.
 */
typedef struct MUST_USE_STRUCT LDKRawInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRawInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRawInvoice;



/**
 * Recoverable signature
 */
typedef struct MUST_USE_STRUCT LDKInvoiceSignature {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceSignature *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceSignature;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ {
   /**
    * The element at position 0
    */
   struct LDKRawInvoice a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
   /**
    * The element at position 2
    */
   struct LDKInvoiceSignature c;
} LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ;



/**
 * Payee public key
 */
typedef struct MUST_USE_STRUCT LDKPayeePubKey {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePayeePubKey *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPayeePubKey;

/**
 * The contents of CResult_PayeePubKeyErrorZ
 */
typedef union LDKCResult_PayeePubKeyErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPayeePubKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_PayeePubKeyErrorZPtr;

/**
 * A CResult_PayeePubKeyErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PayeePubKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PayeePubKeyErrorZ {
   /**
    * The contents of this CResult_PayeePubKeyErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PayeePubKeyErrorZPtr contents;
   /**
    * Whether this CResult_PayeePubKeyErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PayeePubKeyErrorZ;



/**
 * Private routing information
 *
 * # Invariants
 * The encoded route has to be <1024 5bit characters long (<=639 bytes or <=12 hops)
 *
 */
typedef struct MUST_USE_STRUCT LDKPrivateRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePrivateRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPrivateRoute;

/**
 * A dynamically-allocated array of crate::lightning_invoice::PrivateRoutes of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PrivateRouteZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPrivateRoute *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PrivateRouteZ;



/**
 * A timestamp that refers to a date after 1 January 1970 which means its representation as UNIX
 * timestamp is positive.
 *
 * # Invariants
 * The UNIX timestamp representing the stored time has to be positive and small enough so that
 * a `EpiryTime` can be added to it without an overflow.
 */
typedef struct MUST_USE_STRUCT LDKPositiveTimestamp {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePositiveTimestamp *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPositiveTimestamp;

/**
 * The contents of CResult_PositiveTimestampCreationErrorZ
 */
typedef union LDKCResult_PositiveTimestampCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPositiveTimestamp *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_PositiveTimestampCreationErrorZPtr;

/**
 * A CResult_PositiveTimestampCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PositiveTimestamp on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PositiveTimestampCreationErrorZ {
   /**
    * The contents of this CResult_PositiveTimestampCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PositiveTimestampCreationErrorZPtr contents;
   /**
    * Whether this CResult_PositiveTimestampCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PositiveTimestampCreationErrorZ;

/**
 * The contents of CResult_NoneSemanticErrorZ
 */
typedef union LDKCResult_NoneSemanticErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSemanticError *err;
} LDKCResult_NoneSemanticErrorZPtr;

/**
 * A CResult_NoneSemanticErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning_invoice::SemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneSemanticErrorZ {
   /**
    * The contents of this CResult_NoneSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneSemanticErrorZPtr contents;
   /**
    * Whether this CResult_NoneSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneSemanticErrorZ;

/**
 * The contents of CResult_InvoiceSemanticErrorZ
 */
typedef union LDKCResult_InvoiceSemanticErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSemanticError *err;
} LDKCResult_InvoiceSemanticErrorZPtr;

/**
 * A CResult_InvoiceSemanticErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::SemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceSemanticErrorZ {
   /**
    * The contents of this CResult_InvoiceSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceSemanticErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceSemanticErrorZ;



/**
 * Description string
 *
 * # Invariants
 * The description can be at most 639 __bytes__ long
 */
typedef struct MUST_USE_STRUCT LDKDescription {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDescription *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDescription;

/**
 * The contents of CResult_DescriptionCreationErrorZ
 */
typedef union LDKCResult_DescriptionCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDescription *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_DescriptionCreationErrorZPtr;

/**
 * A CResult_DescriptionCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Description on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DescriptionCreationErrorZ {
   /**
    * The contents of this CResult_DescriptionCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DescriptionCreationErrorZPtr contents;
   /**
    * Whether this CResult_DescriptionCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DescriptionCreationErrorZ;



/**
 * Positive duration that defines when (relatively to the timestamp) in the future the invoice
 * expires
 *
 * # Invariants
 * The number of seconds this expiry time represents has to be in the range
 * `0...(SYSTEM_TIME_MAX_UNIX_TIMESTAMP - MAX_EXPIRY_TIME)` to avoid overflows when adding it to a
 * timestamp
 */
typedef struct MUST_USE_STRUCT LDKExpiryTime {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeExpiryTime *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKExpiryTime;

/**
 * The contents of CResult_ExpiryTimeCreationErrorZ
 */
typedef union LDKCResult_ExpiryTimeCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKExpiryTime *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_ExpiryTimeCreationErrorZPtr;

/**
 * A CResult_ExpiryTimeCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::ExpiryTime on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ExpiryTimeCreationErrorZ {
   /**
    * The contents of this CResult_ExpiryTimeCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ExpiryTimeCreationErrorZPtr contents;
   /**
    * Whether this CResult_ExpiryTimeCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ExpiryTimeCreationErrorZ;

/**
 * The contents of CResult_PrivateRouteCreationErrorZ
 */
typedef union LDKCResult_PrivateRouteCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPrivateRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_PrivateRouteCreationErrorZPtr;

/**
 * A CResult_PrivateRouteCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PrivateRoute on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PrivateRouteCreationErrorZ {
   /**
    * The contents of this CResult_PrivateRouteCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PrivateRouteCreationErrorZPtr contents;
   /**
    * Whether this CResult_PrivateRouteCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PrivateRouteCreationErrorZ;

/**
 * The contents of CResult_StringErrorZ
 */
typedef union LDKCResult_StringErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKStr *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_StringErrorZPtr;

/**
 * A CResult_StringErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::Str on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_StringErrorZ {
   /**
    * The contents of this CResult_StringErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_StringErrorZPtr contents;
   /**
    * Whether this CResult_StringErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_StringErrorZ;

/**
 * The contents of CResult_ChannelMonitorUpdateDecodeErrorZ
 */
typedef union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelMonitorUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr;

/**
 * A CResult_ChannelMonitorUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::channelmonitor::ChannelMonitorUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelMonitorUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelMonitorUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZ;

/**
 * The contents of CResult_HTLCUpdateDecodeErrorZ
 */
typedef union LDKCResult_HTLCUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCUpdateDecodeErrorZPtr;

/**
 * A CResult_HTLCUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::channelmonitor::HTLCUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCUpdateDecodeErrorZ;



/**
 * General Err type for ChannelMonitor actions. Generally, this implies that the data provided is
 * inconsistent with the ChannelMonitor being called. eg for ChannelMonitor::update_monitor this
 * means you tried to update a monitor for a different channel or the ChannelMonitorUpdate was
 * corrupted.
 * Contains a developer-readable error message.
 */
typedef struct MUST_USE_STRUCT LDKMonitorUpdateError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMonitorUpdateError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMonitorUpdateError;

/**
 * The contents of CResult_NoneMonitorUpdateErrorZ
 */
typedef union LDKCResult_NoneMonitorUpdateErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKMonitorUpdateError *err;
} LDKCResult_NoneMonitorUpdateErrorZPtr;

/**
 * A CResult_NoneMonitorUpdateErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::chain::channelmonitor::MonitorUpdateError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneMonitorUpdateErrorZ {
   /**
    * The contents of this CResult_NoneMonitorUpdateErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneMonitorUpdateErrorZPtr contents;
   /**
    * Whether this CResult_NoneMonitorUpdateErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneMonitorUpdateErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_OutPointScriptZ {
   /**
    * The element at position 0
    */
   struct LDKOutPoint a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_OutPointScriptZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u32ScriptZ {
   /**
    * The element at position 0
    */
   uint32_t a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_u32ScriptZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32ScriptZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u32ScriptZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u32ScriptZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32ScriptZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCVec_C2Tuple_u32ScriptZZ b;
} LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ;

/**
 * An Event which you should probably take some action in response to.
 *
 * Note that while Writeable and Readable are implemented for Event, you probably shouldn't use
 * them directly as they don't round-trip exactly (for example FundingGenerationReady is never
 * written as it makes no sense to respond to it after reconnecting to peers).
 */
typedef enum LDKEvent_Tag {
   /**
    * Used to indicate that the client should generate a funding transaction with the given
    * parameters and then call ChannelManager::funding_transaction_generated.
    * Generated in ChannelManager message handling.
    * Note that *all inputs* in the funding transaction must spend SegWit outputs or your
    * counterparty can steal your funds!
    */
   LDKEvent_FundingGenerationReady,
   /**
    * Indicates we've received money! Just gotta dig out that payment preimage and feed it to
    * ChannelManager::claim_funds to get it....
    * Note that if the preimage is not known or the amount paid is incorrect, you should call
    * ChannelManager::fail_htlc_backwards to free up resources for this HTLC and avoid
    * network congestion.
    * The amount paid should be considered 'incorrect' when it is less than or more than twice
    * the amount expected.
    * If you fail to call either ChannelManager::claim_funds or
    * ChannelManager::fail_htlc_backwards within the HTLC's timeout, the HTLC will be
    * automatically failed.
    */
   LDKEvent_PaymentReceived,
   /**
    * Indicates an outbound payment we made succeeded (ie it made it all the way to its target
    * and we got back the payment preimage for it).
    */
   LDKEvent_PaymentSent,
   /**
    * Indicates an outbound payment we made failed. Probably some intermediary node dropped
    * something. You may wish to retry with a different route.
    */
   LDKEvent_PaymentFailed,
   /**
    * Used to indicate that ChannelManager::process_pending_htlc_forwards should be called at a
    * time in the future.
    */
   LDKEvent_PendingHTLCsForwardable,
   /**
    * Used to indicate that an output which you should know how to spend was confirmed on chain
    * and is now spendable.
    * Such an output will *not* ever be spent by rust-lightning, and are not at risk of your
    * counterparty spending them due to some kind of timeout. Thus, you need to store them
    * somewhere and spend them when you create on-chain transactions.
    */
   LDKEvent_SpendableOutputs,
   /**
    * Must be last for serialization purposes
    */
   LDKEvent_Sentinel,
} LDKEvent_Tag;

typedef struct LDKEvent_LDKFundingGenerationReady_Body {
   /**
    * The random channel_id we picked which you'll need to pass into
    * ChannelManager::funding_transaction_generated.
    */
   struct LDKThirtyTwoBytes temporary_channel_id;
   /**
    * The value, in satoshis, that the output should have.
    */
   uint64_t channel_value_satoshis;
   /**
    * The script which should be used in the transaction output.
    */
   struct LDKCVec_u8Z output_script;
   /**
    * The value passed in to ChannelManager::create_channel
    */
   uint64_t user_channel_id;
} LDKEvent_LDKFundingGenerationReady_Body;

typedef struct LDKEvent_LDKPaymentReceived_Body {
   /**
    * The hash for which the preimage should be handed to the ChannelManager.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The preimage to the payment_hash, if the payment hash (and secret) were fetched via
    * [`ChannelManager::create_inbound_payment`]. If provided, this can be handed directly to
    * [`ChannelManager::claim_funds`].
    *
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    */
   struct LDKThirtyTwoBytes payment_preimage;
   /**
    * The \"payment secret\". This authenticates the sender to the recipient, preventing a
    * number of deanonymization attacks during the routing process.
    * It is provided here for your reference, however its accuracy is enforced directly by
    * [`ChannelManager`] using the values you previously provided to
    * [`ChannelManager::create_inbound_payment`] or
    * [`ChannelManager::create_inbound_payment_for_hash`].
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::create_inbound_payment_for_hash`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
    */
   struct LDKThirtyTwoBytes payment_secret;
   /**
    * The value, in thousandths of a satoshi, that this payment is for. Note that you must
    * compare this to the expected value before accepting the payment (as otherwise you are
    * providing proof-of-payment for less than the value you expected!).
    */
   uint64_t amt;
   /**
    * This is the `user_payment_id` which was provided to
    * [`ChannelManager::create_inbound_payment_for_hash`] or
    * [`ChannelManager::create_inbound_payment`]. It has no meaning inside of LDK and is
    * simply copied here. It may be used to correlate PaymentReceived events with invoice
    * metadata stored elsewhere.
    *
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::create_inbound_payment_for_hash`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
    */
   uint64_t user_payment_id;
} LDKEvent_LDKPaymentReceived_Body;

typedef struct LDKEvent_LDKPaymentSent_Body {
   /**
    * The preimage to the hash given to ChannelManager::send_payment.
    * Note that this serves as a payment receipt, if you wish to have such a thing, you must
    * store it somehow!
    */
   struct LDKThirtyTwoBytes payment_preimage;
} LDKEvent_LDKPaymentSent_Body;

typedef struct LDKEvent_LDKPaymentFailed_Body {
   /**
    * The hash which was given to ChannelManager::send_payment.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * Indicates the payment was rejected for some reason by the recipient. This implies that
    * the payment has failed, not just the route in question. If this is not set, you may
    * retry the payment via a different route.
    */
   bool rejected_by_dest;
} LDKEvent_LDKPaymentFailed_Body;

typedef struct LDKEvent_LDKPendingHTLCsForwardable_Body {
   /**
    * The minimum amount of time that should be waited prior to calling
    * process_pending_htlc_forwards. To increase the effort required to correlate payments,
    * you should wait a random amount of time in roughly the range (now + time_forwardable,
    * now + 5*time_forwardable).
    */
   uint64_t time_forwardable;
} LDKEvent_LDKPendingHTLCsForwardable_Body;

typedef struct LDKEvent_LDKSpendableOutputs_Body {
   /**
    * The outputs which you should store as spendable by you.
    */
   struct LDKCVec_SpendableOutputDescriptorZ outputs;
} LDKEvent_LDKSpendableOutputs_Body;

typedef struct MUST_USE_STRUCT LDKEvent {
   LDKEvent_Tag tag;
   union {
      LDKEvent_LDKFundingGenerationReady_Body funding_generation_ready;
      LDKEvent_LDKPaymentReceived_Body payment_received;
      LDKEvent_LDKPaymentSent_Body payment_sent;
      LDKEvent_LDKPaymentFailed_Body payment_failed;
      LDKEvent_LDKPendingHTLCsForwardable_Body pending_htl_cs_forwardable;
      LDKEvent_LDKSpendableOutputs_Body spendable_outputs;
   };
} LDKEvent;

/**
 * A dynamically-allocated array of crate::lightning::util::events::Events of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_EventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_EventZ;

/**
 * A dynamically-allocated array of crate::c_types::Transactions of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TransactionZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKTransaction *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TransactionZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u32TxOutZ {
   /**
    * The element at position 0
    */
   uint32_t a;
   /**
    * The element at position 1
    */
   struct LDKTxOut b;
} LDKC2Tuple_u32TxOutZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32TxOutZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u32TxOutZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u32TxOutZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32TxOutZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCVec_C2Tuple_u32TxOutZZ b;
} LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TransactionOutputsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TransactionOutputsZ;

/**
 * The contents of CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
 */
typedef union LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_BlockHashChannelMonitorZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr;

/**
 * A CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_BlockHashChannelMonitorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ {
   /**
    * The contents of this CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ;

/**
 * The contents of CResult_boolLightningErrorZ
 */
typedef union LDKCResult_boolLightningErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   bool *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_boolLightningErrorZPtr;

/**
 * A CResult_boolLightningErrorZ represents the result of a fallible operation,
 * containing a bool on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_boolLightningErrorZ {
   /**
    * The contents of this CResult_boolLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_boolLightningErrorZPtr contents;
   /**
    * Whether this CResult_boolLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_boolLightningErrorZ;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
   /**
    * The element at position 0
    */
   struct LDKChannelAnnouncement a;
   /**
    * The element at position 1
    */
   struct LDKChannelUpdate b;
   /**
    * The element at position 2
    */
   struct LDKChannelUpdate c;
} LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::NodeAnnouncements of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_NodeAnnouncementZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKNodeAnnouncement *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_NodeAnnouncementZ;

/**
 * The contents of CResult_NoneLightningErrorZ
 */
typedef union LDKCResult_NoneLightningErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_NoneLightningErrorZPtr;

/**
 * A CResult_NoneLightningErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneLightningErrorZ {
   /**
    * The contents of this CResult_NoneLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneLightningErrorZPtr contents;
   /**
    * Whether this CResult_NoneLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneLightningErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::PublicKeys of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PublicKeyZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPublicKey *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PublicKeyZ;



/**
 * Error for PeerManager errors. If you get one of these, you must disconnect the socket and
 * generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
 * descriptor.
 */
typedef struct MUST_USE_STRUCT LDKPeerHandleError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerHandleError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerHandleError;

/**
 * The contents of CResult_CVec_u8ZPeerHandleErrorZ
 */
typedef union LDKCResult_CVec_u8ZPeerHandleErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_u8Z *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_CVec_u8ZPeerHandleErrorZPtr;

/**
 * A CResult_CVec_u8ZPeerHandleErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_u8Z on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_u8ZPeerHandleErrorZ {
   /**
    * The contents of this CResult_CVec_u8ZPeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_u8ZPeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_CVec_u8ZPeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_u8ZPeerHandleErrorZ;

/**
 * The contents of CResult_NonePeerHandleErrorZ
 */
typedef union LDKCResult_NonePeerHandleErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_NonePeerHandleErrorZPtr;

/**
 * A CResult_NonePeerHandleErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePeerHandleErrorZ {
   /**
    * The contents of this CResult_NonePeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_NonePeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePeerHandleErrorZ;

/**
 * The contents of CResult_boolPeerHandleErrorZ
 */
typedef union LDKCResult_boolPeerHandleErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   bool *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_boolPeerHandleErrorZPtr;

/**
 * A CResult_boolPeerHandleErrorZ represents the result of a fallible operation,
 * containing a bool on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_boolPeerHandleErrorZ {
   /**
    * The contents of this CResult_boolPeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_boolPeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_boolPeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_boolPeerHandleErrorZ;



/**
 * Details about one direction of a channel. Received
 * within a channel update.
 */
typedef struct MUST_USE_STRUCT LDKDirectionalChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectionalChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectionalChannelInfo;

/**
 * The contents of CResult_DirectionalChannelInfoDecodeErrorZ
 */
typedef union LDKCResult_DirectionalChannelInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDirectionalChannelInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_DirectionalChannelInfoDecodeErrorZPtr;

/**
 * A CResult_DirectionalChannelInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::DirectionalChannelInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DirectionalChannelInfoDecodeErrorZ {
   /**
    * The contents of this CResult_DirectionalChannelInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DirectionalChannelInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_DirectionalChannelInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DirectionalChannelInfoDecodeErrorZ;



/**
 * Details about a channel (both directions).
 * Received within a channel announcement.
 */
typedef struct MUST_USE_STRUCT LDKChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelInfo;

/**
 * The contents of CResult_ChannelInfoDecodeErrorZ
 */
typedef union LDKCResult_ChannelInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelInfoDecodeErrorZPtr;

/**
 * A CResult_ChannelInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::ChannelInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelInfoDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelInfoDecodeErrorZ;



/**
 * Fees for routing via a given channel or a node
 */
typedef struct MUST_USE_STRUCT LDKRoutingFees {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoutingFees *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoutingFees;

/**
 * The contents of CResult_RoutingFeesDecodeErrorZ
 */
typedef union LDKCResult_RoutingFeesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoutingFees *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RoutingFeesDecodeErrorZPtr;

/**
 * A CResult_RoutingFeesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::RoutingFees on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RoutingFeesDecodeErrorZ {
   /**
    * The contents of this CResult_RoutingFeesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RoutingFeesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RoutingFeesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RoutingFeesDecodeErrorZ;



/**
 * Information received in the latest node_announcement from this node.
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncementInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncementInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncementInfo;

/**
 * The contents of CResult_NodeAnnouncementInfoDecodeErrorZ
 */
typedef union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAnnouncementInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr;

/**
 * A CResult_NodeAnnouncementInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::NodeAnnouncementInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAnnouncementInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAnnouncementInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZ;

/**
 * A dynamically-allocated array of u64s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u64Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   uint64_t *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u64Z;



/**
 * Details about a node in the network, known from the network announcement.
 */
typedef struct MUST_USE_STRUCT LDKNodeInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeInfo;

/**
 * The contents of CResult_NodeInfoDecodeErrorZ
 */
typedef union LDKCResult_NodeInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeInfoDecodeErrorZPtr;

/**
 * A CResult_NodeInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::NodeInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeInfoDecodeErrorZ {
   /**
    * The contents of this CResult_NodeInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeInfoDecodeErrorZ;



/**
 * Represents the network as nodes and channels between them
 */
typedef struct MUST_USE_STRUCT LDKNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNetworkGraph;

/**
 * The contents of CResult_NetworkGraphDecodeErrorZ
 */
typedef union LDKCResult_NetworkGraphDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNetworkGraph *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NetworkGraphDecodeErrorZPtr;

/**
 * A CResult_NetworkGraphDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::NetworkGraph on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NetworkGraphDecodeErrorZ {
   /**
    * The contents of this CResult_NetworkGraphDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NetworkGraphDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NetworkGraphDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NetworkGraphDecodeErrorZ;

/**
 * The contents of CResult_NetAddressu8Z
 */
typedef union LDKCResult_NetAddressu8ZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNetAddress *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   uint8_t *err;
} LDKCResult_NetAddressu8ZPtr;

/**
 * A CResult_NetAddressu8Z represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::NetAddress on success and a u8 on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NetAddressu8Z {
   /**
    * The contents of this CResult_NetAddressu8Z, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NetAddressu8ZPtr contents;
   /**
    * Whether this CResult_NetAddressu8Z represents a success state.
    */
   bool result_ok;
} LDKCResult_NetAddressu8Z;

/**
 * The contents of CResult_CResult_NetAddressu8ZDecodeErrorZ
 */
typedef union LDKCResult_CResult_NetAddressu8ZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCResult_NetAddressu8Z *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CResult_NetAddressu8ZDecodeErrorZPtr;

/**
 * A CResult_CResult_NetAddressu8ZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CResult_NetAddressu8Z on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ {
   /**
    * The contents of this CResult_CResult_NetAddressu8ZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CResult_NetAddressu8ZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CResult_NetAddressu8ZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CResult_NetAddressu8ZDecodeErrorZ;

/**
 * The contents of CResult_NetAddressDecodeErrorZ
 */
typedef union LDKCResult_NetAddressDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNetAddress *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NetAddressDecodeErrorZPtr;

/**
 * A CResult_NetAddressDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::NetAddress on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NetAddressDecodeErrorZ {
   /**
    * The contents of this CResult_NetAddressDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NetAddressDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NetAddressDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NetAddressDecodeErrorZ;



/**
 * An update_add_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateAddHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateAddHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateAddHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateAddHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateAddHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateAddHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateAddHTLCZ;



/**
 * An update_fulfill_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFulfillHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFulfillHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFulfillHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFulfillHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFulfillHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFulfillHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFulfillHTLCZ;



/**
 * An update_fail_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFailHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFailHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFailHTLCZ;



/**
 * An update_fail_malformed_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailMalformedHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailMalformedHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailMalformedHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailMalformedHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFailMalformedHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFailMalformedHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFailMalformedHTLCZ;

/**
 * The contents of CResult_AcceptChannelDecodeErrorZ
 */
typedef union LDKCResult_AcceptChannelDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAcceptChannel *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AcceptChannelDecodeErrorZPtr;

/**
 * A CResult_AcceptChannelDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AcceptChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AcceptChannelDecodeErrorZ {
   /**
    * The contents of this CResult_AcceptChannelDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AcceptChannelDecodeErrorZPtr contents;
   /**
    * Whether this CResult_AcceptChannelDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AcceptChannelDecodeErrorZ;

/**
 * The contents of CResult_AnnouncementSignaturesDecodeErrorZ
 */
typedef union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAnnouncementSignatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AnnouncementSignaturesDecodeErrorZPtr;

/**
 * A CResult_AnnouncementSignaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AnnouncementSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AnnouncementSignaturesDecodeErrorZ {
   /**
    * The contents of this CResult_AnnouncementSignaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_AnnouncementSignaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AnnouncementSignaturesDecodeErrorZ;

/**
 * The contents of CResult_ChannelReestablishDecodeErrorZ
 */
typedef union LDKCResult_ChannelReestablishDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelReestablish *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelReestablishDecodeErrorZPtr;

/**
 * A CResult_ChannelReestablishDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelReestablish on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelReestablishDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelReestablishDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelReestablishDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelReestablishDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelReestablishDecodeErrorZ;

/**
 * The contents of CResult_ClosingSignedDecodeErrorZ
 */
typedef union LDKCResult_ClosingSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKClosingSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ClosingSignedDecodeErrorZPtr;

/**
 * A CResult_ClosingSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ClosingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ClosingSignedDecodeErrorZ {
   /**
    * The contents of this CResult_ClosingSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ClosingSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ClosingSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ClosingSignedDecodeErrorZ;



/**
 * A commitment_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKCommitmentSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentSigned;

/**
 * The contents of CResult_CommitmentSignedDecodeErrorZ
 */
typedef union LDKCResult_CommitmentSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCommitmentSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CommitmentSignedDecodeErrorZPtr;

/**
 * A CResult_CommitmentSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::CommitmentSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CommitmentSignedDecodeErrorZ {
   /**
    * The contents of this CResult_CommitmentSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CommitmentSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CommitmentSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CommitmentSignedDecodeErrorZ;

/**
 * The contents of CResult_FundingCreatedDecodeErrorZ
 */
typedef union LDKCResult_FundingCreatedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingCreated *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingCreatedDecodeErrorZPtr;

/**
 * A CResult_FundingCreatedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingCreated on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingCreatedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingCreatedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingCreatedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingCreatedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingCreatedDecodeErrorZ;

/**
 * The contents of CResult_FundingSignedDecodeErrorZ
 */
typedef union LDKCResult_FundingSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingSignedDecodeErrorZPtr;

/**
 * A CResult_FundingSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingSignedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingSignedDecodeErrorZ;

/**
 * The contents of CResult_FundingLockedDecodeErrorZ
 */
typedef union LDKCResult_FundingLockedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingLocked *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingLockedDecodeErrorZPtr;

/**
 * A CResult_FundingLockedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingLocked on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingLockedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingLockedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingLockedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingLockedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingLockedDecodeErrorZ;



/**
 * An init message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKInit {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInit *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInit;

/**
 * The contents of CResult_InitDecodeErrorZ
 */
typedef union LDKCResult_InitDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInit *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InitDecodeErrorZPtr;

/**
 * A CResult_InitDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Init on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InitDecodeErrorZ {
   /**
    * The contents of this CResult_InitDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InitDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InitDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InitDecodeErrorZ;

/**
 * The contents of CResult_OpenChannelDecodeErrorZ
 */
typedef union LDKCResult_OpenChannelDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOpenChannel *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OpenChannelDecodeErrorZPtr;

/**
 * A CResult_OpenChannelDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::OpenChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OpenChannelDecodeErrorZ {
   /**
    * The contents of this CResult_OpenChannelDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OpenChannelDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OpenChannelDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OpenChannelDecodeErrorZ;

/**
 * The contents of CResult_RevokeAndACKDecodeErrorZ
 */
typedef union LDKCResult_RevokeAndACKDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRevokeAndACK *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RevokeAndACKDecodeErrorZPtr;

/**
 * A CResult_RevokeAndACKDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::RevokeAndACK on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RevokeAndACKDecodeErrorZ {
   /**
    * The contents of this CResult_RevokeAndACKDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RevokeAndACKDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RevokeAndACKDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RevokeAndACKDecodeErrorZ;

/**
 * The contents of CResult_ShutdownDecodeErrorZ
 */
typedef union LDKCResult_ShutdownDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdown *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ShutdownDecodeErrorZPtr;

/**
 * A CResult_ShutdownDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Shutdown on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownDecodeErrorZ {
   /**
    * The contents of this CResult_ShutdownDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ShutdownDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownDecodeErrorZ;

/**
 * The contents of CResult_UpdateFailHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFailHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFailHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFailHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFailHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFailHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFailHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFailHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFailHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFailHTLCDecodeErrorZ;

/**
 * The contents of CResult_UpdateFailMalformedHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFailMalformedHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFailMalformedHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFailMalformedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFailMalformedHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFailMalformedHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ;



/**
 * An update_fee message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFee {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFee *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFee;

/**
 * The contents of CResult_UpdateFeeDecodeErrorZ
 */
typedef union LDKCResult_UpdateFeeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFee *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFeeDecodeErrorZPtr;

/**
 * A CResult_UpdateFeeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFee on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFeeDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFeeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFeeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFeeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFeeDecodeErrorZ;

/**
 * The contents of CResult_UpdateFulfillHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFulfillHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFulfillHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFulfillHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFulfillHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFulfillHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZ;

/**
 * The contents of CResult_UpdateAddHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateAddHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateAddHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateAddHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateAddHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateAddHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateAddHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateAddHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateAddHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateAddHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateAddHTLCDecodeErrorZ;



/**
 * A ping message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKPing {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePing *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPing;

/**
 * The contents of CResult_PingDecodeErrorZ
 */
typedef union LDKCResult_PingDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPing *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PingDecodeErrorZPtr;

/**
 * A CResult_PingDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Ping on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PingDecodeErrorZ {
   /**
    * The contents of this CResult_PingDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PingDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PingDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PingDecodeErrorZ;



/**
 * A pong message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKPong {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePong *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPong;

/**
 * The contents of CResult_PongDecodeErrorZ
 */
typedef union LDKCResult_PongDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPong *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PongDecodeErrorZPtr;

/**
 * A CResult_PongDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Pong on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PongDecodeErrorZ {
   /**
    * The contents of this CResult_PongDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PongDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PongDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PongDecodeErrorZ;

/**
 * The contents of CResult_UnsignedChannelAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedChannelAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr;

/**
 * A CResult_UnsignedChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedChannelAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedChannelAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_ChannelAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_ChannelAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelAnnouncementDecodeErrorZPtr;

/**
 * A CResult_ChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelAnnouncementDecodeErrorZ;



/**
 * The unsigned part of a channel_update
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelUpdate;

/**
 * The contents of CResult_UnsignedChannelUpdateDecodeErrorZ
 */
typedef union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedChannelUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr;

/**
 * A CResult_UnsignedChannelUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedChannelUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedChannelUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZ;

/**
 * The contents of CResult_ChannelUpdateDecodeErrorZ
 */
typedef union LDKCResult_ChannelUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelUpdateDecodeErrorZPtr;

/**
 * A CResult_ChannelUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelUpdateDecodeErrorZ;

/**
 * The contents of CResult_ErrorMessageDecodeErrorZ
 */
typedef union LDKCResult_ErrorMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKErrorMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ErrorMessageDecodeErrorZPtr;

/**
 * A CResult_ErrorMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ErrorMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ErrorMessageDecodeErrorZ {
   /**
    * The contents of this CResult_ErrorMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ErrorMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ErrorMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ErrorMessageDecodeErrorZ;



/**
 * The unsigned part of a node_announcement
 */
typedef struct MUST_USE_STRUCT LDKUnsignedNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedNodeAnnouncement;

/**
 * The contents of CResult_UnsignedNodeAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedNodeAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr;

/**
 * A CResult_UnsignedNodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedNodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedNodeAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedNodeAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_NodeAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_NodeAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementDecodeErrorZPtr;

/**
 * A CResult_NodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::NodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_QueryShortChannelIdsDecodeErrorZ
 */
typedef union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKQueryShortChannelIds *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_QueryShortChannelIdsDecodeErrorZPtr;

/**
 * A CResult_QueryShortChannelIdsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::QueryShortChannelIds on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_QueryShortChannelIdsDecodeErrorZ {
   /**
    * The contents of this CResult_QueryShortChannelIdsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_QueryShortChannelIdsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_QueryShortChannelIdsDecodeErrorZ;



/**
 * A reply_short_channel_ids_end message is sent as a reply to a
 * query_short_channel_ids message. The query recipient makes a best
 * effort to respond based on their local network view which may not be
 * a perfect view of the network.
 */
typedef struct MUST_USE_STRUCT LDKReplyShortChannelIdsEnd {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyShortChannelIdsEnd *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyShortChannelIdsEnd;

/**
 * The contents of CResult_ReplyShortChannelIdsEndDecodeErrorZ
 */
typedef union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReplyShortChannelIdsEnd *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr;

/**
 * A CResult_ReplyShortChannelIdsEndDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ReplyShortChannelIdsEnd on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ {
   /**
    * The contents of this CResult_ReplyShortChannelIdsEndDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReplyShortChannelIdsEndDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ;

/**
 * The contents of CResult_QueryChannelRangeDecodeErrorZ
 */
typedef union LDKCResult_QueryChannelRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKQueryChannelRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_QueryChannelRangeDecodeErrorZPtr;

/**
 * A CResult_QueryChannelRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::QueryChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_QueryChannelRangeDecodeErrorZ {
   /**
    * The contents of this CResult_QueryChannelRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_QueryChannelRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_QueryChannelRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_QueryChannelRangeDecodeErrorZ;

/**
 * The contents of CResult_ReplyChannelRangeDecodeErrorZ
 */
typedef union LDKCResult_ReplyChannelRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReplyChannelRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReplyChannelRangeDecodeErrorZPtr;

/**
 * A CResult_ReplyChannelRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ReplyChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReplyChannelRangeDecodeErrorZ {
   /**
    * The contents of this CResult_ReplyChannelRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReplyChannelRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReplyChannelRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReplyChannelRangeDecodeErrorZ;



/**
 * A gossip_timestamp_filter message is used by a node to request
 * gossip relay for messages in the requested time range when the
 * gossip_queries feature has been negotiated.
 */
typedef struct MUST_USE_STRUCT LDKGossipTimestampFilter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeGossipTimestampFilter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKGossipTimestampFilter;

/**
 * The contents of CResult_GossipTimestampFilterDecodeErrorZ
 */
typedef union LDKCResult_GossipTimestampFilterDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKGossipTimestampFilter *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_GossipTimestampFilterDecodeErrorZPtr;

/**
 * A CResult_GossipTimestampFilterDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::GossipTimestampFilter on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_GossipTimestampFilterDecodeErrorZ {
   /**
    * The contents of this CResult_GossipTimestampFilterDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_GossipTimestampFilterDecodeErrorZPtr contents;
   /**
    * Whether this CResult_GossipTimestampFilterDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_GossipTimestampFilterDecodeErrorZ;

/**
 * When signing using a fallible method either an user-supplied `SignError` or a `CreationError`
 * may occur.
 */
typedef enum LDKSignOrCreationError_Tag {
   /**
    * An error occurred during signing
    */
   LDKSignOrCreationError_SignError,
   /**
    * An error occurred while building the transaction
    */
   LDKSignOrCreationError_CreationError,
   /**
    * Must be last for serialization purposes
    */
   LDKSignOrCreationError_Sentinel,
} LDKSignOrCreationError_Tag;

typedef struct MUST_USE_STRUCT LDKSignOrCreationError {
   LDKSignOrCreationError_Tag tag;
   union {
      struct {
         enum LDKCreationError creation_error;
      };
   };
} LDKSignOrCreationError;

/**
 * The contents of CResult_InvoiceSignOrCreationErrorZ
 */
typedef union LDKCResult_InvoiceSignOrCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKSignOrCreationError *err;
} LDKCResult_InvoiceSignOrCreationErrorZPtr;

/**
 * A CResult_InvoiceSignOrCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::SignOrCreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceSignOrCreationErrorZ {
   /**
    * The contents of this CResult_InvoiceSignOrCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceSignOrCreationErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceSignOrCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceSignOrCreationErrorZ;

/**
 * A trait indicating an object may generate message send events
 */
typedef struct LDKMessageSendEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the list of pending events which were generated by previous actions, clearing the list
    * in the process.
    */
   struct LDKCVec_MessageSendEventZ (*get_and_clear_pending_msg_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKMessageSendEventsProvider;

/**
 * A trait implemented for objects handling events from [`EventsProvider`].
 */
typedef struct LDKEventHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handles the given [`Event`].
    *
    * See [`EventsProvider`] for details that must be considered when implementing this method.
    */
   void (*handle_event)(const void *this_arg, struct LDKEvent event);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventHandler;

/**
 * A trait indicating an object may generate events.
 *
 * Events are processed by passing an [`EventHandler`] to [`process_pending_events`].
 *
 * # Requirements
 *
 * See [`process_pending_events`] for requirements around event processing.
 *
 * When using this trait, [`process_pending_events`] will call [`handle_event`] for each pending
 * event since the last invocation. The handler must either act upon the event immediately
 * or preserve it for later handling.
 *
 * Note, handlers may call back into the provider and thus deadlocking must be avoided. Be sure to
 * consult the provider's documentation on the implication of processing events and how a handler
 * may safely use the provider (e.g., see [`ChannelManager::process_pending_events`] and
 * [`ChainMonitor::process_pending_events`]).
 *
 * (C-not implementable) As there is likely no reason for a user to implement this trait on their
 * own type(s).
 *
 * [`process_pending_events`]: Self::process_pending_events
 * [`handle_event`]: EventHandler::handle_event
 * [`ChannelManager::process_pending_events`]: crate::ln::channelmanager::ChannelManager#method.process_pending_events
 * [`ChainMonitor::process_pending_events`]: crate::chain::chainmonitor::ChainMonitor#method.process_pending_events
 */
typedef struct LDKEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Processes any events generated since the last call using the given event handler.
    *
    * Subsequent calls must only process new events. However, handlers must be capable of handling
    * duplicate events across process restarts. This may occur if the provider was recovered from
    * an old state (i.e., it hadn't been successfully persisted after processing pending events).
    */
   void (*process_pending_events)(const void *this_arg, struct LDKEventHandler handler);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventsProvider;



/**
 * Configuration we set when applicable.
 *
 * Default::default() provides sane defaults.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeConfig;



/**
 * Optional channel limits which are applied during channel creation.
 *
 * These limits are only applied to our counterparty's limits, not our own.
 *
 * Use 0/<type>::max_value() as appropriate to skip checking.
 *
 * Provides sane defaults for most configurations.
 *
 * Most additional limits are disabled except those with which specify a default in individual
 * field documentation. Note that this may result in barely-usable channels, but since they
 * are applied mostly only to incoming channels that's not much of a problem.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeLimits {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeLimits *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeLimits;



/**
 * Top-level config which holds ChannelHandshakeLimits and ChannelConfig.
 *
 * Default::default() provides sane defaults for most configurations
 * (but currently with 0 relay fees!)
 */
typedef struct MUST_USE_STRUCT LDKUserConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUserConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUserConfig;



/**
 * The best known block as identified by its hash and height.
 */
typedef struct MUST_USE_STRUCT LDKBestBlock {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBestBlock *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBestBlock;

/**
 * The `Access` trait defines behavior for accessing chain data and state, such as blocks and
 * UTXOs.
 */
typedef struct LDKAccess {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the transaction output of a funding transaction encoded by [`short_channel_id`].
    * Returns an error if `genesis_hash` is for a different chain or if such a transaction output
    * is unknown.
    *
    * [`short_channel_id`]: https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#definition-of-short_channel_id
    */
   struct LDKCResult_TxOutAccessErrorZ (*get_utxo)(const void *this_arg, const uint8_t (*genesis_hash)[32], uint64_t short_channel_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKAccess;

/**
 * The `Listen` trait is used to notify when blocks have been connected or disconnected from the
 * chain.
 *
 * Useful when needing to replay chain data upon startup or as new chain events occur. Clients
 * sourcing chain data using a block-oriented API should prefer this interface over [`Confirm`].
 * Such clients fetch the entire header chain whereas clients using [`Confirm`] only fetch headers
 * when needed.
 */
typedef struct LDKListen {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Notifies the listener that a block was added at the given height.
    */
   void (*block_connected)(const void *this_arg, struct LDKu8slice block, uint32_t height);
   /**
    * Notifies the listener that a block was removed at the given height.
    */
   void (*block_disconnected)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKListen;

/**
 * The `Confirm` trait is used to notify when transactions have been confirmed on chain or
 * unconfirmed during a chain reorganization.
 *
 * Clients sourcing chain data using a transaction-oriented API should prefer this interface over
 * [`Listen`]. For instance, an Electrum client may implement [`Filter`] by subscribing to activity
 * related to registered transactions and outputs. Upon notification, it would pass along the
 * matching transactions using this interface.
 *
 * # Use
 *
 * The intended use is as follows:
 * - Call [`transactions_confirmed`] to process any on-chain activity of interest.
 * - Call [`transaction_unconfirmed`] to process any transaction returned by [`get_relevant_txids`]
 *   that has been reorganized out of the chain.
 * - Call [`best_block_updated`] whenever a new chain tip becomes available.
 *
 * # Order
 *
 * Clients must call these methods in chain order. Specifically:
 * - Transactions confirmed in a block must be given before transactions confirmed in a later
 *   block.
 * - Dependent transactions within the same block must be given in topological order, possibly in
 *   separate calls.
 * - Unconfirmed transactions must be given after the original confirmations and before any
 *   reconfirmation.
 *
 * See individual method documentation for further details.
 *
 * [`transactions_confirmed`]: Self::transactions_confirmed
 * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
 * [`best_block_updated`]: Self::best_block_updated
 * [`get_relevant_txids`]: Self::get_relevant_txids
 */
typedef struct LDKConfirm {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Processes transactions confirmed in a block with a given header and height.
    *
    * Should be called for any transactions registered by [`Filter::register_tx`] or any
    * transactions spending an output registered by [`Filter::register_output`]. Such transactions
    * appearing in the same block do not need to be included in the same call; instead, multiple
    * calls with additional transactions may be made so long as they are made in [chain order].
    *
    * May be called before or after [`best_block_updated`] for the corresponding block. However,
    * in the event of a chain reorganization, it must not be called with a `header` that is no
    * longer in the chain as of the last call to [`best_block_updated`].
    *
    * [chain order]: Confirm#Order
    * [`best_block_updated`]: Self::best_block_updated
    */
   void (*transactions_confirmed)(const void *this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height);
   /**
    * Processes a transaction that is no longer confirmed as result of a chain reorganization.
    *
    * Should be called for any transaction returned by [`get_relevant_txids`] if it has been
    * reorganized out of the best chain. Once called, the given transaction should not be returned
    * by [`get_relevant_txids`] unless it has been reconfirmed via [`transactions_confirmed`].
    *
    * [`get_relevant_txids`]: Self::get_relevant_txids
    * [`transactions_confirmed`]: Self::transactions_confirmed
    */
   void (*transaction_unconfirmed)(const void *this_arg, const uint8_t (*txid)[32]);
   /**
    * Processes an update to the best header connected at the given height.
    *
    * Should be called when a new header is available but may be skipped for intermediary blocks
    * if they become available at the same time.
    */
   void (*best_block_updated)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Returns transactions that should be monitored for reorganization out of the chain.
    *
    * Should include any transactions passed to [`transactions_confirmed`] that have insufficient
    * confirmations to be safe from a chain reorganization. Should not include any transactions
    * passed to [`transaction_unconfirmed`] unless later reconfirmed.
    *
    * May be called to determine the subset of transactions that must still be monitored for
    * reorganization. Will be idempotent between calls but may change as a result of calls to the
    * other interface methods. Thus, this is useful to determine which transactions may need to be
    * given to [`transaction_unconfirmed`].
    *
    * [`transactions_confirmed`]: Self::transactions_confirmed
    * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
    */
   struct LDKCVec_TxidZ (*get_relevant_txids)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKConfirm;



/**
 * A transaction output watched by a [`ChannelMonitor`] for spends on-chain.
 *
 * Used to convey to a [`Filter`] such an output with a given spending condition. Any transaction
 * spending the output must be given to [`ChannelMonitor::block_connected`] either directly or via
 * the return value of [`Filter::register_output`].
 *
 * If `block_hash` is `Some`, this indicates the output was created in the corresponding block and
 * may have been spent there. See [`Filter::register_output`] for details.
 *
 * [`ChannelMonitor`]: channelmonitor::ChannelMonitor
 * [`ChannelMonitor::block_connected`]: channelmonitor::ChannelMonitor::block_connected
 */
typedef struct MUST_USE_STRUCT LDKWatchedOutput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeWatchedOutput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKWatchedOutput;

/**
 * The `Filter` trait defines behavior for indicating chain activity of interest pertaining to
 * channels.
 *
 * This is useful in order to have a [`Watch`] implementation convey to a chain source which
 * transactions to be notified of. Notification may take the form of pre-filtering blocks or, in
 * the case of [BIP 157]/[BIP 158], only fetching a block if the compact filter matches. If
 * receiving full blocks from a chain source, any further filtering is unnecessary.
 *
 * After an output has been registered, subsequent block retrievals from the chain source must not
 * exclude any transactions matching the new criteria nor any in-block descendants of such
 * transactions.
 *
 * Note that use as part of a [`Watch`] implementation involves reentrancy. Therefore, the `Filter`
 * should not block on I/O. Implementations should instead queue the newly monitored data to be
 * processed later. Then, in order to block until the data has been processed, any [`Watch`]
 * invocation that has called the `Filter` must return [`TemporaryFailure`].
 *
 * [`TemporaryFailure`]: channelmonitor::ChannelMonitorUpdateErr::TemporaryFailure
 * [BIP 157]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
 * [BIP 158]: https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
 */
typedef struct LDKFilter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Registers interest in a transaction with `txid` and having an output with `script_pubkey` as
    * a spending condition.
    */
   void (*register_tx)(const void *this_arg, const uint8_t (*txid)[32], struct LDKu8slice script_pubkey);
   /**
    * Registers interest in spends of a transaction output.
    *
    * Optionally, when `output.block_hash` is set, should return any transaction spending the
    * output that is found in the corresponding block along with its index.
    *
    * This return value is useful for Electrum clients in order to supply in-block descendant
    * transactions which otherwise were not included. This is not necessary for other clients if
    * such descendant transactions were already included (e.g., when a BIP 157 client provides the
    * full block).
    */
   struct LDKCOption_C2Tuple_usizeTransactionZZ (*register_output)(const void *this_arg, struct LDKWatchedOutput output);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFilter;

/**
 * `Persist` defines behavior for persisting channel monitors: this could mean
 * writing once to disk, and/or uploading to one or more backup services.
 *
 * Note that for every new monitor, you **must** persist the new `ChannelMonitor`
 * to disk/backups. And, on every update, you **must** persist either the
 * `ChannelMonitorUpdate` or the updated monitor itself. Otherwise, there is risk
 * of situations such as revoking a transaction, then crashing before this
 * revocation can be persisted, then unintentionally broadcasting a revoked
 * transaction and losing money. This is a risk because previous channel states
 * are toxic, so it's important that whatever channel state is persisted is
 * kept up-to-date.
 */
typedef struct LDKPersist {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist a new channel's data. The data can be stored any way you want, but
    * the identifier provided by Rust-Lightning is the channel's outpoint (and
    * it is up to you to maintain a correct mapping between the outpoint and the
    * stored channel data). Note that you **must** persist every new monitor to
    * disk. See the `Persist` trait documentation for more details.
    *
    * See [`ChannelMonitor::write`] for writing out a `ChannelMonitor`,
    * and [`ChannelMonitorUpdateErr`] for requirements when returning errors.
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*persist_new_channel)(const void *this_arg, struct LDKOutPoint id, const struct LDKChannelMonitor *NONNULL_PTR data);
   /**
    * Update one channel's data. The provided `ChannelMonitor` has already
    * applied the given update.
    *
    * Note that on every update, you **must** persist either the
    * `ChannelMonitorUpdate` or the updated monitor itself to disk/backups. See
    * the `Persist` trait documentation for more details.
    *
    * If an implementer chooses to persist the updates only, they need to make
    * sure that all the updates are applied to the `ChannelMonitors` *before*
    * the set of channel monitors is given to the `ChannelManager`
    * deserialization routine. See [`ChannelMonitor::update_monitor`] for
    * applying a monitor update to a monitor. If full `ChannelMonitors` are
    * persisted, then there is no need to persist individual updates.
    *
    * Note that there could be a performance tradeoff between persisting complete
    * channel monitors on every update vs. persisting only updates and applying
    * them in batches. The size of each monitor grows `O(number of state updates)`
    * whereas updates are small and `O(1)`.
    *
    * See [`ChannelMonitor::write`] for writing out a `ChannelMonitor`,
    * [`ChannelMonitorUpdate::write`] for writing out an update, and
    * [`ChannelMonitorUpdateErr`] for requirements when returning errors.
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*update_persisted_channel)(const void *this_arg, struct LDKOutPoint id, const struct LDKChannelMonitorUpdate *NONNULL_PTR update, const struct LDKChannelMonitor *NONNULL_PTR data);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPersist;



/**
 * An implementation of [`chain::Watch`] for monitoring channels.
 *
 * Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
 * [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
 * or used independently to monitor channels remotely. See the [module-level documentation] for
 * details.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [module-level documentation]: crate::chain::chainmonitor
 */
typedef struct MUST_USE_STRUCT LDKChainMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainMonitor;



/**
 * Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key
 * and derives keys from that.
 *
 * Your node_id is seed/0'
 * ChannelMonitor closes may use seed/1'
 * Cooperative closes may use seed/2'
 * The two close keys may be needed to claim on-chain funds!
 */
typedef struct MUST_USE_STRUCT LDKKeysManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeKeysManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKKeysManager;



/**
 * Chain-related parameters used to construct a new `ChannelManager`.
 *
 * Typically, the block-specific parameters are derived from the best block hash for the network,
 * as a newly constructed `ChannelManager` will not have created any channels yet. These parameters
 * are not needed when deserializing a previously constructed `ChannelManager`.
 */
typedef struct MUST_USE_STRUCT LDKChainParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainParameters;



/**
 * Channel parameters which apply to our counterparty. These are split out from [`ChannelDetails`]
 * to better separate parameters.
 */
typedef struct MUST_USE_STRUCT LDKChannelCounterparty {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelCounterparty *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelCounterparty;

/**
 * A 3-byte byte array.
 */
typedef struct LDKThreeBytes {
   /**
    * The three bytes
    */
   uint8_t data[3];
} LDKThreeBytes;

/**
 * A trait to describe an object which can receive channel messages.
 *
 * Messages MAY be called in parallel when they originate from different their_node_ids, however
 * they MUST NOT be called in parallel when the two calls have the same their_node_id.
 */
typedef struct LDKChannelMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming open_channel message from the given peer.
    */
   void (*handle_open_channel)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKOpenChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming accept_channel message from the given peer.
    */
   void (*handle_accept_channel)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKAcceptChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_created message from the given peer.
    */
   void (*handle_funding_created)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingCreated *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_signed message from the given peer.
    */
   void (*handle_funding_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_locked message from the given peer.
    */
   void (*handle_funding_locked)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingLocked *NONNULL_PTR msg);
   /**
    * Handle an incoming shutdown message from the given peer.
    */
   void (*handle_shutdown)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInitFeatures *NONNULL_PTR their_features, const struct LDKShutdown *NONNULL_PTR msg);
   /**
    * Handle an incoming closing_signed message from the given peer.
    */
   void (*handle_closing_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKClosingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming update_add_htlc message from the given peer.
    */
   void (*handle_update_add_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateAddHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fulfill_htlc message from the given peer.
    */
   void (*handle_update_fulfill_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFulfillHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fail_htlc message from the given peer.
    */
   void (*handle_update_fail_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fail_malformed_htlc message from the given peer.
    */
   void (*handle_update_fail_malformed_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming commitment_signed message from the given peer.
    */
   void (*handle_commitment_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKCommitmentSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming revoke_and_ack message from the given peer.
    */
   void (*handle_revoke_and_ack)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKRevokeAndACK *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fee message from the given peer.
    */
   void (*handle_update_fee)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFee *NONNULL_PTR msg);
   /**
    * Handle an incoming announcement_signatures message from the given peer.
    */
   void (*handle_announcement_signatures)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKAnnouncementSignatures *NONNULL_PTR msg);
   /**
    * Indicates a connection to the peer failed/an existing connection was lost. If no connection
    * is believed to be possible in the future (eg they're sending us messages we don't
    * understand or indicate they require unknown feature bits), no_connection_possible is set
    * and any outstanding channels should be failed.
    */
   void (*peer_disconnected)(const void *this_arg, struct LDKPublicKey their_node_id, bool no_connection_possible);
   /**
    * Handle a peer reconnecting, possibly generating channel_reestablish message(s).
    */
   void (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_reestablish message from the given peer.
    */
   void (*handle_channel_reestablish)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReestablish *NONNULL_PTR msg);
   /**
    * Handle an incoming channel update from the given peer.
    */
   void (*handle_channel_update)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Handle an incoming error message from the given peer.
    */
   void (*handle_error)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKErrorMessage *NONNULL_PTR msg);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKChannelMessageHandler;



/**
 * Arguments for the creation of a ChannelManager that are not deserialized.
 *
 * At a high-level, the process for deserializing a ChannelManager and resuming normal operation
 * is:
 * 1) Deserialize all stored ChannelMonitors.
 * 2) Deserialize the ChannelManager by filling in this struct and calling:
 *    <(BlockHash, ChannelManager)>::read(reader, args)
 *    This may result in closing some Channels if the ChannelMonitor is newer than the stored
 *    ChannelManager state to ensure no loss of funds. Thus, transactions may be broadcasted.
 * 3) If you are not fetching full blocks, register all relevant ChannelMonitor outpoints the same
 *    way you would handle a `chain::Filter` call using ChannelMonitor::get_outputs_to_watch() and
 *    ChannelMonitor::get_funding_txo().
 * 4) Reconnect blocks on your ChannelMonitors.
 * 5) Disconnect/connect blocks on the ChannelManager.
 * 6) Move the ChannelMonitors into your local chain::Watch.
 *
 * Note that the ordering of #4-6 is not of importance, however all three must occur before you
 * call any other methods on the newly-deserialized ChannelManager.
 *
 * Note that because some channels may be closed during deserialization, it is critical that you
 * always deserialize only the latest version of a ChannelManager and ChannelMonitors available to
 * you. If you deserialize an old ChannelManager (during which force-closure transactions may be
 * broadcast), and then later deserialize a newer version of the same ChannelManager (which will
 * not force-close the same channels but consider them live), you may end up revoking a state for
 * which you've already broadcasted the transaction.
 */
typedef struct MUST_USE_STRUCT LDKChannelManagerReadArgs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManagerReadArgs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManagerReadArgs;



/**
 * Proof that the sender knows the per-commitment secret of the previous commitment transaction.
 * This is used to convince the recipient that the channel is at a certain commitment
 * number even if they lost that data due to a local failure.  Of course, the peer may lie
 * and even later commitments may have been revoked.
 */
typedef struct MUST_USE_STRUCT LDKDataLossProtect {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDataLossProtect *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDataLossProtect;

/**
 * A trait to describe an object which can receive routing messages.
 *
 * # Implementor DoS Warnings
 *
 * For `gossip_queries` messages there are potential DoS vectors when handling
 * inbound queries. Implementors using an on-disk network graph should be aware of
 * repeated disk I/O for queries accessing different parts of the network graph.
 */
typedef struct LDKRoutingMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming node_announcement message, returning true if it should be forwarded on,
    * false or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_node_announcement)(const void *this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);
   /**
    * Handle a channel_announcement message, returning true if it should be forwarded on, false
    * or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_announcement)(const void *this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_update message, returning true if it should be forwarded on,
    * false or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_update)(const void *this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Handle some updates to the route graph that we learned due to an outbound failed payment.
    */
   void (*handle_htlc_fail_channel_update)(const void *this_arg, const struct LDKHTLCFailChannelUpdate *NONNULL_PTR update);
   /**
    * Gets a subset of the channel announcements and updates required to dump our routing table
    * to a remote node, starting at the short_channel_id indicated by starting_point and
    * including the batch_amount entries immediately higher in numerical value than starting_point.
    */
   struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ (*get_next_channel_announcements)(const void *this_arg, uint64_t starting_point, uint8_t batch_amount);
   /**
    * Gets a subset of the node announcements required to dump our routing table to a remote node,
    * starting at the node *after* the provided publickey and including batch_amount entries
    * immediately higher (as defined by <PublicKey as Ord>::cmp) than starting_point.
    * If None is provided for starting_point, we start at the first node.
    */
   struct LDKCVec_NodeAnnouncementZ (*get_next_node_announcements)(const void *this_arg, struct LDKPublicKey starting_point, uint8_t batch_amount);
   /**
    * Called when a connection is established with a peer. This can be used to
    * perform routing table synchronization using a strategy defined by the
    * implementor.
    */
   void (*sync_routing_table)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init);
   /**
    * Handles the reply of a query we initiated to learn about channels
    * for a given range of blocks. We can expect to receive one or more
    * replies to a single query.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyChannelRange msg);
   /**
    * Handles the reply of a query we initiated asking for routing gossip
    * messages for a list of channels. We should receive this message when
    * a node has completed its best effort to send us the pertaining routing
    * gossip messages.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_short_channel_ids_end)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyShortChannelIdsEnd msg);
   /**
    * Handles when a peer asks us to send a list of short_channel_ids
    * for the requested range of blocks.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryChannelRange msg);
   /**
    * Handles when a peer asks us to send routing gossip messages for a
    * list of short_channel_ids.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_short_channel_ids)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryShortChannelIds msg);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKRoutingMessageHandler;



/**
 * A dummy struct which implements `RoutingMessageHandler` without storing any routing information
 * or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKIgnoringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeIgnoringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKIgnoringMessageHandler;



/**
 * A dummy struct which implements `ChannelMessageHandler` without having any channels.
 * You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKErroringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErroringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErroringMessageHandler;



/**
 * Provides references to trait impls which handle different types of messages.
 */
typedef struct MUST_USE_STRUCT LDKMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMessageHandler;

/**
 * Provides an object which can be used to send data to and which uniquely identifies a connection
 * to a remote host. You will need to be able to generate multiple of these which meet Eq and
 * implement Hash to meet the PeerManager API.
 *
 * For efficiency, Clone should be relatively cheap for this type.
 *
 * Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
 * has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
 * having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
 * further calls to the [`PeerManager`] related to the original socket occur. This allows you to
 * use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
 * to simply use another value which is guaranteed to be globally unique instead.
 */
typedef struct LDKSocketDescriptor {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Attempts to send some data from the given slice to the peer.
    *
    * Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
    * Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
    * called and further write attempts may occur until that time.
    *
    * If the returned size is smaller than `data.len()`, a
    * [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
    * written. Additionally, until a `send_data` event completes fully, no further
    * [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
    * prevent denial-of-service issues, you should not read or buffer any data from the socket
    * until then.
    *
    * If a [`PeerManager::read_event`] call on this descriptor had previously returned true
    * (indicating that read events should be paused to prevent DoS in the send buffer),
    * `resume_read` may be set indicating that read events on this descriptor should resume. A
    * `resume_read` of false carries no meaning, and should not cause any action.
    */
   uintptr_t (*send_data)(void *this_arg, struct LDKu8slice data, bool resume_read);
   /**
    * Disconnect the socket pointed to by this SocketDescriptor.
    *
    * You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
    * call (doing so is a noop).
    */
   void (*disconnect_socket)(void *this_arg);
   /**
    * Checks if two objects are equal given this object's this_arg pointer and another object.
    */
   bool (*eq)(const void *this_arg, const struct LDKSocketDescriptor *NONNULL_PTR other_arg);
   /**
    * Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
    * This is used, for example, for inclusion of this object in a hash map.
    */
   uint64_t (*hash)(const void *this_arg);
   /**
    * Creates a copy of the object pointed to by this_arg, for a copy of this SocketDescriptor.
    * Note that the ultimate copy of the SocketDescriptor will have all function pointers the same as the original.
    * May be NULL if no action needs to be taken, the this_arg pointer will be copied into the new SocketDescriptor.
    */
   void *(*clone)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSocketDescriptor;



/**
 * A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
 * socket events into messages which it passes on to its [`MessageHandler`].
 *
 * Locks are taken internally, so you must never assume that reentrancy from a
 * [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
 *
 * Calls to [`read_event`] will decode relevant messages and pass them to the
 * [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
 * parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
 * [`PeerManager`] functions related to the same connection must occur only in serial, making new
 * calls only after previous ones have returned.
 *
 * Rather than using a plain PeerManager, it is preferable to use either a SimpleArcPeerManager
 * a SimpleRefPeerManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefPeerManager, and use a
 * SimpleArcPeerManager when you require a PeerManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 *
 * [`read_event`]: PeerManager::read_event
 */
typedef struct MUST_USE_STRUCT LDKPeerManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerManager;



/**
 * Static channel fields used to build transactions given per-commitment fields, organized by
 * broadcaster/countersignatory.
 *
 * This is derived from the holder/counterparty-organized ChannelTransactionParameters via the
 * as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKDirectedChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectedChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectedChannelTransactionParameters;



/**
 * A channel descriptor for a hop along a payment path.
 */
typedef struct MUST_USE_STRUCT LDKRouteHintHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHintHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHintHop;



/**
 * A simple newtype for RwLockReadGuard<'a, NetworkGraph>.
 * This exists only to make accessing a RwLock<NetworkGraph> possible from
 * the C bindings, as it can be done directly in Rust code.
 */
typedef struct MUST_USE_STRUCT LDKLockedNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLockedNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLockedNetworkGraph;



/**
 * Receives and validates network updates from peers,
 * stores authentic and relevant data as a network graph.
 * This network graph is then used for routing payments.
 * Provides interface to help with initial routing sync by
 * serving historical announcements.
 */
typedef struct MUST_USE_STRUCT LDKNetGraphMsgHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNetGraphMsgHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNetGraphMsgHandler;



/**
 * FilesystemPersister persists channel data on disk, where each channel's
 * data is stored in a file named after its funding outpoint.
 *
 * Warning: this module does the best it can with calls to persist data, but it
 * can only guarantee that the data is passed to the drive. It is up to the
 * drive manufacturers to do the actual persistence properly, which they often
 * don't (especially on consumer-grade hardware). Therefore, it is up to the
 * user to validate their entire storage stack, to ensure the writes are
 * persistent.
 * Corollary: especially when dealing with larger amounts of money, it is best
 * practice to have multiple channel data backups and not rely only on one
 * FilesystemPersister.
 */
typedef struct MUST_USE_STRUCT LDKFilesystemPersister {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFilesystemPersister *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFilesystemPersister;



/**
 * BackgroundProcessor takes care of tasks that (1) need to happen periodically to keep
 * Rust-Lightning running properly, and (2) either can or should be run in the background. Its
 * responsibilities are:
 * * Monitoring whether the ChannelManager needs to be re-persisted to disk, and if so,
 *   writing it to disk/backups by invoking the callback given to it at startup.
 *   ChannelManager persistence should be done in the background.
 * * Calling `ChannelManager::timer_tick_occurred()` and
 *   `PeerManager::timer_tick_occurred()` every minute (can be done in the
 *   background).
 *
 * Note that if ChannelManager persistence fails and the persisted manager becomes out-of-date,
 * then there is a risk of channels force-closing on startup when the manager realizes it's
 * outdated. However, as long as `ChannelMonitor` backups are sound, no funds besides those used
 * for unilateral chain closure fees are at risk.
 */
typedef struct MUST_USE_STRUCT LDKBackgroundProcessor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBackgroundProcessor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBackgroundProcessor;

/**
 * Trait which handles persisting a [`ChannelManager`] to disk.
 *
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 */
typedef struct LDKChannelManagerPersister {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist the given [`ChannelManager`] to disk, returning an error if persistence failed
    * (which will cause the [`BackgroundProcessor`] which called this method to exit.
    *
    * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
    */
   struct LDKCResult_NoneErrorZ (*persist_manager)(const void *this_arg, const struct LDKChannelManager *NONNULL_PTR channel_manager);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKChannelManagerPersister;



/**
 * Data of the `RawInvoice` that is encoded in the data part
 */
typedef struct MUST_USE_STRUCT LDKRawDataPart {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRawDataPart *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRawDataPart;



/**
 * SHA-256 hash
 */
typedef struct MUST_USE_STRUCT LDKSha256 {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSha256 *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSha256;



/**
 * `min_final_cltv_expiry` to use for the last HTLC in the route
 */
typedef struct MUST_USE_STRUCT LDKMinFinalCltvExpiry {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMinFinalCltvExpiry *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMinFinalCltvExpiry;

/**
 * Integer in the range `0..32`
 */
typedef struct LDKu5 {
   uint8_t _0;
} LDKu5;

/**
 * A 20-byte byte array.
 */
typedef struct LDKTwentyBytes {
   /**
    * The twenty bytes
    */
   uint8_t data[20];
} LDKTwentyBytes;

/**
 * Fallback address in case no LN payment is possible
 */
typedef enum LDKFallback_Tag {
   LDKFallback_SegWitProgram,
   LDKFallback_PubKeyHash,
   LDKFallback_ScriptHash,
   /**
    * Must be last for serialization purposes
    */
   LDKFallback_Sentinel,
} LDKFallback_Tag;

typedef struct LDKFallback_LDKSegWitProgram_Body {
   struct LDKu5 version;
   struct LDKCVec_u8Z program;
} LDKFallback_LDKSegWitProgram_Body;

typedef struct MUST_USE_STRUCT LDKFallback {
   LDKFallback_Tag tag;
   union {
      LDKFallback_LDKSegWitProgram_Body seg_wit_program;
      struct {
         struct LDKTwentyBytes pub_key_hash;
      };
      struct {
         struct LDKTwentyBytes script_hash;
      };
   };
} LDKFallback;

extern const uintptr_t MAX_BUF_SIZE;

extern const uint64_t MIN_RELAY_FEE_SAT_PER_1000_WEIGHT;

extern const uint64_t CLOSED_CHANNEL_UPDATE_ID;

extern const uint32_t ANTI_REORG_DELAY;

extern const uint16_t BREAKDOWN_TIMEOUT;

extern const uint16_t MIN_CLTV_EXPIRY_DELTA;

extern const uint32_t MIN_FINAL_CLTV_EXPIRY;

extern const uintptr_t REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH;

extern const uint64_t DEFAULT_EXPIRY_TIME;

extern const uint64_t DEFAULT_MIN_FINAL_CLTV_EXPIRY;

extern const uint8_t TAG_PAYMENT_HASH;

extern const uint8_t TAG_DESCRIPTION;

extern const uint8_t TAG_PAYEE_PUB_KEY;

extern const uint8_t TAG_DESCRIPTION_HASH;

extern const uint8_t TAG_EXPIRY_TIME;

extern const uint8_t TAG_MIN_FINAL_CLTV_EXPIRY;

extern const uint8_t TAG_FALLBACK;

extern const uint8_t TAG_PRIVATE_ROUTE;

extern const uint8_t TAG_PAYMENT_SECRET;

extern const uint8_t TAG_FEATURES;

struct LDKStr _ldk_get_compiled_version(void);

struct LDKStr _ldk_c_bindings_get_compiled_version(void);

/**
 * Frees the data buffer, if data_is_owned is set and datalen > 0.
 */
void Transaction_free(struct LDKTransaction _res);

/**
 * Frees the data pointed to by script_pubkey.
 */
void TxOut_free(struct LDKTxOut _res);

/**
 * Creates a new TxOut which has the same data as `orig` but with a new script buffer.
 */
struct LDKTxOut TxOut_clone(const struct LDKTxOut *NONNULL_PTR orig);

/**
 * Frees the data buffer, if chars_is_owned is set and len > 0.
 */
void Str_free(struct LDKStr _res);

/**
 * Creates a new CResult_SecretKeyErrorZ in the success state.
 */
struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_ok(struct LDKSecretKey o);

/**
 * Creates a new CResult_SecretKeyErrorZ in the error state.
 */
struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Frees any resources used by the CResult_SecretKeyErrorZ.
 */
void CResult_SecretKeyErrorZ_free(struct LDKCResult_SecretKeyErrorZ _res);

/**
 * Creates a new CResult_PublicKeyErrorZ in the success state.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_ok(struct LDKPublicKey o);

/**
 * Creates a new CResult_PublicKeyErrorZ in the error state.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Frees any resources used by the CResult_PublicKeyErrorZ.
 */
void CResult_PublicKeyErrorZ_free(struct LDKCResult_PublicKeyErrorZ _res);

/**
 * Creates a new CResult_PublicKeyErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_clone(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ in the success state.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(struct LDKTxCreationKeys o);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ in the error state.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_TxCreationKeysDecodeErrorZ.
 */
void CResult_TxCreationKeysDecodeErrorZ_free(struct LDKCResult_TxCreationKeysDecodeErrorZ _res);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_clone(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_ok(struct LDKChannelPublicKeys o);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelPublicKeysDecodeErrorZ.
 */
void CResult_ChannelPublicKeysDecodeErrorZ_free(struct LDKCResult_ChannelPublicKeysDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_clone(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxCreationKeysErrorZ in the success state.
 */
struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_ok(struct LDKTxCreationKeys o);

/**
 * Creates a new CResult_TxCreationKeysErrorZ in the error state.
 */
struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Frees any resources used by the CResult_TxCreationKeysErrorZ.
 */
void CResult_TxCreationKeysErrorZ_free(struct LDKCResult_TxCreationKeysErrorZ _res);

/**
 * Creates a new CResult_TxCreationKeysErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_clone(const struct LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_u32Z containing a u32
 */
struct LDKCOption_u32Z COption_u32Z_some(uint32_t o);

/**
 * Constructs a new COption_u32Z containing nothing
 */
struct LDKCOption_u32Z COption_u32Z_none(void);

/**
 * Frees any resources associated with the u32, if we are in the Some state
 */
void COption_u32Z_free(struct LDKCOption_u32Z _res);

/**
 * Creates a new COption_u32Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u32Z COption_u32Z_clone(const struct LDKCOption_u32Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(struct LDKHTLCOutputInCommitment o);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_HTLCOutputInCommitmentDecodeErrorZ.
 */
void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(struct LDKCounterpartyChannelTransactionParameters o);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_CounterpartyChannelTransactionParametersDecodeErrorZ.
 */
void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_ok(struct LDKChannelTransactionParameters o);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelTransactionParametersDecodeErrorZ.
 */
void CResult_ChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_ChannelTransactionParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_SignatureZ_free(struct LDKCVec_SignatureZ _res);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_ok(struct LDKHolderCommitmentTransaction o);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_HolderCommitmentTransactionDecodeErrorZ.
 */
void CResult_HolderCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(struct LDKBuiltCommitmentTransaction o);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_BuiltCommitmentTransactionDecodeErrorZ.
 */
void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_ok(struct LDKCommitmentTransaction o);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_CommitmentTransactionDecodeErrorZ.
 */
void CResult_CommitmentTransactionDecodeErrorZ_free(struct LDKCResult_CommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the success state.
 */
struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_ok(struct LDKTrustedCommitmentTransaction o);

/**
 * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the error state.
 */
struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_err(void);

/**
 * Frees any resources used by the CResult_TrustedCommitmentTransactionNoneZ.
 */
void CResult_TrustedCommitmentTransactionNoneZ_free(struct LDKCResult_TrustedCommitmentTransactionNoneZ _res);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ in the success state.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_ok(struct LDKCVec_SignatureZ o);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ in the error state.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_err(void);

/**
 * Frees any resources used by the CResult_CVec_SignatureZNoneZ.
 */
void CResult_CVec_SignatureZNoneZ_free(struct LDKCResult_CVec_SignatureZNoneZ _res);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_clone(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneErrorZ in the success state.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_ok(void);

/**
 * Creates a new CResult_NoneErrorZ in the error state.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_err(enum LDKIOError e);

/**
 * Frees any resources used by the CResult_NoneErrorZ.
 */
void CResult_NoneErrorZ_free(struct LDKCResult_NoneErrorZ _res);

/**
 * Creates a new CResult_NoneErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_clone(const struct LDKCResult_NoneErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_ok(struct LDKRouteHop o);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_RouteHopDecodeErrorZ.
 */
void CResult_RouteHopDecodeErrorZ_free(struct LDKCResult_RouteHopDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_clone(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHopZ_free(struct LDKCVec_RouteHopZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CVec_RouteHopZZ_free(struct LDKCVec_CVec_RouteHopZZ _res);

/**
 * Creates a new CResult_RouteDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(struct LDKRoute o);

/**
 * Creates a new CResult_RouteDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_RouteDecodeErrorZ.
 */
void CResult_RouteDecodeErrorZ_free(struct LDKCResult_RouteDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_u64Z containing a u64
 */
struct LDKCOption_u64Z COption_u64Z_some(uint64_t o);

/**
 * Constructs a new COption_u64Z containing nothing
 */
struct LDKCOption_u64Z COption_u64Z_none(void);

/**
 * Frees any resources associated with the u64, if we are in the Some state
 */
void COption_u64Z_free(struct LDKCOption_u64Z _res);

/**
 * Creates a new COption_u64Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u64Z COption_u64Z_clone(const struct LDKCOption_u64Z *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ChannelDetailsZ_free(struct LDKCVec_ChannelDetailsZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHintZ_free(struct LDKCVec_RouteHintZ _res);

/**
 * Creates a new CResult_RouteLightningErrorZ in the success state.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(struct LDKRoute o);

/**
 * Creates a new CResult_RouteLightningErrorZ in the error state.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(struct LDKLightningError e);

/**
 * Frees any resources used by the CResult_RouteLightningErrorZ.
 */
void CResult_RouteLightningErrorZ_free(struct LDKCResult_RouteLightningErrorZ _res);

/**
 * Creates a new CResult_RouteLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxOutAccessErrorZ in the success state.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_ok(struct LDKTxOut o);

/**
 * Creates a new CResult_TxOutAccessErrorZ in the error state.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_err(enum LDKAccessError e);

/**
 * Frees any resources used by the CResult_TxOutAccessErrorZ.
 */
void CResult_TxOutAccessErrorZ_free(struct LDKCResult_TxOutAccessErrorZ _res);

/**
 * Creates a new CResult_TxOutAccessErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_clone(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_clone(const struct LDKC2Tuple_usizeTransactionZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_usizeTransactionZ from the contained elements.
 */
struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(uintptr_t a, struct LDKTransaction b);

/**
 * Frees any resources used by the C2Tuple_usizeTransactionZ.
 */
void C2Tuple_usizeTransactionZ_free(struct LDKC2Tuple_usizeTransactionZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_usizeTransactionZZ_free(struct LDKCVec_C2Tuple_usizeTransactionZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TxidZ_free(struct LDKCVec_TxidZ _res);

/**
 * Creates a new CResult_NoneChannelMonitorUpdateErrZ in the success state.
 */
struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_ok(void);

/**
 * Creates a new CResult_NoneChannelMonitorUpdateErrZ in the error state.
 */
struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_err(enum LDKChannelMonitorUpdateErr e);

/**
 * Frees any resources used by the CResult_NoneChannelMonitorUpdateErrZ.
 */
void CResult_NoneChannelMonitorUpdateErrZ_free(struct LDKCResult_NoneChannelMonitorUpdateErrZ _res);

/**
 * Creates a new CResult_NoneChannelMonitorUpdateErrZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_clone(const struct LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MonitorEventZ_free(struct LDKCVec_MonitorEventZ _res);

/**
 * Constructs a new COption_C2Tuple_usizeTransactionZZ containing a crate::c_types::derived::C2Tuple_usizeTransactionZ
 */
struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_some(struct LDKC2Tuple_usizeTransactionZ o);

/**
 * Constructs a new COption_C2Tuple_usizeTransactionZZ containing nothing
 */
struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::C2Tuple_usizeTransactionZ, if we are in the Some state
 */
void COption_C2Tuple_usizeTransactionZZ_free(struct LDKCOption_C2Tuple_usizeTransactionZZ _res);

/**
 * Creates a new COption_C2Tuple_usizeTransactionZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_clone(const struct LDKCOption_C2Tuple_usizeTransactionZZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_SpendableOutputDescriptorZ_free(struct LDKCVec_SpendableOutputDescriptorZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MessageSendEventZ_free(struct LDKCVec_MessageSendEventZ _res);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(struct LDKInitFeatures o);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_InitFeaturesDecodeErrorZ.
 */
void CResult_InitFeaturesDecodeErrorZ_free(struct LDKCResult_InitFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(struct LDKNodeFeatures o);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_NodeFeaturesDecodeErrorZ.
 */
void CResult_NodeFeaturesDecodeErrorZ_free(struct LDKCResult_NodeFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(struct LDKChannelFeatures o);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelFeaturesDecodeErrorZ.
 */
void CResult_ChannelFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_ok(struct LDKInvoiceFeatures o);

/**
 * Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_InvoiceFeaturesDecodeErrorZ.
 */
void CResult_InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_InvoiceFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKDelayedPaymentOutputDescriptor o);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_DelayedPaymentOutputDescriptorDecodeErrorZ.
 */
void CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKStaticPaymentOutputDescriptor o);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_StaticPaymentOutputDescriptorDecodeErrorZ.
 */
void CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_ok(struct LDKSpendableOutputDescriptor o);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_SpendableOutputDescriptorDecodeErrorZ.
 */
void CResult_SpendableOutputDescriptorDecodeErrorZ_free(struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_clone(const struct LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_SignatureCVec_SignatureZZ from the contained elements.
 */
struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_new(struct LDKSignature a, struct LDKCVec_SignatureZ b);

/**
 * Frees any resources used by the C2Tuple_SignatureCVec_SignatureZZ.
 */
void C2Tuple_SignatureCVec_SignatureZZ_free(struct LDKC2Tuple_SignatureCVec_SignatureZZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(struct LDKC2Tuple_SignatureCVec_SignatureZZ o);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(void);

/**
 * Frees any resources used by the CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ.
 */
void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignatureNoneZ in the success state.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_ok(struct LDKSignature o);

/**
 * Creates a new CResult_SignatureNoneZ in the error state.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err(void);

/**
 * Frees any resources used by the CResult_SignatureNoneZ.
 */
void CResult_SignatureNoneZ_free(struct LDKCResult_SignatureNoneZ _res);

/**
 * Creates a new CResult_SignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_clone(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignDecodeErrorZ in the success state.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_ok(struct LDKSign o);

/**
 * Creates a new CResult_SignDecodeErrorZ in the error state.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_SignDecodeErrorZ.
 */
void CResult_SignDecodeErrorZ_free(struct LDKCResult_SignDecodeErrorZ _res);

/**
 * Creates a new CResult_SignDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_clone(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u8Z_free(struct LDKCVec_u8Z _res);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ in the success state.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_ok(struct LDKRecoverableSignature o);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ in the error state.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_err(void);

/**
 * Frees any resources used by the CResult_RecoverableSignatureNoneZ.
 */
void CResult_RecoverableSignatureNoneZ_free(struct LDKCResult_RecoverableSignatureNoneZ _res);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_clone(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CVec_u8ZZ_free(struct LDKCVec_CVec_u8ZZ _res);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the success state.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(struct LDKCVec_CVec_u8ZZ o);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the error state.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err(void);

/**
 * Frees any resources used by the CResult_CVec_CVec_u8ZZNoneZ.
 */
void CResult_CVec_CVec_u8ZZNoneZ_free(struct LDKCResult_CVec_CVec_u8ZZNoneZ _res);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ in the success state.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(struct LDKInMemorySigner o);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ in the error state.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_InMemorySignerDecodeErrorZ.
 */
void CResult_InMemorySignerDecodeErrorZ_free(struct LDKCResult_InMemorySignerDecodeErrorZ _res);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_clone(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TxOutZ_free(struct LDKCVec_TxOutZ _res);

/**
 * Creates a new CResult_TransactionNoneZ in the success state.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(struct LDKTransaction o);

/**
 * Creates a new CResult_TransactionNoneZ in the error state.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err(void);

/**
 * Frees any resources used by the CResult_TransactionNoneZ.
 */
void CResult_TransactionNoneZ_free(struct LDKCResult_TransactionNoneZ _res);

/**
 * Creates a new CResult_TransactionNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_clone(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_BlockHashChannelMonitorZ from the contained elements.
 */
struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelMonitor b);

/**
 * Frees any resources used by the C2Tuple_BlockHashChannelMonitorZ.
 */
void C2Tuple_BlockHashChannelMonitorZ_free(struct LDKC2Tuple_BlockHashChannelMonitorZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_BlockHashChannelMonitorZZ_free(struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ in the success state.
 */
struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_ok(struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ o);

/**
 * Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ in the error state.
 */
struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_err(enum LDKIOError e);

/**
 * Frees any resources used by the CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ.
 */
void CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_free(struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ _res);

/**
 * Constructs a new COption_u16Z containing a u16
 */
struct LDKCOption_u16Z COption_u16Z_some(uint16_t o);

/**
 * Constructs a new COption_u16Z containing nothing
 */
struct LDKCOption_u16Z COption_u16Z_none(void);

/**
 * Frees any resources associated with the u16, if we are in the Some state
 */
void COption_u16Z_free(struct LDKCOption_u16Z _res);

/**
 * Creates a new COption_u16Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u16Z COption_u16Z_clone(const struct LDKCOption_u16Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneAPIErrorZ in the success state.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok(void);

/**
 * Creates a new CResult_NoneAPIErrorZ in the error state.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(struct LDKAPIError e);

/**
 * Frees any resources used by the CResult_NoneAPIErrorZ.
 */
void CResult_NoneAPIErrorZ_free(struct LDKCResult_NoneAPIErrorZ _res);

/**
 * Creates a new CResult_NoneAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CResult_NoneAPIErrorZZ_free(struct LDKCVec_CResult_NoneAPIErrorZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_APIErrorZ_free(struct LDKCVec_APIErrorZ _res);

/**
 * Creates a new CResult_NonePaymentSendFailureZ in the success state.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok(void);

/**
 * Creates a new CResult_NonePaymentSendFailureZ in the error state.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Frees any resources used by the CResult_NonePaymentSendFailureZ.
 */
void CResult_NonePaymentSendFailureZ_free(struct LDKCResult_NonePaymentSendFailureZ _res);

/**
 * Creates a new CResult_NonePaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_NetAddressZ_free(struct LDKCVec_NetAddressZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_clone(const struct LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PaymentHashPaymentSecretZ from the contained elements.
 */
struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);

/**
 * Frees any resources used by the C2Tuple_PaymentHashPaymentSecretZ.
 */
void C2Tuple_PaymentHashPaymentSecretZ_free(struct LDKC2Tuple_PaymentHashPaymentSecretZ _res);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ in the success state.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ in the error state.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_err(struct LDKAPIError e);

/**
 * Frees any resources used by the CResult_PaymentSecretAPIErrorZ.
 */
void CResult_PaymentSecretAPIErrorZ_free(struct LDKCResult_PaymentSecretAPIErrorZ _res);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_clone(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ChannelMonitorZ_free(struct LDKCVec_ChannelMonitorZ _res);

/**
 * Creates a new C2Tuple_BlockHashChannelManagerZ from the contained elements.
 */
struct LDKC2Tuple_BlockHashChannelManagerZ C2Tuple_BlockHashChannelManagerZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelManager b);

/**
 * Frees any resources used by the C2Tuple_BlockHashChannelManagerZ.
 */
void C2Tuple_BlockHashChannelManagerZ_free(struct LDKC2Tuple_BlockHashChannelManagerZ _res);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelManagerZ o);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.
 */
void CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(struct LDKChannelConfig o);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelConfigDecodeErrorZ.
 */
void CResult_ChannelConfigDecodeErrorZ_free(struct LDKCResult_ChannelConfigDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OutPointDecodeErrorZ in the success state.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(struct LDKOutPoint o);

/**
 * Creates a new CResult_OutPointDecodeErrorZ in the error state.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_OutPointDecodeErrorZ.
 */
void CResult_OutPointDecodeErrorZ_free(struct LDKCResult_OutPointDecodeErrorZ _res);

/**
 * Creates a new CResult_OutPointDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SiPrefixNoneZ in the success state.
 */
struct LDKCResult_SiPrefixNoneZ CResult_SiPrefixNoneZ_ok(enum LDKSiPrefix o);

/**
 * Creates a new CResult_SiPrefixNoneZ in the error state.
 */
struct LDKCResult_SiPrefixNoneZ CResult_SiPrefixNoneZ_err(void);

/**
 * Frees any resources used by the CResult_SiPrefixNoneZ.
 */
void CResult_SiPrefixNoneZ_free(struct LDKCResult_SiPrefixNoneZ _res);

/**
 * Creates a new CResult_SiPrefixNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SiPrefixNoneZ CResult_SiPrefixNoneZ_clone(const struct LDKCResult_SiPrefixNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceNoneZ in the success state.
 */
struct LDKCResult_InvoiceNoneZ CResult_InvoiceNoneZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceNoneZ in the error state.
 */
struct LDKCResult_InvoiceNoneZ CResult_InvoiceNoneZ_err(void);

/**
 * Frees any resources used by the CResult_InvoiceNoneZ.
 */
void CResult_InvoiceNoneZ_free(struct LDKCResult_InvoiceNoneZ _res);

/**
 * Creates a new CResult_InvoiceNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceNoneZ CResult_InvoiceNoneZ_clone(const struct LDKCResult_InvoiceNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignedRawInvoiceNoneZ in the success state.
 */
struct LDKCResult_SignedRawInvoiceNoneZ CResult_SignedRawInvoiceNoneZ_ok(struct LDKSignedRawInvoice o);

/**
 * Creates a new CResult_SignedRawInvoiceNoneZ in the error state.
 */
struct LDKCResult_SignedRawInvoiceNoneZ CResult_SignedRawInvoiceNoneZ_err(void);

/**
 * Frees any resources used by the CResult_SignedRawInvoiceNoneZ.
 */
void CResult_SignedRawInvoiceNoneZ_free(struct LDKCResult_SignedRawInvoiceNoneZ _res);

/**
 * Creates a new CResult_SignedRawInvoiceNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignedRawInvoiceNoneZ CResult_SignedRawInvoiceNoneZ_clone(const struct LDKCResult_SignedRawInvoiceNoneZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(const struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_RawInvoice_u832InvoiceSignatureZ from the contained elements.
 */
struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(struct LDKRawInvoice a, struct LDKThirtyTwoBytes b, struct LDKInvoiceSignature c);

/**
 * Frees any resources used by the C3Tuple_RawInvoice_u832InvoiceSignatureZ.
 */
void C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ _res);

/**
 * Creates a new CResult_PayeePubKeyErrorZ in the success state.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_ok(struct LDKPayeePubKey o);

/**
 * Creates a new CResult_PayeePubKeyErrorZ in the error state.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Frees any resources used by the CResult_PayeePubKeyErrorZ.
 */
void CResult_PayeePubKeyErrorZ_free(struct LDKCResult_PayeePubKeyErrorZ _res);

/**
 * Creates a new CResult_PayeePubKeyErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_clone(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PrivateRouteZ_free(struct LDKCVec_PrivateRouteZ _res);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ in the success state.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_ok(struct LDKPositiveTimestamp o);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ in the error state.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_err(enum LDKCreationError e);

/**
 * Frees any resources used by the CResult_PositiveTimestampCreationErrorZ.
 */
void CResult_PositiveTimestampCreationErrorZ_free(struct LDKCResult_PositiveTimestampCreationErrorZ _res);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_clone(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneSemanticErrorZ in the success state.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_ok(void);

/**
 * Creates a new CResult_NoneSemanticErrorZ in the error state.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_err(enum LDKSemanticError e);

/**
 * Frees any resources used by the CResult_NoneSemanticErrorZ.
 */
void CResult_NoneSemanticErrorZ_free(struct LDKCResult_NoneSemanticErrorZ _res);

/**
 * Creates a new CResult_NoneSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_clone(const struct LDKCResult_NoneSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ in the success state.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ in the error state.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_err(enum LDKSemanticError e);

/**
 * Frees any resources used by the CResult_InvoiceSemanticErrorZ.
 */
void CResult_InvoiceSemanticErrorZ_free(struct LDKCResult_InvoiceSemanticErrorZ _res);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_clone(const struct LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_DescriptionCreationErrorZ in the success state.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_ok(struct LDKDescription o);

/**
 * Creates a new CResult_DescriptionCreationErrorZ in the error state.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_err(enum LDKCreationError e);

/**
 * Frees any resources used by the CResult_DescriptionCreationErrorZ.
 */
void CResult_DescriptionCreationErrorZ_free(struct LDKCResult_DescriptionCreationErrorZ _res);

/**
 * Creates a new CResult_DescriptionCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_clone(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ExpiryTimeCreationErrorZ in the success state.
 */
struct LDKCResult_ExpiryTimeCreationErrorZ CResult_ExpiryTimeCreationErrorZ_ok(struct LDKExpiryTime o);

/**
 * Creates a new CResult_ExpiryTimeCreationErrorZ in the error state.
 */
struct LDKCResult_ExpiryTimeCreationErrorZ CResult_ExpiryTimeCreationErrorZ_err(enum LDKCreationError e);

/**
 * Frees any resources used by the CResult_ExpiryTimeCreationErrorZ.
 */
void CResult_ExpiryTimeCreationErrorZ_free(struct LDKCResult_ExpiryTimeCreationErrorZ _res);

/**
 * Creates a new CResult_ExpiryTimeCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ExpiryTimeCreationErrorZ CResult_ExpiryTimeCreationErrorZ_clone(const struct LDKCResult_ExpiryTimeCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ in the success state.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_ok(struct LDKPrivateRoute o);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ in the error state.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_err(enum LDKCreationError e);

/**
 * Frees any resources used by the CResult_PrivateRouteCreationErrorZ.
 */
void CResult_PrivateRouteCreationErrorZ_free(struct LDKCResult_PrivateRouteCreationErrorZ _res);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_clone(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_StringErrorZ in the success state.
 */
struct LDKCResult_StringErrorZ CResult_StringErrorZ_ok(struct LDKStr o);

/**
 * Creates a new CResult_StringErrorZ in the error state.
 */
struct LDKCResult_StringErrorZ CResult_StringErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Frees any resources used by the CResult_StringErrorZ.
 */
void CResult_StringErrorZ_free(struct LDKCResult_StringErrorZ _res);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_ok(struct LDKChannelMonitorUpdate o);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelMonitorUpdateDecodeErrorZ.
 */
void CResult_ChannelMonitorUpdateDecodeErrorZ_free(struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(struct LDKHTLCUpdate o);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_HTLCUpdateDecodeErrorZ.
 */
void CResult_HTLCUpdateDecodeErrorZ_free(struct LDKCResult_HTLCUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneMonitorUpdateErrorZ in the success state.
 */
struct LDKCResult_NoneMonitorUpdateErrorZ CResult_NoneMonitorUpdateErrorZ_ok(void);

/**
 * Creates a new CResult_NoneMonitorUpdateErrorZ in the error state.
 */
struct LDKCResult_NoneMonitorUpdateErrorZ CResult_NoneMonitorUpdateErrorZ_err(struct LDKMonitorUpdateError e);

/**
 * Frees any resources used by the CResult_NoneMonitorUpdateErrorZ.
 */
void CResult_NoneMonitorUpdateErrorZ_free(struct LDKCResult_NoneMonitorUpdateErrorZ _res);

/**
 * Creates a new CResult_NoneMonitorUpdateErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneMonitorUpdateErrorZ CResult_NoneMonitorUpdateErrorZ_clone(const struct LDKCResult_NoneMonitorUpdateErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_clone(const struct LDKC2Tuple_OutPointScriptZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_OutPointScriptZ from the contained elements.
 */
struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_new(struct LDKOutPoint a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_OutPointScriptZ.
 */
void C2Tuple_OutPointScriptZ_free(struct LDKC2Tuple_OutPointScriptZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_clone(const struct LDKC2Tuple_u32ScriptZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u32ScriptZ from the contained elements.
 */
struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_new(uint32_t a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_u32ScriptZ.
 */
void C2Tuple_u32ScriptZ_free(struct LDKC2Tuple_u32ScriptZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u32ScriptZZ_free(struct LDKCVec_C2Tuple_u32ScriptZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ from the contained elements.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32ScriptZZ b);

/**
 * Frees any resources used by the C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ.
 */
void C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_EventZ_free(struct LDKCVec_EventZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TransactionZ_free(struct LDKCVec_TransactionZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(const struct LDKC2Tuple_u32TxOutZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u32TxOutZ from the contained elements.
 */
struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(uint32_t a, struct LDKTxOut b);

/**
 * Frees any resources used by the C2Tuple_u32TxOutZ.
 */
void C2Tuple_u32TxOutZ_free(struct LDKC2Tuple_u32TxOutZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u32TxOutZZ_free(struct LDKCVec_C2Tuple_u32TxOutZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ from the contained elements.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32TxOutZZ b);

/**
 * Frees any resources used by the C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ.
 */
void C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TransactionOutputsZ_free(struct LDKCVec_TransactionOutputsZ _res);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelMonitorZ o);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.
 */
void CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res);

/**
 * Creates a new CResult_boolLightningErrorZ in the success state.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(bool o);

/**
 * Creates a new CResult_boolLightningErrorZ in the error state.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(struct LDKLightningError e);

/**
 * Frees any resources used by the CResult_boolLightningErrorZ.
 */
void CResult_boolLightningErrorZ_free(struct LDKCResult_boolLightningErrorZ _res);

/**
 * Creates a new CResult_boolLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(const struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ from the contained elements.
 */
struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(struct LDKChannelAnnouncement a, struct LDKChannelUpdate b, struct LDKChannelUpdate c);

/**
 * Frees any resources used by the C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.
 */
void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_NodeAnnouncementZ_free(struct LDKCVec_NodeAnnouncementZ _res);

/**
 * Creates a new CResult_NoneLightningErrorZ in the success state.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok(void);

/**
 * Creates a new CResult_NoneLightningErrorZ in the error state.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(struct LDKLightningError e);

/**
 * Frees any resources used by the CResult_NoneLightningErrorZ.
 */
void CResult_NoneLightningErrorZ_free(struct LDKCResult_NoneLightningErrorZ _res);

/**
 * Creates a new CResult_NoneLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PublicKeyZ_free(struct LDKCVec_PublicKeyZ _res);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the success state.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(struct LDKCVec_u8Z o);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the error state.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Frees any resources used by the CResult_CVec_u8ZPeerHandleErrorZ.
 */
void CResult_CVec_u8ZPeerHandleErrorZ_free(struct LDKCResult_CVec_u8ZPeerHandleErrorZ _res);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NonePeerHandleErrorZ in the success state.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok(void);

/**
 * Creates a new CResult_NonePeerHandleErrorZ in the error state.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Frees any resources used by the CResult_NonePeerHandleErrorZ.
 */
void CResult_NonePeerHandleErrorZ_free(struct LDKCResult_NonePeerHandleErrorZ _res);

/**
 * Creates a new CResult_NonePeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_boolPeerHandleErrorZ in the success state.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(bool o);

/**
 * Creates a new CResult_boolPeerHandleErrorZ in the error state.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Frees any resources used by the CResult_boolPeerHandleErrorZ.
 */
void CResult_boolPeerHandleErrorZ_free(struct LDKCResult_boolPeerHandleErrorZ _res);

/**
 * Creates a new CResult_boolPeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_DirectionalChannelInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_ok(struct LDKDirectionalChannelInfo o);

/**
 * Creates a new CResult_DirectionalChannelInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_DirectionalChannelInfoDecodeErrorZ.
 */
void CResult_DirectionalChannelInfoDecodeErrorZ_free(struct LDKCResult_DirectionalChannelInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_DirectionalChannelInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_clone(const struct LDKCResult_DirectionalChannelInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(struct LDKChannelInfo o);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelInfoDecodeErrorZ.
 */
void CResult_ChannelInfoDecodeErrorZ_free(struct LDKCResult_ChannelInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ in the success state.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(struct LDKRoutingFees o);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ in the error state.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_RoutingFeesDecodeErrorZ.
 */
void CResult_RoutingFeesDecodeErrorZ_free(struct LDKCResult_RoutingFeesDecodeErrorZ _res);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_ok(struct LDKNodeAnnouncementInfo o);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_NodeAnnouncementInfoDecodeErrorZ.
 */
void CResult_NodeAnnouncementInfoDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u64Z_free(struct LDKCVec_u64Z _res);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(struct LDKNodeInfo o);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_NodeInfoDecodeErrorZ.
 */
void CResult_NodeInfoDecodeErrorZ_free(struct LDKCResult_NodeInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ in the success state.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(struct LDKNetworkGraph o);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ in the error state.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_NetworkGraphDecodeErrorZ.
 */
void CResult_NetworkGraphDecodeErrorZ_free(struct LDKCResult_NetworkGraphDecodeErrorZ _res);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_clone(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NetAddressu8Z in the success state.
 */
struct LDKCResult_NetAddressu8Z CResult_NetAddressu8Z_ok(struct LDKNetAddress o);

/**
 * Creates a new CResult_NetAddressu8Z in the error state.
 */
struct LDKCResult_NetAddressu8Z CResult_NetAddressu8Z_err(uint8_t e);

/**
 * Frees any resources used by the CResult_NetAddressu8Z.
 */
void CResult_NetAddressu8Z_free(struct LDKCResult_NetAddressu8Z _res);

/**
 * Creates a new CResult_NetAddressu8Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NetAddressu8Z CResult_NetAddressu8Z_clone(const struct LDKCResult_NetAddressu8Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_CResult_NetAddressu8ZDecodeErrorZ in the success state.
 */
struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ CResult_CResult_NetAddressu8ZDecodeErrorZ_ok(struct LDKCResult_NetAddressu8Z o);

/**
 * Creates a new CResult_CResult_NetAddressu8ZDecodeErrorZ in the error state.
 */
struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ CResult_CResult_NetAddressu8ZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_CResult_NetAddressu8ZDecodeErrorZ.
 */
void CResult_CResult_NetAddressu8ZDecodeErrorZ_free(struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ _res);

/**
 * Creates a new CResult_CResult_NetAddressu8ZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ CResult_CResult_NetAddressu8ZDecodeErrorZ_clone(const struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ in the success state.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_ok(struct LDKNetAddress o);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ in the error state.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_NetAddressDecodeErrorZ.
 */
void CResult_NetAddressDecodeErrorZ_free(struct LDKCResult_NetAddressDecodeErrorZ _res);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_clone(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateAddHTLCZ_free(struct LDKCVec_UpdateAddHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFulfillHTLCZ_free(struct LDKCVec_UpdateFulfillHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFailHTLCZ_free(struct LDKCVec_UpdateFailHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFailMalformedHTLCZ_free(struct LDKCVec_UpdateFailMalformedHTLCZ _res);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ in the success state.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(struct LDKAcceptChannel o);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ in the error state.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_AcceptChannelDecodeErrorZ.
 */
void CResult_AcceptChannelDecodeErrorZ_free(struct LDKCResult_AcceptChannelDecodeErrorZ _res);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_ok(struct LDKAnnouncementSignatures o);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_AnnouncementSignaturesDecodeErrorZ.
 */
void CResult_AnnouncementSignaturesDecodeErrorZ_free(struct LDKCResult_AnnouncementSignaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_clone(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_ok(struct LDKChannelReestablish o);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelReestablishDecodeErrorZ.
 */
void CResult_ChannelReestablishDecodeErrorZ_free(struct LDKCResult_ChannelReestablishDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_clone(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(struct LDKClosingSigned o);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ClosingSignedDecodeErrorZ.
 */
void CResult_ClosingSignedDecodeErrorZ_free(struct LDKCResult_ClosingSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_ok(struct LDKCommitmentSigned o);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_CommitmentSignedDecodeErrorZ.
 */
void CResult_CommitmentSignedDecodeErrorZ_free(struct LDKCResult_CommitmentSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_clone(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(struct LDKFundingCreated o);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_FundingCreatedDecodeErrorZ.
 */
void CResult_FundingCreatedDecodeErrorZ_free(struct LDKCResult_FundingCreatedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_clone(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(struct LDKFundingSigned o);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_FundingSignedDecodeErrorZ.
 */
void CResult_FundingSignedDecodeErrorZ_free(struct LDKCResult_FundingSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingLockedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_ok(struct LDKFundingLocked o);

/**
 * Creates a new CResult_FundingLockedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_FundingLockedDecodeErrorZ.
 */
void CResult_FundingLockedDecodeErrorZ_free(struct LDKCResult_FundingLockedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingLockedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_clone(const struct LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InitDecodeErrorZ in the success state.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(struct LDKInit o);

/**
 * Creates a new CResult_InitDecodeErrorZ in the error state.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_InitDecodeErrorZ.
 */
void CResult_InitDecodeErrorZ_free(struct LDKCResult_InitDecodeErrorZ _res);

/**
 * Creates a new CResult_InitDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ in the success state.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(struct LDKOpenChannel o);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ in the error state.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_OpenChannelDecodeErrorZ.
 */
void CResult_OpenChannelDecodeErrorZ_free(struct LDKCResult_OpenChannelDecodeErrorZ _res);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ in the success state.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(struct LDKRevokeAndACK o);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ in the error state.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_RevokeAndACKDecodeErrorZ.
 */
void CResult_RevokeAndACKDecodeErrorZ_free(struct LDKCResult_RevokeAndACKDecodeErrorZ _res);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ in the success state.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(struct LDKShutdown o);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ in the error state.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ShutdownDecodeErrorZ.
 */
void CResult_ShutdownDecodeErrorZ_free(struct LDKCResult_ShutdownDecodeErrorZ _res);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(struct LDKUpdateFailHTLC o);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_UpdateFailHTLCDecodeErrorZ.
 */
void CResult_UpdateFailHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(struct LDKUpdateFailMalformedHTLC o);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_UpdateFailMalformedHTLCDecodeErrorZ.
 */
void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(struct LDKUpdateFee o);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_UpdateFeeDecodeErrorZ.
 */
void CResult_UpdateFeeDecodeErrorZ_free(struct LDKCResult_UpdateFeeDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_ok(struct LDKUpdateFulfillHTLC o);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_UpdateFulfillHTLCDecodeErrorZ.
 */
void CResult_UpdateFulfillHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(struct LDKUpdateAddHTLC o);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_UpdateAddHTLCDecodeErrorZ.
 */
void CResult_UpdateAddHTLCDecodeErrorZ_free(struct LDKCResult_UpdateAddHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PingDecodeErrorZ in the success state.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(struct LDKPing o);

/**
 * Creates a new CResult_PingDecodeErrorZ in the error state.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_PingDecodeErrorZ.
 */
void CResult_PingDecodeErrorZ_free(struct LDKCResult_PingDecodeErrorZ _res);

/**
 * Creates a new CResult_PingDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PongDecodeErrorZ in the success state.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(struct LDKPong o);

/**
 * Creates a new CResult_PongDecodeErrorZ in the error state.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_PongDecodeErrorZ.
 */
void CResult_PongDecodeErrorZ_free(struct LDKCResult_PongDecodeErrorZ _res);

/**
 * Creates a new CResult_PongDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(struct LDKUnsignedChannelAnnouncement o);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_UnsignedChannelAnnouncementDecodeErrorZ.
 */
void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_ok(struct LDKChannelAnnouncement o);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelAnnouncementDecodeErrorZ.
 */
void CResult_ChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_ChannelAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_ok(struct LDKUnsignedChannelUpdate o);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_UnsignedChannelUpdateDecodeErrorZ.
 */
void CResult_UnsignedChannelUpdateDecodeErrorZ_free(struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(struct LDKChannelUpdate o);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ChannelUpdateDecodeErrorZ.
 */
void CResult_ChannelUpdateDecodeErrorZ_free(struct LDKCResult_ChannelUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(struct LDKErrorMessage o);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ErrorMessageDecodeErrorZ.
 */
void CResult_ErrorMessageDecodeErrorZ_free(struct LDKCResult_ErrorMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(struct LDKUnsignedNodeAnnouncement o);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_UnsignedNodeAnnouncementDecodeErrorZ.
 */
void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_ok(struct LDKNodeAnnouncement o);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_NodeAnnouncementDecodeErrorZ.
 */
void CResult_NodeAnnouncementDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the success state.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_ok(struct LDKQueryShortChannelIds o);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the error state.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_QueryShortChannelIdsDecodeErrorZ.
 */
void CResult_QueryShortChannelIdsDecodeErrorZ_free(struct LDKCResult_QueryShortChannelIdsDecodeErrorZ _res);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_clone(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the success state.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(struct LDKReplyShortChannelIdsEnd o);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the error state.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ReplyShortChannelIdsEndDecodeErrorZ.
 */
void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_ok(struct LDKQueryChannelRange o);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_QueryChannelRangeDecodeErrorZ.
 */
void CResult_QueryChannelRangeDecodeErrorZ_free(struct LDKCResult_QueryChannelRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_clone(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_ok(struct LDKReplyChannelRange o);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_ReplyChannelRangeDecodeErrorZ.
 */
void CResult_ReplyChannelRangeDecodeErrorZ_free(struct LDKCResult_ReplyChannelRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_clone(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the success state.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_ok(struct LDKGossipTimestampFilter o);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the error state.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Frees any resources used by the CResult_GossipTimestampFilterDecodeErrorZ.
 */
void CResult_GossipTimestampFilterDecodeErrorZ_free(struct LDKCResult_GossipTimestampFilterDecodeErrorZ _res);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_clone(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ in the success state.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ in the error state.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_err(struct LDKSignOrCreationError e);

/**
 * Frees any resources used by the CResult_InvoiceSignOrCreationErrorZ.
 */
void CResult_InvoiceSignOrCreationErrorZ_free(struct LDKCResult_InvoiceSignOrCreationErrorZ _res);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_clone(const struct LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR orig);

/**
 * Frees any resources used by the Event
 */
void Event_free(struct LDKEvent this_ptr);

/**
 * Creates a copy of the Event
 */
struct LDKEvent Event_clone(const struct LDKEvent *NONNULL_PTR orig);

/**
 * Serialize the Event object into a byte array which can be read by Event_read
 */
struct LDKCVec_u8Z Event_write(const struct LDKEvent *NONNULL_PTR obj);

/**
 * Frees any resources used by the MessageSendEvent
 */
void MessageSendEvent_free(struct LDKMessageSendEvent this_ptr);

/**
 * Creates a copy of the MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_clone(const struct LDKMessageSendEvent *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void MessageSendEventsProvider_free(struct LDKMessageSendEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventsProvider_free(struct LDKEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventHandler_free(struct LDKEventHandler this_ptr);

/**
 * Frees any resources used by the APIError
 */
void APIError_free(struct LDKAPIError this_ptr);

/**
 * Creates a copy of the APIError
 */
struct LDKAPIError APIError_clone(const struct LDKAPIError *NONNULL_PTR orig);

/**
 * Creates a digital signature of a message given a SecretKey, like the node's secret.
 * A receiver knowing the PublicKey (e.g. the node's id) and the message can be sure that the signature was generated by the caller.
 * Signatures are EC recoverable, meaning that given the message and the signature the PublicKey of the signer can be extracted.
 */
struct LDKCResult_StringErrorZ sign(struct LDKu8slice msg, const uint8_t (*sk)[32]);

/**
 * Recovers the PublicKey of the signer of the message given the message and the signature.
 */
struct LDKCResult_PublicKeyErrorZ recover_pk(struct LDKu8slice msg, struct LDKStr sig);

/**
 * Verifies a message was signed by a PrivateKey that derives to a given PublicKey, given a message, a signature,
 * and the PublicKey.
 */
bool verify(struct LDKu8slice msg, struct LDKStr sig, struct LDKPublicKey pk);

/**
 * Creates a copy of the Level
 */
enum LDKLevel Level_clone(const enum LDKLevel *NONNULL_PTR orig);

/**
 * Checks if two Levels contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Level_eq(const enum LDKLevel *NONNULL_PTR a, const enum LDKLevel *NONNULL_PTR b);

/**
 * Checks if two Levels contain equal inner contents.
 */
uint64_t Level_hash(const enum LDKLevel *NONNULL_PTR o);

/**
 * Returns the most verbose logging level.
 */
MUST_USE_RES enum LDKLevel Level_max(void);

/**
 * Calls the free function if one is set
 */
void Logger_free(struct LDKLogger this_ptr);

/**
 * Frees any resources used by the ChannelHandshakeConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeConfig_free(struct LDKChannelHandshakeConfig this_obj);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * Default value: 6.
 */
uint32_t ChannelHandshakeConfig_get_minimum_depth(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * Default value: 6.
 */
void ChannelHandshakeConfig_set_minimum_depth(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to the number of blocks we require our counterparty to wait to claim their money (ie
 * the number of blocks we have to punish our counterparty if they broadcast a revoked
 * transaction).
 *
 * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
 * be online to check for revoked transactions on-chain at least once every our_to_self_delay
 * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
 * possibly with time in between to RBF the spending transaction).
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
 * can tweak config to ask for more security, not less.
 */
uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the number of blocks we require our counterparty to wait to claim their money (ie
 * the number of blocks we have to punish our counterparty if they broadcast a revoked
 * transaction).
 *
 * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
 * be online to check for revoked transactions on-chain at least once every our_to_self_delay
 * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
 * possibly with time in between to RBF the spending transaction).
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
 * can tweak config to ask for more security, not less.
 */
void ChannelHandshakeConfig_set_our_to_self_delay(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
void ChannelHandshakeConfig_set_our_htlc_minimum_msat(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ChannelHandshakeConfig given each field
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg);

/**
 * Creates a copy of the ChannelHandshakeConfig
 */
struct LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(const struct LDKChannelHandshakeConfig *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);

/**
 * Frees any resources used by the ChannelHandshakeLimits, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeLimits_free(struct LDKChannelHandshakeLimits this_obj);

/**
 * Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_htlc_minimum_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_accepted_htlcs(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
void ChannelHandshakeLimits_set_max_minimum_depth(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to force an incoming channel to match our announced channel preference in
 * [`ChannelConfig::announced_channel`].
 *
 * For a node which is not online reliably, this should be set to true and
 * [`ChannelConfig::announced_channel`] set to false, ensuring that no announced (aka public)
 * channels will ever be opened.
 *
 * Default value: true.
 */
bool ChannelHandshakeLimits_get_force_announced_channel_preference(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to force an incoming channel to match our announced channel preference in
 * [`ChannelConfig::announced_channel`].
 *
 * For a node which is not online reliably, this should be set to true and
 * [`ChannelConfig::announced_channel`] set to false, ensuring that no announced (aka public)
 * channels will ever be opened.
 *
 * Default value: true.
 */
void ChannelHandshakeLimits_set_force_announced_channel_preference(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
void ChannelHandshakeLimits_set_their_to_self_delay(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new ChannelHandshakeLimits given each field
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint32_t max_minimum_depth_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);

/**
 * Creates a copy of the ChannelHandshakeLimits
 */
struct LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(const struct LDKChannelHandshakeLimits *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeLimits. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);

/**
 * Frees any resources used by the ChannelConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelConfig_free(struct LDKChannelConfig this_obj);

/**
 * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
 * over the channel.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
uint32_t ChannelConfig_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
 * over the channel.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
void ChannelConfig_set_forwarding_fee_proportional_millionths(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
 * excess of [`forwarding_fee_proportional_millionths`].
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * The default value of a single satoshi roughly matches the market rate on many routing nodes
 * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
 * this node.
 *
 * Default value: 1000.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 */
uint32_t ChannelConfig_get_forwarding_fee_base_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
 * excess of [`forwarding_fee_proportional_millionths`].
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * The default value of a single satoshi roughly matches the market rate on many routing nodes
 * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
 * this node.
 *
 * Default value: 1000.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 */
void ChannelConfig_set_forwarding_fee_base_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
 * the channel this config applies to.
 *
 * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
 * HTLC balance when a channel appears on-chain whereas
 * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
 * (non-HTLC-encumbered) balance.
 *
 * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
 * we (or one of our watchtowers) MUST be online to check for broadcast of the current
 * commitment transaction at least once per this many blocks (minus some margin to allow us
 * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
 * the spending transaction).
 *
 * Default value: 72 (12 hours at an average of 6 blocks/hour).
 * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
 *                [`MIN_CLTV_EXPIRY_DELTA`] instead.
 *
 * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
 */
uint16_t ChannelConfig_get_cltv_expiry_delta(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
 * the channel this config applies to.
 *
 * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
 * HTLC balance when a channel appears on-chain whereas
 * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
 * (non-HTLC-encumbered) balance.
 *
 * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
 * we (or one of our watchtowers) MUST be online to check for broadcast of the current
 * commitment transaction at least once per this many blocks (minus some margin to allow us
 * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
 * the spending transaction).
 *
 * Default value: 72 (12 hours at an average of 6 blocks/hour).
 * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
 *                [`MIN_CLTV_EXPIRY_DELTA`] instead.
 *
 * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
 */
void ChannelConfig_set_cltv_expiry_delta(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
 *
 * This cannot be changed after the initial channel handshake.
 *
 * Default value: false.
 */
bool ChannelConfig_get_announced_channel(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
 *
 * This cannot be changed after the initial channel handshake.
 *
 * Default value: false.
 */
void ChannelConfig_set_announced_channel(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * This cannot be changed after a channel has been initialized.
 *
 * Default value: true.
 */
bool ChannelConfig_get_commit_upfront_shutdown_pubkey(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * This cannot be changed after a channel has been initialized.
 *
 * Default value: true.
 */
void ChannelConfig_set_commit_upfront_shutdown_pubkey(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ChannelConfig given each field
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_new(uint32_t forwarding_fee_proportional_millionths_arg, uint32_t forwarding_fee_base_msat_arg, uint16_t cltv_expiry_delta_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg);

/**
 * Creates a copy of the ChannelConfig
 */
struct LDKChannelConfig ChannelConfig_clone(const struct LDKChannelConfig *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_default(void);

/**
 * Serialize the ChannelConfig object into a byte array which can be read by ChannelConfig_read
 */
struct LDKCVec_u8Z ChannelConfig_write(const struct LDKChannelConfig *NONNULL_PTR obj);

/**
 * Read a ChannelConfig from a byte array, created by ChannelConfig_write
 */
struct LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UserConfig, if is_owned is set and inner is non-NULL.
 */
void UserConfig_free(struct LDKUserConfig this_obj);

/**
 * Channel config that we propose to our counterparty.
 */
struct LDKChannelHandshakeConfig UserConfig_get_own_channel_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel config that we propose to our counterparty.
 */
void UserConfig_set_own_channel_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeConfig val);

/**
 * Limits applied to our counterparty's proposed channel config settings.
 */
struct LDKChannelHandshakeLimits UserConfig_get_peer_channel_config_limits(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Limits applied to our counterparty's proposed channel config settings.
 */
void UserConfig_set_peer_channel_config_limits(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeLimits val);

/**
 * Channel config which affects behavior during channel lifetime.
 */
struct LDKChannelConfig UserConfig_get_channel_options(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel config which affects behavior during channel lifetime.
 */
void UserConfig_set_channel_options(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelConfig val);

/**
 * If this is set to false, we will reject any HTLCs which were to be forwarded over private
 * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
 * node which is not online reliably.
 *
 * For nodes which are not online reliably, you should set all channels to *not* be announced
 * (using [`ChannelConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
 * ensure you are not exposed to any forwarding risk.
 *
 * Note that because you cannot change a channel's announced state after creation, there is no
 * way to disable forwarding on public channels retroactively. Thus, in order to change a node
 * from a publicly-announced forwarding node to a private non-forwarding node you must close
 * all your channels and open new ones. For privacy, you should also change your node_id
 * (swapping all private and public key material for new ones) at that time.
 *
 * Default value: false.
 */
bool UserConfig_get_accept_forwards_to_priv_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to false, we will reject any HTLCs which were to be forwarded over private
 * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
 * node which is not online reliably.
 *
 * For nodes which are not online reliably, you should set all channels to *not* be announced
 * (using [`ChannelConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
 * ensure you are not exposed to any forwarding risk.
 *
 * Note that because you cannot change a channel's announced state after creation, there is no
 * way to disable forwarding on public channels retroactively. Thus, in order to change a node
 * from a publicly-announced forwarding node to a private non-forwarding node you must close
 * all your channels and open new ones. For privacy, you should also change your node_id
 * (swapping all private and public key material for new ones) at that time.
 *
 * Default value: false.
 */
void UserConfig_set_accept_forwards_to_priv_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new UserConfig given each field
 */
MUST_USE_RES struct LDKUserConfig UserConfig_new(struct LDKChannelHandshakeConfig own_channel_config_arg, struct LDKChannelHandshakeLimits peer_channel_config_limits_arg, struct LDKChannelConfig channel_options_arg, bool accept_forwards_to_priv_channels_arg);

/**
 * Creates a copy of the UserConfig
 */
struct LDKUserConfig UserConfig_clone(const struct LDKUserConfig *NONNULL_PTR orig);

/**
 * Creates a "default" UserConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKUserConfig UserConfig_default(void);

/**
 * Frees any resources used by the BestBlock, if is_owned is set and inner is non-NULL.
 */
void BestBlock_free(struct LDKBestBlock this_obj);

/**
 * Creates a copy of the BestBlock
 */
struct LDKBestBlock BestBlock_clone(const struct LDKBestBlock *NONNULL_PTR orig);

/**
 * Constructs a `BestBlock` that represents the genesis block at height 0 of the given
 * network.
 */
MUST_USE_RES struct LDKBestBlock BestBlock_from_genesis(enum LDKNetwork network);

/**
 * Returns a `BestBlock` as identified by the given block hash and height.
 */
MUST_USE_RES struct LDKBestBlock BestBlock_new(struct LDKThirtyTwoBytes block_hash, uint32_t height);

/**
 * Returns the best block hash.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BestBlock_block_hash(const struct LDKBestBlock *NONNULL_PTR this_arg);

/**
 * Returns the best block height.
 */
MUST_USE_RES uint32_t BestBlock_height(const struct LDKBestBlock *NONNULL_PTR this_arg);

/**
 * Creates a copy of the AccessError
 */
enum LDKAccessError AccessError_clone(const enum LDKAccessError *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Access_free(struct LDKAccess this_ptr);

/**
 * Calls the free function if one is set
 */
void Listen_free(struct LDKListen this_ptr);

/**
 * Calls the free function if one is set
 */
void Confirm_free(struct LDKConfirm this_ptr);

/**
 * Calls the free function if one is set
 */
void Watch_free(struct LDKWatch this_ptr);

/**
 * Calls the free function if one is set
 */
void Filter_free(struct LDKFilter this_ptr);

/**
 * Frees any resources used by the WatchedOutput, if is_owned is set and inner is non-NULL.
 */
void WatchedOutput_free(struct LDKWatchedOutput this_obj);

/**
 * First block where the transaction output may have been spent.
 */
struct LDKThirtyTwoBytes WatchedOutput_get_block_hash(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * First block where the transaction output may have been spent.
 */
void WatchedOutput_set_block_hash(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Outpoint identifying the transaction output.
 */
struct LDKOutPoint WatchedOutput_get_outpoint(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * Outpoint identifying the transaction output.
 */
void WatchedOutput_set_outpoint(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Spending condition of the transaction output.
 */
struct LDKu8slice WatchedOutput_get_script_pubkey(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * Spending condition of the transaction output.
 */
void WatchedOutput_set_script_pubkey(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new WatchedOutput given each field
 */
MUST_USE_RES struct LDKWatchedOutput WatchedOutput_new(struct LDKThirtyTwoBytes block_hash_arg, struct LDKOutPoint outpoint_arg, struct LDKCVec_u8Z script_pubkey_arg);

/**
 * Creates a copy of the WatchedOutput
 */
struct LDKWatchedOutput WatchedOutput_clone(const struct LDKWatchedOutput *NONNULL_PTR orig);

/**
 * Checks if two WatchedOutputs contain equal inner contents.
 */
uint64_t WatchedOutput_hash(const struct LDKWatchedOutput *NONNULL_PTR o);

/**
 * Calls the free function if one is set
 */
void BroadcasterInterface_free(struct LDKBroadcasterInterface this_ptr);

/**
 * Creates a copy of the ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_clone(const enum LDKConfirmationTarget *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void FeeEstimator_free(struct LDKFeeEstimator this_ptr);

/**
 * Frees any resources used by the ChainMonitor, if is_owned is set and inner is non-NULL.
 */
void ChainMonitor_free(struct LDKChainMonitor this_obj);

/**
 * Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
 *
 * When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
 * will call back to it indicating transactions and outputs of interest. This allows clients to
 * pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
 * always need to fetch full blocks absent another means for determining which blocks contain
 * transactions relevant to the watched channels.
 */
MUST_USE_RES struct LDKChainMonitor ChainMonitor_new(struct LDKFilter *chain_source, struct LDKBroadcasterInterface broadcaster, struct LDKLogger logger, struct LDKFeeEstimator feeest, struct LDKPersist persister);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChainMonitor_as_Listen(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Confirm which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
 */
struct LDKConfirm ChainMonitor_as_Confirm(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Watch which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
 */
struct LDKWatch ChainMonitor_as_Watch(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChainMonitor_as_EventsProvider(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelMonitorUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitorUpdate_free(struct LDKChannelMonitorUpdate this_obj);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with one exception specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instance where update_id values are not strictly increasing is the case where we
 * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
 * its docs for more details.
 */
uint64_t ChannelMonitorUpdate_get_update_id(const struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with one exception specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instance where update_id values are not strictly increasing is the case where we
 * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
 * its docs for more details.
 */
void ChannelMonitorUpdate_set_update_id(struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelMonitorUpdate
 */
struct LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(const struct LDKChannelMonitorUpdate *NONNULL_PTR orig);

/**
 * Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
 */
struct LDKCVec_u8Z ChannelMonitorUpdate_write(const struct LDKChannelMonitorUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(struct LDKu8slice ser);

/**
 * Creates a copy of the ChannelMonitorUpdateErr
 */
enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_clone(const enum LDKChannelMonitorUpdateErr *NONNULL_PTR orig);

/**
 * Frees any resources used by the MonitorUpdateError, if is_owned is set and inner is non-NULL.
 */
void MonitorUpdateError_free(struct LDKMonitorUpdateError this_obj);

/**
 * Creates a copy of the MonitorUpdateError
 */
struct LDKMonitorUpdateError MonitorUpdateError_clone(const struct LDKMonitorUpdateError *NONNULL_PTR orig);

/**
 * Frees any resources used by the MonitorEvent
 */
void MonitorEvent_free(struct LDKMonitorEvent this_ptr);

/**
 * Creates a copy of the MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_clone(const struct LDKMonitorEvent *NONNULL_PTR orig);

/**
 * Frees any resources used by the HTLCUpdate, if is_owned is set and inner is non-NULL.
 */
void HTLCUpdate_free(struct LDKHTLCUpdate this_obj);

/**
 * Creates a copy of the HTLCUpdate
 */
struct LDKHTLCUpdate HTLCUpdate_clone(const struct LDKHTLCUpdate *NONNULL_PTR orig);

/**
 * Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
 */
struct LDKCVec_u8Z HTLCUpdate_write(const struct LDKHTLCUpdate *NONNULL_PTR obj);

/**
 * Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelMonitor, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitor_free(struct LDKChannelMonitor this_obj);

/**
 * Creates a copy of the ChannelMonitor
 */
struct LDKChannelMonitor ChannelMonitor_clone(const struct LDKChannelMonitor *NONNULL_PTR orig);

/**
 * Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
 */
struct LDKCVec_u8Z ChannelMonitor_write(const struct LDKChannelMonitor *NONNULL_PTR obj);

/**
 * Updates a ChannelMonitor on the basis of some new information provided by the Channel
 * itself.
 *
 * panics if the given update is not the next update by update_id.
 */
MUST_USE_RES struct LDKCResult_NoneMonitorUpdateErrorZ ChannelMonitor_update_monitor(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR updates, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, const struct LDKFeeEstimator *NONNULL_PTR fee_estimator, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
 * ChannelMonitor.
 */
MUST_USE_RES uint64_t ChannelMonitor_get_latest_update_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
 */
MUST_USE_RES struct LDKC2Tuple_OutPointScriptZ ChannelMonitor_get_funding_txo(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets a list of txids, with their output scripts (in the order they appear in the
 * transaction), which we must learn about spends of via block_connected().
 */
MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ChannelMonitor_get_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
 * calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
 * have been registered.
 */
void ChannelMonitor_load_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKFilter *NONNULL_PTR filter);

/**
 * Get the list of HTLCs who's status has been updated on chain. This should be called by
 * ChannelManager via [`chain::Watch::release_pending_monitor_events`].
 */
MUST_USE_RES struct LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the list of pending events which were generated by previous actions, clearing the list
 * in the process.
 *
 * This is called by ChainMonitor::get_and_clear_pending_events() and is equivalent to
 * EventsProvider::get_and_clear_pending_events() except that it requires &mut self as we do
 * no internal locking in ChannelMonitors.
 */
MUST_USE_RES struct LDKCVec_EventZ ChannelMonitor_get_and_clear_pending_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Used by ChannelManager deserialization to broadcast the latest holder state if its copy of
 * the Channel was out-of-date. You may use it to get a broadcastable holder toxic tx in case of
 * fallen-behind, i.e when receiving a channel_reestablish with a proof that our counterparty side knows
 * a higher revocation secret than the holder commitment number we are aware of. Broadcasting these
 * transactions are UNSAFE, as they allow counterparty side to punish you. Nevertheless you may want to
 * broadcast them if counterparty don't close channel with his higher commitment transaction after a
 * substantial amount of time (a month or even a year) to get back funds. Best may be to contact
 * out-of-band the other node operator to coordinate with him if option is available to you.
 * In any-case, choice is up to the user.
 */
MUST_USE_RES struct LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Processes transactions in a newly connected block, which may result in any of the following:
 * - update the monitor's state against resolved HTLCs
 * - punish the counterparty in the case of seeing a revoked commitment transaction
 * - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
 * - detect settled outputs for later spending
 * - schedule and bump any in-flight claims
 *
 * Returns any new outputs to watch from `txdata`; after called, these are also included in
 * [`get_outputs_to_watch`].
 *
 * [`get_outputs_to_watch`]: #method.get_outputs_to_watch
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_block_connected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Determines if the disconnected block contained any transactions of interest and updates
 * appropriately.
 */
void ChannelMonitor_block_disconnected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Processes transactions confirmed in a block with the given header and height, returning new
 * outputs to watch. See [`block_connected`] for details.
 *
 * Used instead of [`block_connected`] by clients that are notified of transactions rather than
 * blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_connected`]: Self::block_connected
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_transactions_confirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Processes a transaction that was reorganized out of the chain.
 *
 * Used instead of [`block_disconnected`] by clients that are notified of transactions rather
 * than blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_disconnected`]: Self::block_disconnected
 */
void ChannelMonitor_transaction_unconfirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Updates the monitor with the current best chain tip, returning new outputs to watch. See
 * [`block_connected`] for details.
 *
 * Used instead of [`block_connected`] by clients that are notified of transactions rather than
 * blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_connected`]: Self::block_connected
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_best_block_updated(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Returns the set of txids that should be monitored for re-organization out of the chain.
 */
MUST_USE_RES struct LDKCVec_TxidZ ChannelMonitor_get_relevant_txids(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the latest best block which was connected either via the [`chain::Listen`] or
 * [`chain::Confirm`] interfaces.
 */
MUST_USE_RES struct LDKBestBlock ChannelMonitor_current_best_block(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Calls the free function if one is set
 */
void Persist_free(struct LDKPersist this_ptr);

/**
 * Read a C2Tuple_BlockHashChannelMonitorZ from a byte array, created by C2Tuple_BlockHashChannelMonitorZ_write
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ C2Tuple_BlockHashChannelMonitorZ_read(struct LDKu8slice ser, const struct LDKKeysInterface *NONNULL_PTR arg);

/**
 * Frees any resources used by the OutPoint, if is_owned is set and inner is non-NULL.
 */
void OutPoint_free(struct LDKOutPoint this_obj);

/**
 * The referenced transaction's txid.
 */
const uint8_t (*OutPoint_get_txid(const struct LDKOutPoint *NONNULL_PTR this_ptr))[32];

/**
 * The referenced transaction's txid.
 */
void OutPoint_set_txid(struct LDKOutPoint *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The index of the referenced output in its transaction's vout.
 */
uint16_t OutPoint_get_index(const struct LDKOutPoint *NONNULL_PTR this_ptr);

/**
 * The index of the referenced output in its transaction's vout.
 */
void OutPoint_set_index(struct LDKOutPoint *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new OutPoint given each field
 */
MUST_USE_RES struct LDKOutPoint OutPoint_new(struct LDKThirtyTwoBytes txid_arg, uint16_t index_arg);

/**
 * Creates a copy of the OutPoint
 */
struct LDKOutPoint OutPoint_clone(const struct LDKOutPoint *NONNULL_PTR orig);

/**
 * Checks if two OutPoints contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OutPoint_eq(const struct LDKOutPoint *NONNULL_PTR a, const struct LDKOutPoint *NONNULL_PTR b);

/**
 * Checks if two OutPoints contain equal inner contents.
 */
uint64_t OutPoint_hash(const struct LDKOutPoint *NONNULL_PTR o);

/**
 * Convert an `OutPoint` to a lightning channel id.
 */
MUST_USE_RES struct LDKThirtyTwoBytes OutPoint_to_channel_id(const struct LDKOutPoint *NONNULL_PTR this_arg);

/**
 * Serialize the OutPoint object into a byte array which can be read by OutPoint_read
 */
struct LDKCVec_u8Z OutPoint_write(const struct LDKOutPoint *NONNULL_PTR obj);

/**
 * Read a OutPoint from a byte array, created by OutPoint_write
 */
struct LDKCResult_OutPointDecodeErrorZ OutPoint_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DelayedPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void DelayedPaymentOutputDescriptor_free(struct LDKDelayedPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable
 */
struct LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable
 */
void DelayedPaymentOutputDescriptor_set_outpoint(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Per commitment point to derive delayed_payment_key by key holder
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * Per commitment point to derive delayed_payment_key by key holder
 */
void DelayedPaymentOutputDescriptor_set_per_commitment_point(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The nSequence value which must be set in the spending input to satisfy the OP_CSV in
 * the witness_script.
 */
uint16_t DelayedPaymentOutputDescriptor_get_to_self_delay(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The nSequence value which must be set in the spending input to satisfy the OP_CSV in
 * the witness_script.
 */
void DelayedPaymentOutputDescriptor_set_to_self_delay(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The output which is referenced by the given outpoint
 */
void DelayedPaymentOutputDescriptor_set_output(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
void DelayedPaymentOutputDescriptor_set_revocation_pubkey(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
const uint8_t (*DelayedPaymentOutputDescriptor_get_channel_keys_id(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
void DelayedPaymentOutputDescriptor_set_channel_keys_id(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
uint64_t DelayedPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new DelayedPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKPublicKey per_commitment_point_arg, uint16_t to_self_delay_arg, struct LDKTxOut output_arg, struct LDKPublicKey revocation_pubkey_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the DelayedPaymentOutputDescriptor
 */
struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Serialize the DelayedPaymentOutputDescriptor object into a byte array which can be read by DelayedPaymentOutputDescriptor_read
 */
struct LDKCVec_u8Z DelayedPaymentOutputDescriptor_write(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a DelayedPaymentOutputDescriptor from a byte array, created by DelayedPaymentOutputDescriptor_write
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ DelayedPaymentOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the StaticPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void StaticPaymentOutputDescriptor_free(struct LDKStaticPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable
 */
struct LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable
 */
void StaticPaymentOutputDescriptor_set_outpoint(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The output which is referenced by the given outpoint
 */
void StaticPaymentOutputDescriptor_set_output(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
const uint8_t (*StaticPaymentOutputDescriptor_get_channel_keys_id(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
void StaticPaymentOutputDescriptor_set_channel_keys_id(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this transactions spends.
 */
uint64_t StaticPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this transactions spends.
 */
void StaticPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new StaticPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the StaticPaymentOutputDescriptor
 */
struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Serialize the StaticPaymentOutputDescriptor object into a byte array which can be read by StaticPaymentOutputDescriptor_read
 */
struct LDKCVec_u8Z StaticPaymentOutputDescriptor_write(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a StaticPaymentOutputDescriptor from a byte array, created by StaticPaymentOutputDescriptor_write
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ StaticPaymentOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the SpendableOutputDescriptor
 */
void SpendableOutputDescriptor_free(struct LDKSpendableOutputDescriptor this_ptr);

/**
 * Creates a copy of the SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(const struct LDKSpendableOutputDescriptor *NONNULL_PTR orig);

/**
 * Serialize the SpendableOutputDescriptor object into a byte array which can be read by SpendableOutputDescriptor_read
 */
struct LDKCVec_u8Z SpendableOutputDescriptor_write(const struct LDKSpendableOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a SpendableOutputDescriptor from a byte array, created by SpendableOutputDescriptor_write
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ SpendableOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Calls the free function if one is set
 */
void BaseSign_free(struct LDKBaseSign this_ptr);

/**
 * Creates a copy of a Sign
 */
struct LDKSign Sign_clone(const struct LDKSign *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Sign_free(struct LDKSign this_ptr);

/**
 * Calls the free function if one is set
 */
void KeysInterface_free(struct LDKKeysInterface this_ptr);

/**
 * Frees any resources used by the InMemorySigner, if is_owned is set and inner is non-NULL.
 */
void InMemorySigner_free(struct LDKInMemorySigner this_obj);

/**
 * Private key of anchor tx
 */
const uint8_t (*InMemorySigner_get_funding_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Private key of anchor tx
 */
void InMemorySigner_set_funding_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key for blinded revocation pubkey
 */
const uint8_t (*InMemorySigner_get_revocation_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key for blinded revocation pubkey
 */
void InMemorySigner_set_revocation_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions
 */
const uint8_t (*InMemorySigner_get_payment_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions
 */
void InMemorySigner_set_payment_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used in HTLC tx
 */
const uint8_t (*InMemorySigner_get_delayed_payment_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used in HTLC tx
 */
void InMemorySigner_set_delayed_payment_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder htlc secret key used in commitment tx htlc outputs
 */
const uint8_t (*InMemorySigner_get_htlc_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder htlc secret key used in commitment tx htlc outputs
 */
void InMemorySigner_set_htlc_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Commitment seed
 */
const uint8_t (*InMemorySigner_get_commitment_seed(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Commitment seed
 */
void InMemorySigner_set_commitment_seed(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Creates a copy of the InMemorySigner
 */
struct LDKInMemorySigner InMemorySigner_clone(const struct LDKInMemorySigner *NONNULL_PTR orig);

/**
 * Create a new InMemorySigner
 */
MUST_USE_RES struct LDKInMemorySigner InMemorySigner_new(struct LDKSecretKey funding_key, struct LDKSecretKey revocation_base_key, struct LDKSecretKey payment_key, struct LDKSecretKey delayed_payment_base_key, struct LDKSecretKey htlc_base_key, struct LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id);

/**
 * Counterparty pubkeys.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * The contest_delay value specified by our counterparty and applied on holder-broadcastable
 * transactions, ie the amount of time that we have to wait to recover our funds if we
 * broadcast a transaction.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES uint16_t InMemorySigner_counterparty_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * The contest_delay value specified by us and applied on transactions broadcastable
 * by our counterparty, ie the amount of time that they have to wait to recover their funds
 * if they broadcast a transaction.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES uint16_t InMemorySigner_holder_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Whether the holder is the initiator
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES bool InMemorySigner_is_outbound(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Funding outpoint
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKOutPoint InMemorySigner_funding_outpoint(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Obtain a ChannelTransactionParameters for this channel, to be used when verifying or
 * building transactions.
 *
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Sign the single input of spend_tx at index `input_idx` which spends the output
 * described by descriptor, returning the witness stack for the input.
 *
 * Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
 * or is not spending the outpoint described by `descriptor.outpoint`.
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Sign the single input of spend_tx at index `input_idx` which spends the output
 * described by descriptor, returning the witness stack for the input.
 *
 * Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
 * is not spending the outpoint described by `descriptor.outpoint`, or does not have a
 * sequence set to `descriptor.to_self_delay`.
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Constructs a new BaseSign which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned BaseSign must be freed before this_arg is
 */
struct LDKBaseSign InMemorySigner_as_BaseSign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Constructs a new Sign which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Sign must be freed before this_arg is
 */
struct LDKSign InMemorySigner_as_Sign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Serialize the InMemorySigner object into a byte array which can be read by InMemorySigner_read
 */
struct LDKCVec_u8Z InMemorySigner_write(const struct LDKInMemorySigner *NONNULL_PTR obj);

/**
 * Read a InMemorySigner from a byte array, created by InMemorySigner_write
 */
struct LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the KeysManager, if is_owned is set and inner is non-NULL.
 */
void KeysManager_free(struct LDKKeysManager this_obj);

/**
 * Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your
 * CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
 * starting_time isn't strictly required to actually be a time, but it must absolutely,
 * without a doubt, be unique to this instance. ie if you start multiple times with the same
 * seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to
 * simply use the current time (with very high precision).
 *
 * The seed MUST be backed up safely prior to use so that the keys can be re-created, however,
 * obviously, starting_time should be unique every time you reload the library - it is only
 * used to generate new ephemeral key data (which will be stored by the individual channel if
 * necessary).
 *
 * Note that the seed is required to recover certain on-chain funds independent of
 * ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any
 * channel, and some on-chain during-closing funds.
 *
 * Note that until the 0.1 release there is no guarantee of backward compatibility between
 * versions. Once the library is more fully supported, the docs will be updated to include a
 * detailed description of the guarantee.
 */
MUST_USE_RES struct LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos);

/**
 * Derive an old Sign containing per-channel secrets based on a key derivation parameters.
 *
 * Key derivation parameters are accessible through a per-channel secrets
 * Sign::channel_keys_id and is provided inside DynamicOuputP2WSH in case of
 * onchain output detection for which a corresponding delayed_payment_key must be derived.
 */
MUST_USE_RES struct LDKInMemorySigner KeysManager_derive_channel_keys(const struct LDKKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);

/**
 * Creates a Transaction which spends the given descriptors to the given outputs, plus an
 * output to the given change destination (if sufficient change value remains). The
 * transaction will have a feerate, at least, of the given value.
 *
 * Returns `Err(())` if the output value is greater than the input value minus required fee or
 * if a descriptor was duplicated.
 *
 * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
 *
 * May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
 * this KeysManager or one of the `InMemorySigner` created by this KeysManager.
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);

/**
 * Constructs a new KeysInterface which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
 */
struct LDKKeysInterface KeysManager_as_KeysInterface(const struct LDKKeysManager *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelManager, if is_owned is set and inner is non-NULL.
 */
void ChannelManager_free(struct LDKChannelManager this_obj);

/**
 * Frees any resources used by the ChainParameters, if is_owned is set and inner is non-NULL.
 */
void ChainParameters_free(struct LDKChainParameters this_obj);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
enum LDKNetwork ChainParameters_get_network(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
void ChainParameters_set_network(struct LDKChainParameters *NONNULL_PTR this_ptr, enum LDKNetwork val);

/**
 * The hash and height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
struct LDKBestBlock ChainParameters_get_best_block(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The hash and height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
void ChainParameters_set_best_block(struct LDKChainParameters *NONNULL_PTR this_ptr, struct LDKBestBlock val);

/**
 * Constructs a new ChainParameters given each field
 */
MUST_USE_RES struct LDKChainParameters ChainParameters_new(enum LDKNetwork network_arg, struct LDKBestBlock best_block_arg);

/**
 * Creates a copy of the ChainParameters
 */
struct LDKChainParameters ChainParameters_clone(const struct LDKChainParameters *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelCounterparty, if is_owned is set and inner is non-NULL.
 */
void ChannelCounterparty_free(struct LDKChannelCounterparty this_obj);

/**
 * The node_id of our counterparty
 */
struct LDKPublicKey ChannelCounterparty_get_node_id(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The node_id of our counterparty
 */
void ChannelCounterparty_set_node_id(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
struct LDKInitFeatures ChannelCounterparty_get_features(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
void ChannelCounterparty_set_features(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * The value, in satoshis, that must always be held in the channel for our counterparty. This
 * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
 *
 * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
 */
uint64_t ChannelCounterparty_get_unspendable_punishment_reserve(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, that must always be held in the channel for our counterparty. This
 * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
 *
 * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
 */
void ChannelCounterparty_set_unspendable_punishment_reserve(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelCounterparty
 */
struct LDKChannelCounterparty ChannelCounterparty_clone(const struct LDKChannelCounterparty *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelDetails, if is_owned is set and inner is non-NULL.
 */
void ChannelDetails_free(struct LDKChannelDetails this_obj);

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
const uint8_t (*ChannelDetails_get_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr))[32];

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
void ChannelDetails_set_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Parameters which apply to our counterparty. See individual fields for more information.
 */
struct LDKChannelCounterparty ChannelDetails_get_counterparty(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Parameters which apply to our counterparty. See individual fields for more information.
 */
void ChannelDetails_set_counterparty(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelCounterparty val);

/**
 * The Channel's funding transaction output, if we've negotiated the funding transaction with
 * our counterparty already.
 *
 * Note that, if this has been set, `channel_id` will be equivalent to
 * `funding_txo.unwrap().to_channel_id()`.
 */
struct LDKOutPoint ChannelDetails_get_funding_txo(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The Channel's funding transaction output, if we've negotiated the funding transaction with
 * our counterparty already.
 *
 * Note that, if this has been set, `channel_id` will be equivalent to
 * `funding_txo.unwrap().to_channel_id()`.
 */
void ChannelDetails_set_funding_txo(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The position of the funding transaction in the chain. None if the funding transaction has
 * not yet been confirmed and the channel fully opened.
 */
struct LDKCOption_u64Z ChannelDetails_get_short_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The position of the funding transaction in the chain. None if the funding transaction has
 * not yet been confirmed and the channel fully opened.
 */
void ChannelDetails_set_short_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
uint64_t ChannelDetails_get_channel_value_satoshis(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
void ChannelDetails_set_channel_value_satoshis(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The value, in satoshis, that must always be held in the channel for us. This value ensures
 * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
 * this value on chain.
 *
 * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
 */
struct LDKCOption_u64Z ChannelDetails_get_unspendable_punishment_reserve(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, that must always be held in the channel for us. This value ensures
 * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
 * this value on chain.
 *
 * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
 */
void ChannelDetails_set_unspendable_punishment_reserve(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The user_id passed in to create_channel, or 0 if the channel was inbound.
 */
uint64_t ChannelDetails_get_user_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The user_id passed in to create_channel, or 0 if the channel was inbound.
 */
void ChannelDetails_set_user_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
 * should be able to spend nearly this amount.
 */
uint64_t ChannelDetails_get_outbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
 * should be able to spend nearly this amount.
 */
void ChannelDetails_set_outbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
 * However, our counterparty should be able to spend nearly this amount.
 */
uint64_t ChannelDetails_get_inbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
 * However, our counterparty should be able to spend nearly this amount.
 */
void ChannelDetails_set_inbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The number of required confirmations on the funding transaction before the funding will be
 * considered \"locked\". This number is selected by the channel fundee (i.e. us if
 * [`is_outbound`] is *not* set), and can be selected for inbound channels with
 * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
 * [`ChannelHandshakeLimits::max_minimum_depth`].
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`is_outbound`]: ChannelDetails::is_outbound
 * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
 * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
 */
struct LDKCOption_u32Z ChannelDetails_get_confirmations_required(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The number of required confirmations on the funding transaction before the funding will be
 * considered \"locked\". This number is selected by the channel fundee (i.e. us if
 * [`is_outbound`] is *not* set), and can be selected for inbound channels with
 * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
 * [`ChannelHandshakeLimits::max_minimum_depth`].
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`is_outbound`]: ChannelDetails::is_outbound
 * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
 * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
 */
void ChannelDetails_set_confirmations_required(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * The number of blocks (after our commitment transaction confirms) that we will need to wait
 * until we can claim our funds after we force-close the channel. During this time our
 * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
 * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
 * time to claim our non-HTLC-encumbered funds.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 */
struct LDKCOption_u16Z ChannelDetails_get_force_close_spend_delay(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The number of blocks (after our commitment transaction confirms) that we will need to wait
 * until we can claim our funds after we force-close the channel. During this time our
 * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
 * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
 * time to claim our non-HTLC-encumbered funds.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 */
void ChannelDetails_set_force_close_spend_delay(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);

/**
 * True if the channel was initiated (and thus funded) by us.
 */
bool ChannelDetails_get_is_outbound(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel was initiated (and thus funded) by us.
 */
void ChannelDetails_set_is_outbound(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if the channel is confirmed, funding_locked messages have been exchanged, and the
 * channel is not currently being shut down. `funding_locked` message exchange implies the
 * required confirmation count has been reached (and we were connected to the peer at some
 * point after the funding transaction received enough confirmations). The required
 * confirmation count is provided in [`confirmations_required`].
 *
 * [`confirmations_required`]: ChannelDetails::confirmations_required
 */
bool ChannelDetails_get_is_funding_locked(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is confirmed, funding_locked messages have been exchanged, and the
 * channel is not currently being shut down. `funding_locked` message exchange implies the
 * required confirmation count has been reached (and we were connected to the peer at some
 * point after the funding transaction received enough confirmations). The required
 * confirmation count is provided in [`confirmations_required`].
 *
 * [`confirmations_required`]: ChannelDetails::confirmations_required
 */
void ChannelDetails_set_is_funding_locked(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)
 * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
 *
 * This is a strict superset of `is_funding_locked`.
 */
bool ChannelDetails_get_is_usable(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)
 * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
 *
 * This is a strict superset of `is_funding_locked`.
 */
void ChannelDetails_set_is_usable(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if this channel is (or will be) publicly-announced.
 */
bool ChannelDetails_get_is_public(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if this channel is (or will be) publicly-announced.
 */
void ChannelDetails_set_is_public(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ChannelDetails given each field
 */
MUST_USE_RES struct LDKChannelDetails ChannelDetails_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKChannelCounterparty counterparty_arg, struct LDKOutPoint funding_txo_arg, struct LDKCOption_u64Z short_channel_id_arg, uint64_t channel_value_satoshis_arg, struct LDKCOption_u64Z unspendable_punishment_reserve_arg, uint64_t user_id_arg, uint64_t outbound_capacity_msat_arg, uint64_t inbound_capacity_msat_arg, struct LDKCOption_u32Z confirmations_required_arg, struct LDKCOption_u16Z force_close_spend_delay_arg, bool is_outbound_arg, bool is_funding_locked_arg, bool is_usable_arg, bool is_public_arg);

/**
 * Creates a copy of the ChannelDetails
 */
struct LDKChannelDetails ChannelDetails_clone(const struct LDKChannelDetails *NONNULL_PTR orig);

/**
 * Frees any resources used by the PaymentSendFailure
 */
void PaymentSendFailure_free(struct LDKPaymentSendFailure this_ptr);

/**
 * Creates a copy of the PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_clone(const struct LDKPaymentSendFailure *NONNULL_PTR orig);

/**
 * Constructs a new ChannelManager to hold several channels and route between them.
 *
 * This is the main \"logic hub\" for all channel-related actions, and implements
 * ChannelMessageHandler.
 *
 * Non-proportional fees are fixed according to our risk using the provided fee estimator.
 *
 * panics if channel_value_satoshis is >= `MAX_FUNDING_SATOSHIS`!
 *
 * Users need to notify the new ChannelManager when a new block is connected or
 * disconnected using its `block_connected` and `block_disconnected` methods, starting
 * from after `params.latest_hash`.
 */
MUST_USE_RES struct LDKChannelManager ChannelManager_new(struct LDKFeeEstimator fee_est, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKKeysInterface keys_manager, struct LDKUserConfig config, struct LDKChainParameters params);

/**
 * Gets the current configuration applied to all new channels,  as
 */
MUST_USE_RES struct LDKUserConfig ChannelManager_get_current_default_configuration(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Creates a new outbound channel to the given remote node and with the given value.
 *
 * user_id will be provided back as user_channel_id in FundingGenerationReady events to allow
 * tracking of which events correspond with which create_channel call. Note that the
 * user_channel_id defaults to 0 for inbound channels, so you may wish to avoid using 0 for
 * user_id here. user_id has no meaning inside of LDK, it is simply copied to events and
 * otherwise ignored.
 *
 * If successful, will generate a SendOpenChannel message event, so you should probably poll
 * PeerManager::process_events afterwards.
 *
 * Raises APIError::APIMisuseError when channel_value_satoshis > 2**24 or push_msat is
 * greater than channel_value_satoshis * 1k or channel_value_satoshis is < 1000.
 *
 * Note that we do not check if you are currently connected to the given peer. If no
 * connection is available, the outbound `open_channel` message may fail to send, resulting in
 * the channel eventually being silently forgotten.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_create_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, uint64_t user_id, struct LDKUserConfig override_config);

/**
 * Gets the list of open channels, in random order. See ChannelDetail field documentation for
 * more information.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the list of usable channels, in random order. Useful as an argument to
 * get_route to ensure non-announced channels are used.
 *
 * These are guaranteed to have their [`ChannelDetails::is_usable`] value set to true, see the
 * documentation for [`ChannelDetails::is_usable`] for more info on exactly what the criteria
 * are.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
 * will be accepted on the given channel, and after additional timeout/the closing of all
 * pending HTLCs, the channel will be closed on chain.
 *
 * May generate a SendShutdown message event on success, which should be relayed.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);

/**
 * Force closes a channel, immediately broadcasting the latest local commitment transaction to
 * the chain and rejecting new HTLCs on the given channel. Fails if channel_id is unknown to the manager.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);

/**
 * Force close all channels, immediately broadcasting the latest local commitment transaction
 * for each to the chain and rejecting new HTLCs on each.
 */
void ChannelManager_force_close_all_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Sends a payment along a given route.
 *
 * Value parameters are provided via the last hop in route, see documentation for RouteHop
 * fields for more info.
 *
 * Note that if the payment_hash already exists elsewhere (eg you're sending a duplicative
 * payment), we don't do anything to stop you! We always try to ensure that if the provided
 * next hop knows the preimage to payment_hash they can claim an additional amount as
 * specified in the last hop in the route! Thus, you should probably do your own
 * payment_preimage tracking (which you should already be doing as they represent \"proof of
 * payment\") and prevent double-sends yourself.
 *
 * May generate SendHTLCs message(s) event on success, which should be relayed.
 *
 * Each path may have a different return value, and PaymentSendValue may return a Vec with
 * each entry matching the corresponding-index entry in the route paths, see
 * PaymentSendFailure for more info.
 *
 * In general, a path may raise:
 *  * APIError::RouteError when an invalid route or forwarding parameter (cltv_delta, fee,
 *    node public key) is specified.
 *  * APIError::ChannelUnavailable if the next-hop channel is not available for updates
 *    (including due to previous monitor update failure or new permanent monitor update
 *    failure).
 *  * APIError::MonitorUpdateFailed if a new monitor update failure prevented sending the
 *    relevant updates.
 *
 * Note that depending on the type of the PaymentSendFailure the HTLC may have been
 * irrevocably committed to on our end. In such a case, do NOT retry the payment with a
 * different route unless you intend to pay twice!
 *
 * payment_secret is unrelated to payment_hash (or PaymentPreimage) and exists to authenticate
 * the sender to the recipient and prevent payment-probing (deanonymization) attacks. For
 * newer nodes, it will be provided to you in the invoice. If you do not have one, the Route
 * must not contain multiple paths as multi-path payments require a recipient-provided
 * payment_secret.
 * If a payment_secret *is* provided, we assume that the invoice had the payment_secret feature
 * bit set (either as required or as available). If multiple paths are present in the Route,
 * we assume the invoice had the basic_mpp feature set.
 */
MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_send_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);

/**
 * Call this upon creation of a funding transaction for the given channel.
 *
 * Returns an [`APIError::APIMisuseError`] if the funding_transaction spent non-SegWit outputs
 * or if no output was found which matches the parameters in [`Event::FundingGenerationReady`].
 *
 * Panics if a funding transaction has already been provided for this channel.
 *
 * May panic if the output found in the funding transaction is duplicative with some other
 * channel (note that this should be trivially prevented by using unique funding transaction
 * keys per-channel).
 *
 * Do NOT broadcast the funding transaction yourself. When we have safely received our
 * counterparty's signature the funding transaction will automatically be broadcast via the
 * [`BroadcasterInterface`] provided when this `ChannelManager` was constructed.
 *
 * Note that this includes RBF or similar transaction replacement strategies - lightning does
 * not currently support replacing a funding transaction on an existing channel. Instead,
 * create a new channel with a conflicting funding transaction.
 *
 * [`Event::FundingGenerationReady`]: crate::util::events::Event::FundingGenerationReady
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKTransaction funding_transaction);

/**
 * Regenerates channel_announcements and generates a signed node_announcement from the given
 * arguments, providing them in corresponding events via
 * [`get_and_clear_pending_msg_events`], if at least one public channel has been confirmed
 * on-chain. This effectively re-broadcasts all channel announcements and sends our node
 * announcement to ensure that the lightning P2P network is aware of the channels we have and
 * our network addresses.
 *
 * `rgb` is a node \"color\" and `alias` is a printable human-readable string to describe this
 * node to humans. They carry no in-protocol meaning.
 *
 * `addresses` represent the set (possibly empty) of socket addresses on which this node
 * accepts incoming connections. These will be included in the node_announcement, publicly
 * tying these addresses together and to this node. If you wish to preserve user privacy,
 * addresses should likely contain only Tor Onion addresses.
 *
 * Panics if `addresses` is absurdly large (more than 500).
 *
 * [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
 */
void ChannelManager_broadcast_node_announcement(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThreeBytes rgb, struct LDKThirtyTwoBytes alias, struct LDKCVec_NetAddressZ addresses);

/**
 * Processes HTLCs which are pending waiting on random forward delay.
 *
 * Should only really ever be called in response to a PendingHTLCsForwardable event.
 * Will likely generate further events.
 */
void ChannelManager_process_pending_htlc_forwards(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * If a peer is disconnected we mark any channels with that peer as 'disabled'.
 * After some time, if channels are still disabled we need to broadcast a ChannelUpdate
 * to inform the network about the uselessness of these channels.
 *
 * This method handles all the details, and must be called roughly once per minute.
 *
 * Note that in some rare cases this may generate a `chain::Watch::update_channel` call.
 */
void ChannelManager_timer_tick_occurred(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Indicates that the preimage for payment_hash is unknown or the received amount is incorrect
 * after a PaymentReceived event, failing the HTLC back to its origin and freeing resources
 * along the path (including in our own channel on which we received it).
 * Returns false if no payment was found to fail backwards, true if the process of failing the
 * HTLC backwards has been started.
 */
MUST_USE_RES bool ChannelManager_fail_htlc_backwards(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);

/**
 * Provides a payment preimage in response to a PaymentReceived event, returning true and
 * generating message events for the net layer to claim the payment, if possible. Thus, you
 * should probably kick the net layer to go send messages if this returns true!
 *
 * Note that if you did not set an `amount_msat` when calling [`create_inbound_payment`] or
 * [`create_inbound_payment_for_hash`] you must check that the amount in the `PaymentReceived`
 * event matches your expectation. If you fail to do so and call this method, you may provide
 * the sender \"proof-of-payment\" when they did not fulfill the full expected payment.
 *
 * May panic if called except in response to a PaymentReceived event.
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 */
MUST_USE_RES bool ChannelManager_claim_funds(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage);

/**
 * Gets the node_id held by this ChannelManager
 */
MUST_USE_RES struct LDKPublicKey ChannelManager_get_our_node_id(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Restores a single, given channel to normal operation after a
 * ChannelMonitorUpdateErr::TemporaryFailure was returned from a channel monitor update
 * operation.
 *
 * All ChannelMonitor updates up to and including highest_applied_update_id must have been
 * fully committed in every copy of the given channels' ChannelMonitors.
 *
 * Note that there is no effect to calling with a highest_applied_update_id other than the
 * current latest ChannelMonitorUpdate and one call to this function after multiple
 * ChannelMonitorUpdateErr::TemporaryFailures is fine. The highest_applied_update_id field
 * exists largely only to prevent races between this and concurrent update_monitor calls.
 *
 * Thus, the anticipated use is, at a high level:
 *  1) You register a chain::Watch with this ChannelManager,
 *  2) it stores each update to disk, and begins updating any remote (eg watchtower) copies of
 *     said ChannelMonitors as it can, returning ChannelMonitorUpdateErr::TemporaryFailures
 *     any time it cannot do so instantly,
 *  3) update(s) are applied to each remote copy of a ChannelMonitor,
 *  4) once all remote copies are updated, you call this function with the update_id that
 *     completed, and once it is the latest the Channel will be re-enabled.
 */
void ChannelManager_channel_monitor_updated(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKOutPoint *NONNULL_PTR funding_txo, uint64_t highest_applied_update_id);

/**
 * Gets a payment secret and payment hash for use in an invoice given to a third party wishing
 * to pay us.
 *
 * This differs from [`create_inbound_payment_for_hash`] only in that it generates the
 * [`PaymentHash`] and [`PaymentPreimage`] for you, returning the first and storing the second.
 *
 * The [`PaymentPreimage`] will ultimately be returned to you in the [`PaymentReceived`], which
 * will have the [`PaymentReceived::payment_preimage`] field filled in. That should then be
 * passed directly to [`claim_funds`].
 *
 * See [`create_inbound_payment_for_hash`] for detailed documentation on behavior and requirements.
 *
 * [`claim_funds`]: Self::claim_funds
 * [`PaymentReceived`]: events::Event::PaymentReceived
 * [`PaymentReceived::payment_preimage`]: events::Event::PaymentReceived::payment_preimage
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 */
MUST_USE_RES struct LDKC2Tuple_PaymentHashPaymentSecretZ ChannelManager_create_inbound_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, uint64_t user_payment_id);

/**
 * Gets a [`PaymentSecret`] for a given [`PaymentHash`], for which the payment preimage is
 * stored external to LDK.
 *
 * A [`PaymentReceived`] event will only be generated if the [`PaymentSecret`] matches a
 * payment secret fetched via this method or [`create_inbound_payment`], and which is at least
 * the `min_value_msat` provided here, if one is provided.
 *
 * The [`PaymentHash`] (and corresponding [`PaymentPreimage`]) must be globally unique. This
 * method may return an Err if another payment with the same payment_hash is still pending.
 *
 * `user_payment_id` will be provided back in [`PaymentReceived::user_payment_id`] events to
 * allow tracking of which events correspond with which calls to this and
 * [`create_inbound_payment`]. `user_payment_id` has no meaning inside of LDK, it is simply
 * copied to events and otherwise ignored. It may be used to correlate PaymentReceived events
 * with invoice metadata stored elsewhere.
 *
 * `min_value_msat` should be set if the invoice being generated contains a value. Any payment
 * received for the returned [`PaymentHash`] will be required to be at least `min_value_msat`
 * before a [`PaymentReceived`] event will be generated, ensuring that we do not provide the
 * sender \"proof-of-payment\" unless they have paid the required amount.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time. This should roughly match the expiry time set in the invoice.
 * After this many seconds, we will remove the inbound payment, resulting in any attempts to
 * pay the invoice failing. The BOLT spec suggests 3,600 secs as a default validity time for
 * invoices when no timeout is set.
 *
 * Note that we use block header time to time-out pending inbound payments (with some margin
 * to compensate for the inaccuracy of block header timestamps). Thus, in practice we will
 * accept a payment and generate a [`PaymentReceived`] event for some time after the expiry.
 * If you need exact expiry semantics, you should enforce them upon receipt of
 * [`PaymentReceived`].
 *
 * Pending inbound payments are stored in memory and in serialized versions of this
 * [`ChannelManager`]. If potentially unbounded numbers of inbound payments may exist and
 * space is limited, you may wish to rate-limit inbound payment creation.
 *
 * May panic if `invoice_expiry_delta_secs` is greater than one year.
 *
 * Note that invoices generated for inbound payments should have their `min_final_cltv_expiry`
 * set to at least [`MIN_FINAL_CLTV_EXPIRY`].
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 * [`PaymentReceived`]: events::Event::PaymentReceived
 * [`PaymentReceived::user_payment_id`]: events::Event::PaymentReceived::user_payment_id
 */
MUST_USE_RES struct LDKCResult_PaymentSecretAPIErrorZ ChannelManager_create_inbound_payment_for_hash(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, uint64_t user_payment_id);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChannelManager_as_EventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChannelManager_as_Listen(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Confirm which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
 */
struct LDKConfirm ChannelManager_as_Confirm(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Blocks until ChannelManager needs to be persisted or a timeout is reached. It returns a bool
 * indicating whether persistence is necessary. Only one listener on
 * `await_persistable_update` or `await_persistable_update_timeout` is guaranteed to be woken
 * up.
 * Note that the feature `allow_wallclock_use` must be enabled to use this function.
 */
MUST_USE_RES bool ChannelManager_await_persistable_update_timeout(const struct LDKChannelManager *NONNULL_PTR this_arg, uint64_t max_wait);

/**
 * Blocks until ChannelManager needs to be persisted. Only one listener on
 * `await_persistable_update` or `await_persistable_update_timeout` is guaranteed to be woken
 * up.
 */
void ChannelManager_await_persistable_update(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the latest best block which was connected either via the [`chain::Listen`] or
 * [`chain::Confirm`] interfaces.
 */
MUST_USE_RES struct LDKBestBlock ChannelManager_current_best_block(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Serialize the ChannelManager object into a byte array which can be read by ChannelManager_read
 */
struct LDKCVec_u8Z ChannelManager_write(const struct LDKChannelManager *NONNULL_PTR obj);

/**
 * Frees any resources used by the ChannelManagerReadArgs, if is_owned is set and inner is non-NULL.
 */
void ChannelManagerReadArgs_free(struct LDKChannelManagerReadArgs this_obj);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
const struct LDKKeysInterface *ChannelManagerReadArgs_get_keys_manager(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
void ChannelManagerReadArgs_set_keys_manager(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKKeysInterface val);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
const struct LDKFeeEstimator *ChannelManagerReadArgs_get_fee_estimator(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
void ChannelManagerReadArgs_set_fee_estimator(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKFeeEstimator val);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
const struct LDKWatch *ChannelManagerReadArgs_get_chain_monitor(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
void ChannelManagerReadArgs_set_chain_monitor(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKWatch val);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
const struct LDKBroadcasterInterface *ChannelManagerReadArgs_get_tx_broadcaster(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
void ChannelManagerReadArgs_set_tx_broadcaster(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKBroadcasterInterface val);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
const struct LDKLogger *ChannelManagerReadArgs_get_logger(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
void ChannelManagerReadArgs_set_logger(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKLogger val);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
struct LDKUserConfig ChannelManagerReadArgs_get_default_config(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
void ChannelManagerReadArgs_set_default_config(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKUserConfig val);

/**
 * Simple utility function to create a ChannelManagerReadArgs which creates the monitor
 * HashMap for you. This is primarily useful for C bindings where it is not practical to
 * populate a HashMap directly from C.
 */
MUST_USE_RES struct LDKChannelManagerReadArgs ChannelManagerReadArgs_new(struct LDKKeysInterface keys_manager, struct LDKFeeEstimator fee_estimator, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKUserConfig default_config, struct LDKCVec_ChannelMonitorZ channel_monitors);

/**
 * Read a C2Tuple_BlockHashChannelManagerZ from a byte array, created by C2Tuple_BlockHashChannelManagerZ_write
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ C2Tuple_BlockHashChannelManagerZ_read(struct LDKu8slice ser, struct LDKChannelManagerReadArgs arg);

/**
 * Frees any resources used by the DecodeError, if is_owned is set and inner is non-NULL.
 */
void DecodeError_free(struct LDKDecodeError this_obj);

/**
 * Creates a copy of the DecodeError
 */
struct LDKDecodeError DecodeError_clone(const struct LDKDecodeError *NONNULL_PTR orig);

/**
 * Frees any resources used by the Init, if is_owned is set and inner is non-NULL.
 */
void Init_free(struct LDKInit this_obj);

/**
 * The relevant features which the sender supports
 */
struct LDKInitFeatures Init_get_features(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * The relevant features which the sender supports
 */
void Init_set_features(struct LDKInit *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * Constructs a new Init given each field
 */
MUST_USE_RES struct LDKInit Init_new(struct LDKInitFeatures features_arg);

/**
 * Creates a copy of the Init
 */
struct LDKInit Init_clone(const struct LDKInit *NONNULL_PTR orig);

/**
 * Frees any resources used by the ErrorMessage, if is_owned is set and inner is non-NULL.
 */
void ErrorMessage_free(struct LDKErrorMessage this_obj);

/**
 * The channel ID involved in the error
 */
const uint8_t (*ErrorMessage_get_channel_id(const struct LDKErrorMessage *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID involved in the error
 */
void ErrorMessage_set_channel_id(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A possibly human-readable error description.
 * The string should be sanitized before it is used (e.g. emitted to logs
 * or printed to stdout).  Otherwise, a well crafted error message may trigger a security
 * vulnerability in the terminal emulator or the logging subsystem.
 */
struct LDKStr ErrorMessage_get_data(const struct LDKErrorMessage *NONNULL_PTR this_ptr);

/**
 * A possibly human-readable error description.
 * The string should be sanitized before it is used (e.g. emitted to logs
 * or printed to stdout).  Otherwise, a well crafted error message may trigger a security
 * vulnerability in the terminal emulator or the logging subsystem.
 */
void ErrorMessage_set_data(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new ErrorMessage given each field
 */
MUST_USE_RES struct LDKErrorMessage ErrorMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);

/**
 * Creates a copy of the ErrorMessage
 */
struct LDKErrorMessage ErrorMessage_clone(const struct LDKErrorMessage *NONNULL_PTR orig);

/**
 * Frees any resources used by the Ping, if is_owned is set and inner is non-NULL.
 */
void Ping_free(struct LDKPing this_obj);

/**
 * The desired response length
 */
uint16_t Ping_get_ponglen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The desired response length
 */
void Ping_set_ponglen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The ping packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Ping_get_byteslen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The ping packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Ping_set_byteslen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Ping given each field
 */
MUST_USE_RES struct LDKPing Ping_new(uint16_t ponglen_arg, uint16_t byteslen_arg);

/**
 * Creates a copy of the Ping
 */
struct LDKPing Ping_clone(const struct LDKPing *NONNULL_PTR orig);

/**
 * Frees any resources used by the Pong, if is_owned is set and inner is non-NULL.
 */
void Pong_free(struct LDKPong this_obj);

/**
 * The pong packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Pong_get_byteslen(const struct LDKPong *NONNULL_PTR this_ptr);

/**
 * The pong packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Pong_set_byteslen(struct LDKPong *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Pong given each field
 */
MUST_USE_RES struct LDKPong Pong_new(uint16_t byteslen_arg);

/**
 * Creates a copy of the Pong
 */
struct LDKPong Pong_clone(const struct LDKPong *NONNULL_PTR orig);

/**
 * Frees any resources used by the OpenChannel, if is_owned is set and inner is non-NULL.
 */
void OpenChannel_free(struct LDKOpenChannel this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*OpenChannel_get_chain_hash(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void OpenChannel_set_chain_hash(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*OpenChannel_get_temporary_channel_id(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void OpenChannel_set_temporary_channel_id(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The channel value
 */
uint64_t OpenChannel_get_funding_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel value
 */
void OpenChannel_set_funding_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
uint64_t OpenChannel_get_push_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
void OpenChannel_set_push_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t OpenChannel_get_dust_limit_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void OpenChannel_set_dust_limit_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t OpenChannel_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void OpenChannel_set_max_htlc_value_in_flight_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t OpenChannel_get_channel_reserve_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void OpenChannel_set_channel_reserve_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t OpenChannel_get_htlc_minimum_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void OpenChannel_set_htlc_minimum_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
 */
uint32_t OpenChannel_get_feerate_per_kw(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
 */
void OpenChannel_set_feerate_per_kw(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t OpenChannel_get_to_self_delay(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void OpenChannel_set_to_self_delay(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t OpenChannel_get_max_accepted_htlcs(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void OpenChannel_set_max_accepted_htlcs(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey OpenChannel_get_funding_pubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void OpenChannel_set_funding_pubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_revocation_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void OpenChannel_set_revocation_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_payment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void OpenChannel_set_payment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey OpenChannel_get_delayed_payment_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void OpenChannel_set_delayed_payment_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender
 */
struct LDKPublicKey OpenChannel_get_htlc_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender
 */
void OpenChannel_set_htlc_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey OpenChannel_get_first_per_commitment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void OpenChannel_set_first_per_commitment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Channel flags
 */
uint8_t OpenChannel_get_channel_flags(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void OpenChannel_set_channel_flags(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint8_t val);

/**
 * Creates a copy of the OpenChannel
 */
struct LDKOpenChannel OpenChannel_clone(const struct LDKOpenChannel *NONNULL_PTR orig);

/**
 * Frees any resources used by the AcceptChannel, if is_owned is set and inner is non-NULL.
 */
void AcceptChannel_free(struct LDKAcceptChannel this_obj);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*AcceptChannel_get_temporary_channel_id(const struct LDKAcceptChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void AcceptChannel_set_temporary_channel_id(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t AcceptChannel_get_dust_limit_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void AcceptChannel_set_dust_limit_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void AcceptChannel_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t AcceptChannel_get_channel_reserve_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void AcceptChannel_set_channel_reserve_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_htlc_minimum_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void AcceptChannel_set_htlc_minimum_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
uint32_t AcceptChannel_get_minimum_depth(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
void AcceptChannel_set_minimum_depth(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t AcceptChannel_get_to_self_delay(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void AcceptChannel_set_to_self_delay(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t AcceptChannel_get_max_accepted_htlcs(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void AcceptChannel_set_max_accepted_htlcs(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey AcceptChannel_get_funding_pubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void AcceptChannel_set_funding_pubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_revocation_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void AcceptChannel_set_revocation_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_payment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_payment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void AcceptChannel_set_delayed_payment_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_htlc_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_htlc_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey AcceptChannel_get_first_per_commitment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void AcceptChannel_set_first_per_commitment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Creates a copy of the AcceptChannel
 */
struct LDKAcceptChannel AcceptChannel_clone(const struct LDKAcceptChannel *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingCreated, if is_owned is set and inner is non-NULL.
 */
void FundingCreated_free(struct LDKFundingCreated this_obj);

/**
 * A temporary channel ID, until the funding is established
 */
const uint8_t (*FundingCreated_get_temporary_channel_id(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding is established
 */
void FundingCreated_set_temporary_channel_id(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The funding transaction ID
 */
const uint8_t (*FundingCreated_get_funding_txid(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * The funding transaction ID
 */
void FundingCreated_set_funding_txid(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The specific output index funding this channel
 */
uint16_t FundingCreated_get_funding_output_index(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The specific output index funding this channel
 */
void FundingCreated_set_funding_output_index(struct LDKFundingCreated *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The signature of the channel initiator (funder) on the funding transaction
 */
struct LDKSignature FundingCreated_get_signature(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The signature of the channel initiator (funder) on the funding transaction
 */
void FundingCreated_set_signature(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new FundingCreated given each field
 */
MUST_USE_RES struct LDKFundingCreated FundingCreated_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, struct LDKThirtyTwoBytes funding_txid_arg, uint16_t funding_output_index_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the FundingCreated
 */
struct LDKFundingCreated FundingCreated_clone(const struct LDKFundingCreated *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingSigned, if is_owned is set and inner is non-NULL.
 */
void FundingSigned_free(struct LDKFundingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*FundingSigned_get_channel_id(const struct LDKFundingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void FundingSigned_set_channel_id(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The signature of the channel acceptor (fundee) on the funding transaction
 */
struct LDKSignature FundingSigned_get_signature(const struct LDKFundingSigned *NONNULL_PTR this_ptr);

/**
 * The signature of the channel acceptor (fundee) on the funding transaction
 */
void FundingSigned_set_signature(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new FundingSigned given each field
 */
MUST_USE_RES struct LDKFundingSigned FundingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the FundingSigned
 */
struct LDKFundingSigned FundingSigned_clone(const struct LDKFundingSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingLocked, if is_owned is set and inner is non-NULL.
 */
void FundingLocked_free(struct LDKFundingLocked this_obj);

/**
 * The channel ID
 */
const uint8_t (*FundingLocked_get_channel_id(const struct LDKFundingLocked *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void FundingLocked_set_channel_id(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The per-commitment point of the second commitment transaction
 */
struct LDKPublicKey FundingLocked_get_next_per_commitment_point(const struct LDKFundingLocked *NONNULL_PTR this_ptr);

/**
 * The per-commitment point of the second commitment transaction
 */
void FundingLocked_set_next_per_commitment_point(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new FundingLocked given each field
 */
MUST_USE_RES struct LDKFundingLocked FundingLocked_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKPublicKey next_per_commitment_point_arg);

/**
 * Creates a copy of the FundingLocked
 */
struct LDKFundingLocked FundingLocked_clone(const struct LDKFundingLocked *NONNULL_PTR orig);

/**
 * Frees any resources used by the Shutdown, if is_owned is set and inner is non-NULL.
 */
void Shutdown_free(struct LDKShutdown this_obj);

/**
 * The channel ID
 */
const uint8_t (*Shutdown_get_channel_id(const struct LDKShutdown *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void Shutdown_set_channel_id(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The destination of this peer's funds on closing.
 * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
 */
struct LDKu8slice Shutdown_get_scriptpubkey(const struct LDKShutdown *NONNULL_PTR this_ptr);

/**
 * The destination of this peer's funds on closing.
 * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
 */
void Shutdown_set_scriptpubkey(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new Shutdown given each field
 */
MUST_USE_RES struct LDKShutdown Shutdown_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z scriptpubkey_arg);

/**
 * Creates a copy of the Shutdown
 */
struct LDKShutdown Shutdown_clone(const struct LDKShutdown *NONNULL_PTR orig);

/**
 * Frees any resources used by the ClosingSigned, if is_owned is set and inner is non-NULL.
 */
void ClosingSigned_free(struct LDKClosingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*ClosingSigned_get_channel_id(const struct LDKClosingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ClosingSigned_set_channel_id(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The proposed total fee for the closing transaction
 */
uint64_t ClosingSigned_get_fee_satoshis(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * The proposed total fee for the closing transaction
 */
void ClosingSigned_set_fee_satoshis(struct LDKClosingSigned *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature on the closing transaction
 */
struct LDKSignature ClosingSigned_get_signature(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the closing transaction
 */
void ClosingSigned_set_signature(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new ClosingSigned given each field
 */
MUST_USE_RES struct LDKClosingSigned ClosingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t fee_satoshis_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the ClosingSigned
 */
struct LDKClosingSigned ClosingSigned_clone(const struct LDKClosingSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateAddHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateAddHTLC_free(struct LDKUpdateAddHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateAddHTLC_get_channel_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateAddHTLC_set_channel_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateAddHTLC_get_htlc_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateAddHTLC_set_htlc_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The HTLC value in milli-satoshi
 */
uint64_t UpdateAddHTLC_get_amount_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC value in milli-satoshi
 */
void UpdateAddHTLC_set_amount_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
const uint8_t (*UpdateAddHTLC_get_payment_hash(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
void UpdateAddHTLC_set_payment_hash(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The expiry height of the HTLC
 */
uint32_t UpdateAddHTLC_get_cltv_expiry(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The expiry height of the HTLC
 */
void UpdateAddHTLC_set_cltv_expiry(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the UpdateAddHTLC
 */
struct LDKUpdateAddHTLC UpdateAddHTLC_clone(const struct LDKUpdateAddHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFulfillHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFulfillHTLC_free(struct LDKUpdateFulfillHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFulfillHTLC_get_channel_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFulfillHTLC_set_channel_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFulfillHTLC_get_htlc_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFulfillHTLC_set_htlc_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
const uint8_t (*UpdateFulfillHTLC_get_payment_preimage(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
void UpdateFulfillHTLC_set_payment_preimage(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new UpdateFulfillHTLC given each field
 */
MUST_USE_RES struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t htlc_id_arg, struct LDKThirtyTwoBytes payment_preimage_arg);

/**
 * Creates a copy of the UpdateFulfillHTLC
 */
struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(const struct LDKUpdateFulfillHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFailHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailHTLC_free(struct LDKUpdateFailHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailHTLC_get_channel_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailHTLC_set_channel_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailHTLC_get_htlc_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailHTLC_set_htlc_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the UpdateFailHTLC
 */
struct LDKUpdateFailHTLC UpdateFailHTLC_clone(const struct LDKUpdateFailHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFailMalformedHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailMalformedHTLC_free(struct LDKUpdateFailMalformedHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailMalformedHTLC_get_channel_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailMalformedHTLC_set_channel_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailMalformedHTLC_get_htlc_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailMalformedHTLC_set_htlc_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The failure code
 */
uint16_t UpdateFailMalformedHTLC_get_failure_code(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The failure code
 */
void UpdateFailMalformedHTLC_set_failure_code(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Creates a copy of the UpdateFailMalformedHTLC
 */
struct LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the CommitmentSigned, if is_owned is set and inner is non-NULL.
 */
void CommitmentSigned_free(struct LDKCommitmentSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*CommitmentSigned_get_channel_id(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void CommitmentSigned_set_channel_id(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A signature on the commitment transaction
 */
struct LDKSignature CommitmentSigned_get_signature(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the commitment transaction
 */
void CommitmentSigned_set_signature(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Signatures on the HTLC transactions
 */
void CommitmentSigned_set_htlc_signatures(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);

/**
 * Constructs a new CommitmentSigned given each field
 */
MUST_USE_RES struct LDKCommitmentSigned CommitmentSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg, struct LDKCVec_SignatureZ htlc_signatures_arg);

/**
 * Creates a copy of the CommitmentSigned
 */
struct LDKCommitmentSigned CommitmentSigned_clone(const struct LDKCommitmentSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the RevokeAndACK, if is_owned is set and inner is non-NULL.
 */
void RevokeAndACK_free(struct LDKRevokeAndACK this_obj);

/**
 * The channel ID
 */
const uint8_t (*RevokeAndACK_get_channel_id(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void RevokeAndACK_set_channel_id(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The secret corresponding to the per-commitment point
 */
const uint8_t (*RevokeAndACK_get_per_commitment_secret(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The secret corresponding to the per-commitment point
 */
void RevokeAndACK_set_per_commitment_secret(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
struct LDKPublicKey RevokeAndACK_get_next_per_commitment_point(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
void RevokeAndACK_set_next_per_commitment_point(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new RevokeAndACK given each field
 */
MUST_USE_RES struct LDKRevokeAndACK RevokeAndACK_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes per_commitment_secret_arg, struct LDKPublicKey next_per_commitment_point_arg);

/**
 * Creates a copy of the RevokeAndACK
 */
struct LDKRevokeAndACK RevokeAndACK_clone(const struct LDKRevokeAndACK *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFee, if is_owned is set and inner is non-NULL.
 */
void UpdateFee_free(struct LDKUpdateFee this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFee_get_channel_id(const struct LDKUpdateFee *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFee_set_channel_id(struct LDKUpdateFee *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Fee rate per 1000-weight of the transaction
 */
uint32_t UpdateFee_get_feerate_per_kw(const struct LDKUpdateFee *NONNULL_PTR this_ptr);

/**
 * Fee rate per 1000-weight of the transaction
 */
void UpdateFee_set_feerate_per_kw(struct LDKUpdateFee *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new UpdateFee given each field
 */
MUST_USE_RES struct LDKUpdateFee UpdateFee_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t feerate_per_kw_arg);

/**
 * Creates a copy of the UpdateFee
 */
struct LDKUpdateFee UpdateFee_clone(const struct LDKUpdateFee *NONNULL_PTR orig);

/**
 * Frees any resources used by the DataLossProtect, if is_owned is set and inner is non-NULL.
 */
void DataLossProtect_free(struct LDKDataLossProtect this_obj);

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
const uint8_t (*DataLossProtect_get_your_last_per_commitment_secret(const struct LDKDataLossProtect *NONNULL_PTR this_ptr))[32];

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
void DataLossProtect_set_your_last_per_commitment_secret(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
struct LDKPublicKey DataLossProtect_get_my_current_per_commitment_point(const struct LDKDataLossProtect *NONNULL_PTR this_ptr);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
void DataLossProtect_set_my_current_per_commitment_point(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new DataLossProtect given each field
 */
MUST_USE_RES struct LDKDataLossProtect DataLossProtect_new(struct LDKThirtyTwoBytes your_last_per_commitment_secret_arg, struct LDKPublicKey my_current_per_commitment_point_arg);

/**
 * Creates a copy of the DataLossProtect
 */
struct LDKDataLossProtect DataLossProtect_clone(const struct LDKDataLossProtect *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelReestablish, if is_owned is set and inner is non-NULL.
 */
void ChannelReestablish_free(struct LDKChannelReestablish this_obj);

/**
 * The channel ID
 */
const uint8_t (*ChannelReestablish_get_channel_id(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ChannelReestablish_set_channel_id(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next commitment number for the sender
 */
uint64_t ChannelReestablish_get_next_local_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the sender
 */
void ChannelReestablish_set_next_local_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The next commitment number for the recipient
 */
uint64_t ChannelReestablish_get_next_remote_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the recipient
 */
void ChannelReestablish_set_next_remote_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelReestablish
 */
struct LDKChannelReestablish ChannelReestablish_clone(const struct LDKChannelReestablish *NONNULL_PTR orig);

/**
 * Frees any resources used by the AnnouncementSignatures, if is_owned is set and inner is non-NULL.
 */
void AnnouncementSignatures_free(struct LDKAnnouncementSignatures this_obj);

/**
 * The channel ID
 */
const uint8_t (*AnnouncementSignatures_get_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void AnnouncementSignatures_set_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t AnnouncementSignatures_get_short_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void AnnouncementSignatures_set_short_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature by the node key
 */
struct LDKSignature AnnouncementSignatures_get_node_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the node key
 */
void AnnouncementSignatures_set_node_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * A signature by the funding key
 */
struct LDKSignature AnnouncementSignatures_get_bitcoin_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the funding key
 */
void AnnouncementSignatures_set_bitcoin_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new AnnouncementSignatures given each field
 */
MUST_USE_RES struct LDKAnnouncementSignatures AnnouncementSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t short_channel_id_arg, struct LDKSignature node_signature_arg, struct LDKSignature bitcoin_signature_arg);

/**
 * Creates a copy of the AnnouncementSignatures
 */
struct LDKAnnouncementSignatures AnnouncementSignatures_clone(const struct LDKAnnouncementSignatures *NONNULL_PTR orig);

/**
 * Frees any resources used by the NetAddress
 */
void NetAddress_free(struct LDKNetAddress this_ptr);

/**
 * Creates a copy of the NetAddress
 */
struct LDKNetAddress NetAddress_clone(const struct LDKNetAddress *NONNULL_PTR orig);

/**
 * Serialize the NetAddress object into a byte array which can be read by NetAddress_read
 */
struct LDKCVec_u8Z NetAddress_write(const struct LDKNetAddress *NONNULL_PTR obj);

/**
 * Read a Result from a byte array, created by Result_write
 */
struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ Result_read(struct LDKu8slice ser);

/**
 * Read a NetAddress from a byte array, created by NetAddress_write
 */
struct LDKCResult_NetAddressDecodeErrorZ NetAddress_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UnsignedNodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedNodeAnnouncement_free(struct LDKUnsignedNodeAnnouncement this_obj);

/**
 * The advertised features
 */
struct LDKNodeFeatures UnsignedNodeAnnouncement_get_features(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised features
 */
void UnsignedNodeAnnouncement_set_features(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
uint32_t UnsignedNodeAnnouncement_get_timestamp(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
void UnsignedNodeAnnouncement_set_timestamp(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The node_id this announcement originated from (don't rebroadcast the node_announcement back
 * to this node).
 */
struct LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The node_id this announcement originated from (don't rebroadcast the node_announcement back
 * to this node).
 */
void UnsignedNodeAnnouncement_set_node_id(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * An RGB color for UI purposes
 */
const uint8_t (*UnsignedNodeAnnouncement_get_rgb(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[3];

/**
 * An RGB color for UI purposes
 */
void UnsignedNodeAnnouncement_set_rgb(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
 * of uniqueness.
 */
const uint8_t (*UnsignedNodeAnnouncement_get_alias(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
 * of uniqueness.
 */
void UnsignedNodeAnnouncement_set_alias(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * List of addresses on which this node is reachable
 */
void UnsignedNodeAnnouncement_set_addresses(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);

/**
 * Creates a copy of the UnsignedNodeAnnouncement
 */
struct LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the NodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncement_free(struct LDKNodeAnnouncement this_obj);

/**
 * The signature by the node key
 */
struct LDKSignature NodeAnnouncement_get_signature(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The signature by the node key
 */
void NodeAnnouncement_set_signature(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual content of the announcement
 */
struct LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual content of the announcement
 */
void NodeAnnouncement_set_contents(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncement given each field
 */
MUST_USE_RES struct LDKNodeAnnouncement NodeAnnouncement_new(struct LDKSignature signature_arg, struct LDKUnsignedNodeAnnouncement contents_arg);

/**
 * Creates a copy of the NodeAnnouncement
 */
struct LDKNodeAnnouncement NodeAnnouncement_clone(const struct LDKNodeAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the UnsignedChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelAnnouncement_free(struct LDKUnsignedChannelAnnouncement this_obj);

/**
 * The advertised channel features
 */
struct LDKChannelFeatures UnsignedChannelAnnouncement_get_features(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised channel features
 */
void UnsignedChannelAnnouncement_set_features(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelAnnouncement_get_chain_hash(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelAnnouncement_set_chain_hash(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelAnnouncement_get_short_channel_id(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelAnnouncement_set_short_channel_id(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, uint64_t val);

/**
 * One of the two node_ids which are endpoints of this channel
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * One of the two node_ids which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The other of the two node_ids which are endpoints of this channel
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The other of the two node_ids which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The funding key for the first node
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the first node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The funding key for the second node
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the second node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Creates a copy of the UnsignedChannelAnnouncement
 */
struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void ChannelAnnouncement_free(struct LDKChannelAnnouncement this_obj);

/**
 * Authentication of the announcement by the first public node
 */
struct LDKSignature ChannelAnnouncement_get_node_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the first public node
 */
void ChannelAnnouncement_set_node_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Authentication of the announcement by the second public node
 */
struct LDKSignature ChannelAnnouncement_get_node_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the second public node
 */
void ChannelAnnouncement_set_node_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Proof of funding UTXO ownership by the first public node
 */
struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the first public node
 */
void ChannelAnnouncement_set_bitcoin_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Proof of funding UTXO ownership by the second public node
 */
struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the second public node
 */
void ChannelAnnouncement_set_bitcoin_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual announcement
 */
struct LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual announcement
 */
void ChannelAnnouncement_set_contents(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedChannelAnnouncement val);

/**
 * Constructs a new ChannelAnnouncement given each field
 */
MUST_USE_RES struct LDKChannelAnnouncement ChannelAnnouncement_new(struct LDKSignature node_signature_1_arg, struct LDKSignature node_signature_2_arg, struct LDKSignature bitcoin_signature_1_arg, struct LDKSignature bitcoin_signature_2_arg, struct LDKUnsignedChannelAnnouncement contents_arg);

/**
 * Creates a copy of the ChannelAnnouncement
 */
struct LDKChannelAnnouncement ChannelAnnouncement_clone(const struct LDKChannelAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the UnsignedChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelUpdate_free(struct LDKUnsignedChannelUpdate this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelUpdate_get_chain_hash(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelUpdate_set_chain_hash(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelUpdate_get_short_channel_id(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelUpdate_set_short_channel_id(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
uint32_t UnsignedChannelUpdate_get_timestamp(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
void UnsignedChannelUpdate_set_timestamp(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Channel flags
 */
uint8_t UnsignedChannelUpdate_get_flags(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void UnsignedChannelUpdate_set_flags(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint8_t val);

/**
 * The number of blocks such that if:
 * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
 * then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
 * the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
 * cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
 * then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
 * forwarding. Note that the HTLC sender is the one who originally sets this value when
 * constructing the route.
 */
uint16_t UnsignedChannelUpdate_get_cltv_expiry_delta(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The number of blocks such that if:
 * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
 * then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
 * the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
 * cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
 * then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
 * forwarding. Note that the HTLC sender is the one who originally sets this value when
 * constructing the route.
 */
void UnsignedChannelUpdate_set_cltv_expiry_delta(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t UnsignedChannelUpdate_get_htlc_minimum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_htlc_minimum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_base_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_fee_base_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_proportional_millionths(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
void UnsignedChannelUpdate_set_fee_proportional_millionths(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the UnsignedChannelUpdate
 */
struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(const struct LDKUnsignedChannelUpdate *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelUpdate_free(struct LDKChannelUpdate this_obj);

/**
 * A signature of the channel update
 */
struct LDKSignature ChannelUpdate_get_signature(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A signature of the channel update
 */
void ChannelUpdate_set_signature(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual channel update
 */
struct LDKUnsignedChannelUpdate ChannelUpdate_get_contents(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The actual channel update
 */
void ChannelUpdate_set_contents(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKUnsignedChannelUpdate val);

/**
 * Constructs a new ChannelUpdate given each field
 */
MUST_USE_RES struct LDKChannelUpdate ChannelUpdate_new(struct LDKSignature signature_arg, struct LDKUnsignedChannelUpdate contents_arg);

/**
 * Creates a copy of the ChannelUpdate
 */
struct LDKChannelUpdate ChannelUpdate_clone(const struct LDKChannelUpdate *NONNULL_PTR orig);

/**
 * Frees any resources used by the QueryChannelRange, if is_owned is set and inner is non-NULL.
 */
void QueryChannelRange_free(struct LDKQueryChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryChannelRange_get_chain_hash(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryChannelRange_set_chain_hash(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block for the channel UTXOs being queried
 */
uint32_t QueryChannelRange_get_first_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block for the channel UTXOs being queried
 */
void QueryChannelRange_set_first_blocknum(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks to include in the query results
 */
uint32_t QueryChannelRange_get_number_of_blocks(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks to include in the query results
 */
void QueryChannelRange_set_number_of_blocks(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new QueryChannelRange given each field
 */
MUST_USE_RES struct LDKQueryChannelRange QueryChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg);

/**
 * Creates a copy of the QueryChannelRange
 */
struct LDKQueryChannelRange QueryChannelRange_clone(const struct LDKQueryChannelRange *NONNULL_PTR orig);

/**
 * Frees any resources used by the ReplyChannelRange, if is_owned is set and inner is non-NULL.
 */
void ReplyChannelRange_free(struct LDKReplyChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*ReplyChannelRange_get_chain_hash(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void ReplyChannelRange_set_chain_hash(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block in the range of the reply
 */
uint32_t ReplyChannelRange_get_first_blocknum(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block in the range of the reply
 */
void ReplyChannelRange_set_first_blocknum(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks included in the range of the reply
 */
uint32_t ReplyChannelRange_get_number_of_blocks(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks included in the range of the reply
 */
void ReplyChannelRange_set_number_of_blocks(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * True when this is the final reply for a query
 */
bool ReplyChannelRange_get_sync_complete(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * True when this is the final reply for a query
 */
void ReplyChannelRange_set_sync_complete(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, bool val);

/**
 * The short_channel_ids in the channel range
 */
void ReplyChannelRange_set_short_channel_ids(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new ReplyChannelRange given each field
 */
MUST_USE_RES struct LDKReplyChannelRange ReplyChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg, bool sync_complete_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the ReplyChannelRange
 */
struct LDKReplyChannelRange ReplyChannelRange_clone(const struct LDKReplyChannelRange *NONNULL_PTR orig);

/**
 * Frees any resources used by the QueryShortChannelIds, if is_owned is set and inner is non-NULL.
 */
void QueryShortChannelIds_free(struct LDKQueryShortChannelIds this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryShortChannelIds_get_chain_hash(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryShortChannelIds_set_chain_hash(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short_channel_ids that are being queried
 */
void QueryShortChannelIds_set_short_channel_ids(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new QueryShortChannelIds given each field
 */
MUST_USE_RES struct LDKQueryShortChannelIds QueryShortChannelIds_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the QueryShortChannelIds
 */
struct LDKQueryShortChannelIds QueryShortChannelIds_clone(const struct LDKQueryShortChannelIds *NONNULL_PTR orig);

/**
 * Frees any resources used by the ReplyShortChannelIdsEnd, if is_owned is set and inner is non-NULL.
 */
void ReplyShortChannelIdsEnd_free(struct LDKReplyShortChannelIdsEnd this_obj);

/**
 * The genesis hash of the blockchain that was queried
 */
const uint8_t (*ReplyShortChannelIdsEnd_get_chain_hash(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain that was queried
 */
void ReplyShortChannelIdsEnd_set_chain_hash(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the chain_hash
 */
bool ReplyShortChannelIdsEnd_get_full_information(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the chain_hash
 */
void ReplyShortChannelIdsEnd_set_full_information(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ReplyShortChannelIdsEnd given each field
 */
MUST_USE_RES struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(struct LDKThirtyTwoBytes chain_hash_arg, bool full_information_arg);

/**
 * Creates a copy of the ReplyShortChannelIdsEnd
 */
struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR orig);

/**
 * Frees any resources used by the GossipTimestampFilter, if is_owned is set and inner is non-NULL.
 */
void GossipTimestampFilter_free(struct LDKGossipTimestampFilter this_obj);

/**
 * The genesis hash of the blockchain for channel and node information
 */
const uint8_t (*GossipTimestampFilter_get_chain_hash(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain for channel and node information
 */
void GossipTimestampFilter_set_chain_hash(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The starting unix timestamp
 */
uint32_t GossipTimestampFilter_get_first_timestamp(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The starting unix timestamp
 */
void GossipTimestampFilter_set_first_timestamp(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The range of information in seconds
 */
uint32_t GossipTimestampFilter_get_timestamp_range(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The range of information in seconds
 */
void GossipTimestampFilter_set_timestamp_range(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new GossipTimestampFilter given each field
 */
MUST_USE_RES struct LDKGossipTimestampFilter GossipTimestampFilter_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_timestamp_arg, uint32_t timestamp_range_arg);

/**
 * Creates a copy of the GossipTimestampFilter
 */
struct LDKGossipTimestampFilter GossipTimestampFilter_clone(const struct LDKGossipTimestampFilter *NONNULL_PTR orig);

/**
 * Frees any resources used by the ErrorAction
 */
void ErrorAction_free(struct LDKErrorAction this_ptr);

/**
 * Creates a copy of the ErrorAction
 */
struct LDKErrorAction ErrorAction_clone(const struct LDKErrorAction *NONNULL_PTR orig);

/**
 * Frees any resources used by the LightningError, if is_owned is set and inner is non-NULL.
 */
void LightningError_free(struct LDKLightningError this_obj);

/**
 * A human-readable message describing the error
 */
struct LDKStr LightningError_get_err(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * A human-readable message describing the error
 */
void LightningError_set_err(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The action which should be taken against the offending peer.
 */
struct LDKErrorAction LightningError_get_action(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * The action which should be taken against the offending peer.
 */
void LightningError_set_action(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKErrorAction val);

/**
 * Constructs a new LightningError given each field
 */
MUST_USE_RES struct LDKLightningError LightningError_new(struct LDKStr err_arg, struct LDKErrorAction action_arg);

/**
 * Creates a copy of the LightningError
 */
struct LDKLightningError LightningError_clone(const struct LDKLightningError *NONNULL_PTR orig);

/**
 * Frees any resources used by the CommitmentUpdate, if is_owned is set and inner is non-NULL.
 */
void CommitmentUpdate_free(struct LDKCommitmentUpdate this_obj);

/**
 * update_add_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_add_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateAddHTLCZ val);

/**
 * update_fulfill_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fulfill_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFulfillHTLCZ val);

/**
 * update_fail_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fail_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailHTLCZ val);

/**
 * update_fail_malformed_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fail_malformed_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailMalformedHTLCZ val);

/**
 * An update_fee message which should be sent
 */
struct LDKUpdateFee CommitmentUpdate_get_update_fee(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * An update_fee message which should be sent
 */
void CommitmentUpdate_set_update_fee(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKUpdateFee val);

/**
 * Finally, the commitment_signed message which should be sent
 */
struct LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * Finally, the commitment_signed message which should be sent
 */
void CommitmentUpdate_set_commitment_signed(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCommitmentSigned val);

/**
 * Constructs a new CommitmentUpdate given each field
 */
MUST_USE_RES struct LDKCommitmentUpdate CommitmentUpdate_new(struct LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, struct LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, struct LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, struct LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, struct LDKUpdateFee update_fee_arg, struct LDKCommitmentSigned commitment_signed_arg);

/**
 * Creates a copy of the CommitmentUpdate
 */
struct LDKCommitmentUpdate CommitmentUpdate_clone(const struct LDKCommitmentUpdate *NONNULL_PTR orig);

/**
 * Frees any resources used by the HTLCFailChannelUpdate
 */
void HTLCFailChannelUpdate_free(struct LDKHTLCFailChannelUpdate this_ptr);

/**
 * Creates a copy of the HTLCFailChannelUpdate
 */
struct LDKHTLCFailChannelUpdate HTLCFailChannelUpdate_clone(const struct LDKHTLCFailChannelUpdate *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void ChannelMessageHandler_free(struct LDKChannelMessageHandler this_ptr);

/**
 * Calls the free function if one is set
 */
void RoutingMessageHandler_free(struct LDKRoutingMessageHandler this_ptr);

/**
 * Serialize the AcceptChannel object into a byte array which can be read by AcceptChannel_read
 */
struct LDKCVec_u8Z AcceptChannel_write(const struct LDKAcceptChannel *NONNULL_PTR obj);

/**
 * Read a AcceptChannel from a byte array, created by AcceptChannel_write
 */
struct LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(struct LDKu8slice ser);

/**
 * Serialize the AnnouncementSignatures object into a byte array which can be read by AnnouncementSignatures_read
 */
struct LDKCVec_u8Z AnnouncementSignatures_write(const struct LDKAnnouncementSignatures *NONNULL_PTR obj);

/**
 * Read a AnnouncementSignatures from a byte array, created by AnnouncementSignatures_write
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelReestablish object into a byte array which can be read by ChannelReestablish_read
 */
struct LDKCVec_u8Z ChannelReestablish_write(const struct LDKChannelReestablish *NONNULL_PTR obj);

/**
 * Read a ChannelReestablish from a byte array, created by ChannelReestablish_write
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(struct LDKu8slice ser);

/**
 * Serialize the ClosingSigned object into a byte array which can be read by ClosingSigned_read
 */
struct LDKCVec_u8Z ClosingSigned_write(const struct LDKClosingSigned *NONNULL_PTR obj);

/**
 * Read a ClosingSigned from a byte array, created by ClosingSigned_write
 */
struct LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the CommitmentSigned object into a byte array which can be read by CommitmentSigned_read
 */
struct LDKCVec_u8Z CommitmentSigned_write(const struct LDKCommitmentSigned *NONNULL_PTR obj);

/**
 * Read a CommitmentSigned from a byte array, created by CommitmentSigned_write
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(struct LDKu8slice ser);

/**
 * Serialize the FundingCreated object into a byte array which can be read by FundingCreated_read
 */
struct LDKCVec_u8Z FundingCreated_write(const struct LDKFundingCreated *NONNULL_PTR obj);

/**
 * Read a FundingCreated from a byte array, created by FundingCreated_write
 */
struct LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(struct LDKu8slice ser);

/**
 * Serialize the FundingSigned object into a byte array which can be read by FundingSigned_read
 */
struct LDKCVec_u8Z FundingSigned_write(const struct LDKFundingSigned *NONNULL_PTR obj);

/**
 * Read a FundingSigned from a byte array, created by FundingSigned_write
 */
struct LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the FundingLocked object into a byte array which can be read by FundingLocked_read
 */
struct LDKCVec_u8Z FundingLocked_write(const struct LDKFundingLocked *NONNULL_PTR obj);

/**
 * Read a FundingLocked from a byte array, created by FundingLocked_write
 */
struct LDKCResult_FundingLockedDecodeErrorZ FundingLocked_read(struct LDKu8slice ser);

/**
 * Serialize the Init object into a byte array which can be read by Init_read
 */
struct LDKCVec_u8Z Init_write(const struct LDKInit *NONNULL_PTR obj);

/**
 * Read a Init from a byte array, created by Init_write
 */
struct LDKCResult_InitDecodeErrorZ Init_read(struct LDKu8slice ser);

/**
 * Serialize the OpenChannel object into a byte array which can be read by OpenChannel_read
 */
struct LDKCVec_u8Z OpenChannel_write(const struct LDKOpenChannel *NONNULL_PTR obj);

/**
 * Read a OpenChannel from a byte array, created by OpenChannel_write
 */
struct LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(struct LDKu8slice ser);

/**
 * Serialize the RevokeAndACK object into a byte array which can be read by RevokeAndACK_read
 */
struct LDKCVec_u8Z RevokeAndACK_write(const struct LDKRevokeAndACK *NONNULL_PTR obj);

/**
 * Read a RevokeAndACK from a byte array, created by RevokeAndACK_write
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(struct LDKu8slice ser);

/**
 * Serialize the Shutdown object into a byte array which can be read by Shutdown_read
 */
struct LDKCVec_u8Z Shutdown_write(const struct LDKShutdown *NONNULL_PTR obj);

/**
 * Read a Shutdown from a byte array, created by Shutdown_write
 */
struct LDKCResult_ShutdownDecodeErrorZ Shutdown_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailHTLC object into a byte array which can be read by UpdateFailHTLC_read
 */
struct LDKCVec_u8Z UpdateFailHTLC_write(const struct LDKUpdateFailHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailHTLC from a byte array, created by UpdateFailHTLC_write
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailMalformedHTLC object into a byte array which can be read by UpdateFailMalformedHTLC_read
 */
struct LDKCVec_u8Z UpdateFailMalformedHTLC_write(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailMalformedHTLC from a byte array, created by UpdateFailMalformedHTLC_write
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFee object into a byte array which can be read by UpdateFee_read
 */
struct LDKCVec_u8Z UpdateFee_write(const struct LDKUpdateFee *NONNULL_PTR obj);

/**
 * Read a UpdateFee from a byte array, created by UpdateFee_write
 */
struct LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFulfillHTLC object into a byte array which can be read by UpdateFulfillHTLC_read
 */
struct LDKCVec_u8Z UpdateFulfillHTLC_write(const struct LDKUpdateFulfillHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFulfillHTLC from a byte array, created by UpdateFulfillHTLC_write
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateAddHTLC object into a byte array which can be read by UpdateAddHTLC_read
 */
struct LDKCVec_u8Z UpdateAddHTLC_write(const struct LDKUpdateAddHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateAddHTLC from a byte array, created by UpdateAddHTLC_write
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the Ping object into a byte array which can be read by Ping_read
 */
struct LDKCVec_u8Z Ping_write(const struct LDKPing *NONNULL_PTR obj);

/**
 * Read a Ping from a byte array, created by Ping_write
 */
struct LDKCResult_PingDecodeErrorZ Ping_read(struct LDKu8slice ser);

/**
 * Serialize the Pong object into a byte array which can be read by Pong_read
 */
struct LDKCVec_u8Z Pong_write(const struct LDKPong *NONNULL_PTR obj);

/**
 * Read a Pong from a byte array, created by Pong_write
 */
struct LDKCResult_PongDecodeErrorZ Pong_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelAnnouncement object into a byte array which can be read by UnsignedChannelAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedChannelAnnouncement_write(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelAnnouncement from a byte array, created by UnsignedChannelAnnouncement_write
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ UnsignedChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelAnnouncement object into a byte array which can be read by ChannelAnnouncement_read
 */
struct LDKCVec_u8Z ChannelAnnouncement_write(const struct LDKChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a ChannelAnnouncement from a byte array, created by ChannelAnnouncement_write
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelUpdate object into a byte array which can be read by UnsignedChannelUpdate_read
 */
struct LDKCVec_u8Z UnsignedChannelUpdate_write(const struct LDKUnsignedChannelUpdate *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelUpdate from a byte array, created by UnsignedChannelUpdate_write
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelUpdate object into a byte array which can be read by ChannelUpdate_read
 */
struct LDKCVec_u8Z ChannelUpdate_write(const struct LDKChannelUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelUpdate from a byte array, created by ChannelUpdate_write
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ErrorMessage object into a byte array which can be read by ErrorMessage_read
 */
struct LDKCVec_u8Z ErrorMessage_write(const struct LDKErrorMessage *NONNULL_PTR obj);

/**
 * Read a ErrorMessage from a byte array, created by ErrorMessage_write
 */
struct LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedNodeAnnouncement object into a byte array which can be read by UnsignedNodeAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedNodeAnnouncement_write(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedNodeAnnouncement from a byte array, created by UnsignedNodeAnnouncement_write
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the NodeAnnouncement object into a byte array which can be read by NodeAnnouncement_read
 */
struct LDKCVec_u8Z NodeAnnouncement_write(const struct LDKNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncement from a byte array, created by NodeAnnouncement_write
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Read a QueryShortChannelIds from a byte array, created by QueryShortChannelIds_write
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(struct LDKu8slice ser);

/**
 * Serialize the QueryShortChannelIds object into a byte array which can be read by QueryShortChannelIds_read
 */
struct LDKCVec_u8Z QueryShortChannelIds_write(const struct LDKQueryShortChannelIds *NONNULL_PTR obj);

/**
 * Read a ReplyShortChannelIdsEnd from a byte array, created by ReplyShortChannelIdsEnd_write
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(struct LDKu8slice ser);

/**
 * Serialize the ReplyShortChannelIdsEnd object into a byte array which can be read by ReplyShortChannelIdsEnd_read
 */
struct LDKCVec_u8Z ReplyShortChannelIdsEnd_write(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR obj);

/**
 *\n\t * Calculates the overflow safe ending block height for the query.\n\t * Overflow returns `0xffffffff`, otherwise returns `first_blocknum + number_of_blocks`\n\t
 */
MUST_USE_RES uint32_t QueryChannelRange_end_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_arg);

/**
 * Read a QueryChannelRange from a byte array, created by QueryChannelRange_write
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(struct LDKu8slice ser);

/**
 * Serialize the QueryChannelRange object into a byte array which can be read by QueryChannelRange_read
 */
struct LDKCVec_u8Z QueryChannelRange_write(const struct LDKQueryChannelRange *NONNULL_PTR obj);

/**
 * Read a ReplyChannelRange from a byte array, created by ReplyChannelRange_write
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(struct LDKu8slice ser);

/**
 * Serialize the ReplyChannelRange object into a byte array which can be read by ReplyChannelRange_read
 */
struct LDKCVec_u8Z ReplyChannelRange_write(const struct LDKReplyChannelRange *NONNULL_PTR obj);

/**
 * Read a GossipTimestampFilter from a byte array, created by GossipTimestampFilter_write
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(struct LDKu8slice ser);

/**
 * Serialize the GossipTimestampFilter object into a byte array which can be read by GossipTimestampFilter_read
 */
struct LDKCVec_u8Z GossipTimestampFilter_write(const struct LDKGossipTimestampFilter *NONNULL_PTR obj);

/**
 * Frees any resources used by the IgnoringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void IgnoringMessageHandler_free(struct LDKIgnoringMessageHandler this_obj);

/**
 * Constructs a new IgnoringMessageHandler given each field
 */
MUST_USE_RES struct LDKIgnoringMessageHandler IgnoringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider IgnoringMessageHandler_as_MessageSendEventsProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ErroringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void ErroringMessageHandler_free(struct LDKErroringMessageHandler this_obj);

/**
 * Constructs a new ErroringMessageHandler
 */
MUST_USE_RES struct LDKErroringMessageHandler ErroringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ErroringMessageHandler_as_MessageSendEventsProvider(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the MessageHandler, if is_owned is set and inner is non-NULL.
 */
void MessageHandler_free(struct LDKMessageHandler this_obj);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * [`ChannelManager`] object or an [`ErroringMessageHandler`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
const struct LDKChannelMessageHandler *MessageHandler_get_chan_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * [`ChannelManager`] object or an [`ErroringMessageHandler`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
void MessageHandler_set_chan_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKChannelMessageHandler val);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a [`NetGraphMsgHandler`] object or an
 * [`IgnoringMessageHandler`].
 *
 * [`NetGraphMsgHandler`]: crate::routing::network_graph::NetGraphMsgHandler
 */
const struct LDKRoutingMessageHandler *MessageHandler_get_route_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a [`NetGraphMsgHandler`] object or an
 * [`IgnoringMessageHandler`].
 *
 * [`NetGraphMsgHandler`]: crate::routing::network_graph::NetGraphMsgHandler
 */
void MessageHandler_set_route_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKRoutingMessageHandler val);

/**
 * Constructs a new MessageHandler given each field
 */
MUST_USE_RES struct LDKMessageHandler MessageHandler_new(struct LDKChannelMessageHandler chan_handler_arg, struct LDKRoutingMessageHandler route_handler_arg);

/**
 * Creates a copy of a SocketDescriptor
 */
struct LDKSocketDescriptor SocketDescriptor_clone(const struct LDKSocketDescriptor *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void SocketDescriptor_free(struct LDKSocketDescriptor this_ptr);

/**
 * Frees any resources used by the PeerHandleError, if is_owned is set and inner is non-NULL.
 */
void PeerHandleError_free(struct LDKPeerHandleError this_obj);

/**
 * Used to indicate that we probably can't make any future connections to this peer, implying
 * we should go ahead and force-close any channels we have with it.
 */
bool PeerHandleError_get_no_connection_possible(const struct LDKPeerHandleError *NONNULL_PTR this_ptr);

/**
 * Used to indicate that we probably can't make any future connections to this peer, implying
 * we should go ahead and force-close any channels we have with it.
 */
void PeerHandleError_set_no_connection_possible(struct LDKPeerHandleError *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new PeerHandleError given each field
 */
MUST_USE_RES struct LDKPeerHandleError PeerHandleError_new(bool no_connection_possible_arg);

/**
 * Creates a copy of the PeerHandleError
 */
struct LDKPeerHandleError PeerHandleError_clone(const struct LDKPeerHandleError *NONNULL_PTR orig);

/**
 * Frees any resources used by the PeerManager, if is_owned is set and inner is non-NULL.
 */
void PeerManager_free(struct LDKPeerManager this_obj);

/**
 * Constructs a new PeerManager with the given message handlers and node_id secret key
 * ephemeral_random_data is used to derive per-connection ephemeral keys and must be
 * cryptographically secure random bytes.
 */
MUST_USE_RES struct LDKPeerManager PeerManager_new(struct LDKMessageHandler message_handler, struct LDKSecretKey our_node_secret, const uint8_t (*ephemeral_random_data)[32], struct LDKLogger logger);

/**
 * Get the list of node ids for peers which have completed the initial handshake.
 *
 * For outbound connections, this will be the same as the their_node_id parameter passed in to
 * new_outbound_connection, however entries will only appear once the initial handshake has
 * completed and we are sure the remote peer has the private key for the given node_id.
 */
MUST_USE_RES struct LDKCVec_PublicKeyZ PeerManager_get_peer_node_ids(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates a new outbound connection has been established to a node with the given node_id.
 * Note that if an Err is returned here you MUST NOT call socket_disconnected for the new
 * descriptor but must disconnect the connection immediately.
 *
 * Returns a small number of bytes to send to the remote node (currently always 50).
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet been
 * [`socket_disconnected()`].
 *
 * [`socket_disconnected()`]: PeerManager::socket_disconnected
 */
MUST_USE_RES struct LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKSocketDescriptor descriptor);

/**
 * Indicates a new inbound connection has been established.
 *
 * May refuse the connection by returning an Err, but will never write bytes to the remote end
 * (outbound connector always speaks first). Note that if an Err is returned here you MUST NOT
 * call socket_disconnected for the new descriptor but must disconnect the connection
 * immediately.
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet been
 * [`socket_disconnected()`].
 *
 * [`socket_disconnected()`]: PeerManager::socket_disconnected
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor descriptor);

/**
 * Indicates that there is room to write data to the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
 * returning. Thus, be very careful with reentrancy issues! The invariants around calling
 * [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
 * ready to call `[write_buffer_space_avail`] again if a write call generated here isn't
 * sufficient!
 *
 * [`send_data`]: SocketDescriptor::send_data
 * [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Indicates that data was read from the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
 * Thus, however, you should call [`process_events`] after any `read_event` to generate
 * [`send_data`] calls to handle responses.
 *
 * If `Ok(true)` is returned, further read_events should not be triggered until a
 * [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
 * send buffer).
 *
 * [`send_data`]: SocketDescriptor::send_data
 * [`process_events`]: PeerManager::process_events
 */
MUST_USE_RES struct LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR peer_descriptor, struct LDKu8slice data);

/**
 * Checks for any events generated by our handlers and processes them. Includes sending most
 * response messages as well as messages generated by calls to handler functions directly (eg
 * functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
 *
 * May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
 * issues!
 *
 * [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
 * [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
 * [`send_data`]: SocketDescriptor::send_data
 */
void PeerManager_process_events(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates that the given socket descriptor's connection is now closed.
 */
void PeerManager_socket_disconnected(const struct LDKPeerManager *NONNULL_PTR this_arg, const struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Disconnect a peer given its node id.
 *
 * Set `no_connection_possible` to true to prevent any further connection with this peer,
 * force-closing any channels we have with it.
 *
 * If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
 * peer. Thus, be very careful about reentrancy issues.
 *
 * [`disconnect_socket`]: SocketDescriptor::disconnect_socket
 */
void PeerManager_disconnect_by_node_id(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id, bool no_connection_possible);

/**
 * This function should be called roughly once every 30 seconds.
 * It will send pings to each peer and disconnect those which did not respond to the last
 * round of pings.
 *
 * May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
 * issues!
 *
 * [`send_data`]: SocketDescriptor::send_data
 */
void PeerManager_timer_tick_occurred(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Build the commitment secret from the seed and the commitment number
 */
struct LDKThirtyTwoBytes build_commitment_secret(const uint8_t (*commitment_seed)[32], uint64_t idx);

/**
 * Derives a per-commitment-transaction private key (eg an htlc key or delayed_payment key)
 * from the base secret and the per_commitment_point.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_SecretKeyErrorZ derive_private_key(struct LDKPublicKey per_commitment_point, const uint8_t (*base_secret)[32]);

/**
 * Derives a per-commitment-transaction public key (eg an htlc key or a delayed_payment key)
 * from the base point and the per_commitment_key. This is the public equivalent of
 * derive_private_key - using only public keys to derive a public key instead of private keys.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_PublicKeyErrorZ derive_public_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey base_point);

/**
 * Derives a per-commitment-transaction revocation key from its constituent parts.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_secret always come from cheater
 * and revocation_base_secret always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_SecretKeyErrorZ derive_private_revocation_key(const uint8_t (*per_commitment_secret)[32], const uint8_t (*countersignatory_revocation_base_secret)[32]);

/**
 * Derives a per-commitment-transaction revocation public key from its constituent parts. This is
 * the public equivalend of derive_private_revocation_key - using only public keys to derive a
 * public key instead of private keys.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_point always come from cheater
 * and revocation_base_point always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_PublicKeyErrorZ derive_public_revocation_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey countersignatory_revocation_base_point);

/**
 * Frees any resources used by the TxCreationKeys, if is_owned is set and inner is non-NULL.
 */
void TxCreationKeys_free(struct LDKTxCreationKeys this_obj);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
struct LDKPublicKey TxCreationKeys_get_per_commitment_point(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
void TxCreationKeys_set_per_commitment_point(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
struct LDKPublicKey TxCreationKeys_get_revocation_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
void TxCreationKeys_set_revocation_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's HTLC Key
 */
void TxCreationKeys_set_broadcaster_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Countersignatory's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Countersignatory's HTLC Key
 */
void TxCreationKeys_set_countersignatory_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
void TxCreationKeys_set_broadcaster_delayed_payment_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new TxCreationKeys given each field
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_new(struct LDKPublicKey per_commitment_point_arg, struct LDKPublicKey revocation_key_arg, struct LDKPublicKey broadcaster_htlc_key_arg, struct LDKPublicKey countersignatory_htlc_key_arg, struct LDKPublicKey broadcaster_delayed_payment_key_arg);

/**
 * Creates a copy of the TxCreationKeys
 */
struct LDKTxCreationKeys TxCreationKeys_clone(const struct LDKTxCreationKeys *NONNULL_PTR orig);

/**
 * Serialize the TxCreationKeys object into a byte array which can be read by TxCreationKeys_read
 */
struct LDKCVec_u8Z TxCreationKeys_write(const struct LDKTxCreationKeys *NONNULL_PTR obj);

/**
 * Read a TxCreationKeys from a byte array, created by TxCreationKeys_write
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelPublicKeys, if is_owned is set and inner is non-NULL.
 */
void ChannelPublicKeys_free(struct LDKChannelPublicKeys this_obj);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
struct LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
void ChannelPublicKeys_set_funding_pubkey(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
struct LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
void ChannelPublicKeys_set_revocation_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
struct LDKPublicKey ChannelPublicKeys_get_payment_point(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
void ChannelPublicKeys_set_payment_point(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
struct LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
void ChannelPublicKeys_set_delayed_payment_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
struct LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
void ChannelPublicKeys_set_htlc_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new ChannelPublicKeys given each field
 */
MUST_USE_RES struct LDKChannelPublicKeys ChannelPublicKeys_new(struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg);

/**
 * Creates a copy of the ChannelPublicKeys
 */
struct LDKChannelPublicKeys ChannelPublicKeys_clone(const struct LDKChannelPublicKeys *NONNULL_PTR orig);

/**
 * Serialize the ChannelPublicKeys object into a byte array which can be read by ChannelPublicKeys_read
 */
struct LDKCVec_u8Z ChannelPublicKeys_write(const struct LDKChannelPublicKeys *NONNULL_PTR obj);

/**
 * Read a ChannelPublicKeys from a byte array, created by ChannelPublicKeys_write
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(struct LDKu8slice ser);

/**
 * Create per-state keys from channel base points and the per-commitment point.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_derive_new(struct LDKPublicKey per_commitment_point, struct LDKPublicKey broadcaster_delayed_payment_base, struct LDKPublicKey broadcaster_htlc_base, struct LDKPublicKey countersignatory_revocation_base, struct LDKPublicKey countersignatory_htlc_base);

/**
 * Generate per-state keys from channel static keys.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_from_channel_static_keys(struct LDKPublicKey per_commitment_point, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * A script either spendable by the revocation
 * key or the broadcaster_delayed_payment_key and satisfying the relative-locktime OP_CSV constrain.
 * Encumbering a `to_holder` output on a commitment transaction or 2nd-stage HTLC transactions.
 */
struct LDKCVec_u8Z get_revokeable_redeemscript(struct LDKPublicKey revocation_key, uint16_t contest_delay, struct LDKPublicKey broadcaster_delayed_payment_key);

/**
 * Frees any resources used by the HTLCOutputInCommitment, if is_owned is set and inner is non-NULL.
 */
void HTLCOutputInCommitment_free(struct LDKHTLCOutputInCommitment this_obj);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
bool HTLCOutputInCommitment_get_offered(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
void HTLCOutputInCommitment_set_offered(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, bool val);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
uint64_t HTLCOutputInCommitment_get_amount_msat(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
void HTLCOutputInCommitment_set_amount_msat(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
uint32_t HTLCOutputInCommitment_get_cltv_expiry(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
void HTLCOutputInCommitment_set_cltv_expiry(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The hash of the preimage which unlocks this HTLC.
 */
const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr))[32];

/**
 * The hash of the preimage which unlocks this HTLC.
 */
void HTLCOutputInCommitment_set_payment_hash(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The position within the commitment transactions' outputs. This may be None if the value is
 * below the dust limit (in which case no output appears in the commitment transaction and the
 * value is spent to additional transaction fees).
 */
struct LDKCOption_u32Z HTLCOutputInCommitment_get_transaction_output_index(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The position within the commitment transactions' outputs. This may be None if the value is
 * below the dust limit (in which case no output appears in the commitment transaction and the
 * value is spent to additional transaction fees).
 */
void HTLCOutputInCommitment_set_transaction_output_index(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * Constructs a new HTLCOutputInCommitment given each field
 */
MUST_USE_RES struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_new(bool offered_arg, uint64_t amount_msat_arg, uint32_t cltv_expiry_arg, struct LDKThirtyTwoBytes payment_hash_arg, struct LDKCOption_u32Z transaction_output_index_arg);

/**
 * Creates a copy of the HTLCOutputInCommitment
 */
struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(const struct LDKHTLCOutputInCommitment *NONNULL_PTR orig);

/**
 * Serialize the HTLCOutputInCommitment object into a byte array which can be read by HTLCOutputInCommitment_read
 */
struct LDKCVec_u8Z HTLCOutputInCommitment_write(const struct LDKHTLCOutputInCommitment *NONNULL_PTR obj);

/**
 * Read a HTLCOutputInCommitment from a byte array, created by HTLCOutputInCommitment_write
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(struct LDKu8slice ser);

/**
 * Gets the witness redeemscript for an HTLC output in a commitment transaction. Note that htlc
 * does not need to have its previous_output_index filled.
 */
struct LDKCVec_u8Z get_htlc_redeemscript(const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, const struct LDKTxCreationKeys *NONNULL_PTR keys);

/**
 * Gets the redeemscript for a funding output from the two funding public keys.
 * Note that the order of funding public keys does not matter.
 */
struct LDKCVec_u8Z make_funding_redeemscript(struct LDKPublicKey broadcaster, struct LDKPublicKey countersignatory);

/**
 * Builds an unsigned HTLC-Success or HTLC-Timeout transaction from the given channel and HTLC
 * parameters. This is used by [`TrustedCommitmentTransaction::get_htlc_sigs`] to fetch the
 * transaction which needs signing, and can be used to construct an HTLC transaction which is
 * broadcastable given a counterparty HTLC signature.
 *
 * Panics if htlc.transaction_output_index.is_none() (as such HTLCs do not appear in the
 * commitment transaction).
 */
struct LDKTransaction build_htlc_transaction(const uint8_t (*commitment_txid)[32], uint32_t feerate_per_kw, uint16_t contest_delay, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, struct LDKPublicKey broadcaster_delayed_payment_key, struct LDKPublicKey revocation_key);

/**
 * Frees any resources used by the ChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void ChannelTransactionParameters_free(struct LDKChannelTransactionParameters this_obj);

/**
 * Holder public keys
 */
struct LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Holder public keys
 */
void ChannelTransactionParameters_set_holder_pubkeys(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
uint16_t ChannelTransactionParameters_get_holder_selected_contest_delay(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
void ChannelTransactionParameters_set_holder_selected_contest_delay(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
bool ChannelTransactionParameters_get_is_outbound_from_holder(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
void ChannelTransactionParameters_set_is_outbound_from_holder(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, bool val);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 */
struct LDKCounterpartyChannelTransactionParameters ChannelTransactionParameters_get_counterparty_parameters(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 */
void ChannelTransactionParameters_set_counterparty_parameters(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKCounterpartyChannelTransactionParameters val);

/**
 * The late-bound funding outpoint
 */
struct LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound funding outpoint
 */
void ChannelTransactionParameters_set_funding_outpoint(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Constructs a new ChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKChannelTransactionParameters ChannelTransactionParameters_new(struct LDKChannelPublicKeys holder_pubkeys_arg, uint16_t holder_selected_contest_delay_arg, bool is_outbound_from_holder_arg, struct LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg, struct LDKOutPoint funding_outpoint_arg);

/**
 * Creates a copy of the ChannelTransactionParameters
 */
struct LDKChannelTransactionParameters ChannelTransactionParameters_clone(const struct LDKChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Frees any resources used by the CounterpartyChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void CounterpartyChannelTransactionParameters_free(struct LDKCounterpartyChannelTransactionParameters this_obj);

/**
 * Counter-party public keys
 */
struct LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Counter-party public keys
 */
void CounterpartyChannelTransactionParameters_set_pubkeys(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
uint16_t CounterpartyChannelTransactionParameters_get_selected_contest_delay(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
void CounterpartyChannelTransactionParameters_set_selected_contest_delay(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new CounterpartyChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_new(struct LDKChannelPublicKeys pubkeys_arg, uint16_t selected_contest_delay_arg);

/**
 * Creates a copy of the CounterpartyChannelTransactionParameters
 */
struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_clone(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Whether the late bound parameters are populated.
 */
MUST_USE_RES bool ChannelTransactionParameters_is_populated(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the holder is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_holder_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the counterparty is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_counterparty_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Serialize the CounterpartyChannelTransactionParameters object into a byte array which can be read by CounterpartyChannelTransactionParameters_read
 */
struct LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a CounterpartyChannelTransactionParameters from a byte array, created by CounterpartyChannelTransactionParameters_write
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CounterpartyChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelTransactionParameters object into a byte array which can be read by ChannelTransactionParameters_read
 */
struct LDKCVec_u8Z ChannelTransactionParameters_write(const struct LDKChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a ChannelTransactionParameters from a byte array, created by ChannelTransactionParameters_write
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ ChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DirectedChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void DirectedChannelTransactionParameters_free(struct LDKDirectedChannelTransactionParameters this_obj);

/**
 * Get the channel pubkeys for the broadcaster
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the channel pubkeys for the countersignatory
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_countersignatory_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the contest delay applicable to the transactions.
 * Note that the contest delay was selected by the countersignatory.
 */
MUST_USE_RES uint16_t DirectedChannelTransactionParameters_contest_delay(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Whether the channel is outbound from the broadcaster.
 *
 * The boolean representing the side that initiated the channel is
 * an input to the commitment number obscure factor computation.
 */
MUST_USE_RES bool DirectedChannelTransactionParameters_is_outbound(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * The funding outpoint
 */
MUST_USE_RES struct LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the HolderCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void HolderCommitmentTransaction_free(struct LDKHolderCommitmentTransaction this_obj);

/**
 * Our counterparty's signature for the transaction
 */
struct LDKSignature HolderCommitmentTransaction_get_counterparty_sig(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * Our counterparty's signature for the transaction
 */
void HolderCommitmentTransaction_set_counterparty_sig(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * All non-dust counterparty HTLC signatures, in the order they appear in the transaction
 */
void HolderCommitmentTransaction_set_counterparty_htlc_sigs(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);

/**
 * Creates a copy of the HolderCommitmentTransaction
 */
struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(const struct LDKHolderCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the HolderCommitmentTransaction object into a byte array which can be read by HolderCommitmentTransaction_read
 */
struct LDKCVec_u8Z HolderCommitmentTransaction_write(const struct LDKHolderCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a HolderCommitmentTransaction from a byte array, created by HolderCommitmentTransaction_write
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ HolderCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Create a new holder transaction with the given counterparty signatures.
 * The funding keys are used to figure out which signature should go first when building the transaction for broadcast.
 */
MUST_USE_RES struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(struct LDKCommitmentTransaction commitment_tx, struct LDKSignature counterparty_sig, struct LDKCVec_SignatureZ counterparty_htlc_sigs, struct LDKPublicKey holder_funding_key, struct LDKPublicKey counterparty_funding_key);

/**
 * Frees any resources used by the BuiltCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void BuiltCommitmentTransaction_free(struct LDKBuiltCommitmentTransaction this_obj);

/**
 * The commitment transaction
 */
struct LDKTransaction BuiltCommitmentTransaction_get_transaction(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * The commitment transaction
 */
void BuiltCommitmentTransaction_set_transaction(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKTransaction val);

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
const uint8_t (*BuiltCommitmentTransaction_get_txid(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr))[32];

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
void BuiltCommitmentTransaction_set_txid(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new BuiltCommitmentTransaction given each field
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(struct LDKTransaction transaction_arg, struct LDKThirtyTwoBytes txid_arg);

/**
 * Creates a copy of the BuiltCommitmentTransaction
 */
struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the BuiltCommitmentTransaction object into a byte array which can be read by BuiltCommitmentTransaction_read
 */
struct LDKCVec_u8Z BuiltCommitmentTransaction_write(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a BuiltCommitmentTransaction from a byte array, created by BuiltCommitmentTransaction_write
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ BuiltCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Get the SIGHASH_ALL sighash value of the transaction.
 *
 * This can be used to verify a signature.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Sign a transaction, either because we are counter-signing the counterparty's transaction or
 * because we are about to broadcast a holder transaction.
 */
MUST_USE_RES struct LDKSignature BuiltCommitmentTransaction_sign(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Frees any resources used by the CommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void CommitmentTransaction_free(struct LDKCommitmentTransaction this_obj);

/**
 * Creates a copy of the CommitmentTransaction
 */
struct LDKCommitmentTransaction CommitmentTransaction_clone(const struct LDKCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the CommitmentTransaction object into a byte array which can be read by CommitmentTransaction_read
 */
struct LDKCVec_u8Z CommitmentTransaction_write(const struct LDKCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a CommitmentTransaction from a byte array, created by CommitmentTransaction_write
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(struct LDKu8slice ser);

/**
 * The backwards-counting commitment number
 */
MUST_USE_RES uint64_t CommitmentTransaction_commitment_number(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the broadcaster
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_broadcaster_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the counterparty
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_countersignatory_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The feerate paid per 1000-weight-unit in this commitment transaction.
 */
MUST_USE_RES uint32_t CommitmentTransaction_feerate_per_kw(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Trust our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * This should only be used if you fully trust the builder of this object.  It should not
 *\tbe used by an external signer - instead use the verify function.
 */
MUST_USE_RES struct LDKTrustedCommitmentTransaction CommitmentTransaction_trust(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Verify our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * An external validating signer must call this method before signing
 * or using the built transaction.
 */
MUST_USE_RES struct LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg, const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * Frees any resources used by the TrustedCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void TrustedCommitmentTransaction_free(struct LDKTrustedCommitmentTransaction this_obj);

/**
 * The transaction ID of the built Bitcoin transaction
 */
MUST_USE_RES struct LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-built Bitcoin commitment transaction
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-calculated transaction creation public keys.
 */
MUST_USE_RES struct LDKTxCreationKeys TrustedCommitmentTransaction_keys(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Get a signature for each HTLC which was included in the commitment transaction (ie for
 * which HTLCOutputInCommitment::transaction_output_index.is_some()).
 *
 * The returned Vec has one entry for each HTLC, and in the same order.
 */
MUST_USE_RES struct LDKCResult_CVec_SignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*htlc_base_key)[32], const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters);

/**
 * Commitment transaction numbers which appear in the transactions themselves are XOR'd with a
 * shared secret first. This prevents on-chain observers from discovering how many commitment
 * transactions occurred in a channel before it was closed.
 *
 * This function gets the shared secret from relevant channel public keys and can be used to
 * \"decrypt\" the commitment transaction number given a commitment transaction on-chain.
 */
uint64_t get_commitment_transaction_number_obscure_factor(struct LDKPublicKey broadcaster_payment_basepoint, struct LDKPublicKey countersignatory_payment_basepoint, bool outbound_from_broadcaster);

/**
 * Checks if two InitFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InitFeatures_eq(const struct LDKInitFeatures *NONNULL_PTR a, const struct LDKInitFeatures *NONNULL_PTR b);

/**
 * Checks if two NodeFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeFeatures_eq(const struct LDKNodeFeatures *NONNULL_PTR a, const struct LDKNodeFeatures *NONNULL_PTR b);

/**
 * Checks if two ChannelFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelFeatures_eq(const struct LDKChannelFeatures *NONNULL_PTR a, const struct LDKChannelFeatures *NONNULL_PTR b);

/**
 * Checks if two InvoiceFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InvoiceFeatures_eq(const struct LDKInvoiceFeatures *NONNULL_PTR a, const struct LDKInvoiceFeatures *NONNULL_PTR b);

/**
 * Creates a copy of the InitFeatures
 */
struct LDKInitFeatures InitFeatures_clone(const struct LDKInitFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the NodeFeatures
 */
struct LDKNodeFeatures NodeFeatures_clone(const struct LDKNodeFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the ChannelFeatures
 */
struct LDKChannelFeatures ChannelFeatures_clone(const struct LDKChannelFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the InvoiceFeatures
 */
struct LDKInvoiceFeatures InvoiceFeatures_clone(const struct LDKInvoiceFeatures *NONNULL_PTR orig);

/**
 * Frees any resources used by the InitFeatures, if is_owned is set and inner is non-NULL.
 */
void InitFeatures_free(struct LDKInitFeatures this_obj);

/**
 * Frees any resources used by the NodeFeatures, if is_owned is set and inner is non-NULL.
 */
void NodeFeatures_free(struct LDKNodeFeatures this_obj);

/**
 * Frees any resources used by the ChannelFeatures, if is_owned is set and inner is non-NULL.
 */
void ChannelFeatures_free(struct LDKChannelFeatures this_obj);

/**
 * Frees any resources used by the InvoiceFeatures, if is_owned is set and inner is non-NULL.
 */
void InvoiceFeatures_free(struct LDKInvoiceFeatures this_obj);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInitFeatures InitFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKInitFeatures InitFeatures_known(void);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKNodeFeatures NodeFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKNodeFeatures NodeFeatures_known(void);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_known(void);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_known(void);

/**
 * Returns whether the `payment_secret` feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_payment_secret(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Returns whether the `payment_secret` feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_payment_secret(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Returns whether the `payment_secret` feature is supported.
 */
MUST_USE_RES bool InvoiceFeatures_supports_payment_secret(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Serialize the InitFeatures object into a byte array which can be read by InitFeatures_read
 */
struct LDKCVec_u8Z InitFeatures_write(const struct LDKInitFeatures *NONNULL_PTR obj);

/**
 * Serialize the NodeFeatures object into a byte array which can be read by NodeFeatures_read
 */
struct LDKCVec_u8Z NodeFeatures_write(const struct LDKNodeFeatures *NONNULL_PTR obj);

/**
 * Serialize the ChannelFeatures object into a byte array which can be read by ChannelFeatures_read
 */
struct LDKCVec_u8Z ChannelFeatures_write(const struct LDKChannelFeatures *NONNULL_PTR obj);

/**
 * Serialize the InvoiceFeatures object into a byte array which can be read by InvoiceFeatures_read
 */
struct LDKCVec_u8Z InvoiceFeatures_write(const struct LDKInvoiceFeatures *NONNULL_PTR obj);

/**
 * Read a InitFeatures from a byte array, created by InitFeatures_write
 */
struct LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(struct LDKu8slice ser);

/**
 * Read a NodeFeatures from a byte array, created by NodeFeatures_write
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(struct LDKu8slice ser);

/**
 * Read a ChannelFeatures from a byte array, created by ChannelFeatures_write
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(struct LDKu8slice ser);

/**
 * Read a InvoiceFeatures from a byte array, created by InvoiceFeatures_write
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ InvoiceFeatures_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHop, if is_owned is set and inner is non-NULL.
 */
void RouteHop_free(struct LDKRouteHop this_obj);

/**
 * The node_id of the node at this hop.
 */
struct LDKPublicKey RouteHop_get_pubkey(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the node at this hop.
 */
void RouteHop_set_pubkey(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
struct LDKNodeFeatures RouteHop_get_node_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
void RouteHop_set_node_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
uint64_t RouteHop_get_short_channel_id(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
void RouteHop_set_short_channel_id(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
struct LDKChannelFeatures RouteHop_get_channel_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
void RouteHop_set_channel_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * For the last hop, this should be the full value of the payment (might be more than
 * requested if we had to match htlc_minimum_msat).
 */
uint64_t RouteHop_get_fee_msat(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * For the last hop, this should be the full value of the payment (might be more than
 * requested if we had to match htlc_minimum_msat).
 */
void RouteHop_set_fee_msat(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
 * expected at the destination, in excess of the current block height.
 */
uint32_t RouteHop_get_cltv_expiry_delta(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
 * expected at the destination, in excess of the current block height.
 */
void RouteHop_set_cltv_expiry_delta(struct LDKRouteHop *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RouteHop given each field
 */
MUST_USE_RES struct LDKRouteHop RouteHop_new(struct LDKPublicKey pubkey_arg, struct LDKNodeFeatures node_features_arg, uint64_t short_channel_id_arg, struct LDKChannelFeatures channel_features_arg, uint64_t fee_msat_arg, uint32_t cltv_expiry_delta_arg);

/**
 * Creates a copy of the RouteHop
 */
struct LDKRouteHop RouteHop_clone(const struct LDKRouteHop *NONNULL_PTR orig);

/**
 * Serialize the RouteHop object into a byte array which can be read by RouteHop_read
 */
struct LDKCVec_u8Z RouteHop_write(const struct LDKRouteHop *NONNULL_PTR obj);

/**
 * Read a RouteHop from a byte array, created by RouteHop_write
 */
struct LDKCResult_RouteHopDecodeErrorZ RouteHop_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Route, if is_owned is set and inner is non-NULL.
 */
void Route_free(struct LDKRoute this_obj);

/**
 * The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
 * last RouteHop in each path must be the same.
 * Each entry represents a list of hops, NOT INCLUDING our own, where the last hop is the
 * destination. Thus, this must always be at least length one. While the maximum length of any
 * given path is variable, keeping the length of any path to less than 20 should currently
 * ensure it is viable.
 */
void Route_set_paths(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKCVec_CVec_RouteHopZZ val);

/**
 * Constructs a new Route given each field
 */
MUST_USE_RES struct LDKRoute Route_new(struct LDKCVec_CVec_RouteHopZZ paths_arg);

/**
 * Creates a copy of the Route
 */
struct LDKRoute Route_clone(const struct LDKRoute *NONNULL_PTR orig);

/**
 * Serialize the Route object into a byte array which can be read by Route_read
 */
struct LDKCVec_u8Z Route_write(const struct LDKRoute *NONNULL_PTR obj);

/**
 * Read a Route from a byte array, created by Route_write
 */
struct LDKCResult_RouteDecodeErrorZ Route_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHint, if is_owned is set and inner is non-NULL.
 */
void RouteHint_free(struct LDKRouteHint this_obj);

/**
 * Checks if two RouteHints contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHint_eq(const struct LDKRouteHint *NONNULL_PTR a, const struct LDKRouteHint *NONNULL_PTR b);

/**
 * Creates a copy of the RouteHint
 */
struct LDKRouteHint RouteHint_clone(const struct LDKRouteHint *NONNULL_PTR orig);

/**
 * Frees any resources used by the RouteHintHop, if is_owned is set and inner is non-NULL.
 */
void RouteHintHop_free(struct LDKRouteHintHop this_obj);

/**
 * The node_id of the non-target end of the route
 */
struct LDKPublicKey RouteHintHop_get_src_node_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the non-target end of the route
 */
void RouteHintHop_set_src_node_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The short_channel_id of this channel
 */
uint64_t RouteHintHop_get_short_channel_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The short_channel_id of this channel
 */
void RouteHintHop_set_short_channel_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The fees which must be paid to use this channel
 */
struct LDKRoutingFees RouteHintHop_get_fees(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The fees which must be paid to use this channel
 */
void RouteHintHop_set_fees(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * The difference in CLTV values between this node and the next node.
 */
uint16_t RouteHintHop_get_cltv_expiry_delta(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values between this node and the next node.
 */
void RouteHintHop_set_cltv_expiry_delta(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, in msat, which must be relayed to the next hop.
 */
struct LDKCOption_u64Z RouteHintHop_get_htlc_minimum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The minimum value, in msat, which must be relayed to the next hop.
 */
void RouteHintHop_set_htlc_minimum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The maximum value in msat available for routing with a single HTLC.
 */
struct LDKCOption_u64Z RouteHintHop_get_htlc_maximum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The maximum value in msat available for routing with a single HTLC.
 */
void RouteHintHop_set_htlc_maximum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new RouteHintHop given each field
 */
MUST_USE_RES struct LDKRouteHintHop RouteHintHop_new(struct LDKPublicKey src_node_id_arg, uint64_t short_channel_id_arg, struct LDKRoutingFees fees_arg, uint16_t cltv_expiry_delta_arg, struct LDKCOption_u64Z htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg);

/**
 * Checks if two RouteHintHops contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHintHop_eq(const struct LDKRouteHintHop *NONNULL_PTR a, const struct LDKRouteHintHop *NONNULL_PTR b);

/**
 * Creates a copy of the RouteHintHop
 */
struct LDKRouteHintHop RouteHintHop_clone(const struct LDKRouteHintHop *NONNULL_PTR orig);

/**
 * Gets a route from us (payer) to the given target node (payee).
 *
 * If the payee provided features in their invoice, they should be provided via payee_features.
 * Without this, MPP will only be used if the payee's features are available in the network graph.
 *
 * Private routing paths between a public node and the target may be included in `last_hops`.
 * Currently, only the last hop in each path is considered.
 *
 * If some channels aren't announced, it may be useful to fill in a first_hops with the
 * results from a local ChannelManager::list_usable_channels() call. If it is filled in, our
 * view of our local channels (from net_graph_msg_handler) will be ignored, and only those
 * in first_hops will be used.
 *
 * Panics if first_hops contains channels without short_channel_ids
 * (ChannelManager::list_usable_channels will never include such channels).
 *
 * The fees on channels from us to next-hops are ignored (as they are assumed to all be
 * equal), however the enabled/disabled bit on such channels as well as the
 * htlc_minimum_msat/htlc_maximum_msat *are* checked as they may change based on the receiving node.
 */
struct LDKCResult_RouteLightningErrorZ get_route(struct LDKPublicKey our_node_id, const struct LDKNetworkGraph *NONNULL_PTR network, struct LDKPublicKey payee, struct LDKInvoiceFeatures payee_features, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKCVec_RouteHintZ last_hops, uint64_t final_value_msat, uint32_t final_cltv, struct LDKLogger logger);

/**
 * Frees any resources used by the NetworkGraph, if is_owned is set and inner is non-NULL.
 */
void NetworkGraph_free(struct LDKNetworkGraph this_obj);

/**
 * Creates a copy of the NetworkGraph
 */
struct LDKNetworkGraph NetworkGraph_clone(const struct LDKNetworkGraph *NONNULL_PTR orig);

/**
 * Frees any resources used by the LockedNetworkGraph, if is_owned is set and inner is non-NULL.
 */
void LockedNetworkGraph_free(struct LDKLockedNetworkGraph this_obj);

/**
 * Frees any resources used by the NetGraphMsgHandler, if is_owned is set and inner is non-NULL.
 */
void NetGraphMsgHandler_free(struct LDKNetGraphMsgHandler this_obj);

/**
 * Creates a new tracker of the actual state of the network of channels and nodes,
 * assuming a fresh network graph.
 * Chain monitor is used to make sure announced channels exist on-chain,
 * channel data is correct, and that the announcement is signed with
 * channel owners' keys.
 */
MUST_USE_RES struct LDKNetGraphMsgHandler NetGraphMsgHandler_new(struct LDKThirtyTwoBytes genesis_hash, struct LDKAccess *chain_access, struct LDKLogger logger);

/**
 * Creates a new tracker of the actual state of the network of channels and nodes,
 * assuming an existing Network Graph.
 */
MUST_USE_RES struct LDKNetGraphMsgHandler NetGraphMsgHandler_from_net_graph(struct LDKAccess *chain_access, struct LDKLogger logger, struct LDKNetworkGraph network_graph);

/**
 * Adds a provider used to check new announcements. Does not affect
 * existing announcements unless they are updated.
 * Add, update or remove the provider would replace the current one.
 */
void NetGraphMsgHandler_add_chain_access(struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg, struct LDKAccess *chain_access);

/**
 * Take a read lock on the network_graph and return it in the C-bindings
 * newtype helper. This is likely only useful when called via the C
 * bindings as you can call `self.network_graph.read().unwrap()` in Rust
 * yourself.
 */
MUST_USE_RES struct LDKLockedNetworkGraph NetGraphMsgHandler_read_locked_graph(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Get a reference to the NetworkGraph which this read-lock contains.
 */
MUST_USE_RES struct LDKNetworkGraph LockedNetworkGraph_graph(const struct LDKLockedNetworkGraph *NONNULL_PTR this_arg);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler NetGraphMsgHandler_as_RoutingMessageHandler(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider NetGraphMsgHandler_as_MessageSendEventsProvider(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the DirectionalChannelInfo, if is_owned is set and inner is non-NULL.
 */
void DirectionalChannelInfo_free(struct LDKDirectionalChannelInfo this_obj);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t DirectionalChannelInfo_get_last_update(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
void DirectionalChannelInfo_set_last_update(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
bool DirectionalChannelInfo_get_enabled(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
void DirectionalChannelInfo_set_enabled(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, bool val);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
uint16_t DirectionalChannelInfo_get_cltv_expiry_delta(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
void DirectionalChannelInfo_set_cltv_expiry_delta(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
uint64_t DirectionalChannelInfo_get_htlc_minimum_msat(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
void DirectionalChannelInfo_set_htlc_minimum_msat(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum value which may be relayed to the next hop via the channel.
 */
struct LDKCOption_u64Z DirectionalChannelInfo_get_htlc_maximum_msat(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * The maximum value which may be relayed to the next hop via the channel.
 */
void DirectionalChannelInfo_set_htlc_maximum_msat(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Fees charged when the channel is used for routing
 */
struct LDKRoutingFees DirectionalChannelInfo_get_fees(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * Fees charged when the channel is used for routing
 */
void DirectionalChannelInfo_set_fees(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
struct LDKChannelUpdate DirectionalChannelInfo_get_last_update_message(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
void DirectionalChannelInfo_set_last_update_message(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdate val);

/**
 * Constructs a new DirectionalChannelInfo given each field
 */
MUST_USE_RES struct LDKDirectionalChannelInfo DirectionalChannelInfo_new(uint32_t last_update_arg, bool enabled_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg, struct LDKRoutingFees fees_arg, struct LDKChannelUpdate last_update_message_arg);

/**
 * Creates a copy of the DirectionalChannelInfo
 */
struct LDKDirectionalChannelInfo DirectionalChannelInfo_clone(const struct LDKDirectionalChannelInfo *NONNULL_PTR orig);

/**
 * Serialize the DirectionalChannelInfo object into a byte array which can be read by DirectionalChannelInfo_read
 */
struct LDKCVec_u8Z DirectionalChannelInfo_write(const struct LDKDirectionalChannelInfo *NONNULL_PTR obj);

/**
 * Read a DirectionalChannelInfo from a byte array, created by DirectionalChannelInfo_write
 */
struct LDKCResult_DirectionalChannelInfoDecodeErrorZ DirectionalChannelInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelInfo, if is_owned is set and inner is non-NULL.
 */
void ChannelInfo_free(struct LDKChannelInfo this_obj);

/**
 * Protocol features of a channel communicated during its announcement
 */
struct LDKChannelFeatures ChannelInfo_get_features(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features of a channel communicated during its announcement
 */
void ChannelInfo_set_features(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * Source node of the first direction of a channel
 */
struct LDKPublicKey ChannelInfo_get_node_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the first direction of a channel
 */
void ChannelInfo_set_node_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Details about the first direction of a channel
 */
struct LDKDirectionalChannelInfo ChannelInfo_get_one_to_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the first direction of a channel
 */
void ChannelInfo_set_one_to_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKDirectionalChannelInfo val);

/**
 * Source node of the second direction of a channel
 */
struct LDKPublicKey ChannelInfo_get_node_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the second direction of a channel
 */
void ChannelInfo_set_node_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Details about the second direction of a channel
 */
struct LDKDirectionalChannelInfo ChannelInfo_get_two_to_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the second direction of a channel
 */
void ChannelInfo_set_two_to_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKDirectionalChannelInfo val);

/**
 * The channel capacity as seen on-chain, if chain lookup is available.
 */
struct LDKCOption_u64Z ChannelInfo_get_capacity_sats(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * The channel capacity as seen on-chain, if chain lookup is available.
 */
void ChannelInfo_set_capacity_sats(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
struct LDKChannelAnnouncement ChannelInfo_get_announcement_message(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
void ChannelInfo_set_announcement_message(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelAnnouncement val);

/**
 * Constructs a new ChannelInfo given each field
 */
MUST_USE_RES struct LDKChannelInfo ChannelInfo_new(struct LDKChannelFeatures features_arg, struct LDKPublicKey node_one_arg, struct LDKDirectionalChannelInfo one_to_two_arg, struct LDKPublicKey node_two_arg, struct LDKDirectionalChannelInfo two_to_one_arg, struct LDKCOption_u64Z capacity_sats_arg, struct LDKChannelAnnouncement announcement_message_arg);

/**
 * Creates a copy of the ChannelInfo
 */
struct LDKChannelInfo ChannelInfo_clone(const struct LDKChannelInfo *NONNULL_PTR orig);

/**
 * Serialize the ChannelInfo object into a byte array which can be read by ChannelInfo_read
 */
struct LDKCVec_u8Z ChannelInfo_write(const struct LDKChannelInfo *NONNULL_PTR obj);

/**
 * Read a ChannelInfo from a byte array, created by ChannelInfo_write
 */
struct LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RoutingFees, if is_owned is set and inner is non-NULL.
 */
void RoutingFees_free(struct LDKRoutingFees this_obj);

/**
 * Flat routing fee in satoshis
 */
uint32_t RoutingFees_get_base_msat(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Flat routing fee in satoshis
 */
void RoutingFees_set_base_msat(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
uint32_t RoutingFees_get_proportional_millionths(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
void RoutingFees_set_proportional_millionths(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RoutingFees given each field
 */
MUST_USE_RES struct LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);

/**
 * Checks if two RoutingFeess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RoutingFees_eq(const struct LDKRoutingFees *NONNULL_PTR a, const struct LDKRoutingFees *NONNULL_PTR b);

/**
 * Creates a copy of the RoutingFees
 */
struct LDKRoutingFees RoutingFees_clone(const struct LDKRoutingFees *NONNULL_PTR orig);

/**
 * Serialize the RoutingFees object into a byte array which can be read by RoutingFees_read
 */
struct LDKCVec_u8Z RoutingFees_write(const struct LDKRoutingFees *NONNULL_PTR obj);

/**
 * Read a RoutingFees from a byte array, created by RoutingFees_write
 */
struct LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeAnnouncementInfo, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncementInfo_free(struct LDKNodeAnnouncementInfo this_obj);

/**
 * Protocol features the node announced support for
 */
struct LDKNodeFeatures NodeAnnouncementInfo_get_features(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features the node announced support for
 */
void NodeAnnouncementInfo_set_features(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t NodeAnnouncementInfo_get_last_update(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
void NodeAnnouncementInfo_set_last_update(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Color assigned to the node
 */
const uint8_t (*NodeAnnouncementInfo_get_rgb(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[3];

/**
 * Color assigned to the node
 */
void NodeAnnouncementInfo_set_rgb(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
const uint8_t (*NodeAnnouncementInfo_get_alias(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[32];

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
void NodeAnnouncementInfo_set_alias(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Internet-level addresses via which one can connect to the node
 */
void NodeAnnouncementInfo_set_addresses(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
struct LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
void NodeAnnouncementInfo_set_announcement_message(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncementInfo given each field
 */
MUST_USE_RES struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(struct LDKNodeFeatures features_arg, uint32_t last_update_arg, struct LDKThreeBytes rgb_arg, struct LDKThirtyTwoBytes alias_arg, struct LDKCVec_NetAddressZ addresses_arg, struct LDKNodeAnnouncement announcement_message_arg);

/**
 * Creates a copy of the NodeAnnouncementInfo
 */
struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(const struct LDKNodeAnnouncementInfo *NONNULL_PTR orig);

/**
 * Serialize the NodeAnnouncementInfo object into a byte array which can be read by NodeAnnouncementInfo_read
 */
struct LDKCVec_u8Z NodeAnnouncementInfo_write(const struct LDKNodeAnnouncementInfo *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncementInfo from a byte array, created by NodeAnnouncementInfo_write
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeInfo, if is_owned is set and inner is non-NULL.
 */
void NodeInfo_free(struct LDKNodeInfo this_obj);

/**
 * All valid channels a node has announced
 */
void NodeInfo_set_channels(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Lowest fees enabling routing via any of the enabled, known channels to a node.
 * The two fields (flat and proportional fee) are independent,
 * meaning they don't have to refer to the same channel.
 */
struct LDKRoutingFees NodeInfo_get_lowest_inbound_channel_fees(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * Lowest fees enabling routing via any of the enabled, known channels to a node.
 * The two fields (flat and proportional fee) are independent,
 * meaning they don't have to refer to the same channel.
 */
void NodeInfo_set_lowest_inbound_channel_fees(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 */
struct LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 */
void NodeInfo_set_announcement_info(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncementInfo val);

/**
 * Constructs a new NodeInfo given each field
 */
MUST_USE_RES struct LDKNodeInfo NodeInfo_new(struct LDKCVec_u64Z channels_arg, struct LDKRoutingFees lowest_inbound_channel_fees_arg, struct LDKNodeAnnouncementInfo announcement_info_arg);

/**
 * Creates a copy of the NodeInfo
 */
struct LDKNodeInfo NodeInfo_clone(const struct LDKNodeInfo *NONNULL_PTR orig);

/**
 * Serialize the NodeInfo object into a byte array which can be read by NodeInfo_read
 */
struct LDKCVec_u8Z NodeInfo_write(const struct LDKNodeInfo *NONNULL_PTR obj);

/**
 * Read a NodeInfo from a byte array, created by NodeInfo_write
 */
struct LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(struct LDKu8slice ser);

/**
 * Serialize the NetworkGraph object into a byte array which can be read by NetworkGraph_read
 */
struct LDKCVec_u8Z NetworkGraph_write(const struct LDKNetworkGraph *NONNULL_PTR obj);

/**
 * Read a NetworkGraph from a byte array, created by NetworkGraph_write
 */
struct LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(struct LDKu8slice ser);

/**
 * Creates a new, empty, network graph.
 */
MUST_USE_RES struct LDKNetworkGraph NetworkGraph_new(struct LDKThirtyTwoBytes genesis_hash);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement without verifying the associated signatures. Because we aren't
 * given the associated signatures here we cannot relay the node announcement to any of our
 * peers.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_unsigned_announcement(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR msg);

/**
 * Store or update channel info from a channel announcement.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg, struct LDKAccess *chain_access);

/**
 * Store or update channel info from a channel announcement without verifying the associated
 * signatures. Because we aren't given the associated signatures here we cannot relay the
 * channel announcement to any of our peers.
 *
 * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_unsigned_announcement(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg, struct LDKAccess *chain_access);

/**
 * Close a channel if a corresponding HTLC fail was sent.
 * If permanent, removes a channel from the local storage.
 * May cause the removal of nodes too, if this was their last channel.
 * If not permanent, makes channels unavailable for routing.
 */
void NetworkGraph_close_channel_from_update(struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, bool is_permanent);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel without verifying the associated signatures. Because we aren't given the
 * associated signatures here we cannot relay the channel update to any of our peers.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelUpdate *NONNULL_PTR msg);

/**
 * Frees any resources used by the FilesystemPersister, if is_owned is set and inner is non-NULL.
 */
void FilesystemPersister_free(struct LDKFilesystemPersister this_obj);

/**
 * Initialize a new FilesystemPersister and set the path to the individual channels'
 * files.
 */
MUST_USE_RES struct LDKFilesystemPersister FilesystemPersister_new(struct LDKStr path_to_channel_data);

/**
 * Get the directory which was provided when this persister was initialized.
 */
MUST_USE_RES struct LDKStr FilesystemPersister_get_data_dir(const struct LDKFilesystemPersister *NONNULL_PTR this_arg);

/**
 * Writes the provided `ChannelManager` to the path provided at `FilesystemPersister`
 * initialization, within a file called \"manager\".
 */
MUST_USE_RES struct LDKCResult_NoneErrorZ FilesystemPersister_persist_manager(struct LDKStr data_dir, const struct LDKChannelManager *NONNULL_PTR manager);

/**
 * Read `ChannelMonitor`s from disk.
 */
MUST_USE_RES struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ FilesystemPersister_read_channelmonitors(const struct LDKFilesystemPersister *NONNULL_PTR this_arg, struct LDKKeysInterface keys_manager);

/**
 * Constructs a new Persist which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Persist must be freed before this_arg is
 */
struct LDKPersist FilesystemPersister_as_Persist(const struct LDKFilesystemPersister *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the BackgroundProcessor, if is_owned is set and inner is non-NULL.
 */
void BackgroundProcessor_free(struct LDKBackgroundProcessor this_obj);

/**
 * Calls the free function if one is set
 */
void ChannelManagerPersister_free(struct LDKChannelManagerPersister this_ptr);

/**
 * Start a background thread that takes care of responsibilities enumerated in the top-level
 * documentation.
 *
 * If `persist_manager` returns an error, then this thread will return said error (and
 * `start()` will need to be called again to restart the `BackgroundProcessor`). Users should
 * wait on [`thread_handle`]'s `join()` method to be able to tell if and when an error is
 * returned, or implement `persist_manager` such that an error is never returned to the
 * `BackgroundProcessor`
 *
 * `persist_manager` is responsible for writing out the [`ChannelManager`] to disk, and/or
 * uploading to one or more backup services. See [`ChannelManager::write`] for writing out a
 * [`ChannelManager`]. See [`FilesystemPersister::persist_manager`] for Rust-Lightning's
 * provided implementation.
 *
 * [`thread_handle`]: BackgroundProcessor::thread_handle
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 * [`ChannelManager::write`]: lightning::ln::channelmanager::ChannelManager#impl-Writeable
 * [`FilesystemPersister::persist_manager`]: lightning_persister::FilesystemPersister::persist_manager
 */
MUST_USE_RES struct LDKBackgroundProcessor BackgroundProcessor_start(struct LDKChannelManagerPersister persister, struct LDKEventHandler event_handler, const struct LDKChainMonitor *NONNULL_PTR chain_monitor, const struct LDKChannelManager *NONNULL_PTR channel_manager, const struct LDKPeerManager *NONNULL_PTR peer_manager, struct LDKLogger logger);

/**
 * Stop `BackgroundProcessor`'s thread.
 */
MUST_USE_RES struct LDKCResult_NoneErrorZ BackgroundProcessor_stop(struct LDKBackgroundProcessor this_arg);

/**
 * **Call this function on startup to ensure that all assumptions about the platform are valid.**
 *
 * Unfortunately we have to make assumptions about the upper bounds of the `SystemTime` type on
 * your platform which we can't fully verify at compile time and which isn't part of it's contract.
 * To our best knowledge our assumptions hold for all platforms officially supported by rust, but
 * since this check is fast we recommend to do it anyway.
 *
 * If this function fails this is considered a bug. Please open an issue describing your
 * platform and stating your current system time.
 *
 * # Panics
 * If the check fails this function panics. By calling this function on startup you ensure that
 * this wont happen at an arbitrary later point in time.
 */
void check_platform(void);

/**
 * Frees any resources used by the Invoice, if is_owned is set and inner is non-NULL.
 */
void Invoice_free(struct LDKInvoice this_obj);

/**
 * Checks if two Invoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Invoice_eq(const struct LDKInvoice *NONNULL_PTR a, const struct LDKInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the Invoice
 */
struct LDKInvoice Invoice_clone(const struct LDKInvoice *NONNULL_PTR orig);

/**
 * Frees any resources used by the SignedRawInvoice, if is_owned is set and inner is non-NULL.
 */
void SignedRawInvoice_free(struct LDKSignedRawInvoice this_obj);

/**
 * Checks if two SignedRawInvoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool SignedRawInvoice_eq(const struct LDKSignedRawInvoice *NONNULL_PTR a, const struct LDKSignedRawInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the SignedRawInvoice
 */
struct LDKSignedRawInvoice SignedRawInvoice_clone(const struct LDKSignedRawInvoice *NONNULL_PTR orig);

/**
 * Frees any resources used by the RawInvoice, if is_owned is set and inner is non-NULL.
 */
void RawInvoice_free(struct LDKRawInvoice this_obj);

/**
 * data part
 */
struct LDKRawDataPart RawInvoice_get_data(const struct LDKRawInvoice *NONNULL_PTR this_ptr);

/**
 * data part
 */
void RawInvoice_set_data(struct LDKRawInvoice *NONNULL_PTR this_ptr, struct LDKRawDataPart val);

/**
 * Checks if two RawInvoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RawInvoice_eq(const struct LDKRawInvoice *NONNULL_PTR a, const struct LDKRawInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the RawInvoice
 */
struct LDKRawInvoice RawInvoice_clone(const struct LDKRawInvoice *NONNULL_PTR orig);

/**
 * Frees any resources used by the RawDataPart, if is_owned is set and inner is non-NULL.
 */
void RawDataPart_free(struct LDKRawDataPart this_obj);

/**
 * generation time of the invoice
 */
struct LDKPositiveTimestamp RawDataPart_get_timestamp(const struct LDKRawDataPart *NONNULL_PTR this_ptr);

/**
 * generation time of the invoice
 */
void RawDataPart_set_timestamp(struct LDKRawDataPart *NONNULL_PTR this_ptr, struct LDKPositiveTimestamp val);

/**
 * Checks if two RawDataParts contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RawDataPart_eq(const struct LDKRawDataPart *NONNULL_PTR a, const struct LDKRawDataPart *NONNULL_PTR b);

/**
 * Creates a copy of the RawDataPart
 */
struct LDKRawDataPart RawDataPart_clone(const struct LDKRawDataPart *NONNULL_PTR orig);

/**
 * Frees any resources used by the PositiveTimestamp, if is_owned is set and inner is non-NULL.
 */
void PositiveTimestamp_free(struct LDKPositiveTimestamp this_obj);

/**
 * Checks if two PositiveTimestamps contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PositiveTimestamp_eq(const struct LDKPositiveTimestamp *NONNULL_PTR a, const struct LDKPositiveTimestamp *NONNULL_PTR b);

/**
 * Creates a copy of the PositiveTimestamp
 */
struct LDKPositiveTimestamp PositiveTimestamp_clone(const struct LDKPositiveTimestamp *NONNULL_PTR orig);

/**
 * Creates a copy of the SiPrefix
 */
enum LDKSiPrefix SiPrefix_clone(const enum LDKSiPrefix *NONNULL_PTR orig);

/**
 * Checks if two SiPrefixs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SiPrefix_eq(const enum LDKSiPrefix *NONNULL_PTR a, const enum LDKSiPrefix *NONNULL_PTR b);

/**
 * Returns the multiplier to go from a BTC value to picoBTC implied by this SiPrefix.
 * This is effectively 10^12 * the prefix multiplier
 */
MUST_USE_RES uint64_t SiPrefix_multiplier(const enum LDKSiPrefix *NONNULL_PTR this_arg);

/**
 * Creates a copy of the Currency
 */
enum LDKCurrency Currency_clone(const enum LDKCurrency *NONNULL_PTR orig);

/**
 * Checks if two Currencys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Currency_eq(const enum LDKCurrency *NONNULL_PTR a, const enum LDKCurrency *NONNULL_PTR b);

/**
 * Frees any resources used by the Sha256, if is_owned is set and inner is non-NULL.
 */
void Sha256_free(struct LDKSha256 this_obj);

/**
 * Checks if two Sha256s contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Sha256_eq(const struct LDKSha256 *NONNULL_PTR a, const struct LDKSha256 *NONNULL_PTR b);

/**
 * Creates a copy of the Sha256
 */
struct LDKSha256 Sha256_clone(const struct LDKSha256 *NONNULL_PTR orig);

/**
 * Frees any resources used by the Description, if is_owned is set and inner is non-NULL.
 */
void Description_free(struct LDKDescription this_obj);

/**
 * Checks if two Descriptions contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Description_eq(const struct LDKDescription *NONNULL_PTR a, const struct LDKDescription *NONNULL_PTR b);

/**
 * Creates a copy of the Description
 */
struct LDKDescription Description_clone(const struct LDKDescription *NONNULL_PTR orig);

/**
 * Frees any resources used by the PayeePubKey, if is_owned is set and inner is non-NULL.
 */
void PayeePubKey_free(struct LDKPayeePubKey this_obj);

/**
 * Checks if two PayeePubKeys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PayeePubKey_eq(const struct LDKPayeePubKey *NONNULL_PTR a, const struct LDKPayeePubKey *NONNULL_PTR b);

/**
 * Creates a copy of the PayeePubKey
 */
struct LDKPayeePubKey PayeePubKey_clone(const struct LDKPayeePubKey *NONNULL_PTR orig);

/**
 * Frees any resources used by the ExpiryTime, if is_owned is set and inner is non-NULL.
 */
void ExpiryTime_free(struct LDKExpiryTime this_obj);

/**
 * Checks if two ExpiryTimes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ExpiryTime_eq(const struct LDKExpiryTime *NONNULL_PTR a, const struct LDKExpiryTime *NONNULL_PTR b);

/**
 * Creates a copy of the ExpiryTime
 */
struct LDKExpiryTime ExpiryTime_clone(const struct LDKExpiryTime *NONNULL_PTR orig);

/**
 * Frees any resources used by the MinFinalCltvExpiry, if is_owned is set and inner is non-NULL.
 */
void MinFinalCltvExpiry_free(struct LDKMinFinalCltvExpiry this_obj);

/**
 * Checks if two MinFinalCltvExpirys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool MinFinalCltvExpiry_eq(const struct LDKMinFinalCltvExpiry *NONNULL_PTR a, const struct LDKMinFinalCltvExpiry *NONNULL_PTR b);

/**
 * Creates a copy of the MinFinalCltvExpiry
 */
struct LDKMinFinalCltvExpiry MinFinalCltvExpiry_clone(const struct LDKMinFinalCltvExpiry *NONNULL_PTR orig);

/**
 * Frees any resources used by the Fallback
 */
void Fallback_free(struct LDKFallback this_ptr);

/**
 * Creates a copy of the Fallback
 */
struct LDKFallback Fallback_clone(const struct LDKFallback *NONNULL_PTR orig);

/**
 * Checks if two Fallbacks contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Fallback_eq(const struct LDKFallback *NONNULL_PTR a, const struct LDKFallback *NONNULL_PTR b);

/**
 * Frees any resources used by the InvoiceSignature, if is_owned is set and inner is non-NULL.
 */
void InvoiceSignature_free(struct LDKInvoiceSignature this_obj);

/**
 * Checks if two InvoiceSignatures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InvoiceSignature_eq(const struct LDKInvoiceSignature *NONNULL_PTR a, const struct LDKInvoiceSignature *NONNULL_PTR b);

/**
 * Creates a copy of the InvoiceSignature
 */
struct LDKInvoiceSignature InvoiceSignature_clone(const struct LDKInvoiceSignature *NONNULL_PTR orig);

/**
 * Frees any resources used by the PrivateRoute, if is_owned is set and inner is non-NULL.
 */
void PrivateRoute_free(struct LDKPrivateRoute this_obj);

/**
 * Checks if two PrivateRoutes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PrivateRoute_eq(const struct LDKPrivateRoute *NONNULL_PTR a, const struct LDKPrivateRoute *NONNULL_PTR b);

/**
 * Creates a copy of the PrivateRoute
 */
struct LDKPrivateRoute PrivateRoute_clone(const struct LDKPrivateRoute *NONNULL_PTR orig);

/**
 * Disassembles the `SignedRawInvoice` into its three parts:
 *  1. raw invoice
 *  2. hash of the raw invoice
 *  3. signature
 */
MUST_USE_RES struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ SignedRawInvoice_into_parts(struct LDKSignedRawInvoice this_arg);

/**
 * The `RawInvoice` which was signed.
 */
MUST_USE_RES struct LDKRawInvoice SignedRawInvoice_raw_invoice(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * The hash of the `RawInvoice` that was signed.
 */
MUST_USE_RES const uint8_t (*SignedRawInvoice_hash(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg))[32];

/**
 * InvoiceSignature for the invoice.
 */
MUST_USE_RES struct LDKInvoiceSignature SignedRawInvoice_signature(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Recovers the public key used for signing the invoice from the recoverable signature.
 */
MUST_USE_RES struct LDKCResult_PayeePubKeyErrorZ SignedRawInvoice_recover_payee_pub_key(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Checks if the signature is valid for the included payee public key or if none exists if it's
 * valid for the recovered signature (which should always be true?).
 */
MUST_USE_RES bool SignedRawInvoice_check_signature(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Calculate the hash of the encoded `RawInvoice`
 */
MUST_USE_RES struct LDKThirtyTwoBytes RawInvoice_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKSha256 RawInvoice_payment_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKDescription RawInvoice_description(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKPayeePubKey RawInvoice_payee_pub_key(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKSha256 RawInvoice_description_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKExpiryTime RawInvoice_expiry_time(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKMinFinalCltvExpiry RawInvoice_min_final_cltv_expiry(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKThirtyTwoBytes RawInvoice_payment_secret(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKInvoiceFeatures RawInvoice_features(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCVec_PrivateRouteZ RawInvoice_private_routes(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCOption_u64Z RawInvoice_amount_pico_btc(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES enum LDKCurrency RawInvoice_currency(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 * Create a new `PositiveTimestamp` from a unix timestamp in the Range
 * `0...SYSTEM_TIME_MAX_UNIX_TIMESTAMP - MAX_EXPIRY_TIME`, otherwise return a
 * `CreationError::TimestampOutOfBounds`.
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_unix_timestamp(uint64_t unix_seconds);

/**
 * Create a new `PositiveTimestamp` from a `SystemTime` with a corresponding unix timestamp in
 * the Range `0...SYSTEM_TIME_MAX_UNIX_TIMESTAMP - MAX_EXPIRY_TIME`, otherwise return a
 * `CreationError::TimestampOutOfBounds`.
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_system_time(uint64_t time);

/**
 * Returns the UNIX timestamp representing the stored time
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_unix_timestamp(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Returns a reference to the internal `SystemTime` time representation
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_time(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Transform the `Invoice` into it's unchecked version
 */
MUST_USE_RES struct LDKSignedRawInvoice Invoice_into_signed_raw(struct LDKInvoice this_arg);

/**
 * Check that the invoice is signed correctly and that key recovery works
 */
MUST_USE_RES struct LDKCResult_NoneSemanticErrorZ Invoice_check_signature(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Constructs an `Invoice` from a `SignedRawInvoice` by checking all its invariants.
 * ```
 * use lightning_invoice::*;
 *
 * let invoice = \"lnbc1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdp\\
 * \tl2pkx2ctnv5sxxmmwwd5kgetjypeh2ursdae8g6twvus8g6rfwvs8qun0dfjkxaq8rkx3yf5tcsyz3d7\\
 * \t3gafnh3cax9rn449d9p5uxz9ezhhypd0elx87sjle52x86fux2ypatgddc6k63n7erqz25le42c4u4ec\\
 * \tky03ylcqca784w\";
 *
 * let signed = invoice.parse::<SignedRawInvoice>().unwrap();
 *
 * assert!(Invoice::from_signed(signed).is_ok());
 * ```
 */
MUST_USE_RES struct LDKCResult_InvoiceSemanticErrorZ Invoice_from_signed(struct LDKSignedRawInvoice signed_invoice);

/**
 * Returns the `Invoice`'s timestamp (should equal it's creation time)
 */
MUST_USE_RES uint64_t Invoice_timestamp(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the hash to which we will receive the preimage on completion of the payment
 */
MUST_USE_RES const uint8_t (*Invoice_payment_hash(const struct LDKInvoice *NONNULL_PTR this_arg))[32];

/**
 * Get the payee's public key if one was included in the invoice
 */
MUST_USE_RES struct LDKPublicKey Invoice_payee_pub_key(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Get the payment secret if one was included in the invoice
 */
MUST_USE_RES struct LDKThirtyTwoBytes Invoice_payment_secret(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Get the invoice features if they were included in the invoice
 */
MUST_USE_RES struct LDKInvoiceFeatures Invoice_features(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Recover the payee's public key (only to be used if none was included in the invoice)
 */
MUST_USE_RES struct LDKPublicKey Invoice_recover_payee_pub_key(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the invoice's expiry time, if present, otherwise [`DEFAULT_EXPIRY_TIME`].
 */
MUST_USE_RES uint64_t Invoice_expiry_time(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the invoice's `min_final_cltv_expiry` time, if present, otherwise
 * [`DEFAULT_MIN_FINAL_CLTV_EXPIRY`].
 */
MUST_USE_RES uint64_t Invoice_min_final_cltv_expiry(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all routes included in the invoice
 */
MUST_USE_RES struct LDKCVec_PrivateRouteZ Invoice_private_routes(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all routes included in the invoice as the underlying hints
 */
MUST_USE_RES struct LDKCVec_RouteHintZ Invoice_route_hints(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the currency for which the invoice was issued
 */
MUST_USE_RES enum LDKCurrency Invoice_currency(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the amount if specified in the invoice as pico <currency>.
 */
MUST_USE_RES struct LDKCOption_u64Z Invoice_amount_pico_btc(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Creates a new `Description` if `description` is at most 1023 __bytes__ long,
 * returns `CreationError::DescriptionTooLong` otherwise
 *
 * Please note that single characters may use more than one byte due to UTF8 encoding.
 */
MUST_USE_RES struct LDKCResult_DescriptionCreationErrorZ Description_new(struct LDKStr description);

/**
 * Returns the underlying description `String`
 */
MUST_USE_RES struct LDKStr Description_into_inner(struct LDKDescription this_arg);

/**
 * Construct an `ExpiryTime` from seconds. If there exists a `PositiveTimestamp` which would
 * overflow on adding the `EpiryTime` to it then this function will return a
 * `CreationError::ExpiryTimeOutOfBounds`.
 */
MUST_USE_RES struct LDKCResult_ExpiryTimeCreationErrorZ ExpiryTime_from_seconds(uint64_t seconds);

/**
 * Construct an `ExpiryTime` from a `Duration`. If there exists a `PositiveTimestamp` which
 * would overflow on adding the `EpiryTime` to it then this function will return a
 * `CreationError::ExpiryTimeOutOfBounds`.
 */
MUST_USE_RES struct LDKCResult_ExpiryTimeCreationErrorZ ExpiryTime_from_duration(uint64_t duration);

/**
 * Returns the expiry time in seconds
 */
MUST_USE_RES uint64_t ExpiryTime_as_seconds(const struct LDKExpiryTime *NONNULL_PTR this_arg);

/**
 * Returns a reference to the underlying `Duration` (=expiry time)
 */
MUST_USE_RES uint64_t ExpiryTime_as_duration(const struct LDKExpiryTime *NONNULL_PTR this_arg);

/**
 * Creates a new (partial) route from a list of hops
 */
MUST_USE_RES struct LDKCResult_PrivateRouteCreationErrorZ PrivateRoute_new(struct LDKRouteHint hops);

/**
 * Returns the underlying list of hops
 */
MUST_USE_RES struct LDKRouteHint PrivateRoute_into_inner(struct LDKPrivateRoute this_arg);

/**
 * Creates a copy of the CreationError
 */
enum LDKCreationError CreationError_clone(const enum LDKCreationError *NONNULL_PTR orig);

/**
 * Checks if two CreationErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool CreationError_eq(const enum LDKCreationError *NONNULL_PTR a, const enum LDKCreationError *NONNULL_PTR b);

/**
 * Get the string representation of a CreationError object
 */
struct LDKStr CreationError_to_str(const enum LDKCreationError *NONNULL_PTR o);

/**
 * Creates a copy of the SemanticError
 */
enum LDKSemanticError SemanticError_clone(const enum LDKSemanticError *NONNULL_PTR orig);

/**
 * Checks if two SemanticErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SemanticError_eq(const enum LDKSemanticError *NONNULL_PTR a, const enum LDKSemanticError *NONNULL_PTR b);

/**
 * Get the string representation of a SemanticError object
 */
struct LDKStr SemanticError_to_str(const enum LDKSemanticError *NONNULL_PTR o);

/**
 * Frees any resources used by the SignOrCreationError
 */
void SignOrCreationError_free(struct LDKSignOrCreationError this_ptr);

/**
 * Creates a copy of the SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_clone(const struct LDKSignOrCreationError *NONNULL_PTR orig);

/**
 * Checks if two SignOrCreationErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SignOrCreationError_eq(const struct LDKSignOrCreationError *NONNULL_PTR a, const struct LDKSignOrCreationError *NONNULL_PTR b);

/**
 * Get the string representation of a SignOrCreationError object
 */
struct LDKStr SignOrCreationError_to_str(const struct LDKSignOrCreationError *NONNULL_PTR o);

/**
 * Utility to construct an invoice. Generally, unless you want to do something like a custom
 * cltv_expiry, this is what you should be using to create an invoice. The reason being, this
 * method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
 * doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
 * that the payment secret is valid when the invoice is paid.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description);

/**
 * Read a SiPrefix object from a string
 */
struct LDKCResult_SiPrefixNoneZ SiPrefix_from_str(struct LDKStr s);

/**
 * Read a Invoice object from a string
 */
struct LDKCResult_InvoiceNoneZ Invoice_from_str(struct LDKStr s);

/**
 * Read a SignedRawInvoice object from a string
 */
struct LDKCResult_SignedRawInvoiceNoneZ SignedRawInvoice_from_str(struct LDKStr s);

/**
 * Get the string representation of a Invoice object
 */
struct LDKStr Invoice_to_str(const struct LDKInvoice *NONNULL_PTR o);

/**
 * Get the string representation of a SignedRawInvoice object
 */
struct LDKStr SignedRawInvoice_to_str(const struct LDKSignedRawInvoice *NONNULL_PTR o);

/**
 * Get the string representation of a Currency object
 */
struct LDKStr Currency_to_str(const enum LDKCurrency *NONNULL_PTR o);

/**
 * Get the string representation of a SiPrefix object
 */
struct LDKStr SiPrefix_to_str(const enum LDKSiPrefix *NONNULL_PTR o);

#endif /* LDK_C_BINDINGS_H */

#include "ldk_ver.h"
