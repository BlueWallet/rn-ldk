#ifndef LDK_C_BINDINGS_H
#define LDK_C_BINDINGS_H

/* Generated with cbindgen:0.20.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include "ldk_rust_types.h"

/**
 * An error when accessing the chain via [`Access`].
 */
typedef enum LDKAccessError {
   /**
    * The requested chain is unknown.
    */
   LDKAccessError_UnknownChain,
   /**
    * The requested transaction doesn't exist or hasn't confirmed.
    */
   LDKAccessError_UnknownTx,
   /**
    * Must be last for serialization purposes
    */
   LDKAccessError_Sentinel,
} LDKAccessError;

/**
 * An enum which can either contain a  or not
 */
typedef enum LDKCOption_NoneZ {
   /**
    * When we're in this state, this COption_NoneZ contains a
    */
   LDKCOption_NoneZ_Some,
   /**
    * When we're in this state, this COption_NoneZ contains nothing
    */
   LDKCOption_NoneZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_NoneZ_Sentinel,
} LDKCOption_NoneZ;

/**
 * An error enum representing a failure to persist a channel monitor update.
 */
typedef enum LDKChannelMonitorUpdateErr {
   /**
    * Used to indicate a temporary failure (eg connection to a watchtower or remote backup of
    * our state failed, but is expected to succeed at some point in the future).
    *
    * Such a failure will \"freeze\" a channel, preventing us from revoking old states or
    * submitting new commitment transactions to the counterparty. Once the update(s) that failed
    * have been successfully applied, a [`MonitorEvent::UpdateCompleted`] event should be returned
    * via [`Watch::release_pending_monitor_events`] which will then restore the channel to an
    * operational state.
    *
    * Note that a given ChannelManager will *never* re-generate a given ChannelMonitorUpdate. If
    * you return a TemporaryFailure you must ensure that it is written to disk safely before
    * writing out the latest ChannelManager state.
    *
    * Even when a channel has been \"frozen\" updates to the ChannelMonitor can continue to occur
    * (eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting
    * to claim it on this channel) and those updates must be applied wherever they can be. At
    * least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should
    * be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to
    * the channel which would invalidate previous ChannelMonitors are not made when a channel has
    * been \"frozen\".
    *
    * Note that even if updates made after TemporaryFailure succeed you must still provide a
    * [`MonitorEvent::UpdateCompleted`] to ensure you have the latest monitor and re-enable
    * normal channel operation. Note that this is normally generated through a call to
    * [`ChainMonitor::channel_monitor_updated`].
    *
    * Note that the update being processed here will not be replayed for you when you return a
    * [`MonitorEvent::UpdateCompleted`] event via [`Watch::release_pending_monitor_events`], so
    * you must store the update itself on your own local disk prior to returning a
    * TemporaryFailure. You may, of course, employ a journaling approach, storing only the
    * ChannelMonitorUpdate on disk without updating the monitor itself, replaying the journal at
    * reload-time.
    *
    * For deployments where a copy of ChannelMonitors and other local state are backed up in a
    * remote location (with local copies persisted immediately), it is anticipated that all
    * updates will return TemporaryFailure until the remote copies could be updated.
    *
    * [`ChainMonitor::channel_monitor_updated`]: chainmonitor::ChainMonitor::channel_monitor_updated
    */
   LDKChannelMonitorUpdateErr_TemporaryFailure,
   /**
    * Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a
    * different watchtower and cannot update with all watchtowers that were previously informed
    * of this channel).
    *
    * At reception of this error, ChannelManager will force-close the channel and return at
    * least a final ChannelMonitorUpdate::ChannelForceClosed which must be delivered to at
    * least one ChannelMonitor copy. Revocation secret MUST NOT be released and offchain channel
    * update must be rejected.
    *
    * This failure may also signal a failure to update the local persisted copy of one of
    * the channel monitor instance.
    *
    * Note that even when you fail a holder commitment transaction update, you must store the
    * update to ensure you can claim from it in case of a duplicate copy of this ChannelMonitor
    * broadcasts it (e.g distributed channel-monitor deployment)
    *
    * In case of distributed watchtowers deployment, the new version must be written to disk, as
    * state may have been stored but rejected due to a block forcing a commitment broadcast. This
    * storage is used to claim outputs of rejected state confirmed onchain by another watchtower,
    * lagging behind on block processing.
    */
   LDKChannelMonitorUpdateErr_PermanentFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKChannelMonitorUpdateErr_Sentinel,
} LDKChannelMonitorUpdateErr;

/**
 * An enum that represents the speed at which we want a transaction to confirm used for feerate
 * estimation.
 */
typedef enum LDKConfirmationTarget {
   /**
    * We are happy with this transaction confirming slowly when feerate drops some.
    */
   LDKConfirmationTarget_Background,
   /**
    * We'd like this transaction to confirm without major delay, but 12-18 blocks is fine.
    */
   LDKConfirmationTarget_Normal,
   /**
    * We'd like this transaction to confirm in the next few blocks.
    */
   LDKConfirmationTarget_HighPriority,
   /**
    * Must be last for serialization purposes
    */
   LDKConfirmationTarget_Sentinel,
} LDKConfirmationTarget;

/**
 * Errors that may occur when constructing a new `RawInvoice` or `Invoice`
 */
typedef enum LDKCreationError {
   /**
    * The supplied description string was longer than 639 __bytes__ (see [`Description::new(â€¦)`](./struct.Description.html#method.new))
    */
   LDKCreationError_DescriptionTooLong,
   /**
    * The specified route has too many hops and can't be encoded
    */
   LDKCreationError_RouteTooLong,
   /**
    * The Unix timestamp of the supplied date is less than zero or greater than 35-bits
    */
   LDKCreationError_TimestampOutOfBounds,
   /**
    * The supplied millisatoshi amount was greater than the total bitcoin supply.
    */
   LDKCreationError_InvalidAmount,
   /**
    * Route hints were required for this invoice and were missing. Applies to
    * [phantom invoices].
    *
    * [phantom invoices]: crate::utils::create_phantom_invoice
    */
   LDKCreationError_MissingRouteHints,
   /**
    * Must be last for serialization purposes
    */
   LDKCreationError_Sentinel,
} LDKCreationError;

/**
 * Enum representing the crypto currencies (or networks) supported by this library
 */
typedef enum LDKCurrency {
   /**
    * Bitcoin mainnet
    */
   LDKCurrency_Bitcoin,
   /**
    * Bitcoin testnet
    */
   LDKCurrency_BitcoinTestnet,
   /**
    * Bitcoin regtest
    */
   LDKCurrency_Regtest,
   /**
    * Bitcoin simnet
    */
   LDKCurrency_Simnet,
   /**
    * Bitcoin signet
    */
   LDKCurrency_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKCurrency_Sentinel,
} LDKCurrency;

/**
 * Represents an IO Error. Note that some information is lost in the conversion from Rust.
 */
typedef enum LDKIOError {
   LDKIOError_NotFound,
   LDKIOError_PermissionDenied,
   LDKIOError_ConnectionRefused,
   LDKIOError_ConnectionReset,
   LDKIOError_ConnectionAborted,
   LDKIOError_NotConnected,
   LDKIOError_AddrInUse,
   LDKIOError_AddrNotAvailable,
   LDKIOError_BrokenPipe,
   LDKIOError_AlreadyExists,
   LDKIOError_WouldBlock,
   LDKIOError_InvalidInput,
   LDKIOError_InvalidData,
   LDKIOError_TimedOut,
   LDKIOError_WriteZero,
   LDKIOError_Interrupted,
   LDKIOError_Other,
   LDKIOError_UnexpectedEof,
   /**
    * Must be last for serialization purposes
    */
   LDKIOError_Sentinel,
} LDKIOError;

/**
 * An enum representing the available verbosity levels of the logger.
 */
typedef enum LDKLevel {
   /**
    * Designates extremely verbose information, including gossip-induced messages
    */
   LDKLevel_Gossip,
   /**
    * Designates very low priority, often extremely verbose, information
    */
   LDKLevel_Trace,
   /**
    * Designates lower priority information
    */
   LDKLevel_Debug,
   /**
    * Designates useful information
    */
   LDKLevel_Info,
   /**
    * Designates hazardous situations
    */
   LDKLevel_Warn,
   /**
    * Designates very serious errors
    */
   LDKLevel_Error,
   /**
    * Must be last for serialization purposes
    */
   LDKLevel_Sentinel,
} LDKLevel;

/**
 * An enum representing the possible Bitcoin or test networks which we can run on
 */
typedef enum LDKNetwork {
   /**
    * The main Bitcoin blockchain.
    */
   LDKNetwork_Bitcoin,
   /**
    * The testnet3 blockchain.
    */
   LDKNetwork_Testnet,
   /**
    * A local test blockchain.
    */
   LDKNetwork_Regtest,
   /**
    * A blockchain on which blocks are signed instead of mined.
    */
   LDKNetwork_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKNetwork_Sentinel,
} LDKNetwork;

/**
 * Specifies the recipient of an invoice, to indicate to [`KeysInterface::sign_invoice`] what node
 * secret key should be used to sign the invoice.
 */
typedef enum LDKRecipient {
   /**
    * The invoice should be signed with the local node secret key.
    */
   LDKRecipient_Node,
   /**
    * The invoice should be signed with the phantom node secret key. This secret key must be the
    * same for all nodes participating in the [phantom node payment].
    *
    * [phantom node payment]: PhantomKeysManager
    */
   LDKRecipient_PhantomNode,
   /**
    * Must be last for serialization purposes
    */
   LDKRecipient_Sentinel,
} LDKRecipient;

/**
 * Represents an error returned from libsecp256k1 during validation of some secp256k1 data
 */
typedef enum LDKSecp256k1Error {
   /**
    * Signature failed verification
    */
   LDKSecp256k1Error_IncorrectSignature,
   /**
    * Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
    */
   LDKSecp256k1Error_InvalidMessage,
   /**
    * Bad public key
    */
   LDKSecp256k1Error_InvalidPublicKey,
   /**
    * Bad signature
    */
   LDKSecp256k1Error_InvalidSignature,
   /**
    * Bad secret key
    */
   LDKSecp256k1Error_InvalidSecretKey,
   /**
    * Bad recovery id
    */
   LDKSecp256k1Error_InvalidRecoveryId,
   /**
    * Invalid tweak for add_assign or mul_assign
    */
   LDKSecp256k1Error_InvalidTweak,
   /**
    * tweak_add_check failed on an xonly public key
    */
   LDKSecp256k1Error_TweakCheckFailed,
   /**
    * Didn't pass enough memory to context creation with preallocated memory
    */
   LDKSecp256k1Error_NotEnoughMemory,
   /**
    * Must be last for serialization purposes
    */
   LDKSecp256k1Error_Sentinel,
} LDKSecp256k1Error;

/**
 * Errors that may occur when converting a `RawInvoice` to an `Invoice`. They relate to the
 * requirements sections in BOLT #11
 */
typedef enum LDKSemanticError {
   /**
    * The invoice is missing the mandatory payment hash
    */
   LDKSemanticError_NoPaymentHash,
   /**
    * The invoice has multiple payment hashes which isn't allowed
    */
   LDKSemanticError_MultiplePaymentHashes,
   /**
    * No description or description hash are part of the invoice
    */
   LDKSemanticError_NoDescription,
   /**
    * The invoice contains multiple descriptions and/or description hashes which isn't allowed
    */
   LDKSemanticError_MultipleDescriptions,
   /**
    * The invoice is missing the mandatory payment secret, which all modern lightning nodes
    * should provide.
    */
   LDKSemanticError_NoPaymentSecret,
   /**
    * The invoice contains multiple payment secrets
    */
   LDKSemanticError_MultiplePaymentSecrets,
   /**
    * The invoice's features are invalid
    */
   LDKSemanticError_InvalidFeatures,
   /**
    * The recovery id doesn't fit the signature/pub key
    */
   LDKSemanticError_InvalidRecoveryId,
   /**
    * The invoice's signature is invalid
    */
   LDKSemanticError_InvalidSignature,
   /**
    * The invoice's amount was not a whole number of millisatoshis
    */
   LDKSemanticError_ImpreciseAmount,
   /**
    * Must be last for serialization purposes
    */
   LDKSemanticError_Sentinel,
} LDKSemanticError;

/**
 * SI prefixes for the human readable part
 */
typedef enum LDKSiPrefix {
   /**
    * 10^-3
    */
   LDKSiPrefix_Milli,
   /**
    * 10^-6
    */
   LDKSiPrefix_Micro,
   /**
    * 10^-9
    */
   LDKSiPrefix_Nano,
   /**
    * 10^-12
    */
   LDKSiPrefix_Pico,
   /**
    * Must be last for serialization purposes
    */
   LDKSiPrefix_Sentinel,
} LDKSiPrefix;

/**
 * A Rust str object, ie a reference to a UTF8-valid string.
 * This is *not* null-terminated so cannot be used directly as a C string!
 */
typedef struct LDKStr {
   /**
    * A pointer to the string's bytes, in UTF8 encoding
    */
   const uint8_t *chars;
   /**
    * The number of bytes (not characters!) pointed to by `chars`
    */
   uintptr_t len;
   /**
    * Whether the data pointed to by `chars` should be freed or not.
    */
   bool chars_is_owned;
} LDKStr;

/**
 * Represents an error returned from the bech32 library during validation of some bech32 data
 */
typedef enum LDKBech32Error_Tag {
   /**
    * String does not contain the separator character
    */
   LDKBech32Error_MissingSeparator,
   /**
    * The checksum does not match the rest of the data
    */
   LDKBech32Error_InvalidChecksum,
   /**
    * The data or human-readable part is too long or too short
    */
   LDKBech32Error_InvalidLength,
   /**
    * Some part of the string contains an invalid character
    */
   LDKBech32Error_InvalidChar,
   /**
    * Some part of the data has an invalid value
    */
   LDKBech32Error_InvalidData,
   /**
    * The bit conversion failed due to a padding issue
    */
   LDKBech32Error_InvalidPadding,
   /**
    * The whole string must be of one case
    */
   LDKBech32Error_MixedCase,
   /**
    * Must be last for serialization purposes
    */
   LDKBech32Error_Sentinel,
} LDKBech32Error_Tag;

typedef struct LDKBech32Error {
   LDKBech32Error_Tag tag;
   union {
      struct {
         uint32_t invalid_char;
      };
      struct {
         uint8_t invalid_data;
      };
   };
} LDKBech32Error;

/**
 * A serialized transaction, in (pointer, length) form.
 *
 * This type optionally owns its own memory, and thus the semantics around access change based on
 * the `data_is_owned` flag. If `data_is_owned` is set, you must call `Transaction_free` to free
 * the underlying buffer before the object goes out of scope. If `data_is_owned` is not set, any
 * access to the buffer after the scope in which the object was provided to you is invalid. eg,
 * access after you return from the call in which a `!data_is_owned` `Transaction` is provided to
 * you would be invalid.
 *
 * Note that, while it may change in the future, because transactions on the Rust side are stored
 * in a deserialized form, all `Transaction`s generated on the Rust side will have `data_is_owned`
 * set. Similarly, while it may change in the future, all `Transaction`s you pass to Rust may have
 * `data_is_owned` either set or unset at your discretion.
 */
typedef struct LDKTransaction {
   /**
    * The serialized transaction data.
    *
    * This is non-const for your convenience, an object passed to Rust is never written to.
    */
   uint8_t *data;
   /**
    * The length of the serialized transaction
    */
   uintptr_t datalen;
   /**
    * Whether the data pointed to by `data` should be freed or not.
    */
   bool data_is_owned;
} LDKTransaction;

/**
 * A dynamically-allocated array of u8s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u8Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   uint8_t *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u8Z;

/**
 * A transaction output including a scriptPubKey and value.
 * This type *does* own its own memory, so must be free'd appropriately.
 */
typedef struct LDKTxOut {
   /**
    * The script_pubkey in this output
    */
   struct LDKCVec_u8Z script_pubkey;
   /**
    * The value, in satoshis, of this output
    */
   uint64_t value;
} LDKTxOut;

/**
 * The contents of CResult_NoneNoneZ
 */
typedef union LDKCResult_NoneNoneZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_NoneNoneZPtr;

/**
 * A CResult_NoneNoneZ represents the result of a fallible operation,
 * containing a () on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneNoneZ {
   /**
    * The contents of this CResult_NoneNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneNoneZPtr contents;
   /**
    * Whether this CResult_NoneNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneNoneZ;



/**
 * Implements the per-commitment secret storage scheme from
 * [BOLT 3](https://github.com/lightningnetwork/lightning-rfc/blob/dcbf8583976df087c79c3ce0b535311212e6812d/03-transactions.md#efficient-per-commitment-secret-storage).
 *
 * Allows us to keep track of all of the revocation secrets of our counterparty in just 50*32 bytes
 * or so.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyCommitmentSecrets {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyCommitmentSecrets *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyCommitmentSecrets;



/**
 * An error in decoding a message or struct.
 */
typedef struct MUST_USE_STRUCT LDKDecodeError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDecodeError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDecodeError;

/**
 * The contents of CResult_CounterpartyCommitmentSecretsDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyCommitmentSecrets *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr;

/**
 * A CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyCommitmentSecretsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ;

/**
 * Represents a valid secp256k1 secret key serialized as a 32 byte array.
 */
typedef struct LDKSecretKey {
   /**
    * The bytes of the secret key
    */
   uint8_t bytes[32];
} LDKSecretKey;

/**
 * The contents of CResult_SecretKeyErrorZ
 */
typedef union LDKCResult_SecretKeyErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSecretKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_SecretKeyErrorZPtr;

/**
 * A CResult_SecretKeyErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::SecretKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SecretKeyErrorZ {
   /**
    * The contents of this CResult_SecretKeyErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SecretKeyErrorZPtr contents;
   /**
    * Whether this CResult_SecretKeyErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SecretKeyErrorZ;

/**
 * Represents a valid secp256k1 public key serialized in "compressed form" as a 33 byte array.
 */
typedef struct LDKPublicKey {
   /**
    * The bytes of the public key
    */
   uint8_t compressed_form[33];
} LDKPublicKey;

/**
 * The contents of CResult_PublicKeyErrorZ
 */
typedef union LDKCResult_PublicKeyErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPublicKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_PublicKeyErrorZPtr;

/**
 * A CResult_PublicKeyErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::PublicKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PublicKeyErrorZ {
   /**
    * The contents of this CResult_PublicKeyErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PublicKeyErrorZPtr contents;
   /**
    * Whether this CResult_PublicKeyErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PublicKeyErrorZ;



/**
 * The set of public keys which are used in the creation of one commitment transaction.
 * These are derived from the channel base keys and per-commitment data.
 *
 * A broadcaster key is provided from potential broadcaster of the computed transaction.
 * A countersignatory key is coming from a protocol participant unable to broadcast the
 * transaction.
 *
 * These keys are assumed to be good, either because the code derived them from
 * channel basepoints via the new function, or they were obtained via
 * CommitmentTransaction.trust().keys() because we trusted the source of the
 * pre-calculated keys.
 */
typedef struct MUST_USE_STRUCT LDKTxCreationKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxCreationKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxCreationKeys;

/**
 * The contents of CResult_TxCreationKeysDecodeErrorZ
 */
typedef union LDKCResult_TxCreationKeysDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxCreationKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxCreationKeysDecodeErrorZPtr;

/**
 * A CResult_TxCreationKeysDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxCreationKeysDecodeErrorZ {
   /**
    * The contents of this CResult_TxCreationKeysDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxCreationKeysDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxCreationKeysDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxCreationKeysDecodeErrorZ;



/**
 * One counterparty's public keys which do not change over the life of a channel.
 */
typedef struct MUST_USE_STRUCT LDKChannelPublicKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelPublicKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelPublicKeys;

/**
 * The contents of CResult_ChannelPublicKeysDecodeErrorZ
 */
typedef union LDKCResult_ChannelPublicKeysDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelPublicKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelPublicKeysDecodeErrorZPtr;

/**
 * A CResult_ChannelPublicKeysDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::ChannelPublicKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelPublicKeysDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelPublicKeysDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelPublicKeysDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelPublicKeysDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelPublicKeysDecodeErrorZ;

/**
 * The contents of CResult_TxCreationKeysErrorZ
 */
typedef union LDKCResult_TxCreationKeysErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxCreationKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_TxCreationKeysErrorZPtr;

/**
 * A CResult_TxCreationKeysErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxCreationKeysErrorZ {
   /**
    * The contents of this CResult_TxCreationKeysErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxCreationKeysErrorZPtr contents;
   /**
    * Whether this CResult_TxCreationKeysErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxCreationKeysErrorZ;

/**
 * An enum which can either contain a u32 or not
 */
typedef enum LDKCOption_u32Z_Tag {
   /**
    * When we're in this state, this COption_u32Z contains a u32
    */
   LDKCOption_u32Z_Some,
   /**
    * When we're in this state, this COption_u32Z contains nothing
    */
   LDKCOption_u32Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u32Z_Sentinel,
} LDKCOption_u32Z_Tag;

typedef struct LDKCOption_u32Z {
   LDKCOption_u32Z_Tag tag;
   union {
      struct {
         uint32_t some;
      };
   };
} LDKCOption_u32Z;



/**
 * Information about an HTLC as it appears in a commitment transaction
 */
typedef struct MUST_USE_STRUCT LDKHTLCOutputInCommitment {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCOutputInCommitment *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCOutputInCommitment;

/**
 * The contents of CResult_HTLCOutputInCommitmentDecodeErrorZ
 */
typedef union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCOutputInCommitment *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr;

/**
 * A CResult_HTLCOutputInCommitmentDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::HTLCOutputInCommitment on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCOutputInCommitmentDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCOutputInCommitmentDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZ;



/**
 * Late-bound per-channel counterparty data used to build transactions.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyChannelTransactionParameters;

/**
 * The contents of CResult_CounterpartyChannelTransactionParametersDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyChannelTransactionParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr;

/**
 * A CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ;



/**
 * Per-channel data used to build transactions in conjunction with the per-commitment data (CommitmentTransaction).
 * The fields are organized by holder/counterparty.
 *
 * Normally, this is converted to the broadcaster/countersignatory-organized DirectedChannelTransactionParameters
 * before use, via the as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelTransactionParameters;

/**
 * The contents of CResult_ChannelTransactionParametersDecodeErrorZ
 */
typedef union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelTransactionParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelTransactionParametersDecodeErrorZPtr;

/**
 * A CResult_ChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::ChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelTransactionParametersDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelTransactionParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelTransactionParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelTransactionParametersDecodeErrorZ;

/**
 * Represents a secp256k1 signature serialized as two 32-byte numbers
 */
typedef struct LDKSignature {
   /**
    * The bytes of the signature in "compact" form
    */
   uint8_t compact_form[64];
} LDKSignature;

/**
 * A dynamically-allocated array of crate::c_types::Signatures of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_SignatureZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKSignature *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_SignatureZ;



/**
 * Information needed to build and sign a holder's commitment transaction.
 *
 * The transaction is only signed once we are ready to broadcast.
 */
typedef struct MUST_USE_STRUCT LDKHolderCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHolderCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHolderCommitmentTransaction;

/**
 * The contents of CResult_HolderCommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHolderCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_HolderCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::HolderCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_HolderCommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HolderCommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZ;



/**
 * A pre-built Bitcoin commitment transaction and its txid.
 */
typedef struct MUST_USE_STRUCT LDKBuiltCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBuiltCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBuiltCommitmentTransaction;

/**
 * The contents of CResult_BuiltCommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBuiltCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_BuiltCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::BuiltCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_BuiltCommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BuiltCommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZ;



/**
 * A wrapper on ClosingTransaction indicating that the built bitcoin
 * transaction is trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */
typedef struct MUST_USE_STRUCT LDKTrustedClosingTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTrustedClosingTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTrustedClosingTransaction;

/**
 * The contents of CResult_TrustedClosingTransactionNoneZ
 */
typedef union LDKCResult_TrustedClosingTransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTrustedClosingTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TrustedClosingTransactionNoneZPtr;

/**
 * A CResult_TrustedClosingTransactionNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TrustedClosingTransaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TrustedClosingTransactionNoneZ {
   /**
    * The contents of this CResult_TrustedClosingTransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TrustedClosingTransactionNoneZPtr contents;
   /**
    * Whether this CResult_TrustedClosingTransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TrustedClosingTransactionNoneZ;



/**
 * This class tracks the per-transaction information needed to build a commitment transaction and will
 * actually build it and sign.  It is used for holder transactions that we sign only when needed
 * and for transactions we sign for the counterparty.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentTransaction;

/**
 * The contents of CResult_CommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_CommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_CommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_CommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CommitmentTransactionDecodeErrorZ;



/**
 * A wrapper on CommitmentTransaction indicating that the derived fields (the built bitcoin
 * transaction and the transaction creation keys) are trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */
typedef struct MUST_USE_STRUCT LDKTrustedCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTrustedCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTrustedCommitmentTransaction;

/**
 * The contents of CResult_TrustedCommitmentTransactionNoneZ
 */
typedef union LDKCResult_TrustedCommitmentTransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTrustedCommitmentTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TrustedCommitmentTransactionNoneZPtr;

/**
 * A CResult_TrustedCommitmentTransactionNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TrustedCommitmentTransaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TrustedCommitmentTransactionNoneZ {
   /**
    * The contents of this CResult_TrustedCommitmentTransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TrustedCommitmentTransactionNoneZPtr contents;
   /**
    * Whether this CResult_TrustedCommitmentTransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TrustedCommitmentTransactionNoneZ;

/**
 * The contents of CResult_CVec_SignatureZNoneZ
 */
typedef union LDKCResult_CVec_SignatureZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_SignatureZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_SignatureZNoneZPtr;

/**
 * A CResult_CVec_SignatureZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_SignatureZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_SignatureZNoneZ {
   /**
    * The contents of this CResult_CVec_SignatureZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_SignatureZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_SignatureZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_SignatureZNoneZ;



/**
 * A script pubkey for shutting down a channel as defined by [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md
 */
typedef struct MUST_USE_STRUCT LDKShutdownScript {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeShutdownScript *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKShutdownScript;

/**
 * The contents of CResult_ShutdownScriptDecodeErrorZ
 */
typedef union LDKCResult_ShutdownScriptDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdownScript *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ShutdownScriptDecodeErrorZPtr;

/**
 * A CResult_ShutdownScriptDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownScriptDecodeErrorZ {
   /**
    * The contents of this CResult_ShutdownScriptDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownScriptDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ShutdownScriptDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownScriptDecodeErrorZ;



/**
 * An error occurring when converting from [`Script`] to [`ShutdownScript`].
 */
typedef struct MUST_USE_STRUCT LDKInvalidShutdownScript {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvalidShutdownScript *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvalidShutdownScript;

/**
 * The contents of CResult_ShutdownScriptInvalidShutdownScriptZ
 */
typedef union LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdownScript *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKInvalidShutdownScript *err;
} LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr;

/**
 * A CResult_ShutdownScriptInvalidShutdownScriptZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::script::InvalidShutdownScript on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ {
   /**
    * The contents of this CResult_ShutdownScriptInvalidShutdownScriptZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr contents;
   /**
    * Whether this CResult_ShutdownScriptInvalidShutdownScriptZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownScriptInvalidShutdownScriptZ;

/**
 * The contents of CResult_NoneErrorZ
 */
typedef union LDKCResult_NoneErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_NoneErrorZPtr;

/**
 * A CResult_NoneErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneErrorZ {
   /**
    * The contents of this CResult_NoneErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneErrorZPtr contents;
   /**
    * Whether this CResult_NoneErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneErrorZ;



/**
 * A hop in a route
 */
typedef struct MUST_USE_STRUCT LDKRouteHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHop;

/**
 * The contents of CResult_RouteHopDecodeErrorZ
 */
typedef union LDKCResult_RouteHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHopDecodeErrorZPtr;

/**
 * A CResult_RouteHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHopDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHopDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHops of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHopZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHop *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHopZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CVec_RouteHopZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CVec_RouteHopZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCVec_RouteHopZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CVec_RouteHopZZ;



/**
 * A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,
 * it can take multiple paths. Each path is composed of one or more hops through the network.
 */
typedef struct MUST_USE_STRUCT LDKRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoute;

/**
 * The contents of CResult_RouteDecodeErrorZ
 */
typedef union LDKCResult_RouteDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteDecodeErrorZPtr;

/**
 * A CResult_RouteDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteDecodeErrorZ {
   /**
    * The contents of this CResult_RouteDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteDecodeErrorZ;



/**
 * Parameters needed to find a [`Route`].
 *
 * Passed to [`find_route`] and also provided in [`Event::PaymentPathFailed`] for retrying a failed
 * payment path.
 *
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 */
typedef struct MUST_USE_STRUCT LDKRouteParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteParameters;

/**
 * The contents of CResult_RouteParametersDecodeErrorZ
 */
typedef union LDKCResult_RouteParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteParametersDecodeErrorZPtr;

/**
 * A CResult_RouteParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteParametersDecodeErrorZ {
   /**
    * The contents of this CResult_RouteParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteParametersDecodeErrorZ;



/**
 * A list of hops along a payment path terminating with a channel to the recipient.
 */
typedef struct MUST_USE_STRUCT LDKRouteHint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHint;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHints of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHintZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHint *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHintZ;

/**
 * An enum which can either contain a u64 or not
 */
typedef enum LDKCOption_u64Z_Tag {
   /**
    * When we're in this state, this COption_u64Z contains a u64
    */
   LDKCOption_u64Z_Some,
   /**
    * When we're in this state, this COption_u64Z contains nothing
    */
   LDKCOption_u64Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u64Z_Sentinel,
} LDKCOption_u64Z_Tag;

typedef struct LDKCOption_u64Z {
   LDKCOption_u64Z_Tag tag;
   union {
      struct {
         uint64_t some;
      };
   };
} LDKCOption_u64Z;



/**
 * The recipient of a payment.
 */
typedef struct MUST_USE_STRUCT LDKPaymentParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePaymentParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPaymentParameters;

/**
 * The contents of CResult_PaymentParametersDecodeErrorZ
 */
typedef union LDKCResult_PaymentParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPaymentParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PaymentParametersDecodeErrorZPtr;

/**
 * A CResult_PaymentParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::PaymentParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentParametersDecodeErrorZ {
   /**
    * The contents of this CResult_PaymentParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PaymentParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentParametersDecodeErrorZ;



/**
 * A channel descriptor for a hop along a payment path.
 */
typedef struct MUST_USE_STRUCT LDKRouteHintHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHintHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHintHop;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHintHops of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHintHopZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHintHop *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHintHopZ;

/**
 * The contents of CResult_RouteHintDecodeErrorZ
 */
typedef union LDKCResult_RouteHintDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHint *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHintDecodeErrorZPtr;

/**
 * A CResult_RouteHintDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHint on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHintDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHintDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHintDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHintDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHintDecodeErrorZ;

/**
 * The contents of CResult_RouteHintHopDecodeErrorZ
 */
typedef union LDKCResult_RouteHintHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHintHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHintHopDecodeErrorZPtr;

/**
 * A CResult_RouteHintHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHintHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHintHopDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHintHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHintHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHintHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHintHopDecodeErrorZ;



/**
 * Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels
 */
typedef struct MUST_USE_STRUCT LDKChannelDetails {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelDetails *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelDetails;

/**
 * A dynamically-allocated array of crate::lightning::ln::channelmanager::ChannelDetailss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ChannelDetailsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKChannelDetails *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ChannelDetailsZ;



/**
 * An Err type for failure to process messages.
 */
typedef struct MUST_USE_STRUCT LDKLightningError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLightningError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLightningError;

/**
 * The contents of CResult_RouteLightningErrorZ
 */
typedef union LDKCResult_RouteLightningErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_RouteLightningErrorZPtr;

/**
 * A CResult_RouteLightningErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteLightningErrorZ {
   /**
    * The contents of this CResult_RouteLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteLightningErrorZPtr contents;
   /**
    * Whether this CResult_RouteLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteLightningErrorZ;

/**
 * The contents of CResult_TxOutAccessErrorZ
 */
typedef union LDKCResult_TxOutAccessErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxOut *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKAccessError *err;
} LDKCResult_TxOutAccessErrorZPtr;

/**
 * A CResult_TxOutAccessErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::TxOut on success and a crate::lightning::chain::AccessError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxOutAccessErrorZ {
   /**
    * The contents of this CResult_TxOutAccessErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxOutAccessErrorZPtr contents;
   /**
    * Whether this CResult_TxOutAccessErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxOutAccessErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_usizeTransactionZ {
   /**
    * The element at position 0
    */
   uintptr_t a;
   /**
    * The element at position 1
    */
   struct LDKTransaction b;
} LDKC2Tuple_usizeTransactionZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_usizeTransactionZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_usizeTransactionZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_usizeTransactionZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_usizeTransactionZZ;

/**
 * Arbitrary 32 bytes, which could represent one of a few different things. You probably want to
 * look up the corresponding function in rust-lightning's docs.
 */
typedef struct LDKThirtyTwoBytes {
   /**
    * The thirty-two bytes
    */
   uint8_t data[32];
} LDKThirtyTwoBytes;

/**
 * A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TxidZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKThirtyTwoBytes *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TxidZ;

/**
 * The contents of CResult_NoneChannelMonitorUpdateErrZ
 */
typedef union LDKCResult_NoneChannelMonitorUpdateErrZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKChannelMonitorUpdateErr *err;
} LDKCResult_NoneChannelMonitorUpdateErrZPtr;

/**
 * A CResult_NoneChannelMonitorUpdateErrZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::chain::ChannelMonitorUpdateErr on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneChannelMonitorUpdateErrZ {
   /**
    * The contents of this CResult_NoneChannelMonitorUpdateErrZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneChannelMonitorUpdateErrZPtr contents;
   /**
    * Whether this CResult_NoneChannelMonitorUpdateErrZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneChannelMonitorUpdateErrZ;



/**
 * Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
 * chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
 * preimage claim backward will lead to loss of funds.
 */
typedef struct MUST_USE_STRUCT LDKHTLCUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCUpdate;



/**
 * A reference to a transaction output.
 *
 * Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32
 * due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way.
 */
typedef struct MUST_USE_STRUCT LDKOutPoint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOutPoint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOutPoint;

/**
 * An event to be processed by the ChannelManager.
 */
typedef enum LDKMonitorEvent_Tag {
   /**
    * A monitor event containing an HTLCUpdate.
    */
   LDKMonitorEvent_HTLCEvent,
   /**
    * A monitor event that the Channel's commitment transaction was confirmed.
    */
   LDKMonitorEvent_CommitmentTxConfirmed,
   /**
    * Indicates a [`ChannelMonitor`] update has completed. See
    * [`ChannelMonitorUpdateErr::TemporaryFailure`] for more information on how this is used.
    *
    * [`ChannelMonitorUpdateErr::TemporaryFailure`]: super::ChannelMonitorUpdateErr::TemporaryFailure
    */
   LDKMonitorEvent_UpdateCompleted,
   /**
    * Indicates a [`ChannelMonitor`] update has failed. See
    * [`ChannelMonitorUpdateErr::PermanentFailure`] for more information on how this is used.
    *
    * [`ChannelMonitorUpdateErr::PermanentFailure`]: super::ChannelMonitorUpdateErr::PermanentFailure
    */
   LDKMonitorEvent_UpdateFailed,
   /**
    * Must be last for serialization purposes
    */
   LDKMonitorEvent_Sentinel,
} LDKMonitorEvent_Tag;

typedef struct LDKMonitorEvent_LDKUpdateCompleted_Body {
   /**
    * The funding outpoint of the [`ChannelMonitor`] that was updated
    */
   struct LDKOutPoint funding_txo;
   /**
    * The Update ID from [`ChannelMonitorUpdate::update_id`] which was applied or
    * [`ChannelMonitor::get_latest_update_id`].
    *
    * Note that this should only be set to a given update's ID if all previous updates for the
    * same [`ChannelMonitor`] have been applied and persisted.
    */
   uint64_t monitor_update_id;
} LDKMonitorEvent_LDKUpdateCompleted_Body;

typedef struct MUST_USE_STRUCT LDKMonitorEvent {
   LDKMonitorEvent_Tag tag;
   union {
      struct {
         struct LDKHTLCUpdate htlc_event;
      };
      struct {
         struct LDKOutPoint commitment_tx_confirmed;
      };
      LDKMonitorEvent_LDKUpdateCompleted_Body update_completed;
      struct {
         struct LDKOutPoint update_failed;
      };
   };
} LDKMonitorEvent;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::MonitorEvents of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MonitorEventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMonitorEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MonitorEventZ;

/**
 * An enum which can either contain a crate::c_types::derived::C2Tuple_usizeTransactionZ or not
 */
typedef enum LDKCOption_C2Tuple_usizeTransactionZZ_Tag {
   /**
    * When we're in this state, this COption_C2Tuple_usizeTransactionZZ contains a crate::c_types::derived::C2Tuple_usizeTransactionZ
    */
   LDKCOption_C2Tuple_usizeTransactionZZ_Some,
   /**
    * When we're in this state, this COption_C2Tuple_usizeTransactionZZ contains nothing
    */
   LDKCOption_C2Tuple_usizeTransactionZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_C2Tuple_usizeTransactionZZ_Sentinel,
} LDKCOption_C2Tuple_usizeTransactionZZ_Tag;

typedef struct LDKCOption_C2Tuple_usizeTransactionZZ {
   LDKCOption_C2Tuple_usizeTransactionZZ_Tag tag;
   union {
      struct {
         struct LDKC2Tuple_usizeTransactionZ some;
      };
   };
} LDKCOption_C2Tuple_usizeTransactionZZ;

/**
 * The reason the channel was closed. See individual variants more details.
 */
typedef enum LDKClosureReason_Tag {
   /**
    * Closure generated from receiving a peer error message.
    *
    * Our counterparty may have broadcasted their latest commitment state, and we have
    * as well.
    */
   LDKClosureReason_CounterpartyForceClosed,
   /**
    * Closure generated from [`ChannelManager::force_close_channel`], called by the user.
    *
    * [`ChannelManager::force_close_channel`]: crate::ln::channelmanager::ChannelManager::force_close_channel.
    */
   LDKClosureReason_HolderForceClosed,
   /**
    * The channel was closed after negotiating a cooperative close and we've now broadcasted
    * the cooperative close transaction. Note the shutdown may have been initiated by us.
    */
   LDKClosureReason_CooperativeClosure,
   /**
    * A commitment transaction was confirmed on chain, closing the channel. Most likely this
    * commitment transaction came from our counterparty, but it may also have come from
    * a copy of our own `ChannelMonitor`.
    */
   LDKClosureReason_CommitmentTxConfirmed,
   /**
    * The funding transaction failed to confirm in a timely manner on an inbound channel.
    */
   LDKClosureReason_FundingTimedOut,
   /**
    * Closure generated from processing an event, likely a HTLC forward/relay/reception.
    */
   LDKClosureReason_ProcessingError,
   /**
    * The `PeerManager` informed us that we've disconnected from the peer. We close channels
    * if the `PeerManager` informed us that it is unlikely we'll be able to connect to the
    * peer again in the future or if the peer disconnected before we finished negotiating
    * the channel open. The first case may be caused by incompatible features which our
    * counterparty, or we, require.
    */
   LDKClosureReason_DisconnectedPeer,
   /**
    * Closure generated from `ChannelManager::read` if the ChannelMonitor is newer than
    * the ChannelManager deserialized.
    */
   LDKClosureReason_OutdatedChannelManager,
   /**
    * Must be last for serialization purposes
    */
   LDKClosureReason_Sentinel,
} LDKClosureReason_Tag;

typedef struct LDKClosureReason_LDKCounterpartyForceClosed_Body {
   /**
    * The error which the peer sent us.
    *
    * The string should be sanitized before it is used (e.g emitted to logs
    * or printed to stdout). Otherwise, a well crafted error message may exploit
    * a security vulnerability in the terminal emulator or the logging subsystem.
    */
   struct LDKStr peer_msg;
} LDKClosureReason_LDKCounterpartyForceClosed_Body;

typedef struct LDKClosureReason_LDKProcessingError_Body {
   /**
    * A developer-readable error message which we generated.
    */
   struct LDKStr err;
} LDKClosureReason_LDKProcessingError_Body;

typedef struct MUST_USE_STRUCT LDKClosureReason {
   LDKClosureReason_Tag tag;
   union {
      LDKClosureReason_LDKCounterpartyForceClosed_Body counterparty_force_closed;
      LDKClosureReason_LDKProcessingError_Body processing_error;
   };
} LDKClosureReason;

/**
 * An enum which can either contain a crate::lightning::util::events::ClosureReason or not
 */
typedef enum LDKCOption_ClosureReasonZ_Tag {
   /**
    * When we're in this state, this COption_ClosureReasonZ contains a crate::lightning::util::events::ClosureReason
    */
   LDKCOption_ClosureReasonZ_Some,
   /**
    * When we're in this state, this COption_ClosureReasonZ contains nothing
    */
   LDKCOption_ClosureReasonZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_ClosureReasonZ_Sentinel,
} LDKCOption_ClosureReasonZ_Tag;

typedef struct LDKCOption_ClosureReasonZ {
   LDKCOption_ClosureReasonZ_Tag tag;
   union {
      struct {
         struct LDKClosureReason some;
      };
   };
} LDKCOption_ClosureReasonZ;

/**
 * The contents of CResult_COption_ClosureReasonZDecodeErrorZ
 */
typedef union LDKCResult_COption_ClosureReasonZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_ClosureReasonZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_ClosureReasonZDecodeErrorZPtr;

/**
 * A CResult_COption_ClosureReasonZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_ClosureReasonZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_ClosureReasonZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_ClosureReasonZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_ClosureReasonZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_ClosureReasonZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_ClosureReasonZDecodeErrorZ;



/**
 * A channel_update message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUpdate;

/**
 * Update to the [`NetworkGraph`] based on payment failure information conveyed via the Onion
 * return packet by a node along the route. See [BOLT #4] for details.
 *
 * [BOLT #4]: https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md
 */
typedef enum LDKNetworkUpdate_Tag {
   /**
    * An error indicating a `channel_update` messages should be applied via
    * [`NetworkGraph::update_channel`].
    */
   LDKNetworkUpdate_ChannelUpdateMessage,
   /**
    * An error indicating only that a channel has been closed, which should be applied via
    * [`NetworkGraph::close_channel_from_update`].
    */
   LDKNetworkUpdate_ChannelClosed,
   /**
    * An error indicating only that a node has failed, which should be applied via
    * [`NetworkGraph::fail_node`].
    */
   LDKNetworkUpdate_NodeFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKNetworkUpdate_Sentinel,
} LDKNetworkUpdate_Tag;

typedef struct LDKNetworkUpdate_LDKChannelUpdateMessage_Body {
   /**
    * The update to apply via [`NetworkGraph::update_channel`].
    */
   struct LDKChannelUpdate msg;
} LDKNetworkUpdate_LDKChannelUpdateMessage_Body;

typedef struct LDKNetworkUpdate_LDKChannelClosed_Body {
   /**
    * The short channel id of the closed channel.
    */
   uint64_t short_channel_id;
   /**
    * Whether the channel should be permanently removed or temporarily disabled until a new
    * `channel_update` message is received.
    */
   bool is_permanent;
} LDKNetworkUpdate_LDKChannelClosed_Body;

typedef struct LDKNetworkUpdate_LDKNodeFailure_Body {
   /**
    * The node id of the failed node.
    */
   struct LDKPublicKey node_id;
   /**
    * Whether the node should be permanently removed from consideration or can be restored
    * when a new `channel_update` message is received.
    */
   bool is_permanent;
} LDKNetworkUpdate_LDKNodeFailure_Body;

typedef struct MUST_USE_STRUCT LDKNetworkUpdate {
   LDKNetworkUpdate_Tag tag;
   union {
      LDKNetworkUpdate_LDKChannelUpdateMessage_Body channel_update_message;
      LDKNetworkUpdate_LDKChannelClosed_Body channel_closed;
      LDKNetworkUpdate_LDKNodeFailure_Body node_failure;
   };
} LDKNetworkUpdate;

/**
 * An enum which can either contain a crate::lightning::routing::network_graph::NetworkUpdate or not
 */
typedef enum LDKCOption_NetworkUpdateZ_Tag {
   /**
    * When we're in this state, this COption_NetworkUpdateZ contains a crate::lightning::routing::network_graph::NetworkUpdate
    */
   LDKCOption_NetworkUpdateZ_Some,
   /**
    * When we're in this state, this COption_NetworkUpdateZ contains nothing
    */
   LDKCOption_NetworkUpdateZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_NetworkUpdateZ_Sentinel,
} LDKCOption_NetworkUpdateZ_Tag;

typedef struct LDKCOption_NetworkUpdateZ {
   LDKCOption_NetworkUpdateZ_Tag tag;
   union {
      struct {
         struct LDKNetworkUpdate some;
      };
   };
} LDKCOption_NetworkUpdateZ;



/**
 * Information about a spendable output to a P2WSH script. See
 * SpendableOutputDescriptor::DelayedPaymentOutput for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKDelayedPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDelayedPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDelayedPaymentOutputDescriptor;



/**
 * Information about a spendable output to our \"payment key\". See
 * SpendableOutputDescriptor::StaticPaymentOutput for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKStaticPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeStaticPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKStaticPaymentOutputDescriptor;

/**
 * When on-chain outputs are created by rust-lightning (which our counterparty is not able to
 * claim at any point in the future) an event is generated which you must track and be able to
 * spend on-chain. The information needed to do this is provided in this enum, including the
 * outpoint describing which txid and output index is available, the full output which exists at
 * that txid/index, and any keys or other information required to sign.
 */
typedef enum LDKSpendableOutputDescriptor_Tag {
   /**
    * An output to a script which was provided via KeysInterface directly, either from
    * `get_destination_script()` or `get_shutdown_scriptpubkey()`, thus you should already know
    * how to spend it. No secret keys are provided as rust-lightning was never given any key.
    * These may include outputs from a transaction punishing our counterparty or claiming an HTLC
    * on-chain using the payment preimage or after it has timed out.
    */
   LDKSpendableOutputDescriptor_StaticOutput,
   /**
    * An output to a P2WSH script which can be spent with a single signature after a CSV delay.
    *
    * The witness in the spending input should be:
    * <BIP 143 signature> <empty vector> (MINIMALIF standard rule) <provided witnessScript>
    *
    * Note that the nSequence field in the spending input must be set to to_self_delay
    * (which means the transaction is not broadcastable until at least to_self_delay
    * blocks after the outpoint confirms).
    *
    * These are generally the result of a \"revocable\" output to us, spendable only by us unless
    * it is an output from an old state which we broadcast (which should never happen).
    *
    * To derive the delayed_payment key which is used to sign for this input, you must pass the
    * holder delayed_payment_base_key (ie the private key which corresponds to the pubkey in
    * Sign::pubkeys().delayed_payment_basepoint) and the provided per_commitment_point to
    * chan_utils::derive_private_key. The public key can be generated without the secret key
    * using chan_utils::derive_public_key and only the delayed_payment_basepoint which appears in
    * Sign::pubkeys().
    *
    * To derive the revocation_pubkey provided here (which is used in the witness
    * script generation), you must pass the counterparty revocation_basepoint (which appears in the
    * call to Sign::ready_channel) and the provided per_commitment point
    * to chan_utils::derive_public_revocation_key.
    *
    * The witness script which is hashed and included in the output script_pubkey may be
    * regenerated by passing the revocation_pubkey (derived as above), our delayed_payment pubkey
    * (derived as above), and the to_self_delay contained here to
    * chan_utils::get_revokeable_redeemscript.
    */
   LDKSpendableOutputDescriptor_DelayedPaymentOutput,
   /**
    * An output to a P2WPKH, spendable exclusively by our payment key (ie the private key which
    * corresponds to the public key in Sign::pubkeys().payment_point).
    * The witness in the spending input, is, thus, simply:
    * <BIP 143 signature> <payment key>
    *
    * These are generally the result of our counterparty having broadcast the current state,
    * allowing us to claim the non-HTLC-encumbered outputs immediately.
    */
   LDKSpendableOutputDescriptor_StaticPaymentOutput,
   /**
    * Must be last for serialization purposes
    */
   LDKSpendableOutputDescriptor_Sentinel,
} LDKSpendableOutputDescriptor_Tag;

typedef struct LDKSpendableOutputDescriptor_LDKStaticOutput_Body {
   /**
    * The outpoint which is spendable
    */
   struct LDKOutPoint outpoint;
   /**
    * The output which is referenced by the given outpoint.
    */
   struct LDKTxOut output;
} LDKSpendableOutputDescriptor_LDKStaticOutput_Body;

typedef struct MUST_USE_STRUCT LDKSpendableOutputDescriptor {
   LDKSpendableOutputDescriptor_Tag tag;
   union {
      LDKSpendableOutputDescriptor_LDKStaticOutput_Body static_output;
      struct {
         struct LDKDelayedPaymentOutputDescriptor delayed_payment_output;
      };
      struct {
         struct LDKStaticPaymentOutputDescriptor static_payment_output;
      };
   };
} LDKSpendableOutputDescriptor;

/**
 * A dynamically-allocated array of crate::lightning::chain::keysinterface::SpendableOutputDescriptors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_SpendableOutputDescriptorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKSpendableOutputDescriptor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_SpendableOutputDescriptorZ;

/**
 * Some information provided on receipt of payment depends on whether the payment received is a
 * spontaneous payment or a \"conventional\" lightning payment that's paying an invoice.
 */
typedef enum LDKPaymentPurpose_Tag {
   /**
    * Information for receiving a payment that we generated an invoice for.
    */
   LDKPaymentPurpose_InvoicePayment,
   /**
    * Because this is a spontaneous payment, the payer generated their own preimage rather than us
    * (the payee) providing a preimage.
    */
   LDKPaymentPurpose_SpontaneousPayment,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentPurpose_Sentinel,
} LDKPaymentPurpose_Tag;

typedef struct LDKPaymentPurpose_LDKInvoicePayment_Body {
   /**
    * The preimage to the payment_hash, if the payment hash (and secret) were fetched via
    * [`ChannelManager::create_inbound_payment`]. If provided, this can be handed directly to
    * [`ChannelManager::claim_funds`].
    *
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes payment_preimage;
   /**
    * The \"payment secret\". This authenticates the sender to the recipient, preventing a
    * number of deanonymization attacks during the routing process.
    * It is provided here for your reference, however its accuracy is enforced directly by
    * [`ChannelManager`] using the values you previously provided to
    * [`ChannelManager::create_inbound_payment`] or
    * [`ChannelManager::create_inbound_payment_for_hash`].
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::create_inbound_payment_for_hash`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
    */
   struct LDKThirtyTwoBytes payment_secret;
} LDKPaymentPurpose_LDKInvoicePayment_Body;

typedef struct MUST_USE_STRUCT LDKPaymentPurpose {
   LDKPaymentPurpose_Tag tag;
   union {
      LDKPaymentPurpose_LDKInvoicePayment_Body invoice_payment;
      struct {
         struct LDKThirtyTwoBytes spontaneous_payment;
      };
   };
} LDKPaymentPurpose;



/**
 * Features used within the channel_type field in an OpenChannel message.
 *
 * A channel is always of some known \"type\", describing the transaction formats used and the exact
 * semantics of our interaction with our peer.
 *
 * Note that because a channel is a specific type which is proposed by the opener and accepted by
 * the counterparty, only required features are allowed here.
 *
 * This is serialized differently from other feature types - it is not prefixed by a length, and
 * thus must only appear inside a TLV where its length is known in advance.
 */
typedef struct MUST_USE_STRUCT LDKChannelTypeFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelTypeFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelTypeFeatures;

/**
 * An Event which you should probably take some action in response to.
 *
 * Note that while Writeable and Readable are implemented for Event, you probably shouldn't use
 * them directly as they don't round-trip exactly (for example FundingGenerationReady is never
 * written as it makes no sense to respond to it after reconnecting to peers).
 */
typedef enum LDKEvent_Tag {
   /**
    * Used to indicate that the client should generate a funding transaction with the given
    * parameters and then call [`ChannelManager::funding_transaction_generated`].
    * Generated in [`ChannelManager`] message handling.
    * Note that *all inputs* in the funding transaction must spend SegWit outputs or your
    * counterparty can steal your funds!
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
    */
   LDKEvent_FundingGenerationReady,
   /**
    * Indicates we've received money! Just gotta dig out that payment preimage and feed it to
    * [`ChannelManager::claim_funds`] to get it....
    * Note that if the preimage is not known, you should call
    * [`ChannelManager::fail_htlc_backwards`] to free up resources for this HTLC and avoid
    * network congestion.
    * If you fail to call either [`ChannelManager::claim_funds`] or
    * [`ChannelManager::fail_htlc_backwards`] within the HTLC's timeout, the HTLC will be
    * automatically failed.
    *
    * # Note
    * LDK will not stop an inbound payment from being paid multiple times, so multiple
    * `PaymentReceived` events may be generated for the same payment.
    *
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    * [`ChannelManager::fail_htlc_backwards`]: crate::ln::channelmanager::ChannelManager::fail_htlc_backwards
    */
   LDKEvent_PaymentReceived,
   /**
    * Indicates an outbound payment we made succeeded (i.e. it made it all the way to its target
    * and we got back the payment preimage for it).
    *
    * Note for MPP payments: in rare cases, this event may be preceded by a `PaymentPathFailed`
    * event. In this situation, you SHOULD treat this payment as having succeeded.
    */
   LDKEvent_PaymentSent,
   /**
    * Indicates an outbound HTLC we sent failed. Probably some intermediary node dropped
    * something. You may wish to retry with a different route.
    *
    * Note that this does *not* indicate that all paths for an MPP payment have failed, see
    * [`Event::PaymentFailed`] and [`all_paths_failed`].
    *
    * [`all_paths_failed`]: Self::PaymentPathFailed::all_paths_failed
    */
   LDKEvent_PaymentPathFailed,
   /**
    * Indicates an outbound payment failed. Individual [`Event::PaymentPathFailed`] events
    * provide failure information for each MPP part in the payment.
    *
    * This event is provided once there are no further pending HTLCs for the payment and the
    * payment is no longer retryable, either due to a several-block timeout or because
    * [`ChannelManager::abandon_payment`] was previously called for the corresponding payment.
    *
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   LDKEvent_PaymentFailed,
   /**
    * Used to indicate that [`ChannelManager::process_pending_htlc_forwards`] should be called at
    * a time in the future.
    *
    * [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
    */
   LDKEvent_PendingHTLCsForwardable,
   /**
    * Used to indicate that an output which you should know how to spend was confirmed on chain
    * and is now spendable.
    * Such an output will *not* ever be spent by rust-lightning, and are not at risk of your
    * counterparty spending them due to some kind of timeout. Thus, you need to store them
    * somewhere and spend them when you create on-chain transactions.
    */
   LDKEvent_SpendableOutputs,
   /**
    * This event is generated when a payment has been successfully forwarded through us and a
    * forwarding fee earned.
    */
   LDKEvent_PaymentForwarded,
   /**
    * Used to indicate that a channel with the given `channel_id` is in the process of closure.
    */
   LDKEvent_ChannelClosed,
   /**
    * Used to indicate to the user that they can abandon the funding transaction and recycle the
    * inputs for another purpose.
    */
   LDKEvent_DiscardFunding,
   /**
    * Indicates that a path for an outbound payment was successful.
    *
    * Always generated after [`Event::PaymentSent`] and thus useful for scoring channels. See
    * [`Event::PaymentSent`] for obtaining the payment preimage.
    */
   LDKEvent_PaymentPathSuccessful,
   /**
    * Indicates a request to open a new channel by a peer.
    *
    * To accept the request, call [`ChannelManager::accept_inbound_channel`]. To reject the
    * request, call [`ChannelManager::force_close_channel`].
    *
    * The event is only triggered when a new open channel request is received and the
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`ChannelManager::force_close_channel`]: crate::ln::channelmanager::ChannelManager::force_close_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   LDKEvent_OpenChannelRequest,
   /**
    * Must be last for serialization purposes
    */
   LDKEvent_Sentinel,
} LDKEvent_Tag;

typedef struct LDKEvent_LDKFundingGenerationReady_Body {
   /**
    * The random channel_id we picked which you'll need to pass into
    * ChannelManager::funding_transaction_generated.
    */
   struct LDKThirtyTwoBytes temporary_channel_id;
   /**
    * The value, in satoshis, that the output should have.
    */
   uint64_t channel_value_satoshis;
   /**
    * The script which should be used in the transaction output.
    */
   struct LDKCVec_u8Z output_script;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`], or 0 for
    * an inbound channel.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    */
   uint64_t user_channel_id;
} LDKEvent_LDKFundingGenerationReady_Body;

typedef struct LDKEvent_LDKPaymentReceived_Body {
   /**
    * The hash for which the preimage should be handed to the ChannelManager. Note that LDK will
    * not stop you from registering duplicate payment hashes for inbound payments.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The value, in thousandths of a satoshi, that this payment is for.
    */
   uint64_t amt;
   /**
    * Information for claiming this received payment, based on whether the purpose of the
    * payment is to pay an invoice or to send a spontaneous payment.
    */
   struct LDKPaymentPurpose purpose;
} LDKEvent_LDKPaymentReceived_Body;

typedef struct LDKEvent_LDKPaymentSent_Body {
   /**
    * The id returned by [`ChannelManager::send_payment`] and used with
    * [`ChannelManager::retry_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The preimage to the hash given to ChannelManager::send_payment.
    * Note that this serves as a payment receipt, if you wish to have such a thing, you must
    * store it somehow!
    */
   struct LDKThirtyTwoBytes payment_preimage;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The total fee which was spent at intermediate hops in this payment, across all paths.
    *
    * Note that, like [`Route::get_total_fees`] this does *not* include any potential
    * overpayment to the recipient node.
    *
    * If the recipient or an intermediate node misbehaves and gives us free money, this may
    * overstate the amount paid, though this is unlikely.
    *
    * [`Route::get_total_fees`]: crate::routing::router::Route::get_total_fees
    */
   struct LDKCOption_u64Z fee_paid_msat;
} LDKEvent_LDKPaymentSent_Body;

typedef struct LDKEvent_LDKPaymentPathFailed_Body {
   /**
    * The id returned by [`ChannelManager::send_payment`] and used with
    * [`ChannelManager::retry_payment`] and [`ChannelManager::abandon_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * Indicates the payment was rejected for some reason by the recipient. This implies that
    * the payment has failed, not just the route in question. If this is not set, you may
    * retry the payment via a different route.
    */
   bool rejected_by_dest;
   /**
    * Any failure information conveyed via the Onion return packet by a node along the failed
    * payment route.
    *
    * Should be applied to the [`NetworkGraph`] so that routing decisions can take into
    * account the update. [`NetGraphMsgHandler`] is capable of doing this.
    *
    * [`NetworkGraph`]: crate::routing::network_graph::NetworkGraph
    * [`NetGraphMsgHandler`]: crate::routing::network_graph::NetGraphMsgHandler
    */
   struct LDKCOption_NetworkUpdateZ network_update;
   /**
    * For both single-path and multi-path payments, this is set if all paths of the payment have
    * failed. This will be set to false if (1) this is an MPP payment and (2) other parts of the
    * larger MPP payment were still in flight when this event was generated.
    *
    * Note that if you are retrying individual MPP parts, using this value to determine if a
    * payment has fully failed is race-y. Because multiple failures can happen prior to events
    * being processed, you may retry in response to a first failure, with a second failure
    * (with `all_paths_failed` set) still pending. Then, when the second failure is processed
    * you will see `all_paths_failed` set even though the retry of the first failure still
    * has an associated in-flight HTLC. See (1) for an example of such a failure.
    *
    * If you wish to retry individual MPP parts and learn when a payment has failed, you must
    * call [`ChannelManager::abandon_payment`] and wait for a [`Event::PaymentFailed`] event.
    *
    * (1) <https://github.com/lightningdevkit/rust-lightning/issues/1164>
    *
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   bool all_paths_failed;
   /**
    * The payment path that failed.
    */
   struct LDKCVec_RouteHopZ path;
   /**
    * The channel responsible for the failed payment path.
    *
    * If this is `Some`, then the corresponding channel should be avoided when the payment is
    * retried. May be `None` for older [`Event`] serializations.
    */
   struct LDKCOption_u64Z short_channel_id;
   /**
    * Parameters needed to compute a new [`Route`] when retrying the failed payment path.
    *
    * See [`find_route`] for details.
    *
    * [`Route`]: crate::routing::router::Route
    * [`find_route`]: crate::routing::router::find_route
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKRouteParameters retry;
} LDKEvent_LDKPaymentPathFailed_Body;

typedef struct LDKEvent_LDKPaymentFailed_Body {
   /**
    * The id returned by [`ChannelManager::send_payment`] and used with
    * [`ChannelManager::retry_payment`] and [`ChannelManager::abandon_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
} LDKEvent_LDKPaymentFailed_Body;

typedef struct LDKEvent_LDKPendingHTLCsForwardable_Body {
   /**
    * The minimum amount of time that should be waited prior to calling
    * process_pending_htlc_forwards. To increase the effort required to correlate payments,
    * you should wait a random amount of time in roughly the range (now + time_forwardable,
    * now + 5*time_forwardable).
    */
   uint64_t time_forwardable;
} LDKEvent_LDKPendingHTLCsForwardable_Body;

typedef struct LDKEvent_LDKSpendableOutputs_Body {
   /**
    * The outputs which you should store as spendable by you.
    */
   struct LDKCVec_SpendableOutputDescriptorZ outputs;
} LDKEvent_LDKSpendableOutputs_Body;

typedef struct LDKEvent_LDKPaymentForwarded_Body {
   /**
    * The fee, in milli-satoshis, which was earned as a result of the payment.
    *
    * Note that if we force-closed the channel over which we forwarded an HTLC while the HTLC
    * was pending, the amount the next hop claimed will have been rounded down to the nearest
    * whole satoshi. Thus, the fee calculated here may be higher than expected as we still
    * claimed the full value in millisatoshis from the source. In this case,
    * `claim_from_onchain_tx` will be set.
    *
    * If the channel which sent us the payment has been force-closed, we will claim the funds
    * via an on-chain transaction. In that case we do not yet know the on-chain transaction
    * fees which we will spend and will instead set this to `None`. It is possible duplicate
    * `PaymentForwarded` events are generated for the same payment iff `fee_earned_msat` is
    * `None`.
    */
   struct LDKCOption_u64Z fee_earned_msat;
   /**
    * If this is `true`, the forwarded HTLC was claimed by our counterparty via an on-chain
    * transaction.
    */
   bool claim_from_onchain_tx;
} LDKEvent_LDKPaymentForwarded_Body;

typedef struct LDKEvent_LDKChannelClosed_Body {
   /**
    * The channel_id of the channel which has been closed. Note that on-chain transactions
    * resolving the channel are likely still awaiting confirmation.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
    * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
    * `user_channel_id` will be 0 for an inbound channel.
    * This will always be zero for objects serialized with LDK versions prior to 0.0.102.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   uint64_t user_channel_id;
   /**
    * The reason the channel was closed.
    */
   struct LDKClosureReason reason;
} LDKEvent_LDKChannelClosed_Body;

typedef struct LDKEvent_LDKDiscardFunding_Body {
   /**
    * The channel_id of the channel which has been closed.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The full transaction received from the user
    */
   struct LDKTransaction transaction;
} LDKEvent_LDKDiscardFunding_Body;

typedef struct LDKEvent_LDKPaymentPathSuccessful_Body {
   /**
    * The id returned by [`ChannelManager::send_payment`] and used with
    * [`ChannelManager::retry_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::retry_payment`]: crate::ln::channelmanager::ChannelManager::retry_payment
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The payment path that was successful.
    *
    * May contain a closed channel if the HTLC sent along the path was fulfilled on chain.
    */
   struct LDKCVec_RouteHopZ path;
} LDKEvent_LDKPaymentPathSuccessful_Body;

typedef struct LDKEvent_LDKOpenChannelRequest_Body {
   /**
    * The temporary channel ID of the channel requested to be opened.
    *
    * When responding to the request, the `temporary_channel_id` should be passed
    * back to the ChannelManager with [`ChannelManager::accept_inbound_channel`] to accept,
    * or to [`ChannelManager::force_close_channel`] to reject.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`ChannelManager::force_close_channel`]: crate::ln::channelmanager::ChannelManager::force_close_channel
    */
   struct LDKThirtyTwoBytes temporary_channel_id;
   /**
    * The node_id of the counterparty requesting to open the channel.
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * The channel value of the requested channel.
    */
   uint64_t funding_satoshis;
   /**
    * Our starting balance in the channel if the request is accepted, in milli-satoshi.
    */
   uint64_t push_msat;
   /**
    * The features that this channel will operate with. If you reject the channel, a
    * well-behaved counterparty may automatically re-attempt the channel with a new set of
    * feature flags.
    *
    * Note that if [`ChannelTypeFeatures::supports_scid_privacy`] returns true on this type,
    * the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
    * 0.0.106.
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   struct LDKChannelTypeFeatures channel_type;
} LDKEvent_LDKOpenChannelRequest_Body;

typedef struct MUST_USE_STRUCT LDKEvent {
   LDKEvent_Tag tag;
   union {
      LDKEvent_LDKFundingGenerationReady_Body funding_generation_ready;
      LDKEvent_LDKPaymentReceived_Body payment_received;
      LDKEvent_LDKPaymentSent_Body payment_sent;
      LDKEvent_LDKPaymentPathFailed_Body payment_path_failed;
      LDKEvent_LDKPaymentFailed_Body payment_failed;
      LDKEvent_LDKPendingHTLCsForwardable_Body pending_htl_cs_forwardable;
      LDKEvent_LDKSpendableOutputs_Body spendable_outputs;
      LDKEvent_LDKPaymentForwarded_Body payment_forwarded;
      LDKEvent_LDKChannelClosed_Body channel_closed;
      LDKEvent_LDKDiscardFunding_Body discard_funding;
      LDKEvent_LDKPaymentPathSuccessful_Body payment_path_successful;
      LDKEvent_LDKOpenChannelRequest_Body open_channel_request;
   };
} LDKEvent;

/**
 * An enum which can either contain a crate::lightning::util::events::Event or not
 */
typedef enum LDKCOption_EventZ_Tag {
   /**
    * When we're in this state, this COption_EventZ contains a crate::lightning::util::events::Event
    */
   LDKCOption_EventZ_Some,
   /**
    * When we're in this state, this COption_EventZ contains nothing
    */
   LDKCOption_EventZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_EventZ_Sentinel,
} LDKCOption_EventZ_Tag;

typedef struct LDKCOption_EventZ {
   LDKCOption_EventZ_Tag tag;
   union {
      struct {
         struct LDKEvent some;
      };
   };
} LDKCOption_EventZ;

/**
 * The contents of CResult_COption_EventZDecodeErrorZ
 */
typedef union LDKCResult_COption_EventZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_EventZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_EventZDecodeErrorZPtr;

/**
 * A CResult_COption_EventZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_EventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_EventZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_EventZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_EventZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_EventZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_EventZDecodeErrorZ;



/**
 * An accept_channel message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKAcceptChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAcceptChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAcceptChannel;



/**
 * An open_channel message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKOpenChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOpenChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOpenChannel;



/**
 * A funding_created message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingCreated {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingCreated *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingCreated;



/**
 * A funding_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingSigned;



/**
 * A funding_locked message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingLocked {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingLocked *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingLocked;



/**
 * An announcement_signatures message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKAnnouncementSignatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAnnouncementSignatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAnnouncementSignatures;



/**
 * Struct used to return values from revoke_and_ack messages, containing a bunch of commitment
 * transaction updates if they were pending.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentUpdate;



/**
 * A revoke_and_ack message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKRevokeAndACK {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRevokeAndACK *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRevokeAndACK;



/**
 * A closing_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKClosingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingSigned;



/**
 * A shutdown message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKShutdown {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeShutdown *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKShutdown;



/**
 * A channel_reestablish message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelReestablish {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelReestablish *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelReestablish;



/**
 * A channel_announcement message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelAnnouncement;



/**
 * A node_announcement message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncement;



/**
 * An error message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKErrorMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErrorMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErrorMessage;



/**
 * A warning message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKWarningMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeWarningMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKWarningMessage;

/**
 * Used to put an error message in a LightningError
 */
typedef enum LDKErrorAction_Tag {
   /**
    * The peer took some action which made us think they were useless. Disconnect them.
    */
   LDKErrorAction_DisconnectPeer,
   /**
    * The peer did something harmless that we weren't able to process, just log and ignore
    */
   LDKErrorAction_IgnoreError,
   /**
    * The peer did something harmless that we weren't able to meaningfully process.
    * If the error is logged, log it at the given level.
    */
   LDKErrorAction_IgnoreAndLog,
   /**
    * The peer provided us with a gossip message which we'd already seen. In most cases this
    * should be ignored, but it may result in the message being forwarded if it is a duplicate of
    * our own channel announcements.
    */
   LDKErrorAction_IgnoreDuplicateGossip,
   /**
    * The peer did something incorrect. Tell them.
    */
   LDKErrorAction_SendErrorMessage,
   /**
    * The peer did something incorrect. Tell them without closing any channels.
    */
   LDKErrorAction_SendWarningMessage,
   /**
    * Must be last for serialization purposes
    */
   LDKErrorAction_Sentinel,
} LDKErrorAction_Tag;

typedef struct LDKErrorAction_LDKDisconnectPeer_Body {
   /**
    * An error message which we should make an effort to send before we disconnect.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKDisconnectPeer_Body;

typedef struct LDKErrorAction_LDKSendErrorMessage_Body {
   /**
    * The message to send.
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKSendErrorMessage_Body;

typedef struct LDKErrorAction_LDKSendWarningMessage_Body {
   /**
    * The message to send.
    */
   struct LDKWarningMessage msg;
   /**
    * The peer may have done something harmless that we weren't able to meaningfully process,
    * though we should still tell them about it.
    * If this event is logged, log it at the given level.
    */
   enum LDKLevel log_level;
} LDKErrorAction_LDKSendWarningMessage_Body;

typedef struct MUST_USE_STRUCT LDKErrorAction {
   LDKErrorAction_Tag tag;
   union {
      LDKErrorAction_LDKDisconnectPeer_Body disconnect_peer;
      struct {
         enum LDKLevel ignore_and_log;
      };
      LDKErrorAction_LDKSendErrorMessage_Body send_error_message;
      LDKErrorAction_LDKSendWarningMessage_Body send_warning_message;
   };
} LDKErrorAction;



/**
 * A query_channel_range message is used to query a peer for channel
 * UTXOs in a range of blocks. The recipient of a query makes a best
 * effort to reply to the query using one or more reply_channel_range
 * messages.
 */
typedef struct MUST_USE_STRUCT LDKQueryChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryChannelRange;



/**
 * A query_short_channel_ids message is used to query a peer for
 * routing gossip messages related to one or more short_channel_ids.
 * The query recipient will reply with the latest, if available,
 * channel_announcement, channel_update and node_announcement messages
 * it maintains for the requested short_channel_ids followed by a
 * reply_short_channel_ids_end message. The short_channel_ids sent in
 * this query are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */
typedef struct MUST_USE_STRUCT LDKQueryShortChannelIds {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryShortChannelIds *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryShortChannelIds;



/**
 * A reply_channel_range message is a reply to a query_channel_range
 * message. Multiple reply_channel_range messages can be sent in reply
 * to a single query_channel_range message. The query recipient makes a
 * best effort to respond based on their local network view which may
 * not be a perfect view of the network. The short_channel_ids in the
 * reply are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */
typedef struct MUST_USE_STRUCT LDKReplyChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyChannelRange;



/**
 * A gossip_timestamp_filter message is used by a node to request
 * gossip relay for messages in the requested time range when the
 * gossip_queries feature has been negotiated.
 */
typedef struct MUST_USE_STRUCT LDKGossipTimestampFilter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeGossipTimestampFilter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKGossipTimestampFilter;

/**
 * An event generated by ChannelManager which indicates a message should be sent to a peer (or
 * broadcast to most peers).
 * These events are handled by PeerManager::process_events if you are using a PeerManager.
 */
typedef enum LDKMessageSendEvent_Tag {
   /**
    * Used to indicate that we've accepted a channel open and should send the accept_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendAcceptChannel,
   /**
    * Used to indicate that we've initiated a channel open and should send the open_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendOpenChannel,
   /**
    * Used to indicate that a funding_created message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingCreated,
   /**
    * Used to indicate that a funding_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingSigned,
   /**
    * Used to indicate that a funding_locked message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingLocked,
   /**
    * Used to indicate that an announcement_signatures message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendAnnouncementSignatures,
   /**
    * Used to indicate that a series of HTLC update messages, as well as a commitment_signed
    * message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_UpdateHTLCs,
   /**
    * Used to indicate that a revoke_and_ack message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendRevokeAndACK,
   /**
    * Used to indicate that a closing_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendClosingSigned,
   /**
    * Used to indicate that a shutdown message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendShutdown,
   /**
    * Used to indicate that a channel_reestablish message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendChannelReestablish,
   /**
    * Used to indicate that a channel_announcement and channel_update should be broadcast to all
    * peers (except the peer with node_id either msg.contents.node_id_1 or msg.contents.node_id_2).
    *
    * Note that after doing so, you very likely (unless you did so very recently) want to call
    * ChannelManager::broadcast_node_announcement to trigger a BroadcastNodeAnnouncement event.
    * This ensures that any nodes which see our channel_announcement also have a relevant
    * node_announcement, including relevant feature flags which may be important for routing
    * through or to us.
    */
   LDKMessageSendEvent_BroadcastChannelAnnouncement,
   /**
    * Used to indicate that a node_announcement should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastNodeAnnouncement,
   /**
    * Used to indicate that a channel_update should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastChannelUpdate,
   /**
    * Used to indicate that a channel_update should be sent to a single peer.
    * In contrast to [`Self::BroadcastChannelUpdate`], this is used when the channel is a
    * private channel and we shouldn't be informing all of our peers of channel parameters.
    */
   LDKMessageSendEvent_SendChannelUpdate,
   /**
    * Broadcast an error downstream to be handled
    */
   LDKMessageSendEvent_HandleError,
   /**
    * Query a peer for channels with funding transaction UTXOs in a block range.
    */
   LDKMessageSendEvent_SendChannelRangeQuery,
   /**
    * Request routing gossip messages from a peer for a list of channels identified by
    * their short_channel_ids.
    */
   LDKMessageSendEvent_SendShortIdsQuery,
   /**
    * Sends a reply to a channel range query. This may be one of several SendReplyChannelRange events
    * emitted during processing of the query.
    */
   LDKMessageSendEvent_SendReplyChannelRange,
   /**
    * Sends a timestamp filter for inbound gossip. This should be sent on each new connection to
    * enable receiving gossip messages from the peer.
    */
   LDKMessageSendEvent_SendGossipTimestampFilter,
   /**
    * Must be last for serialization purposes
    */
   LDKMessageSendEvent_Sentinel,
} LDKMessageSendEvent_Tag;

typedef struct LDKMessageSendEvent_LDKSendAcceptChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKAcceptChannel msg;
} LDKMessageSendEvent_LDKSendAcceptChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendOpenChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKOpenChannel msg;
} LDKMessageSendEvent_LDKSendOpenChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingCreated_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingCreated msg;
} LDKMessageSendEvent_LDKSendFundingCreated_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingSigned msg;
} LDKMessageSendEvent_LDKSendFundingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingLocked_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The funding_locked message which should be sent.
    */
   struct LDKFundingLocked msg;
} LDKMessageSendEvent_LDKSendFundingLocked_Body;

typedef struct LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The announcement_signatures message which should be sent.
    */
   struct LDKAnnouncementSignatures msg;
} LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body;

typedef struct LDKMessageSendEvent_LDKUpdateHTLCs_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The update messages which should be sent. ALL messages in the struct should be sent!
    */
   struct LDKCommitmentUpdate updates;
} LDKMessageSendEvent_LDKUpdateHTLCs_Body;

typedef struct LDKMessageSendEvent_LDKSendRevokeAndACK_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKRevokeAndACK msg;
} LDKMessageSendEvent_LDKSendRevokeAndACK_Body;

typedef struct LDKMessageSendEvent_LDKSendClosingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKClosingSigned msg;
} LDKMessageSendEvent_LDKSendClosingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendShutdown_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKShutdown msg;
} LDKMessageSendEvent_LDKSendShutdown_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelReestablish_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKChannelReestablish msg;
} LDKMessageSendEvent_LDKSendChannelReestablish_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body {
   /**
    * The channel_announcement which should be sent.
    */
   struct LDKChannelAnnouncement msg;
   /**
    * The followup channel_update which should be sent.
    */
   struct LDKChannelUpdate update_msg;
} LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body {
   /**
    * The node_announcement which should be sent.
    */
   struct LDKNodeAnnouncement msg;
} LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body {
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelUpdate_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKSendChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKHandleError_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The action which should be taken.
    */
   struct LDKErrorAction action;
} LDKMessageSendEvent_LDKHandleError_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelRangeQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_channel_range which should be sent.
    */
   struct LDKQueryChannelRange msg;
} LDKMessageSendEvent_LDKSendChannelRangeQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendShortIdsQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_short_channel_ids which should be sent.
    */
   struct LDKQueryShortChannelIds msg;
} LDKMessageSendEvent_LDKSendShortIdsQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendReplyChannelRange_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The reply_channel_range which should be sent.
    */
   struct LDKReplyChannelRange msg;
} LDKMessageSendEvent_LDKSendReplyChannelRange_Body;

typedef struct LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The gossip_timestamp_filter which should be sent.
    */
   struct LDKGossipTimestampFilter msg;
} LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body;

typedef struct MUST_USE_STRUCT LDKMessageSendEvent {
   LDKMessageSendEvent_Tag tag;
   union {
      LDKMessageSendEvent_LDKSendAcceptChannel_Body send_accept_channel;
      LDKMessageSendEvent_LDKSendOpenChannel_Body send_open_channel;
      LDKMessageSendEvent_LDKSendFundingCreated_Body send_funding_created;
      LDKMessageSendEvent_LDKSendFundingSigned_Body send_funding_signed;
      LDKMessageSendEvent_LDKSendFundingLocked_Body send_funding_locked;
      LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body send_announcement_signatures;
      LDKMessageSendEvent_LDKUpdateHTLCs_Body update_htl_cs;
      LDKMessageSendEvent_LDKSendRevokeAndACK_Body send_revoke_and_ack;
      LDKMessageSendEvent_LDKSendClosingSigned_Body send_closing_signed;
      LDKMessageSendEvent_LDKSendShutdown_Body send_shutdown;
      LDKMessageSendEvent_LDKSendChannelReestablish_Body send_channel_reestablish;
      LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body broadcast_channel_announcement;
      LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body broadcast_node_announcement;
      LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body broadcast_channel_update;
      LDKMessageSendEvent_LDKSendChannelUpdate_Body send_channel_update;
      LDKMessageSendEvent_LDKHandleError_Body handle_error;
      LDKMessageSendEvent_LDKSendChannelRangeQuery_Body send_channel_range_query;
      LDKMessageSendEvent_LDKSendShortIdsQuery_Body send_short_ids_query;
      LDKMessageSendEvent_LDKSendReplyChannelRange_Body send_reply_channel_range;
      LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body send_gossip_timestamp_filter;
   };
} LDKMessageSendEvent;

/**
 * A dynamically-allocated array of crate::lightning::util::events::MessageSendEvents of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MessageSendEventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMessageSendEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MessageSendEventZ;



/**
 * [`Score`] implementation that uses a fixed penalty.
 */
typedef struct MUST_USE_STRUCT LDKFixedPenaltyScorer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFixedPenaltyScorer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFixedPenaltyScorer;

/**
 * The contents of CResult_FixedPenaltyScorerDecodeErrorZ
 */
typedef union LDKCResult_FixedPenaltyScorerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFixedPenaltyScorer *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FixedPenaltyScorerDecodeErrorZPtr;

/**
 * A CResult_FixedPenaltyScorerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::scoring::FixedPenaltyScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FixedPenaltyScorerDecodeErrorZ {
   /**
    * The contents of this CResult_FixedPenaltyScorerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FixedPenaltyScorerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FixedPenaltyScorerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FixedPenaltyScorerDecodeErrorZ;



/**
 * Parameters for configuring [`Scorer`].
 */
typedef struct MUST_USE_STRUCT LDKScoringParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeScoringParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKScoringParameters;

/**
 * The contents of CResult_ScoringParametersDecodeErrorZ
 */
typedef union LDKCResult_ScoringParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKScoringParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ScoringParametersDecodeErrorZPtr;

/**
 * A CResult_ScoringParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::scoring::ScoringParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ScoringParametersDecodeErrorZ {
   /**
    * The contents of this CResult_ScoringParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ScoringParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ScoringParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ScoringParametersDecodeErrorZ;



/**
 * [`Score`] implementation that provides reasonable default behavior.
 *
 * Used to apply a fixed penalty to each channel, thus avoiding long paths when shorter paths with
 * slightly higher fees are available. Will further penalize channels that fail to relay payments.
 *
 * See [module-level documentation] for usage and [`ScoringParameters`] for customization.
 *
 * # Note
 *
 * Mixing the `no-std` feature between serialization and deserialization results in undefined
 * behavior.
 *
 * [module-level documentation]: crate::routing::scoring
 */
typedef struct MUST_USE_STRUCT LDKScorer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeScorer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKScorer;

/**
 * The contents of CResult_ScorerDecodeErrorZ
 */
typedef union LDKCResult_ScorerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKScorer *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ScorerDecodeErrorZPtr;

/**
 * A CResult_ScorerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::scoring::Scorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ScorerDecodeErrorZ {
   /**
    * The contents of this CResult_ScorerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ScorerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ScorerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ScorerDecodeErrorZ;



/**
 * Represents the network as nodes and channels between them
 */
typedef struct MUST_USE_STRUCT LDKNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNetworkGraph;



/**
 * [`Score`] implementation using channel success probability distributions.
 *
 * Based on *Optimally Reliable & Cheap Payment Flows on the Lightning Network* by Rene Pickhardt
 * and Stefan Richter [[1]]. Given the uncertainty of channel liquidity balances, probability
 * distributions are defined based on knowledge learned from successful and unsuccessful attempts.
 * Then the negative `log10` of the success probability is used to determine the cost of routing a
 * specific HTLC amount through a channel.
 *
 * Knowledge about channel liquidity balances takes the form of upper and lower bounds on the
 * possible liquidity. Certainty of the bounds is decreased over time using a decay function. See
 * [`ProbabilisticScoringParameters`] for details.
 *
 * Since the scorer aims to learn the current channel liquidity balances, it works best for nodes
 * with high payment volume or that actively probe the [`NetworkGraph`]. Nodes with low payment
 * volume are more likely to experience failed payment paths, which would need to be retried.
 *
 * # Note
 *
 * Mixing the `no-std` feature between serialization and deserialization results in undefined
 * behavior.
 *
 * [1]: https://arxiv.org/abs/2107.05322
 */
typedef struct MUST_USE_STRUCT LDKProbabilisticScorer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeProbabilisticScorer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKProbabilisticScorer;

/**
 * The contents of CResult_ProbabilisticScorerDecodeErrorZ
 */
typedef union LDKCResult_ProbabilisticScorerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKProbabilisticScorer *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ProbabilisticScorerDecodeErrorZPtr;

/**
 * A CResult_ProbabilisticScorerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::scoring::ProbabilisticScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ProbabilisticScorerDecodeErrorZ {
   /**
    * The contents of this CResult_ProbabilisticScorerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ProbabilisticScorerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ProbabilisticScorerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ProbabilisticScorerDecodeErrorZ;



/**
 * Features used within an `init` message.
 */
typedef struct MUST_USE_STRUCT LDKInitFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInitFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInitFeatures;

/**
 * The contents of CResult_InitFeaturesDecodeErrorZ
 */
typedef union LDKCResult_InitFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInitFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InitFeaturesDecodeErrorZPtr;

/**
 * A CResult_InitFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::InitFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InitFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_InitFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InitFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InitFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InitFeaturesDecodeErrorZ;



/**
 * Features used within a `channel_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKChannelFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelFeatures;

/**
 * The contents of CResult_ChannelFeaturesDecodeErrorZ
 */
typedef union LDKCResult_ChannelFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelFeaturesDecodeErrorZPtr;

/**
 * A CResult_ChannelFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::ChannelFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelFeaturesDecodeErrorZ;



/**
 * Features used within a `node_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKNodeFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeFeatures;

/**
 * The contents of CResult_NodeFeaturesDecodeErrorZ
 */
typedef union LDKCResult_NodeFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeFeaturesDecodeErrorZPtr;

/**
 * A CResult_NodeFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::NodeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_NodeFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeFeaturesDecodeErrorZ;



/**
 * Features used within an invoice.
 */
typedef struct MUST_USE_STRUCT LDKInvoiceFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceFeatures;

/**
 * The contents of CResult_InvoiceFeaturesDecodeErrorZ
 */
typedef union LDKCResult_InvoiceFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoiceFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InvoiceFeaturesDecodeErrorZPtr;

/**
 * A CResult_InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_InvoiceFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceFeaturesDecodeErrorZ;

/**
 * The contents of CResult_ChannelTypeFeaturesDecodeErrorZ
 */
typedef union LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelTypeFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr;

/**
 * A CResult_ChannelTypeFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::ChannelTypeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelTypeFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelTypeFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelTypeFeaturesDecodeErrorZ;

/**
 * The contents of CResult_DelayedPaymentOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDelayedPaymentOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::DelayedPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ;

/**
 * The contents of CResult_StaticPaymentOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKStaticPaymentOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::StaticPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_StaticPaymentOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ;

/**
 * The contents of CResult_SpendableOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSpendableOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_SpendableOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::SpendableOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_SpendableOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_SpendableOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PaymentPreimageZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKThirtyTwoBytes *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PaymentPreimageZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_SignatureCVec_SignatureZZ {
   /**
    * The element at position 0
    */
   struct LDKSignature a;
   /**
    * The element at position 1
    */
   struct LDKCVec_SignatureZ b;
} LDKC2Tuple_SignatureCVec_SignatureZZ;

/**
 * The contents of CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ
 */
typedef union LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_SignatureCVec_SignatureZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr;

/**
 * A CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_SignatureCVec_SignatureZZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ;

/**
 * The contents of CResult_SignatureNoneZ
 */
typedef union LDKCResult_SignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SignatureNoneZPtr;

/**
 * A CResult_SignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::Signature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignatureNoneZ {
   /**
    * The contents of this CResult_SignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignatureNoneZPtr contents;
   /**
    * Whether this CResult_SignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignatureNoneZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_SignatureSignatureZ {
   /**
    * The element at position 0
    */
   struct LDKSignature a;
   /**
    * The element at position 1
    */
   struct LDKSignature b;
} LDKC2Tuple_SignatureSignatureZ;

/**
 * The contents of CResult_C2Tuple_SignatureSignatureZNoneZ
 */
typedef union LDKCResult_C2Tuple_SignatureSignatureZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_SignatureSignatureZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_SignatureSignatureZNoneZPtr;

/**
 * A CResult_C2Tuple_SignatureSignatureZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_SignatureSignatureZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_SignatureSignatureZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_SignatureSignatureZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_SignatureSignatureZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_SignatureSignatureZNoneZ;

/**
 * The contents of CResult_SecretKeyNoneZ
 */
typedef union LDKCResult_SecretKeyNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSecretKey *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SecretKeyNoneZPtr;

/**
 * A CResult_SecretKeyNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::SecretKey on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SecretKeyNoneZ {
   /**
    * The contents of this CResult_SecretKeyNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SecretKeyNoneZPtr contents;
   /**
    * Whether this CResult_SecretKeyNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SecretKeyNoneZ;



/**
 * This class tracks the per-transaction information needed to build a closing transaction and will
 * actually build it and sign.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */
typedef struct MUST_USE_STRUCT LDKClosingTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingTransaction;



/**
 * The unsigned part of a channel_announcement
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelAnnouncement;

/**
 * A trait to sign lightning channel transactions as described in BOLT 3.
 *
 * Signing services could be implemented on a hardware wallet. In this case,
 * the current Sign would be a front-end on top of a communication
 * channel connected to your secure device and lightning key material wouldn't
 * reside on a hot server. Nevertheless, a this deployment would still need
 * to trust the ChannelManager to avoid loss of funds as this latest component
 * could ask to sign commitment transaction with HTLCs paying to attacker pubkeys.
 *
 * A more secure iteration would be to use hashlock (or payment points) to pair
 * invoice/incoming HTLCs with outgoing HTLCs to implement a no-trust-ChannelManager
 * at the price of more state and computation on the hardware wallet side. In the future,
 * we are looking forward to design such interface.
 *
 * In any case, ChannelMonitor or fallback watchtowers are always going to be trusted
 * to act, as liveness and breach reply correctness are always going to be hard requirements
 * of LN security model, orthogonal of key management issues.
 */
typedef struct LDKBaseSign {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the per-commitment point for a specific commitment number
    *
    * Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
    */
   struct LDKPublicKey (*get_per_commitment_point)(const void *this_arg, uint64_t idx);
   /**
    * Gets the commitment secret for a specific commitment number as part of the revocation process
    *
    * An external signer implementation should error here if the commitment was already signed
    * and should refuse to sign it in the future.
    *
    * May be called more than once for the same index.
    *
    * Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
    */
   struct LDKThirtyTwoBytes (*release_commitment_secret)(const void *this_arg, uint64_t idx);
   /**
    * Validate the counterparty's signatures on the holder commitment transaction and HTLCs.
    *
    * This is required in order for the signer to make sure that releasing a commitment
    * secret won't leave us without a broadcastable holder transaction.
    * Policy checks should be implemented in this function, including checking the amount
    * sent to us and checking the HTLCs.
    *
    * The preimages of outgoing HTLCs that were fulfilled since the last commitment are provided.
    * A validating signer should ensure that an HTLC output is removed only when the matching
    * preimage is provided, or when the value to holder is restored.
    *
    * NOTE: all the relevant preimages will be provided, but there may also be additional
    * irrelevant or duplicate preimages.
    */
   struct LDKCResult_NoneNoneZ (*validate_holder_commitment)(const void *this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR holder_tx, struct LDKCVec_PaymentPreimageZ preimages);
   /**
    * Gets the holder's channel public keys and basepoints
    */
   struct LDKChannelPublicKeys pubkeys;
   /**
    * Fill in the pubkeys field as a reference to it will be given to Rust after this returns
    * Note that this takes a pointer to this object, not the this_ptr like other methods do
    * This function pointer may be NULL if pubkeys is filled in when this object is created and never needs updating.
    */
   void (*set_pubkeys)(const struct LDKBaseSign*NONNULL_PTR );
   /**
    * Gets an arbitrary identifier describing the set of keys which are provided back to you in
    * some SpendableOutputDescriptor types. This should be sufficient to identify this
    * Sign object uniquely and lookup or re-derive its keys.
    */
   struct LDKThirtyTwoBytes (*channel_keys_id)(const void *this_arg);
   /**
    * Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
    *
    * Note that if signing fails or is rejected, the channel will be force-closed.
    *
    * Policy checks should be implemented in this function, including checking the amount
    * sent to us and checking the HTLCs.
    *
    * The preimages of outgoing HTLCs that were fulfilled since the last commitment are provided.
    * A validating signer should ensure that an HTLC output is removed only when the matching
    * preimage is provided, or when the value to holder is restored.
    *
    * NOTE: all the relevant preimages will be provided, but there may also be additional
    * irrelevant or duplicate preimages.
    */
   struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ (*sign_counterparty_commitment)(const void *this_arg, const struct LDKCommitmentTransaction *NONNULL_PTR commitment_tx, struct LDKCVec_PaymentPreimageZ preimages);
   /**
    * Validate the counterparty's revocation.
    *
    * This is required in order for the signer to make sure that the state has moved
    * forward and it is safe to sign the next counterparty commitment.
    */
   struct LDKCResult_NoneNoneZ (*validate_counterparty_revocation)(const void *this_arg, uint64_t idx, const uint8_t (*secret)[32]);
   /**
    * Create a signatures for a holder's commitment transaction and its claiming HTLC transactions.
    * This will only ever be called with a non-revoked commitment_tx.  This will be called with the
    * latest commitment_tx when we initiate a force-close.
    * This will be called with the previous latest, just to get claiming HTLC signatures, if we are
    * reacting to a ChannelMonitor replica that decided to broadcast before it had been updated to
    * the latest.
    * This may be called multiple times for the same transaction.
    *
    * An external signer implementation should check that the commitment has not been revoked.
    *
    * May return Err if key derivation fails.  Callers, such as ChannelMonitor, will panic in such a case.
    */
   struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ (*sign_holder_commitment_and_htlcs)(const void *this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR commitment_tx);
   /**
    * Create a signature for the given input in a transaction spending an HTLC transaction output
    * or a commitment transaction `to_local` output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiple outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiple times for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * per_commitment_key is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder revocation_secret to do
    * so).
    */
   struct LDKCResult_SignatureNoneZ (*sign_justice_revoked_output)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32]);
   /**
    * Create a signature for the given input in a transaction spending a commitment transaction
    * HTLC output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiple outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiple times for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * per_commitment_key is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder revocation_secret to do
    * so).
    *
    * htlc holds HTLC elements (hash, timelock), thus changing the format of the witness script
    * (which is committed to in the BIP 143 signatures).
    */
   struct LDKCResult_SignatureNoneZ (*sign_justice_revoked_htlc)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32], const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
    * transaction, either offered or received.
    *
    * Such a transaction may claim multiples offered outputs at same time if we know the
    * preimage for each when we create it, but only the input at index `input` should be
    * signed for here. It may be called multiple times for same output(s) if a fee-bump is
    * needed with regards to an upcoming timelock expiration.
    *
    * Witness_script is either a offered or received script as defined in BOLT3 for HTLC
    * outputs.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * Per_commitment_point is the dynamic point corresponding to the channel state
    * detected onchain. It has been generated by our counterparty and is used to derive
    * channel state keys, which are then included in the witness script and committed to in the
    * BIP 143 signature.
    */
   struct LDKCResult_SignatureNoneZ (*sign_counterparty_htlc_transaction)(const void *this_arg, struct LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, struct LDKPublicKey per_commitment_point, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a (proposed) closing transaction.
    *
    * Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
    * chosen to forgo their output as dust.
    */
   struct LDKCResult_SignatureNoneZ (*sign_closing_transaction)(const void *this_arg, const struct LDKClosingTransaction *NONNULL_PTR closing_tx);
   /**
    * Signs a channel announcement message with our funding key and our node secret key (aka
    * node_id or network_key), proving it comes from one of the channel participants.
    *
    * The first returned signature should be from our node secret key, the second from our
    * funding key.
    *
    * Note that if this fails or is rejected, the channel will not be publicly announced and
    * our counterparty may (though likely will not) close the channel on us for violating the
    * protocol.
    */
   struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ (*sign_channel_announcement)(const void *this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Set the counterparty static channel data, including basepoints,
    * counterparty_selected/holder_selected_contest_delay and funding outpoint.
    * This is done as soon as the funding outpoint is known.  Since these are static channel data,
    * they MUST NOT be allowed to change to different values once set.
    *
    * channel_parameters.is_populated() MUST be true.
    *
    * We bind holder_selected_contest_delay late here for API convenience.
    *
    * Will be called before any signatures are applied.
    */
   void (*ready_channel)(void *this_arg, const struct LDKChannelTransactionParameters *NONNULL_PTR channel_parameters);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKBaseSign;

/**
 * A cloneable signer.
 *
 * Although we require signers to be cloneable, it may be useful for developers to be able to use
 * signers in an un-sized way, for example as `dyn BaseSign`. Therefore we separate the Clone trait,
 * which implies Sized, into this derived trait.
 */
typedef struct LDKSign {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Implementation of BaseSign for this object.
    */
   struct LDKBaseSign BaseSign;
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Called, if set, after this Sign has been cloned into a duplicate object.
    * The new Sign is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKSign *NONNULL_PTR new_Sign);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSign;

/**
 * The contents of CResult_SignDecodeErrorZ
 */
typedef union LDKCResult_SignDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSign *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_SignDecodeErrorZPtr;

/**
 * A CResult_SignDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::Sign on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignDecodeErrorZ {
   /**
    * The contents of this CResult_SignDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignDecodeErrorZPtr contents;
   /**
    * Whether this CResult_SignDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignDecodeErrorZ;

/**
 * Integer in the range `0..32`
 */
typedef struct LDKu5 {
   uint8_t _0;
} LDKu5;

/**
 * A dynamically-allocated array of crate::c_types::u5s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u5Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKu5 *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u5Z;

/**
 * Represents a secp256k1 signature serialized as two 32-byte numbers as well as a tag which
 * allows recovering the exact public key which created the signature given the message.
 */
typedef struct LDKRecoverableSignature {
   /**
    * The bytes of the signature in "compact" form plus a "Recovery ID" which allows for
    * recovery.
    */
   uint8_t serialized_form[68];
} LDKRecoverableSignature;

/**
 * The contents of CResult_RecoverableSignatureNoneZ
 */
typedef union LDKCResult_RecoverableSignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRecoverableSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_RecoverableSignatureNoneZPtr;

/**
 * A CResult_RecoverableSignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::RecoverableSignature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RecoverableSignatureNoneZ {
   /**
    * The contents of this CResult_RecoverableSignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RecoverableSignatureNoneZPtr contents;
   /**
    * Whether this CResult_RecoverableSignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RecoverableSignatureNoneZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CVec_u8Zs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CVec_u8ZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCVec_u8Z *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CVec_u8ZZ;

/**
 * The contents of CResult_CVec_CVec_u8ZZNoneZ
 */
typedef union LDKCResult_CVec_CVec_u8ZZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_CVec_u8ZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_CVec_u8ZZNoneZPtr;

/**
 * A CResult_CVec_CVec_u8ZZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_CVec_u8ZZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_CVec_u8ZZNoneZ {
   /**
    * The contents of this CResult_CVec_CVec_u8ZZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_CVec_u8ZZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_CVec_u8ZZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_CVec_u8ZZNoneZ;



/**
 * A simple implementation of Sign that just keeps the private keys in memory.
 *
 * This implementation performs no policy checks and is insufficient by itself as
 * a secure external signer.
 */
typedef struct MUST_USE_STRUCT LDKInMemorySigner {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInMemorySigner *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInMemorySigner;

/**
 * The contents of CResult_InMemorySignerDecodeErrorZ
 */
typedef union LDKCResult_InMemorySignerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInMemorySigner *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InMemorySignerDecodeErrorZPtr;

/**
 * A CResult_InMemorySignerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::keysinterface::InMemorySigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InMemorySignerDecodeErrorZ {
   /**
    * The contents of this CResult_InMemorySignerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InMemorySignerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InMemorySignerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InMemorySignerDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::TxOuts of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TxOutZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKTxOut *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TxOutZ;

/**
 * The contents of CResult_TransactionNoneZ
 */
typedef union LDKCResult_TransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TransactionNoneZPtr;

/**
 * A CResult_TransactionNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::Transaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TransactionNoneZ {
   /**
    * The contents of this CResult_TransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TransactionNoneZPtr contents;
   /**
    * Whether this CResult_TransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TransactionNoneZ;



/**
 * A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
 * on-chain transactions to ensure no loss of funds occurs.
 *
 * You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
 * information and are actively monitoring the chain.
 *
 * Pending Events or updated HTLCs which have not yet been read out by
 * get_and_clear_pending_monitor_events or get_and_clear_pending_events are serialized to disk and
 * reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events
 * gotten are fully handled before re-serializing the new state.
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
 * returned block hash and the the current chain and then reconnecting blocks to get to the
 * best chain) upon deserializing the object!
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitor;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_BlockHashChannelMonitorZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKChannelMonitor b;
} LDKC2Tuple_BlockHashChannelMonitorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_BlockHashChannelMonitorZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_BlockHashChannelMonitorZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_BlockHashChannelMonitorZZ;

/**
 * The contents of CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ
 */
typedef union LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr;

/**
 * A CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_C2Tuple_BlockHashChannelMonitorZZ on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ {
   /**
    * The contents of this CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZPtr contents;
   /**
    * Whether this CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ;

/**
 * An enum which can either contain a u16 or not
 */
typedef enum LDKCOption_u16Z_Tag {
   /**
    * When we're in this state, this COption_u16Z contains a u16
    */
   LDKCOption_u16Z_Some,
   /**
    * When we're in this state, this COption_u16Z contains nothing
    */
   LDKCOption_u16Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u16Z_Sentinel,
} LDKCOption_u16Z_Tag;

typedef struct LDKCOption_u16Z {
   LDKCOption_u16Z_Tag tag;
   union {
      struct {
         uint16_t some;
      };
   };
} LDKCOption_u16Z;

/**
 * Indicates an error on the client's part (usually some variant of attempting to use too-low or
 * too-high values)
 */
typedef enum LDKAPIError_Tag {
   /**
    * Indicates the API was wholly misused (see err for more). Cases where these can be returned
    * are documented, but generally indicates some precondition of a function was violated.
    */
   LDKAPIError_APIMisuseError,
   /**
    * Due to a high feerate, we were unable to complete the request.
    * For example, this may be returned if the feerate implies we cannot open a channel at the
    * requested value, but opening a larger channel would succeed.
    */
   LDKAPIError_FeeRateTooHigh,
   /**
    * A malformed Route was provided (eg overflowed value, node id mismatch, overly-looped route,
    * too-many-hops, etc).
    */
   LDKAPIError_RouteError,
   /**
    * We were unable to complete the request as the Channel required to do so is unable to
    * complete the request (or was not found). This can take many forms, including disconnected
    * peer, channel at capacity, channel shutting down, etc.
    */
   LDKAPIError_ChannelUnavailable,
   /**
    * An attempt to call watch/update_channel returned an Err (ie you did this!), causing the
    * attempted action to fail.
    */
   LDKAPIError_MonitorUpdateFailed,
   /**
    * [`KeysInterface::get_shutdown_scriptpubkey`] returned a shutdown scriptpubkey incompatible
    * with the channel counterparty as negotiated in [`InitFeatures`].
    *
    * Using a SegWit v0 script should resolve this issue. If you cannot, you won't be able to open
    * a channel or cooperatively close one with this peer (and will have to force-close instead).
    *
    * [`KeysInterface::get_shutdown_scriptpubkey`]: crate::chain::keysinterface::KeysInterface::get_shutdown_scriptpubkey
    * [`InitFeatures`]: crate::ln::features::InitFeatures
    */
   LDKAPIError_IncompatibleShutdownScript,
   /**
    * Must be last for serialization purposes
    */
   LDKAPIError_Sentinel,
} LDKAPIError_Tag;

typedef struct LDKAPIError_LDKAPIMisuseError_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKAPIMisuseError_Body;

typedef struct LDKAPIError_LDKFeeRateTooHigh_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
   /**
    * The feerate which was too high.
    */
   uint32_t feerate;
} LDKAPIError_LDKFeeRateTooHigh_Body;

typedef struct LDKAPIError_LDKRouteError_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKRouteError_Body;

typedef struct LDKAPIError_LDKChannelUnavailable_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKChannelUnavailable_Body;

typedef struct LDKAPIError_LDKIncompatibleShutdownScript_Body {
   /**
    * The incompatible shutdown script.
    */
   struct LDKShutdownScript script;
} LDKAPIError_LDKIncompatibleShutdownScript_Body;

typedef struct MUST_USE_STRUCT LDKAPIError {
   LDKAPIError_Tag tag;
   union {
      LDKAPIError_LDKAPIMisuseError_Body api_misuse_error;
      LDKAPIError_LDKFeeRateTooHigh_Body fee_rate_too_high;
      LDKAPIError_LDKRouteError_Body route_error;
      LDKAPIError_LDKChannelUnavailable_Body channel_unavailable;
      LDKAPIError_LDKIncompatibleShutdownScript_Body incompatible_shutdown_script;
   };
} LDKAPIError;

/**
 * The contents of CResult_NoneAPIErrorZ
 */
typedef union LDKCResult_NoneAPIErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_NoneAPIErrorZPtr;

/**
 * A CResult_NoneAPIErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneAPIErrorZ {
   /**
    * The contents of this CResult_NoneAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneAPIErrorZPtr contents;
   /**
    * Whether this CResult_NoneAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneAPIErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CResult_NoneAPIErrorZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CResult_NoneAPIErrorZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCResult_NoneAPIErrorZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CResult_NoneAPIErrorZZ;

/**
 * A dynamically-allocated array of crate::lightning::util::errors::APIErrors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_APIErrorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKAPIError *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_APIErrorZ;

/**
 * The contents of CResult__u832APIErrorZ
 */
typedef union LDKCResult__u832APIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult__u832APIErrorZPtr;

/**
 * A CResult__u832APIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult__u832APIErrorZ {
   /**
    * The contents of this CResult__u832APIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult__u832APIErrorZPtr contents;
   /**
    * Whether this CResult__u832APIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult__u832APIErrorZ;

/**
 * If a payment fails to send, it can be in one of several states. This enum is returned as the
 * Err() type describing which state the payment is in, see the description of individual enum
 * states for more.
 */
typedef enum LDKPaymentSendFailure_Tag {
   /**
    * A parameter which was passed to send_payment was invalid, preventing us from attempting to
    * send the payment at all. No channel state has been changed or messages sent to peers, and
    * once you've changed the parameter at error, you can freely retry the payment in full.
    */
   LDKPaymentSendFailure_ParameterError,
   /**
    * A parameter in a single path which was passed to send_payment was invalid, preventing us
    * from attempting to send the payment at all. No channel state has been changed or messages
    * sent to peers, and once you've changed the parameter at error, you can freely retry the
    * payment in full.
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment.
    */
   LDKPaymentSendFailure_PathParameterError,
   /**
    * All paths which were attempted failed to send, with no channel state change taking place.
    * You can freely retry the payment in full (though you probably want to do so over different
    * paths than the ones selected).
    */
   LDKPaymentSendFailure_AllFailedRetrySafe,
   /**
    * Some paths which were attempted failed to send, though possibly not all. At least some
    * paths have irrevocably committed to the HTLC and retrying the payment in full would result
    * in over-/re-payment.
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment, and any Errs which are not APIError::MonitorUpdateFailed can be safely
    * retried (though there is currently no API with which to do so).
    *
    * Any entries which contain Err(APIError::MonitorUpdateFailed) or Ok(()) MUST NOT be retried
    * as they will result in over-/re-payment. These HTLCs all either successfully sent (in the
    * case of Ok(())) or will send once channel_monitor_updated is called on the next-hop channel
    * with the latest update_id.
    */
   LDKPaymentSendFailure_PartialFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentSendFailure_Sentinel,
} LDKPaymentSendFailure_Tag;

typedef struct LDKPaymentSendFailure_LDKPartialFailure_Body {
   /**
    * The errors themselves, in the same order as the route hops.
    */
   struct LDKCVec_CResult_NoneAPIErrorZZ results;
   /**
    * If some paths failed without irrevocably committing to the new HTLC(s), this will
    * contain a [`RouteParameters`] object which can be used to calculate a new route that
    * will pay all remaining unpaid balance.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKRouteParameters failed_paths_retry;
   /**
    * The payment id for the payment, which is now at least partially pending.
    */
   struct LDKThirtyTwoBytes payment_id;
} LDKPaymentSendFailure_LDKPartialFailure_Body;

typedef struct MUST_USE_STRUCT LDKPaymentSendFailure {
   LDKPaymentSendFailure_Tag tag;
   union {
      struct {
         struct LDKAPIError parameter_error;
      };
      struct {
         struct LDKCVec_CResult_NoneAPIErrorZZ path_parameter_error;
      };
      struct {
         struct LDKCVec_APIErrorZ all_failed_retry_safe;
      };
      LDKPaymentSendFailure_LDKPartialFailure_Body partial_failure;
   };
} LDKPaymentSendFailure;

/**
 * The contents of CResult_PaymentIdPaymentSendFailureZ
 */
typedef union LDKCResult_PaymentIdPaymentSendFailureZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_PaymentIdPaymentSendFailureZPtr;

/**
 * A CResult_PaymentIdPaymentSendFailureZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentIdPaymentSendFailureZ {
   /**
    * The contents of this CResult_PaymentIdPaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentIdPaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_PaymentIdPaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentIdPaymentSendFailureZ;

/**
 * The contents of CResult_NonePaymentSendFailureZ
 */
typedef union LDKCResult_NonePaymentSendFailureZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_NonePaymentSendFailureZPtr;

/**
 * A CResult_NonePaymentSendFailureZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePaymentSendFailureZ {
   /**
    * The contents of this CResult_NonePaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_NonePaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePaymentSendFailureZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PaymentHashPaymentIdZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
} LDKC2Tuple_PaymentHashPaymentIdZ;

/**
 * The contents of CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ
 */
typedef union LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_PaymentHashPaymentIdZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZPtr;

/**
 * A CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentIdZ on success and a crate::lightning::ln::channelmanager::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ {
   /**
    * The contents of this CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ;

/**
 * A 4-byte byte array.
 */
typedef struct LDKFourBytes {
   /**
    * The four bytes
    */
   uint8_t data[4];
} LDKFourBytes;

/**
 * A 16-byte byte array.
 */
typedef struct LDKSixteenBytes {
   /**
    * The sixteen bytes
    */
   uint8_t data[16];
} LDKSixteenBytes;

/**
 * A 12-byte byte array.
 */
typedef struct LDKTwelveBytes {
   /**
    * The twelve bytes
    */
   uint8_t data[12];
} LDKTwelveBytes;

/**
 * An address which can be used to connect to a remote peer
 */
typedef enum LDKNetAddress_Tag {
   /**
    * An IPv4 address/port on which the peer is listening.
    */
   LDKNetAddress_IPv4,
   /**
    * An IPv6 address/port on which the peer is listening.
    */
   LDKNetAddress_IPv6,
   /**
    * An old-style Tor onion address/port on which the peer is listening.
    *
    * This field is deprecated and the Tor network generally no longer supports V2 Onion
    * addresses. Thus, the details are not parsed here.
    */
   LDKNetAddress_OnionV2,
   /**
    * A new-style Tor onion address/port on which the peer is listening.
    * To create the human-readable \"hostname\", concatenate ed25519_pubkey, checksum, and version,
    * wrap as base32 and append \".onion\".
    */
   LDKNetAddress_OnionV3,
   /**
    * Must be last for serialization purposes
    */
   LDKNetAddress_Sentinel,
} LDKNetAddress_Tag;

typedef struct LDKNetAddress_LDKIPv4_Body {
   /**
    * The 4-byte IPv4 address
    */
   struct LDKFourBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKIPv4_Body;

typedef struct LDKNetAddress_LDKIPv6_Body {
   /**
    * The 16-byte IPv6 address
    */
   struct LDKSixteenBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKIPv6_Body;

typedef struct LDKNetAddress_LDKOnionV3_Body {
   /**
    * The ed25519 long-term public key of the peer
    */
   struct LDKThirtyTwoBytes ed25519_pubkey;
   /**
    * The checksum of the pubkey and version, as included in the onion address
    */
   uint16_t checksum;
   /**
    * The version byte, as defined by the Tor Onion v3 spec.
    */
   uint8_t version;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKOnionV3_Body;

typedef struct MUST_USE_STRUCT LDKNetAddress {
   LDKNetAddress_Tag tag;
   union {
      LDKNetAddress_LDKIPv4_Body i_pv4;
      LDKNetAddress_LDKIPv6_Body i_pv6;
      struct {
         struct LDKTwelveBytes onion_v2;
      };
      LDKNetAddress_LDKOnionV3_Body onion_v3;
   };
} LDKNetAddress;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::NetAddresss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_NetAddressZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKNetAddress *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_NetAddressZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PaymentHashPaymentSecretZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
} LDKC2Tuple_PaymentHashPaymentSecretZ;

/**
 * The contents of CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ
 */
typedef union LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_PaymentHashPaymentSecretZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZPtr;

/**
 * A CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentSecretZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ;

/**
 * The contents of CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ
 */
typedef union LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_PaymentHashPaymentSecretZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZPtr;

/**
 * A CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_PaymentHashPaymentSecretZ on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ {
   /**
    * The contents of this CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ;

/**
 * The contents of CResult_PaymentSecretNoneZ
 */
typedef union LDKCResult_PaymentSecretNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_PaymentSecretNoneZPtr;

/**
 * A CResult_PaymentSecretNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentSecretNoneZ {
   /**
    * The contents of this CResult_PaymentSecretNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentSecretNoneZPtr contents;
   /**
    * Whether this CResult_PaymentSecretNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentSecretNoneZ;

/**
 * The contents of CResult_PaymentSecretAPIErrorZ
 */
typedef union LDKCResult_PaymentSecretAPIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_PaymentSecretAPIErrorZPtr;

/**
 * A CResult_PaymentSecretAPIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentSecretAPIErrorZ {
   /**
    * The contents of this CResult_PaymentSecretAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentSecretAPIErrorZPtr contents;
   /**
    * Whether this CResult_PaymentSecretAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentSecretAPIErrorZ;

/**
 * The contents of CResult_PaymentPreimageAPIErrorZ
 */
typedef union LDKCResult_PaymentPreimageAPIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_PaymentPreimageAPIErrorZPtr;

/**
 * A CResult_PaymentPreimageAPIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentPreimageAPIErrorZ {
   /**
    * The contents of this CResult_PaymentPreimageAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentPreimageAPIErrorZPtr contents;
   /**
    * Whether this CResult_PaymentPreimageAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentPreimageAPIErrorZ;



/**
 * Information needed for constructing an invoice route hint for this channel.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyForwardingInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyForwardingInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyForwardingInfo;

/**
 * The contents of CResult_CounterpartyForwardingInfoDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyForwardingInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr;

/**
 * A CResult_CounterpartyForwardingInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::CounterpartyForwardingInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyForwardingInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyForwardingInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyForwardingInfoDecodeErrorZ;



/**
 * Channel parameters which apply to our counterparty. These are split out from [`ChannelDetails`]
 * to better separate parameters.
 */
typedef struct MUST_USE_STRUCT LDKChannelCounterparty {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelCounterparty *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelCounterparty;

/**
 * The contents of CResult_ChannelCounterpartyDecodeErrorZ
 */
typedef union LDKCResult_ChannelCounterpartyDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelCounterparty *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelCounterpartyDecodeErrorZPtr;

/**
 * A CResult_ChannelCounterpartyDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::ChannelCounterparty on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelCounterpartyDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelCounterpartyDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelCounterpartyDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelCounterpartyDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelCounterpartyDecodeErrorZ;

/**
 * The contents of CResult_ChannelDetailsDecodeErrorZ
 */
typedef union LDKCResult_ChannelDetailsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelDetails *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelDetailsDecodeErrorZPtr;

/**
 * A CResult_ChannelDetailsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::ChannelDetails on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelDetailsDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelDetailsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelDetailsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelDetailsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelDetailsDecodeErrorZ;



/**
 * Route hints used in constructing invoices for [phantom node payents].
 *
 * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
 */
typedef struct MUST_USE_STRUCT LDKPhantomRouteHints {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePhantomRouteHints *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPhantomRouteHints;

/**
 * The contents of CResult_PhantomRouteHintsDecodeErrorZ
 */
typedef union LDKCResult_PhantomRouteHintsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPhantomRouteHints *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PhantomRouteHintsDecodeErrorZPtr;

/**
 * A CResult_PhantomRouteHintsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::PhantomRouteHints on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PhantomRouteHintsDecodeErrorZ {
   /**
    * The contents of this CResult_PhantomRouteHintsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PhantomRouteHintsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PhantomRouteHintsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PhantomRouteHintsDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::ChannelMonitors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ChannelMonitorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKChannelMonitor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ChannelMonitorZ;



/**
 * An update generated by the underlying Channel itself which contains some new information the
 * ChannelMonitor should be made aware of.
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitorUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitorUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitorUpdate;

/**
 * The `Watch` trait defines behavior for watching on-chain activity pertaining to channels as
 * blocks are connected and disconnected.
 *
 * Each channel is associated with a [`ChannelMonitor`]. Implementations of this trait are
 * responsible for maintaining a set of monitors such that they can be updated accordingly as
 * channel state changes and HTLCs are resolved. See method documentation for specific
 * requirements.
 *
 * Implementations **must** ensure that updates are successfully applied and persisted upon method
 * completion. If an update fails with a [`PermanentFailure`], then it must immediately shut down
 * without taking any further action such as persisting the current state.
 *
 * If an implementation maintains multiple instances of a channel's monitor (e.g., by storing
 * backup copies), then it must ensure that updates are applied across all instances. Otherwise, it
 * could result in a revoked transaction being broadcast, allowing the counterparty to claim all
 * funds in the channel. See [`ChannelMonitorUpdateErr`] for more details about how to handle
 * multiple instances.
 *
 * [`PermanentFailure`]: ChannelMonitorUpdateErr::PermanentFailure
 */
typedef struct LDKWatch {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Watches a channel identified by `funding_txo` using `monitor`.
    *
    * Implementations are responsible for watching the chain for the funding transaction along
    * with any spends of outputs returned by [`get_outputs_to_watch`]. In practice, this means
    * calling [`block_connected`] and [`block_disconnected`] on the monitor.
    *
    * Note: this interface MUST error with `ChannelMonitorUpdateErr::PermanentFailure` if
    * the given `funding_txo` has previously been registered via `watch_channel`.
    *
    * [`get_outputs_to_watch`]: channelmonitor::ChannelMonitor::get_outputs_to_watch
    * [`block_connected`]: channelmonitor::ChannelMonitor::block_connected
    * [`block_disconnected`]: channelmonitor::ChannelMonitor::block_disconnected
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*watch_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitor monitor);
   /**
    * Updates a channel identified by `funding_txo` by applying `update` to its monitor.
    *
    * Implementations must call [`update_monitor`] with the given update. See
    * [`ChannelMonitorUpdateErr`] for invariants around returning an error.
    *
    * [`update_monitor`]: channelmonitor::ChannelMonitor::update_monitor
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*update_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitorUpdate update);
   /**
    * Returns any monitor events since the last call. Subsequent calls must only return new
    * events.
    *
    * Note that after any block- or transaction-connection calls to a [`ChannelMonitor`], no
    * further events may be returned here until the [`ChannelMonitor`] has been fully persisted
    * to disk.
    *
    * For details on asynchronous [`ChannelMonitor`] updating and returning
    * [`MonitorEvent::UpdateCompleted`] here, see [`ChannelMonitorUpdateErr::TemporaryFailure`].
    */
   struct LDKCVec_MonitorEventZ (*release_pending_monitor_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWatch;

/**
 * An interface to send a transaction to the Bitcoin network.
 */
typedef struct LDKBroadcasterInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Sends a transaction out to (hopefully) be mined.
    */
   void (*broadcast_transaction)(const void *this_arg, struct LDKTransaction tx);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKBroadcasterInterface;

/**
 * A "slice" referencing some byte array. This is simply a length-tagged pointer which does not
 * own the memory pointed to by data.
 */
typedef struct LDKu8slice {
   /**
    * A pointer to the byte buffer
    */
   const uint8_t *data;
   /**
    * The number of bytes pointed to by `data`.
    */
   uintptr_t datalen;
} LDKu8slice;

/**
 * A trait to describe an object which can get user secrets and key material.
 */
typedef struct LDKKeysInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Get node secret key (aka node_id or network_key) based on the provided [`Recipient`].
    *
    * This method must return the same value each time it is called with a given `Recipient`
    * parameter.
    */
   struct LDKCResult_SecretKeyNoneZ (*get_node_secret)(const void *this_arg, enum LDKRecipient recipient);
   /**
    * Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKCVec_u8Z (*get_destination_script)(const void *this_arg);
   /**
    * Get a script pubkey which we will send funds to when closing a channel.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKShutdownScript (*get_shutdown_scriptpubkey)(const void *this_arg);
   /**
    * Get a new set of Sign for per-channel secrets. These MUST be unique even if you
    * restarted with some stale data!
    *
    * This method must return a different value each time it is called.
    */
   struct LDKSign (*get_channel_signer)(const void *this_arg, bool inbound, uint64_t channel_value_satoshis);
   /**
    * Gets a unique, cryptographically-secure, random 32 byte value. This is used for encrypting
    * onion packets and for temporary channel IDs. There is no requirement that these be
    * persisted anywhere, though they must be unique across restarts.
    *
    * This method must return a different value each time it is called.
    */
   struct LDKThirtyTwoBytes (*get_secure_random_bytes)(const void *this_arg);
   /**
    * Reads a `Signer` for this `KeysInterface` from the given input stream.
    * This is only called during deserialization of other objects which contain
    * `Sign`-implementing objects (ie `ChannelMonitor`s and `ChannelManager`s).
    * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
    * contain no versioning scheme. You may wish to include your own version prefix and ensure
    * you've read all of the provided bytes to ensure no corruption occurred.
    */
   struct LDKCResult_SignDecodeErrorZ (*read_chan_signer)(const void *this_arg, struct LDKu8slice reader);
   /**
    * Sign an invoice.
    * By parameterizing by the raw invoice bytes instead of the hash, we allow implementors of
    * this trait to parse the invoice and make sure they're signing what they expect, rather than
    * blindly signing the hash.
    * The hrp is ascii bytes, while the invoice data is base32.
    *
    * The secret key used to sign the invoice is dependent on the [`Recipient`].
    */
   struct LDKCResult_RecoverableSignatureNoneZ (*sign_invoice)(const void *this_arg, struct LDKu8slice hrp_bytes, struct LDKCVec_u5Z invoice_data, enum LDKRecipient receipient);
   /**
    * Get secret key material as bytes for use in encrypting and decrypting inbound payment data.
    *
    * If the implementor of this trait supports [phantom node payments], then every node that is
    * intended to be included in the phantom invoice route hints must return the same value from
    * this method.
    *
    * This method must return the same value each time it is called.
    *
    * [phantom node payments]: PhantomKeysManager
    */
   struct LDKThirtyTwoBytes (*get_inbound_payment_key_material)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKKeysInterface;

/**
 * A trait which should be implemented to provide feerate information on a number of time
 * horizons.
 *
 * Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're
 * called from inside the library in response to chain events, P2P events, or timer events).
 */
typedef struct LDKFeeEstimator {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets estimated satoshis of fee required per 1000 Weight-Units.
    *
    * Must return a value no smaller than 253 (ie 1 satoshi-per-byte rounded up to ensure later
    * round-downs don't put us below 1 satoshi-per-byte).
    *
    * This method can be implemented with the following unit conversions:
    *  * max(satoshis-per-byte * 250, 253)
    *  * max(satoshis-per-kbyte / 4, 253)
    */
   uint32_t (*get_est_sat_per_1000_weight)(const void *this_arg, enum LDKConfirmationTarget confirmation_target);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFeeEstimator;



/**
 * A Record, unit of logging output with Metadata to enable filtering
 * Module_path, file, line to inform on log's source
 */
typedef struct MUST_USE_STRUCT LDKRecord {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRecord *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRecord;

/**
 * A trait encapsulating the operations required of a logger
 */
typedef struct LDKLogger {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Logs the `Record`
    */
   void (*log)(const void *this_arg, const struct LDKRecord *NONNULL_PTR record);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKLogger;



/**
 * Manager which keeps track of a number of channels and sends messages to the appropriate
 * channel, also tracking HTLC preimages and forwarding onion packets appropriately.
 *
 * Implements ChannelMessageHandler, handling the multi-channel parts and passing things through
 * to individual Channels.
 *
 * Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for
 * all peers during write/read (though does not modify this instance, only the instance being
 * serialized). This will result in any channels which have not yet exchanged funding_created (ie
 * called funding_transaction_generated for outbound channels).
 *
 * Note that you can be a bit lazier about writing out ChannelManager than you can be with
 * ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before
 * returning from chain::Watch::watch_/update_channel, with ChannelManagers, writing updates
 * happens out-of-band (and will prevent any other ChannelManager operations from occurring during
 * the serialization process). If the deserialized version is out-of-date compared to the
 * ChannelMonitors passed by reference to read(), those channels will be force-closed based on the
 * ChannelMonitor state and no funds will be lost (mod on-chain transaction fees).
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelManager), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call
 * block_connected() to step towards your best block) upon deserialization before using the
 * object!
 *
 * Note that ChannelManager is responsible for tracking liveness of its channels and generating
 * ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid
 * spam due to quick disconnection/reconnection, updates are not sent until the channel has been
 * offline for a full minute. In order to track this, you must call
 * timer_tick_occurred roughly once per minute, though it doesn't have to be perfect.
 *
 * Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager
 * a SimpleRefChannelManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefChannelManager, and use a
 * SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 */
typedef struct MUST_USE_STRUCT LDKChannelManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManager;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_BlockHashChannelManagerZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKChannelManager b;
} LDKC2Tuple_BlockHashChannelManagerZ;

/**
 * The contents of CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ
 */
typedef union LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_BlockHashChannelManagerZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr;

/**
 * A CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_BlockHashChannelManagerZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ {
   /**
    * The contents of this CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ;



/**
 * Options which apply on a per-channel basis and may change at runtime or based on negotiation
 * with our counterparty.
 */
typedef struct MUST_USE_STRUCT LDKChannelConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelConfig;

/**
 * The contents of CResult_ChannelConfigDecodeErrorZ
 */
typedef union LDKCResult_ChannelConfigDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelConfig *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelConfigDecodeErrorZPtr;

/**
 * A CResult_ChannelConfigDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::config::ChannelConfig on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelConfigDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelConfigDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelConfigDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelConfigDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelConfigDecodeErrorZ;

/**
 * The contents of CResult_OutPointDecodeErrorZ
 */
typedef union LDKCResult_OutPointDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOutPoint *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OutPointDecodeErrorZPtr;

/**
 * A CResult_OutPointDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::transaction::OutPoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OutPointDecodeErrorZ {
   /**
    * The contents of this CResult_OutPointDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OutPointDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OutPointDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OutPointDecodeErrorZ;

/**
 * Defines a type identifier for sending messages over the wire.
 *
 * Messages implementing this trait specify a type and must be [`Writeable`].
 */
typedef struct LDKType {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the type identifying the message payload.
    */
   uint16_t (*type_id)(const void *this_arg);
   /**
    * Return a human-readable "debug" string describing this object
    */
   struct LDKStr (*debug_str)(const void *this_arg);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Called, if set, after this Type has been cloned into a duplicate object.
    * The new Type is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKType *NONNULL_PTR new_Type);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKType;

/**
 * An enum which can either contain a crate::lightning::ln::wire::Type or not
 */
typedef enum LDKCOption_TypeZ_Tag {
   /**
    * When we're in this state, this COption_TypeZ contains a crate::lightning::ln::wire::Type
    */
   LDKCOption_TypeZ_Some,
   /**
    * When we're in this state, this COption_TypeZ contains nothing
    */
   LDKCOption_TypeZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_TypeZ_Sentinel,
} LDKCOption_TypeZ_Tag;

typedef struct LDKCOption_TypeZ {
   LDKCOption_TypeZ_Tag tag;
   union {
      struct {
         struct LDKType some;
      };
   };
} LDKCOption_TypeZ;

/**
 * The contents of CResult_COption_TypeZDecodeErrorZ
 */
typedef union LDKCResult_COption_TypeZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_TypeZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_TypeZDecodeErrorZPtr;

/**
 * A CResult_COption_TypeZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_TypeZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_TypeZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_TypeZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_TypeZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_TypeZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_TypeZDecodeErrorZ;

/**
 * An error that may occur when making a payment.
 */
typedef enum LDKPaymentError_Tag {
   /**
    * An error resulting from the provided [`Invoice`] or payment hash.
    */
   LDKPaymentError_Invoice,
   /**
    * An error occurring when finding a route.
    */
   LDKPaymentError_Routing,
   /**
    * An error occurring when sending a payment.
    */
   LDKPaymentError_Sending,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentError_Sentinel,
} LDKPaymentError_Tag;

typedef struct MUST_USE_STRUCT LDKPaymentError {
   LDKPaymentError_Tag tag;
   union {
      struct {
         struct LDKStr invoice;
      };
      struct {
         struct LDKLightningError routing;
      };
      struct {
         struct LDKPaymentSendFailure sending;
      };
   };
} LDKPaymentError;

/**
 * The contents of CResult_PaymentIdPaymentErrorZ
 */
typedef union LDKCResult_PaymentIdPaymentErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentError *err;
} LDKCResult_PaymentIdPaymentErrorZPtr;

/**
 * A CResult_PaymentIdPaymentErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning_invoice::payment::PaymentError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentIdPaymentErrorZ {
   /**
    * The contents of this CResult_PaymentIdPaymentErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentIdPaymentErrorZPtr contents;
   /**
    * Whether this CResult_PaymentIdPaymentErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentIdPaymentErrorZ;

/**
 * Sub-errors which don't have specific information in them use this type.
 */
typedef struct LDKError {
   /**
    * Zero-Sized_types aren't consistent across Rust/C/C++, so we add some size here
    */
   uint8_t _dummy;
} LDKError;

/**
 * Errors that indicate what is wrong with the invoice. They have some granularity for debug
 * reasons, but should generally result in an \"invalid BOLT11 invoice\" message for the user.
 */
typedef enum LDKParseError_Tag {
   LDKParseError_Bech32Error,
   LDKParseError_ParseAmountError,
   LDKParseError_MalformedSignature,
   LDKParseError_BadPrefix,
   LDKParseError_UnknownCurrency,
   LDKParseError_UnknownSiPrefix,
   LDKParseError_MalformedHRP,
   LDKParseError_TooShortDataPart,
   LDKParseError_UnexpectedEndOfTaggedFields,
   LDKParseError_DescriptionDecodeError,
   LDKParseError_PaddingError,
   LDKParseError_IntegerOverflowError,
   LDKParseError_InvalidSegWitProgramLength,
   LDKParseError_InvalidPubKeyHashLength,
   LDKParseError_InvalidScriptHashLength,
   LDKParseError_InvalidRecoveryId,
   LDKParseError_InvalidSliceLength,
   /**
    * Not an error, but used internally to signal that a part of the invoice should be ignored
    * according to BOLT11
    */
   LDKParseError_Skip,
   /**
    * Must be last for serialization purposes
    */
   LDKParseError_Sentinel,
} LDKParseError_Tag;

typedef struct MUST_USE_STRUCT LDKParseError {
   LDKParseError_Tag tag;
   union {
      struct {
         struct LDKBech32Error bech32_error;
      };
      struct {
         struct LDKError parse_amount_error;
      };
      struct {
         enum LDKSecp256k1Error malformed_signature;
      };
      struct {
         struct LDKError description_decode_error;
      };
      struct {
         struct LDKStr invalid_slice_length;
      };
   };
} LDKParseError;

/**
 * The contents of CResult_SiPrefixParseErrorZ
 */
typedef union LDKCResult_SiPrefixParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   enum LDKSiPrefix *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKParseError *err;
} LDKCResult_SiPrefixParseErrorZPtr;

/**
 * A CResult_SiPrefixParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::SiPrefix on success and a crate::lightning_invoice::ParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SiPrefixParseErrorZ {
   /**
    * The contents of this CResult_SiPrefixParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SiPrefixParseErrorZPtr contents;
   /**
    * Whether this CResult_SiPrefixParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SiPrefixParseErrorZ;



/**
 * Represents a syntactically and semantically correct lightning BOLT11 invoice.
 *
 * There are three ways to construct an `Invoice`:
 *  1. using `InvoiceBuilder`
 *  2. using `Invoice::from_signed(SignedRawInvoice)`
 *  3. using `str::parse::<Invoice>(&str)`
 */
typedef struct MUST_USE_STRUCT LDKInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoice;

/**
 * Indicates that something went wrong while parsing or validating the invoice. Parsing errors
 * should be mostly seen as opaque and are only there for debugging reasons. Semantic errors
 * like wrong signatures, missing fields etc. could mean that someone tampered with the invoice.
 */
typedef enum LDKParseOrSemanticError_Tag {
   /**
    * The invoice couldn't be decoded
    */
   LDKParseOrSemanticError_ParseError,
   /**
    * The invoice could be decoded but violates the BOLT11 standard
    */
   LDKParseOrSemanticError_SemanticError,
   /**
    * Must be last for serialization purposes
    */
   LDKParseOrSemanticError_Sentinel,
} LDKParseOrSemanticError_Tag;

typedef struct MUST_USE_STRUCT LDKParseOrSemanticError {
   LDKParseOrSemanticError_Tag tag;
   union {
      struct {
         struct LDKParseError parse_error;
      };
      struct {
         enum LDKSemanticError semantic_error;
      };
   };
} LDKParseOrSemanticError;

/**
 * The contents of CResult_InvoiceParseOrSemanticErrorZ
 */
typedef union LDKCResult_InvoiceParseOrSemanticErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKParseOrSemanticError *err;
} LDKCResult_InvoiceParseOrSemanticErrorZPtr;

/**
 * A CResult_InvoiceParseOrSemanticErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::ParseOrSemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceParseOrSemanticErrorZ {
   /**
    * The contents of this CResult_InvoiceParseOrSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceParseOrSemanticErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceParseOrSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceParseOrSemanticErrorZ;



/**
 * Represents a signed `RawInvoice` with cached hash. The signature is not checked and may be
 * invalid.
 *
 * # Invariants
 * The hash has to be either from the deserialized invoice or from the serialized `raw_invoice`.
 */
typedef struct MUST_USE_STRUCT LDKSignedRawInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSignedRawInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSignedRawInvoice;

/**
 * The contents of CResult_SignedRawInvoiceParseErrorZ
 */
typedef union LDKCResult_SignedRawInvoiceParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSignedRawInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKParseError *err;
} LDKCResult_SignedRawInvoiceParseErrorZPtr;

/**
 * A CResult_SignedRawInvoiceParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::SignedRawInvoice on success and a crate::lightning_invoice::ParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignedRawInvoiceParseErrorZ {
   /**
    * The contents of this CResult_SignedRawInvoiceParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignedRawInvoiceParseErrorZPtr contents;
   /**
    * Whether this CResult_SignedRawInvoiceParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignedRawInvoiceParseErrorZ;



/**
 * Represents an syntactically correct Invoice for a payment on the lightning network,
 * but without the signature information.
 * De- and encoding should not lead to information loss but may lead to different hashes.
 *
 * For methods without docs see the corresponding methods in `Invoice`.
 */
typedef struct MUST_USE_STRUCT LDKRawInvoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRawInvoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRawInvoice;



/**
 * Recoverable signature
 */
typedef struct MUST_USE_STRUCT LDKInvoiceSignature {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceSignature *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceSignature;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ {
   /**
    * The element at position 0
    */
   struct LDKRawInvoice a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
   /**
    * The element at position 2
    */
   struct LDKInvoiceSignature c;
} LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ;



/**
 * Payee public key
 */
typedef struct MUST_USE_STRUCT LDKPayeePubKey {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePayeePubKey *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPayeePubKey;

/**
 * The contents of CResult_PayeePubKeyErrorZ
 */
typedef union LDKCResult_PayeePubKeyErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPayeePubKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_PayeePubKeyErrorZPtr;

/**
 * A CResult_PayeePubKeyErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PayeePubKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PayeePubKeyErrorZ {
   /**
    * The contents of this CResult_PayeePubKeyErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PayeePubKeyErrorZPtr contents;
   /**
    * Whether this CResult_PayeePubKeyErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PayeePubKeyErrorZ;



/**
 * Private routing information
 *
 * # Invariants
 * The encoded route has to be <1024 5bit characters long (<=639 bytes or <=12 hops)
 *
 */
typedef struct MUST_USE_STRUCT LDKPrivateRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePrivateRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPrivateRoute;

/**
 * A dynamically-allocated array of crate::lightning_invoice::PrivateRoutes of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PrivateRouteZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPrivateRoute *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PrivateRouteZ;



/**
 * A timestamp that refers to a date after 1 January 1970.
 *
 * # Invariants
 *
 * The Unix timestamp representing the stored time has to be positive and no greater than
 * [`MAX_TIMESTAMP`].
 */
typedef struct MUST_USE_STRUCT LDKPositiveTimestamp {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePositiveTimestamp *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPositiveTimestamp;

/**
 * The contents of CResult_PositiveTimestampCreationErrorZ
 */
typedef union LDKCResult_PositiveTimestampCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPositiveTimestamp *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_PositiveTimestampCreationErrorZPtr;

/**
 * A CResult_PositiveTimestampCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PositiveTimestamp on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PositiveTimestampCreationErrorZ {
   /**
    * The contents of this CResult_PositiveTimestampCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PositiveTimestampCreationErrorZPtr contents;
   /**
    * Whether this CResult_PositiveTimestampCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PositiveTimestampCreationErrorZ;

/**
 * The contents of CResult_NoneSemanticErrorZ
 */
typedef union LDKCResult_NoneSemanticErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSemanticError *err;
} LDKCResult_NoneSemanticErrorZPtr;

/**
 * A CResult_NoneSemanticErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning_invoice::SemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneSemanticErrorZ {
   /**
    * The contents of this CResult_NoneSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneSemanticErrorZPtr contents;
   /**
    * Whether this CResult_NoneSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneSemanticErrorZ;

/**
 * The contents of CResult_InvoiceSemanticErrorZ
 */
typedef union LDKCResult_InvoiceSemanticErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSemanticError *err;
} LDKCResult_InvoiceSemanticErrorZPtr;

/**
 * A CResult_InvoiceSemanticErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::SemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceSemanticErrorZ {
   /**
    * The contents of this CResult_InvoiceSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceSemanticErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceSemanticErrorZ;



/**
 * Description string
 *
 * # Invariants
 * The description can be at most 639 __bytes__ long
 */
typedef struct MUST_USE_STRUCT LDKDescription {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDescription *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDescription;

/**
 * The contents of CResult_DescriptionCreationErrorZ
 */
typedef union LDKCResult_DescriptionCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDescription *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_DescriptionCreationErrorZPtr;

/**
 * A CResult_DescriptionCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Description on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DescriptionCreationErrorZ {
   /**
    * The contents of this CResult_DescriptionCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DescriptionCreationErrorZPtr contents;
   /**
    * Whether this CResult_DescriptionCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DescriptionCreationErrorZ;

/**
 * The contents of CResult_PrivateRouteCreationErrorZ
 */
typedef union LDKCResult_PrivateRouteCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPrivateRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_PrivateRouteCreationErrorZPtr;

/**
 * A CResult_PrivateRouteCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PrivateRoute on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PrivateRouteCreationErrorZ {
   /**
    * The contents of this CResult_PrivateRouteCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PrivateRouteCreationErrorZPtr contents;
   /**
    * Whether this CResult_PrivateRouteCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PrivateRouteCreationErrorZ;

/**
 * The contents of CResult_StringErrorZ
 */
typedef union LDKCResult_StringErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKStr *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_StringErrorZPtr;

/**
 * A CResult_StringErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::Str on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_StringErrorZ {
   /**
    * The contents of this CResult_StringErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_StringErrorZPtr contents;
   /**
    * Whether this CResult_StringErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_StringErrorZ;

/**
 * The contents of CResult_ChannelMonitorUpdateDecodeErrorZ
 */
typedef union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelMonitorUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr;

/**
 * A CResult_ChannelMonitorUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::channelmonitor::ChannelMonitorUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelMonitorUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelMonitorUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZ;

/**
 * An enum which can either contain a crate::lightning::chain::channelmonitor::MonitorEvent or not
 */
typedef enum LDKCOption_MonitorEventZ_Tag {
   /**
    * When we're in this state, this COption_MonitorEventZ contains a crate::lightning::chain::channelmonitor::MonitorEvent
    */
   LDKCOption_MonitorEventZ_Some,
   /**
    * When we're in this state, this COption_MonitorEventZ contains nothing
    */
   LDKCOption_MonitorEventZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_MonitorEventZ_Sentinel,
} LDKCOption_MonitorEventZ_Tag;

typedef struct LDKCOption_MonitorEventZ {
   LDKCOption_MonitorEventZ_Tag tag;
   union {
      struct {
         struct LDKMonitorEvent some;
      };
   };
} LDKCOption_MonitorEventZ;

/**
 * The contents of CResult_COption_MonitorEventZDecodeErrorZ
 */
typedef union LDKCResult_COption_MonitorEventZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_MonitorEventZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_MonitorEventZDecodeErrorZPtr;

/**
 * A CResult_COption_MonitorEventZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_MonitorEventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_MonitorEventZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_MonitorEventZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_MonitorEventZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_MonitorEventZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_MonitorEventZDecodeErrorZ;

/**
 * The contents of CResult_HTLCUpdateDecodeErrorZ
 */
typedef union LDKCResult_HTLCUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCUpdateDecodeErrorZPtr;

/**
 * A CResult_HTLCUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::channelmonitor::HTLCUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCUpdateDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_OutPointScriptZ {
   /**
    * The element at position 0
    */
   struct LDKOutPoint a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_OutPointScriptZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u32ScriptZ {
   /**
    * The element at position 0
    */
   uint32_t a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_u32ScriptZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32ScriptZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u32ScriptZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u32ScriptZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32ScriptZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCVec_C2Tuple_u32ScriptZZ b;
} LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ;

/**
 * A dynamically-allocated array of crate::lightning::util::events::Events of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_EventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_EventZ;

/**
 * A dynamically-allocated array of crate::c_types::Transactions of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TransactionZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKTransaction *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TransactionZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u32TxOutZ {
   /**
    * The element at position 0
    */
   uint32_t a;
   /**
    * The element at position 1
    */
   struct LDKTxOut b;
} LDKC2Tuple_u32TxOutZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32TxOutZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u32TxOutZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u32TxOutZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32TxOutZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCVec_C2Tuple_u32TxOutZZ b;
} LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TransactionOutputsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TransactionOutputsZ;

/**
 * Details about the balance(s) available for spending once the channel appears on chain.
 *
 * See [`ChannelMonitor::get_claimable_balances`] for more details on when these will or will not
 * be provided.
 */
typedef enum LDKBalance_Tag {
   /**
    * The channel is not yet closed (or the commitment or closing transaction has not yet
    * appeared in a block). The given balance is claimable (less on-chain fees) if the channel is
    * force-closed now.
    */
   LDKBalance_ClaimableOnChannelClose,
   /**
    * The channel has been closed, and the given balance is ours but awaiting confirmations until
    * we consider it spendable.
    */
   LDKBalance_ClaimableAwaitingConfirmations,
   /**
    * The channel has been closed, and the given balance should be ours but awaiting spending
    * transaction confirmation. If the spending transaction does not confirm in time, it is
    * possible our counterparty can take the funds by broadcasting an HTLC timeout on-chain.
    *
    * Once the spending transaction confirms, before it has reached enough confirmations to be
    * considered safe from chain reorganizations, the balance will instead be provided via
    * [`Balance::ClaimableAwaitingConfirmations`].
    */
   LDKBalance_ContentiousClaimable,
   /**
    * HTLCs which we sent to our counterparty which are claimable after a timeout (less on-chain
    * fees) if the counterparty does not know the preimage for the HTLCs. These are somewhat
    * likely to be claimed by our counterparty before we do.
    */
   LDKBalance_MaybeClaimableHTLCAwaitingTimeout,
   /**
    * Must be last for serialization purposes
    */
   LDKBalance_Sentinel,
} LDKBalance_Tag;

typedef struct LDKBalance_LDKClaimableOnChannelClose_Body {
   /**
    * The amount available to claim, in satoshis, excluding the on-chain fees which will be
    * required to do so.
    */
   uint64_t claimable_amount_satoshis;
} LDKBalance_LDKClaimableOnChannelClose_Body;

typedef struct LDKBalance_LDKClaimableAwaitingConfirmations_Body {
   /**
    * The amount available to claim, in satoshis, possibly excluding the on-chain fees which
    * were spent in broadcasting the transaction.
    */
   uint64_t claimable_amount_satoshis;
   /**
    * The height at which an [`Event::SpendableOutputs`] event will be generated for this
    * amount.
    */
   uint32_t confirmation_height;
} LDKBalance_LDKClaimableAwaitingConfirmations_Body;

typedef struct LDKBalance_LDKContentiousClaimable_Body {
   /**
    * The amount available to claim, in satoshis, excluding the on-chain fees which will be
    * required to do so.
    */
   uint64_t claimable_amount_satoshis;
   /**
    * The height at which the counterparty may be able to claim the balance if we have not
    * done so.
    */
   uint32_t timeout_height;
} LDKBalance_LDKContentiousClaimable_Body;

typedef struct LDKBalance_LDKMaybeClaimableHTLCAwaitingTimeout_Body {
   /**
    * The amount available to claim, in satoshis, excluding the on-chain fees which will be
    * required to do so.
    */
   uint64_t claimable_amount_satoshis;
   /**
    * The height at which we will be able to claim the balance if our counterparty has not
    * done so.
    */
   uint32_t claimable_height;
} LDKBalance_LDKMaybeClaimableHTLCAwaitingTimeout_Body;

typedef struct MUST_USE_STRUCT LDKBalance {
   LDKBalance_Tag tag;
   union {
      LDKBalance_LDKClaimableOnChannelClose_Body claimable_on_channel_close;
      LDKBalance_LDKClaimableAwaitingConfirmations_Body claimable_awaiting_confirmations;
      LDKBalance_LDKContentiousClaimable_Body contentious_claimable;
      LDKBalance_LDKMaybeClaimableHTLCAwaitingTimeout_Body maybe_claimable_htlc_awaiting_timeout;
   };
} LDKBalance;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::Balances of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_BalanceZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKBalance *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_BalanceZ;

/**
 * The contents of CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ
 */
typedef union LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_BlockHashChannelMonitorZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr;

/**
 * A CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_BlockHashChannelMonitorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ {
   /**
    * The contents of this CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ;

/**
 * The contents of CResult_NoneLightningErrorZ
 */
typedef union LDKCResult_NoneLightningErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_NoneLightningErrorZPtr;

/**
 * A CResult_NoneLightningErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneLightningErrorZ {
   /**
    * The contents of this CResult_NoneLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneLightningErrorZPtr contents;
   /**
    * Whether this CResult_NoneLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneLightningErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PublicKeyTypeZ {
   /**
    * The element at position 0
    */
   struct LDKPublicKey a;
   /**
    * The element at position 1
    */
   struct LDKType b;
} LDKC2Tuple_PublicKeyTypeZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyTypeZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_PublicKeyTypeZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_PublicKeyTypeZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_PublicKeyTypeZZ;

/**
 * The contents of CResult_boolLightningErrorZ
 */
typedef union LDKCResult_boolLightningErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   bool *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_boolLightningErrorZPtr;

/**
 * A CResult_boolLightningErrorZ represents the result of a fallible operation,
 * containing a bool on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_boolLightningErrorZ {
   /**
    * The contents of this CResult_boolLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_boolLightningErrorZPtr contents;
   /**
    * Whether this CResult_boolLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_boolLightningErrorZ;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
   /**
    * The element at position 0
    */
   struct LDKChannelAnnouncement a;
   /**
    * The element at position 1
    */
   struct LDKChannelUpdate b;
   /**
    * The element at position 2
    */
   struct LDKChannelUpdate c;
} LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::NodeAnnouncements of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_NodeAnnouncementZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKNodeAnnouncement *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_NodeAnnouncementZ;

/**
 * A dynamically-allocated array of crate::c_types::PublicKeys of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PublicKeyZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPublicKey *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PublicKeyZ;

/**
 * An enum which can either contain a crate::lightning::ln::msgs::NetAddress or not
 */
typedef enum LDKCOption_NetAddressZ_Tag {
   /**
    * When we're in this state, this COption_NetAddressZ contains a crate::lightning::ln::msgs::NetAddress
    */
   LDKCOption_NetAddressZ_Some,
   /**
    * When we're in this state, this COption_NetAddressZ contains nothing
    */
   LDKCOption_NetAddressZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_NetAddressZ_Sentinel,
} LDKCOption_NetAddressZ_Tag;

typedef struct LDKCOption_NetAddressZ {
   LDKCOption_NetAddressZ_Tag tag;
   union {
      struct {
         struct LDKNetAddress some;
      };
   };
} LDKCOption_NetAddressZ;



/**
 * Error for PeerManager errors. If you get one of these, you must disconnect the socket and
 * generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
 * descriptor.
 */
typedef struct MUST_USE_STRUCT LDKPeerHandleError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerHandleError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerHandleError;

/**
 * The contents of CResult_CVec_u8ZPeerHandleErrorZ
 */
typedef union LDKCResult_CVec_u8ZPeerHandleErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_u8Z *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_CVec_u8ZPeerHandleErrorZPtr;

/**
 * A CResult_CVec_u8ZPeerHandleErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_u8Z on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_u8ZPeerHandleErrorZ {
   /**
    * The contents of this CResult_CVec_u8ZPeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_u8ZPeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_CVec_u8ZPeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_u8ZPeerHandleErrorZ;

/**
 * The contents of CResult_NonePeerHandleErrorZ
 */
typedef union LDKCResult_NonePeerHandleErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_NonePeerHandleErrorZPtr;

/**
 * A CResult_NonePeerHandleErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePeerHandleErrorZ {
   /**
    * The contents of this CResult_NonePeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_NonePeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePeerHandleErrorZ;

/**
 * The contents of CResult_boolPeerHandleErrorZ
 */
typedef union LDKCResult_boolPeerHandleErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   bool *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_boolPeerHandleErrorZPtr;

/**
 * A CResult_boolPeerHandleErrorZ represents the result of a fallible operation,
 * containing a bool on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_boolPeerHandleErrorZ {
   /**
    * The contents of this CResult_boolPeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_boolPeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_boolPeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_boolPeerHandleErrorZ;



/**
 * Represents the compressed public key of a node
 */
typedef struct MUST_USE_STRUCT LDKNodeId {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeId *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeId;

/**
 * The contents of CResult_NodeIdDecodeErrorZ
 */
typedef union LDKCResult_NodeIdDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeId *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeIdDecodeErrorZPtr;

/**
 * A CResult_NodeIdDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::NodeId on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeIdDecodeErrorZ {
   /**
    * The contents of this CResult_NodeIdDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeIdDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeIdDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeIdDecodeErrorZ;

/**
 * The contents of CResult_COption_NetworkUpdateZDecodeErrorZ
 */
typedef union LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_NetworkUpdateZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr;

/**
 * A CResult_COption_NetworkUpdateZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_NetworkUpdateZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_NetworkUpdateZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_NetworkUpdateZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_NetworkUpdateZDecodeErrorZ;

/**
 * The `Access` trait defines behavior for accessing chain data and state, such as blocks and
 * UTXOs.
 */
typedef struct LDKAccess {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the transaction output of a funding transaction encoded by [`short_channel_id`].
    * Returns an error if `genesis_hash` is for a different chain or if such a transaction output
    * is unknown.
    *
    * [`short_channel_id`]: https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#definition-of-short_channel_id
    */
   struct LDKCResult_TxOutAccessErrorZ (*get_utxo)(const void *this_arg, const uint8_t (*genesis_hash)[32], uint64_t short_channel_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKAccess;

/**
 * An enum which can either contain a crate::lightning::chain::Access or not
 */
typedef enum LDKCOption_AccessZ_Tag {
   /**
    * When we're in this state, this COption_AccessZ contains a crate::lightning::chain::Access
    */
   LDKCOption_AccessZ_Some,
   /**
    * When we're in this state, this COption_AccessZ contains nothing
    */
   LDKCOption_AccessZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_AccessZ_Sentinel,
} LDKCOption_AccessZ_Tag;

typedef struct LDKCOption_AccessZ {
   LDKCOption_AccessZ_Tag tag;
   union {
      struct {
         struct LDKAccess some;
      };
   };
} LDKCOption_AccessZ;



/**
 * Details about one direction of a channel as received within a [`ChannelUpdate`].
 */
typedef struct MUST_USE_STRUCT LDKChannelUpdateInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUpdateInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUpdateInfo;

/**
 * The contents of CResult_ChannelUpdateInfoDecodeErrorZ
 */
typedef union LDKCResult_ChannelUpdateInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelUpdateInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelUpdateInfoDecodeErrorZPtr;

/**
 * A CResult_ChannelUpdateInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::ChannelUpdateInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelUpdateInfoDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelUpdateInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelUpdateInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelUpdateInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelUpdateInfoDecodeErrorZ;



/**
 * Details about a channel (both directions).
 * Received within a channel announcement.
 */
typedef struct MUST_USE_STRUCT LDKChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelInfo;

/**
 * The contents of CResult_ChannelInfoDecodeErrorZ
 */
typedef union LDKCResult_ChannelInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelInfoDecodeErrorZPtr;

/**
 * A CResult_ChannelInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::ChannelInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelInfoDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelInfoDecodeErrorZ;



/**
 * Fees for routing via a given channel or a node
 */
typedef struct MUST_USE_STRUCT LDKRoutingFees {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoutingFees *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoutingFees;

/**
 * The contents of CResult_RoutingFeesDecodeErrorZ
 */
typedef union LDKCResult_RoutingFeesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoutingFees *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RoutingFeesDecodeErrorZPtr;

/**
 * A CResult_RoutingFeesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::RoutingFees on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RoutingFeesDecodeErrorZ {
   /**
    * The contents of this CResult_RoutingFeesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RoutingFeesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RoutingFeesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RoutingFeesDecodeErrorZ;



/**
 * Information received in the latest node_announcement from this node.
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncementInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncementInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncementInfo;

/**
 * The contents of CResult_NodeAnnouncementInfoDecodeErrorZ
 */
typedef union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAnnouncementInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr;

/**
 * A CResult_NodeAnnouncementInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::NodeAnnouncementInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAnnouncementInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAnnouncementInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZ;

/**
 * A dynamically-allocated array of u64s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u64Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   uint64_t *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u64Z;



/**
 * Details about a node in the network, known from the network announcement.
 */
typedef struct MUST_USE_STRUCT LDKNodeInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeInfo;

/**
 * The contents of CResult_NodeInfoDecodeErrorZ
 */
typedef union LDKCResult_NodeInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeInfoDecodeErrorZPtr;

/**
 * A CResult_NodeInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::NodeInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeInfoDecodeErrorZ {
   /**
    * The contents of this CResult_NodeInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeInfoDecodeErrorZ;

/**
 * The contents of CResult_NetworkGraphDecodeErrorZ
 */
typedef union LDKCResult_NetworkGraphDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNetworkGraph *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NetworkGraphDecodeErrorZPtr;

/**
 * A CResult_NetworkGraphDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::network_graph::NetworkGraph on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NetworkGraphDecodeErrorZ {
   /**
    * The contents of this CResult_NetworkGraphDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NetworkGraphDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NetworkGraphDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NetworkGraphDecodeErrorZ;

/**
 * An enum which can either contain a crate::c_types::derived::CVec_NetAddressZ or not
 */
typedef enum LDKCOption_CVec_NetAddressZZ_Tag {
   /**
    * When we're in this state, this COption_CVec_NetAddressZZ contains a crate::c_types::derived::CVec_NetAddressZ
    */
   LDKCOption_CVec_NetAddressZZ_Some,
   /**
    * When we're in this state, this COption_CVec_NetAddressZZ contains nothing
    */
   LDKCOption_CVec_NetAddressZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_CVec_NetAddressZZ_Sentinel,
} LDKCOption_CVec_NetAddressZZ_Tag;

typedef struct LDKCOption_CVec_NetAddressZZ {
   LDKCOption_CVec_NetAddressZZ_Tag tag;
   union {
      struct {
         struct LDKCVec_NetAddressZ some;
      };
   };
} LDKCOption_CVec_NetAddressZZ;

/**
 * The contents of CResult_NetAddressDecodeErrorZ
 */
typedef union LDKCResult_NetAddressDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNetAddress *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NetAddressDecodeErrorZPtr;

/**
 * A CResult_NetAddressDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::NetAddress on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NetAddressDecodeErrorZ {
   /**
    * The contents of this CResult_NetAddressDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NetAddressDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NetAddressDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NetAddressDecodeErrorZ;



/**
 * An update_add_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateAddHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateAddHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateAddHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateAddHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateAddHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateAddHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateAddHTLCZ;



/**
 * An update_fulfill_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFulfillHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFulfillHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFulfillHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFulfillHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFulfillHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFulfillHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFulfillHTLCZ;



/**
 * An update_fail_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFailHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFailHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFailHTLCZ;



/**
 * An update_fail_malformed_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailMalformedHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailMalformedHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailMalformedHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailMalformedHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFailMalformedHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFailMalformedHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFailMalformedHTLCZ;

/**
 * The contents of CResult_AcceptChannelDecodeErrorZ
 */
typedef union LDKCResult_AcceptChannelDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAcceptChannel *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AcceptChannelDecodeErrorZPtr;

/**
 * A CResult_AcceptChannelDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AcceptChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AcceptChannelDecodeErrorZ {
   /**
    * The contents of this CResult_AcceptChannelDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AcceptChannelDecodeErrorZPtr contents;
   /**
    * Whether this CResult_AcceptChannelDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AcceptChannelDecodeErrorZ;

/**
 * The contents of CResult_AnnouncementSignaturesDecodeErrorZ
 */
typedef union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAnnouncementSignatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AnnouncementSignaturesDecodeErrorZPtr;

/**
 * A CResult_AnnouncementSignaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AnnouncementSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AnnouncementSignaturesDecodeErrorZ {
   /**
    * The contents of this CResult_AnnouncementSignaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_AnnouncementSignaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AnnouncementSignaturesDecodeErrorZ;

/**
 * The contents of CResult_ChannelReestablishDecodeErrorZ
 */
typedef union LDKCResult_ChannelReestablishDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelReestablish *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelReestablishDecodeErrorZPtr;

/**
 * A CResult_ChannelReestablishDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelReestablish on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelReestablishDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelReestablishDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelReestablishDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelReestablishDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelReestablishDecodeErrorZ;

/**
 * The contents of CResult_ClosingSignedDecodeErrorZ
 */
typedef union LDKCResult_ClosingSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKClosingSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ClosingSignedDecodeErrorZPtr;

/**
 * A CResult_ClosingSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ClosingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ClosingSignedDecodeErrorZ {
   /**
    * The contents of this CResult_ClosingSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ClosingSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ClosingSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ClosingSignedDecodeErrorZ;



/**
 * The minimum and maximum fees which the sender is willing to place on the closing transaction.
 * This is provided in [`ClosingSigned`] by both sides to indicate the fee range they are willing
 * to use.
 */
typedef struct MUST_USE_STRUCT LDKClosingSignedFeeRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingSignedFeeRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingSignedFeeRange;

/**
 * The contents of CResult_ClosingSignedFeeRangeDecodeErrorZ
 */
typedef union LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKClosingSignedFeeRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr;

/**
 * A CResult_ClosingSignedFeeRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ClosingSignedFeeRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ {
   /**
    * The contents of this CResult_ClosingSignedFeeRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ClosingSignedFeeRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ClosingSignedFeeRangeDecodeErrorZ;



/**
 * A commitment_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKCommitmentSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentSigned;

/**
 * The contents of CResult_CommitmentSignedDecodeErrorZ
 */
typedef union LDKCResult_CommitmentSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCommitmentSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CommitmentSignedDecodeErrorZPtr;

/**
 * A CResult_CommitmentSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::CommitmentSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CommitmentSignedDecodeErrorZ {
   /**
    * The contents of this CResult_CommitmentSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CommitmentSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CommitmentSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CommitmentSignedDecodeErrorZ;

/**
 * The contents of CResult_FundingCreatedDecodeErrorZ
 */
typedef union LDKCResult_FundingCreatedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingCreated *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingCreatedDecodeErrorZPtr;

/**
 * A CResult_FundingCreatedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingCreated on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingCreatedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingCreatedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingCreatedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingCreatedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingCreatedDecodeErrorZ;

/**
 * The contents of CResult_FundingSignedDecodeErrorZ
 */
typedef union LDKCResult_FundingSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingSignedDecodeErrorZPtr;

/**
 * A CResult_FundingSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingSignedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingSignedDecodeErrorZ;

/**
 * The contents of CResult_FundingLockedDecodeErrorZ
 */
typedef union LDKCResult_FundingLockedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingLocked *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingLockedDecodeErrorZPtr;

/**
 * A CResult_FundingLockedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingLocked on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingLockedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingLockedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingLockedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingLockedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingLockedDecodeErrorZ;



/**
 * An init message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKInit {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInit *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInit;

/**
 * The contents of CResult_InitDecodeErrorZ
 */
typedef union LDKCResult_InitDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInit *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InitDecodeErrorZPtr;

/**
 * A CResult_InitDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Init on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InitDecodeErrorZ {
   /**
    * The contents of this CResult_InitDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InitDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InitDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InitDecodeErrorZ;

/**
 * The contents of CResult_OpenChannelDecodeErrorZ
 */
typedef union LDKCResult_OpenChannelDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOpenChannel *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OpenChannelDecodeErrorZPtr;

/**
 * A CResult_OpenChannelDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::OpenChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OpenChannelDecodeErrorZ {
   /**
    * The contents of this CResult_OpenChannelDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OpenChannelDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OpenChannelDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OpenChannelDecodeErrorZ;

/**
 * The contents of CResult_RevokeAndACKDecodeErrorZ
 */
typedef union LDKCResult_RevokeAndACKDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRevokeAndACK *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RevokeAndACKDecodeErrorZPtr;

/**
 * A CResult_RevokeAndACKDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::RevokeAndACK on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RevokeAndACKDecodeErrorZ {
   /**
    * The contents of this CResult_RevokeAndACKDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RevokeAndACKDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RevokeAndACKDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RevokeAndACKDecodeErrorZ;

/**
 * The contents of CResult_ShutdownDecodeErrorZ
 */
typedef union LDKCResult_ShutdownDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdown *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ShutdownDecodeErrorZPtr;

/**
 * A CResult_ShutdownDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Shutdown on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownDecodeErrorZ {
   /**
    * The contents of this CResult_ShutdownDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ShutdownDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownDecodeErrorZ;

/**
 * The contents of CResult_UpdateFailHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFailHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFailHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFailHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFailHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFailHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFailHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFailHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFailHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFailHTLCDecodeErrorZ;

/**
 * The contents of CResult_UpdateFailMalformedHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFailMalformedHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFailMalformedHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFailMalformedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFailMalformedHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFailMalformedHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ;



/**
 * An update_fee message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFee {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFee *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFee;

/**
 * The contents of CResult_UpdateFeeDecodeErrorZ
 */
typedef union LDKCResult_UpdateFeeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFee *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFeeDecodeErrorZPtr;

/**
 * A CResult_UpdateFeeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFee on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFeeDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFeeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFeeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFeeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFeeDecodeErrorZ;

/**
 * The contents of CResult_UpdateFulfillHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFulfillHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFulfillHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFulfillHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFulfillHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFulfillHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZ;

/**
 * The contents of CResult_UpdateAddHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateAddHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateAddHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateAddHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateAddHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateAddHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateAddHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateAddHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateAddHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateAddHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateAddHTLCDecodeErrorZ;



/**
 * A ping message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKPing {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePing *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPing;

/**
 * The contents of CResult_PingDecodeErrorZ
 */
typedef union LDKCResult_PingDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPing *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PingDecodeErrorZPtr;

/**
 * A CResult_PingDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Ping on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PingDecodeErrorZ {
   /**
    * The contents of this CResult_PingDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PingDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PingDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PingDecodeErrorZ;



/**
 * A pong message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKPong {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePong *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPong;

/**
 * The contents of CResult_PongDecodeErrorZ
 */
typedef union LDKCResult_PongDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPong *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PongDecodeErrorZPtr;

/**
 * A CResult_PongDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Pong on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PongDecodeErrorZ {
   /**
    * The contents of this CResult_PongDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PongDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PongDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PongDecodeErrorZ;

/**
 * The contents of CResult_UnsignedChannelAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedChannelAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr;

/**
 * A CResult_UnsignedChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedChannelAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedChannelAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_ChannelAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_ChannelAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelAnnouncementDecodeErrorZPtr;

/**
 * A CResult_ChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelAnnouncementDecodeErrorZ;



/**
 * The unsigned part of a channel_update
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelUpdate;

/**
 * The contents of CResult_UnsignedChannelUpdateDecodeErrorZ
 */
typedef union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedChannelUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr;

/**
 * A CResult_UnsignedChannelUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedChannelUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedChannelUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZ;

/**
 * The contents of CResult_ChannelUpdateDecodeErrorZ
 */
typedef union LDKCResult_ChannelUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelUpdateDecodeErrorZPtr;

/**
 * A CResult_ChannelUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelUpdateDecodeErrorZ;

/**
 * The contents of CResult_ErrorMessageDecodeErrorZ
 */
typedef union LDKCResult_ErrorMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKErrorMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ErrorMessageDecodeErrorZPtr;

/**
 * A CResult_ErrorMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ErrorMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ErrorMessageDecodeErrorZ {
   /**
    * The contents of this CResult_ErrorMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ErrorMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ErrorMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ErrorMessageDecodeErrorZ;

/**
 * The contents of CResult_WarningMessageDecodeErrorZ
 */
typedef union LDKCResult_WarningMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKWarningMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_WarningMessageDecodeErrorZPtr;

/**
 * A CResult_WarningMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::WarningMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_WarningMessageDecodeErrorZ {
   /**
    * The contents of this CResult_WarningMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_WarningMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_WarningMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_WarningMessageDecodeErrorZ;



/**
 * The unsigned part of a node_announcement
 */
typedef struct MUST_USE_STRUCT LDKUnsignedNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedNodeAnnouncement;

/**
 * The contents of CResult_UnsignedNodeAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedNodeAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr;

/**
 * A CResult_UnsignedNodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedNodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedNodeAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedNodeAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_NodeAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_NodeAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementDecodeErrorZPtr;

/**
 * A CResult_NodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::NodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_QueryShortChannelIdsDecodeErrorZ
 */
typedef union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKQueryShortChannelIds *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_QueryShortChannelIdsDecodeErrorZPtr;

/**
 * A CResult_QueryShortChannelIdsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::QueryShortChannelIds on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_QueryShortChannelIdsDecodeErrorZ {
   /**
    * The contents of this CResult_QueryShortChannelIdsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_QueryShortChannelIdsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_QueryShortChannelIdsDecodeErrorZ;



/**
 * A reply_short_channel_ids_end message is sent as a reply to a
 * query_short_channel_ids message. The query recipient makes a best
 * effort to respond based on their local network view which may not be
 * a perfect view of the network.
 */
typedef struct MUST_USE_STRUCT LDKReplyShortChannelIdsEnd {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyShortChannelIdsEnd *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyShortChannelIdsEnd;

/**
 * The contents of CResult_ReplyShortChannelIdsEndDecodeErrorZ
 */
typedef union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReplyShortChannelIdsEnd *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr;

/**
 * A CResult_ReplyShortChannelIdsEndDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ReplyShortChannelIdsEnd on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ {
   /**
    * The contents of this CResult_ReplyShortChannelIdsEndDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReplyShortChannelIdsEndDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ;

/**
 * The contents of CResult_QueryChannelRangeDecodeErrorZ
 */
typedef union LDKCResult_QueryChannelRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKQueryChannelRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_QueryChannelRangeDecodeErrorZPtr;

/**
 * A CResult_QueryChannelRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::QueryChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_QueryChannelRangeDecodeErrorZ {
   /**
    * The contents of this CResult_QueryChannelRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_QueryChannelRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_QueryChannelRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_QueryChannelRangeDecodeErrorZ;

/**
 * The contents of CResult_ReplyChannelRangeDecodeErrorZ
 */
typedef union LDKCResult_ReplyChannelRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReplyChannelRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReplyChannelRangeDecodeErrorZPtr;

/**
 * A CResult_ReplyChannelRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ReplyChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReplyChannelRangeDecodeErrorZ {
   /**
    * The contents of this CResult_ReplyChannelRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReplyChannelRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReplyChannelRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReplyChannelRangeDecodeErrorZ;

/**
 * The contents of CResult_GossipTimestampFilterDecodeErrorZ
 */
typedef union LDKCResult_GossipTimestampFilterDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKGossipTimestampFilter *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_GossipTimestampFilterDecodeErrorZPtr;

/**
 * A CResult_GossipTimestampFilterDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::GossipTimestampFilter on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_GossipTimestampFilterDecodeErrorZ {
   /**
    * The contents of this CResult_GossipTimestampFilterDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_GossipTimestampFilterDecodeErrorZPtr contents;
   /**
    * Whether this CResult_GossipTimestampFilterDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_GossipTimestampFilterDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::ln::channelmanager::PhantomRouteHintss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PhantomRouteHintsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPhantomRouteHints *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PhantomRouteHintsZ;

/**
 * When signing using a fallible method either an user-supplied `SignError` or a `CreationError`
 * may occur.
 */
typedef enum LDKSignOrCreationError_Tag {
   /**
    * An error occurred during signing
    */
   LDKSignOrCreationError_SignError,
   /**
    * An error occurred while building the transaction
    */
   LDKSignOrCreationError_CreationError,
   /**
    * Must be last for serialization purposes
    */
   LDKSignOrCreationError_Sentinel,
} LDKSignOrCreationError_Tag;

typedef struct MUST_USE_STRUCT LDKSignOrCreationError {
   LDKSignOrCreationError_Tag tag;
   union {
      struct {
         enum LDKCreationError creation_error;
      };
   };
} LDKSignOrCreationError;

/**
 * The contents of CResult_InvoiceSignOrCreationErrorZ
 */
typedef union LDKCResult_InvoiceSignOrCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKSignOrCreationError *err;
} LDKCResult_InvoiceSignOrCreationErrorZPtr;

/**
 * A CResult_InvoiceSignOrCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Invoice on success and a crate::lightning_invoice::SignOrCreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceSignOrCreationErrorZ {
   /**
    * The contents of this CResult_InvoiceSignOrCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceSignOrCreationErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceSignOrCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceSignOrCreationErrorZ;



/**
 * A transaction output watched by a [`ChannelMonitor`] for spends on-chain.
 *
 * Used to convey to a [`Filter`] such an output with a given spending condition. Any transaction
 * spending the output must be given to [`ChannelMonitor::block_connected`] either directly or via
 * the return value of [`Filter::register_output`].
 *
 * If `block_hash` is `Some`, this indicates the output was created in the corresponding block and
 * may have been spent there. See [`Filter::register_output`] for details.
 *
 * [`ChannelMonitor`]: channelmonitor::ChannelMonitor
 * [`ChannelMonitor::block_connected`]: channelmonitor::ChannelMonitor::block_connected
 */
typedef struct MUST_USE_STRUCT LDKWatchedOutput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeWatchedOutput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKWatchedOutput;

/**
 * The `Filter` trait defines behavior for indicating chain activity of interest pertaining to
 * channels.
 *
 * This is useful in order to have a [`Watch`] implementation convey to a chain source which
 * transactions to be notified of. Notification may take the form of pre-filtering blocks or, in
 * the case of [BIP 157]/[BIP 158], only fetching a block if the compact filter matches. If
 * receiving full blocks from a chain source, any further filtering is unnecessary.
 *
 * After an output has been registered, subsequent block retrievals from the chain source must not
 * exclude any transactions matching the new criteria nor any in-block descendants of such
 * transactions.
 *
 * Note that use as part of a [`Watch`] implementation involves reentrancy. Therefore, the `Filter`
 * should not block on I/O. Implementations should instead queue the newly monitored data to be
 * processed later. Then, in order to block until the data has been processed, any [`Watch`]
 * invocation that has called the `Filter` must return [`TemporaryFailure`].
 *
 * [`TemporaryFailure`]: ChannelMonitorUpdateErr::TemporaryFailure
 * [BIP 157]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
 * [BIP 158]: https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
 */
typedef struct LDKFilter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Registers interest in a transaction with `txid` and having an output with `script_pubkey` as
    * a spending condition.
    */
   void (*register_tx)(const void *this_arg, const uint8_t (*txid)[32], struct LDKu8slice script_pubkey);
   /**
    * Registers interest in spends of a transaction output.
    *
    * Optionally, when `output.block_hash` is set, should return any transaction spending the
    * output that is found in the corresponding block along with its index.
    *
    * This return value is useful for Electrum clients in order to supply in-block descendant
    * transactions which otherwise were not included. This is not necessary for other clients if
    * such descendant transactions were already included (e.g., when a BIP 157 client provides the
    * full block).
    */
   struct LDKCOption_C2Tuple_usizeTransactionZZ (*register_output)(const void *this_arg, struct LDKWatchedOutput output);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFilter;

/**
 * An enum which can either contain a crate::lightning::chain::Filter or not
 */
typedef enum LDKCOption_FilterZ_Tag {
   /**
    * When we're in this state, this COption_FilterZ contains a crate::lightning::chain::Filter
    */
   LDKCOption_FilterZ_Some,
   /**
    * When we're in this state, this COption_FilterZ contains nothing
    */
   LDKCOption_FilterZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_FilterZ_Sentinel,
} LDKCOption_FilterZ_Tag;

typedef struct LDKCOption_FilterZ {
   LDKCOption_FilterZ_Tag tag;
   union {
      struct {
         struct LDKFilter some;
      };
   };
} LDKCOption_FilterZ;



/**
 * A read-only reference to a current ChannelMonitor.
 *
 * Note that this holds a mutex in [`ChainMonitor`] and may block other events until it is
 * released.
 */
typedef struct MUST_USE_STRUCT LDKLockedChannelMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLockedChannelMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLockedChannelMonitor;

/**
 * The contents of CResult_LockedChannelMonitorNoneZ
 */
typedef union LDKCResult_LockedChannelMonitorNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKLockedChannelMonitor *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_LockedChannelMonitorNoneZPtr;

/**
 * A CResult_LockedChannelMonitorNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::chainmonitor::LockedChannelMonitor on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_LockedChannelMonitorNoneZ {
   /**
    * The contents of this CResult_LockedChannelMonitorNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_LockedChannelMonitorNoneZPtr contents;
   /**
    * Whether this CResult_LockedChannelMonitorNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_LockedChannelMonitorNoneZ;

/**
 * A dynamically-allocated array of crate::lightning::chain::transaction::OutPoints of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_OutPointZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKOutPoint *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_OutPointZ;

/**
 * A trait indicating an object may generate message send events
 */
typedef struct LDKMessageSendEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the list of pending events which were generated by previous actions, clearing the list
    * in the process.
    */
   struct LDKCVec_MessageSendEventZ (*get_and_clear_pending_msg_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKMessageSendEventsProvider;

/**
 * A trait implemented for objects handling events from [`EventsProvider`].
 */
typedef struct LDKEventHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handles the given [`Event`].
    *
    * See [`EventsProvider`] for details that must be considered when implementing this method.
    */
   void (*handle_event)(const void *this_arg, const struct LDKEvent *NONNULL_PTR event);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventHandler;

/**
 * A trait indicating an object may generate events.
 *
 * Events are processed by passing an [`EventHandler`] to [`process_pending_events`].
 *
 * # Requirements
 *
 * See [`process_pending_events`] for requirements around event processing.
 *
 * When using this trait, [`process_pending_events`] will call [`handle_event`] for each pending
 * event since the last invocation. The handler must either act upon the event immediately
 * or preserve it for later handling.
 *
 * Note, handlers may call back into the provider and thus deadlocking must be avoided. Be sure to
 * consult the provider's documentation on the implication of processing events and how a handler
 * may safely use the provider (e.g., see [`ChannelManager::process_pending_events`] and
 * [`ChainMonitor::process_pending_events`]).
 *
 * (C-not implementable) As there is likely no reason for a user to implement this trait on their
 * own type(s).
 *
 * [`process_pending_events`]: Self::process_pending_events
 * [`handle_event`]: EventHandler::handle_event
 * [`ChannelManager::process_pending_events`]: crate::ln::channelmanager::ChannelManager#method.process_pending_events
 * [`ChainMonitor::process_pending_events`]: crate::chain::chainmonitor::ChainMonitor#method.process_pending_events
 */
typedef struct LDKEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Processes any events generated since the last call using the given event handler.
    *
    * Subsequent calls must only process new events. However, handlers must be capable of handling
    * duplicate events across process restarts. This may occur if the provider was recovered from
    * an old state (i.e., it hadn't been successfully persisted after processing pending events).
    */
   void (*process_pending_events)(const void *this_arg, struct LDKEventHandler handler);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventsProvider;



/**
 * Configuration we set when applicable.
 *
 * Default::default() provides sane defaults.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeConfig;



/**
 * Optional channel limits which are applied during channel creation.
 *
 * These limits are only applied to our counterparty's limits, not our own.
 *
 * Use 0/<type>::max_value() as appropriate to skip checking.
 *
 * Provides sane defaults for most configurations.
 *
 * Most additional limits are disabled except those with which specify a default in individual
 * field documentation. Note that this may result in barely-usable channels, but since they
 * are applied mostly only to incoming channels that's not much of a problem.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeLimits {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeLimits *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeLimits;



/**
 * Top-level config which holds ChannelHandshakeLimits and ChannelConfig.
 *
 * Default::default() provides sane defaults for most configurations
 * (but currently with 0 relay fees!)
 */
typedef struct MUST_USE_STRUCT LDKUserConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUserConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUserConfig;



/**
 * The best known block as identified by its hash and height.
 */
typedef struct MUST_USE_STRUCT LDKBestBlock {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBestBlock *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBestBlock;

/**
 * The `Listen` trait is used to notify when blocks have been connected or disconnected from the
 * chain.
 *
 * Useful when needing to replay chain data upon startup or as new chain events occur. Clients
 * sourcing chain data using a block-oriented API should prefer this interface over [`Confirm`].
 * Such clients fetch the entire header chain whereas clients using [`Confirm`] only fetch headers
 * when needed.
 */
typedef struct LDKListen {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Notifies the listener that a block was added at the given height.
    */
   void (*block_connected)(const void *this_arg, struct LDKu8slice block, uint32_t height);
   /**
    * Notifies the listener that a block was removed at the given height.
    */
   void (*block_disconnected)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKListen;

/**
 * The `Confirm` trait is used to notify when transactions have been confirmed on chain or
 * unconfirmed during a chain reorganization.
 *
 * Clients sourcing chain data using a transaction-oriented API should prefer this interface over
 * [`Listen`]. For instance, an Electrum client may implement [`Filter`] by subscribing to activity
 * related to registered transactions and outputs. Upon notification, it would pass along the
 * matching transactions using this interface.
 *
 * # Use
 *
 * The intended use is as follows:
 * - Call [`transactions_confirmed`] to process any on-chain activity of interest.
 * - Call [`transaction_unconfirmed`] to process any transaction returned by [`get_relevant_txids`]
 *   that has been reorganized out of the chain.
 * - Call [`best_block_updated`] whenever a new chain tip becomes available.
 *
 * # Order
 *
 * Clients must call these methods in chain order. Specifically:
 * - Transactions confirmed in a block must be given before transactions confirmed in a later
 *   block.
 * - Dependent transactions within the same block must be given in topological order, possibly in
 *   separate calls.
 * - Unconfirmed transactions must be given after the original confirmations and before any
 *   reconfirmation.
 *
 * See individual method documentation for further details.
 *
 * [`transactions_confirmed`]: Self::transactions_confirmed
 * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
 * [`best_block_updated`]: Self::best_block_updated
 * [`get_relevant_txids`]: Self::get_relevant_txids
 */
typedef struct LDKConfirm {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Processes transactions confirmed in a block with a given header and height.
    *
    * Should be called for any transactions registered by [`Filter::register_tx`] or any
    * transactions spending an output registered by [`Filter::register_output`]. Such transactions
    * appearing in the same block do not need to be included in the same call; instead, multiple
    * calls with additional transactions may be made so long as they are made in [chain order].
    *
    * May be called before or after [`best_block_updated`] for the corresponding block. However,
    * in the event of a chain reorganization, it must not be called with a `header` that is no
    * longer in the chain as of the last call to [`best_block_updated`].
    *
    * [chain order]: Confirm#Order
    * [`best_block_updated`]: Self::best_block_updated
    */
   void (*transactions_confirmed)(const void *this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height);
   /**
    * Processes a transaction that is no longer confirmed as result of a chain reorganization.
    *
    * Should be called for any transaction returned by [`get_relevant_txids`] if it has been
    * reorganized out of the best chain. Once called, the given transaction should not be returned
    * by [`get_relevant_txids`] unless it has been reconfirmed via [`transactions_confirmed`].
    *
    * [`get_relevant_txids`]: Self::get_relevant_txids
    * [`transactions_confirmed`]: Self::transactions_confirmed
    */
   void (*transaction_unconfirmed)(const void *this_arg, const uint8_t (*txid)[32]);
   /**
    * Processes an update to the best header connected at the given height.
    *
    * Should be called when a new header is available but may be skipped for intermediary blocks
    * if they become available at the same time.
    */
   void (*best_block_updated)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Returns transactions that should be monitored for reorganization out of the chain.
    *
    * Should include any transactions passed to [`transactions_confirmed`] that have insufficient
    * confirmations to be safe from a chain reorganization. Should not include any transactions
    * passed to [`transaction_unconfirmed`] unless later reconfirmed.
    *
    * May be called to determine the subset of transactions that must still be monitored for
    * reorganization. Will be idempotent between calls but may change as a result of calls to the
    * other interface methods. Thus, this is useful to determine which transactions may need to be
    * given to [`transaction_unconfirmed`].
    *
    * [`transactions_confirmed`]: Self::transactions_confirmed
    * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
    */
   struct LDKCVec_TxidZ (*get_relevant_txids)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKConfirm;



/**
 * An opaque identifier describing a specific [`Persist`] method call.
 */
typedef struct MUST_USE_STRUCT LDKMonitorUpdateId {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMonitorUpdateId *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMonitorUpdateId;

/**
 * `Persist` defines behavior for persisting channel monitors: this could mean
 * writing once to disk, and/or uploading to one or more backup services.
 *
 * Each method can return three possible values:
 *  * If persistence (including any relevant `fsync()` calls) happens immediately, the
 *    implementation should return `Ok(())`, indicating normal channel operation should continue.
 *  * If persistence happens asynchronously, implementations should first ensure the
 *    [`ChannelMonitor`] or [`ChannelMonitorUpdate`] are written durably to disk, and then return
 *    `Err(ChannelMonitorUpdateErr::TemporaryFailure)` while the update continues in the
 *    background. Once the update completes, [`ChainMonitor::channel_monitor_updated`] should be
 *    called with the corresponding [`MonitorUpdateId`].
 *
 *    Note that unlike the direct [`chain::Watch`] interface,
 *    [`ChainMonitor::channel_monitor_updated`] must be called once for *each* update which occurs.
 *
 *  * If persistence fails for some reason, implementations should return
 *    `Err(ChannelMonitorUpdateErr::PermanentFailure)`, in which case the channel will likely be
 *    closed without broadcasting the latest state. See
 *    [`ChannelMonitorUpdateErr::PermanentFailure`] for more details.
 */
typedef struct LDKPersist {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist a new channel's data in response to a [`chain::Watch::watch_channel`] call. This is
    * called by [`ChannelManager`] for new channels, or may be called directly, e.g. on startup.
    *
    * The data can be stored any way you want, but the identifier provided by LDK is the
    * channel's outpoint (and it is up to you to maintain a correct mapping between the outpoint
    * and the stored channel data). Note that you **must** persist every new monitor to disk.
    *
    * The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
    * if you return [`ChannelMonitorUpdateErr::TemporaryFailure`].
    *
    * See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`
    * and [`ChannelMonitorUpdateErr`] for requirements when returning errors.
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`Writeable::write`]: crate::util::ser::Writeable::write
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*persist_new_channel)(const void *this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id);
   /**
    * Update one channel's data. The provided [`ChannelMonitor`] has already applied the given
    * update.
    *
    * Note that on every update, you **must** persist either the [`ChannelMonitorUpdate`] or the
    * updated monitor itself to disk/backups. See the [`Persist`] trait documentation for more
    * details.
    *
    * During blockchain synchronization operations, this may be called with no
    * [`ChannelMonitorUpdate`], in which case the full [`ChannelMonitor`] needs to be persisted.
    * Note that after the full [`ChannelMonitor`] is persisted any previous
    * [`ChannelMonitorUpdate`]s which were persisted should be discarded - they can no longer be
    * applied to the persisted [`ChannelMonitor`] as they were already applied.
    *
    * If an implementer chooses to persist the updates only, they need to make
    * sure that all the updates are applied to the `ChannelMonitors` *before*
    * the set of channel monitors is given to the `ChannelManager`
    * deserialization routine. See [`ChannelMonitor::update_monitor`] for
    * applying a monitor update to a monitor. If full `ChannelMonitors` are
    * persisted, then there is no need to persist individual updates.
    *
    * Note that there could be a performance tradeoff between persisting complete
    * channel monitors on every update vs. persisting only updates and applying
    * them in batches. The size of each monitor grows `O(number of state updates)`
    * whereas updates are small and `O(1)`.
    *
    * The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
    * if you return [`ChannelMonitorUpdateErr::TemporaryFailure`].
    *
    * See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`,
    * [`Writeable::write`] on [`ChannelMonitorUpdate`] for writing out an update, and
    * [`ChannelMonitorUpdateErr`] for requirements when returning errors.
    *
    * [`Writeable::write`]: crate::util::ser::Writeable::write
    *
    * Note that update (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*update_persisted_channel)(const void *this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitorUpdate *NONNULL_PTR update, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPersist;



/**
 * An implementation of [`chain::Watch`] for monitoring channels.
 *
 * Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
 * [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
 * or used independently to monitor channels remotely. See the [module-level documentation] for
 * details.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [module-level documentation]: crate::chain::chainmonitor
 */
typedef struct MUST_USE_STRUCT LDKChainMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainMonitor;



/**
 * Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key
 * and derives keys from that.
 *
 * Your node_id is seed/0'
 * ChannelMonitor closes may use seed/1'
 * Cooperative closes may use seed/2'
 * The two close keys may be needed to claim on-chain funds!
 *
 * This struct cannot be used for nodes that wish to support receiving phantom payments;
 * [`PhantomKeysManager`] must be used instead.
 *
 * Note that switching between this struct and [`PhantomKeysManager`] will invalidate any
 * previously issued invoices and attempts to pay previous invoices will fail.
 */
typedef struct MUST_USE_STRUCT LDKKeysManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeKeysManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKKeysManager;



/**
 * Similar to [`KeysManager`], but allows the node using this struct to receive phantom node
 * payments.
 *
 * A phantom node payment is a payment made to a phantom invoice, which is an invoice that can be
 * paid to one of multiple nodes. This works because we encode the invoice route hints such that
 * LDK will recognize an incoming payment as destined for a phantom node, and collect the payment
 * itself without ever needing to forward to this fake node.
 *
 * Phantom node payments are useful for load balancing between multiple LDK nodes. They also
 * provide some fault tolerance, because payers will automatically retry paying other provided
 * nodes in the case that one node goes down.
 *
 * Note that multi-path payments are not supported in phantom invoices for security reasons.
 * Switching between this struct and [`KeysManager`] will invalidate any previously issued
 * invoices and attempts to pay previous invoices will fail.
 */
typedef struct MUST_USE_STRUCT LDKPhantomKeysManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePhantomKeysManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPhantomKeysManager;



/**
 * Chain-related parameters used to construct a new `ChannelManager`.
 *
 * Typically, the block-specific parameters are derived from the best block hash for the network,
 * as a newly constructed `ChannelManager` will not have created any channels yet. These parameters
 * are not needed when deserializing a previously constructed `ChannelManager`.
 */
typedef struct MUST_USE_STRUCT LDKChainParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainParameters;

/**
 * A 3-byte byte array.
 */
typedef struct LDKThreeBytes {
   /**
    * The three bytes
    */
   uint8_t data[3];
} LDKThreeBytes;

/**
 * A trait to describe an object which can receive channel messages.
 *
 * Messages MAY be called in parallel when they originate from different their_node_ids, however
 * they MUST NOT be called in parallel when the two calls have the same their_node_id.
 */
typedef struct LDKChannelMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming open_channel message from the given peer.
    */
   void (*handle_open_channel)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKOpenChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming accept_channel message from the given peer.
    */
   void (*handle_accept_channel)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKAcceptChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_created message from the given peer.
    */
   void (*handle_funding_created)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingCreated *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_signed message from the given peer.
    */
   void (*handle_funding_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_locked message from the given peer.
    */
   void (*handle_funding_locked)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingLocked *NONNULL_PTR msg);
   /**
    * Handle an incoming shutdown message from the given peer.
    */
   void (*handle_shutdown)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInitFeatures *NONNULL_PTR their_features, const struct LDKShutdown *NONNULL_PTR msg);
   /**
    * Handle an incoming closing_signed message from the given peer.
    */
   void (*handle_closing_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKClosingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming update_add_htlc message from the given peer.
    */
   void (*handle_update_add_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateAddHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fulfill_htlc message from the given peer.
    */
   void (*handle_update_fulfill_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFulfillHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fail_htlc message from the given peer.
    */
   void (*handle_update_fail_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fail_malformed_htlc message from the given peer.
    */
   void (*handle_update_fail_malformed_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming commitment_signed message from the given peer.
    */
   void (*handle_commitment_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKCommitmentSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming revoke_and_ack message from the given peer.
    */
   void (*handle_revoke_and_ack)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKRevokeAndACK *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fee message from the given peer.
    */
   void (*handle_update_fee)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFee *NONNULL_PTR msg);
   /**
    * Handle an incoming announcement_signatures message from the given peer.
    */
   void (*handle_announcement_signatures)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKAnnouncementSignatures *NONNULL_PTR msg);
   /**
    * Indicates a connection to the peer failed/an existing connection was lost. If no connection
    * is believed to be possible in the future (eg they're sending us messages we don't
    * understand or indicate they require unknown feature bits), no_connection_possible is set
    * and any outstanding channels should be failed.
    */
   void (*peer_disconnected)(const void *this_arg, struct LDKPublicKey their_node_id, bool no_connection_possible);
   /**
    * Handle a peer reconnecting, possibly generating channel_reestablish message(s).
    */
   void (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_reestablish message from the given peer.
    */
   void (*handle_channel_reestablish)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReestablish *NONNULL_PTR msg);
   /**
    * Handle an incoming channel update from the given peer.
    */
   void (*handle_channel_update)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Handle an incoming error message from the given peer.
    */
   void (*handle_error)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKErrorMessage *NONNULL_PTR msg);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKChannelMessageHandler;



/**
 * Arguments for the creation of a ChannelManager that are not deserialized.
 *
 * At a high-level, the process for deserializing a ChannelManager and resuming normal operation
 * is:
 * 1) Deserialize all stored [`ChannelMonitor`]s.
 * 2) Deserialize the [`ChannelManager`] by filling in this struct and calling:
 *    `<(BlockHash, ChannelManager)>::read(reader, args)`
 *    This may result in closing some channels if the [`ChannelMonitor`] is newer than the stored
 *    [`ChannelManager`] state to ensure no loss of funds. Thus, transactions may be broadcasted.
 * 3) If you are not fetching full blocks, register all relevant [`ChannelMonitor`] outpoints the
 *    same way you would handle a [`chain::Filter`] call using
 *    [`ChannelMonitor::get_outputs_to_watch`] and [`ChannelMonitor::get_funding_txo`].
 * 4) Reconnect blocks on your [`ChannelMonitor`]s.
 * 5) Disconnect/connect blocks on the [`ChannelManager`].
 * 6) Re-persist the [`ChannelMonitor`]s to ensure the latest state is on disk.
 *    Note that if you're using a [`ChainMonitor`] for your [`chain::Watch`] implementation, you
 *    will likely accomplish this as a side-effect of calling [`chain::Watch::watch_channel`] in
 *    the next step.
 * 7) Move the [`ChannelMonitor`]s into your local [`chain::Watch`]. If you're using a
 *    [`ChainMonitor`], this is done by calling [`chain::Watch::watch_channel`].
 *
 * Note that the ordering of #4-7 is not of importance, however all four must occur before you
 * call any other methods on the newly-deserialized [`ChannelManager`].
 *
 * Note that because some channels may be closed during deserialization, it is critical that you
 * always deserialize only the latest version of a ChannelManager and ChannelMonitors available to
 * you. If you deserialize an old ChannelManager (during which force-closure transactions may be
 * broadcast), and then later deserialize a newer version of the same ChannelManager (which will
 * not force-close the same channels but consider them live), you may end up revoking a state for
 * which you've already broadcasted the transaction.
 *
 * [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
 */
typedef struct MUST_USE_STRUCT LDKChannelManagerReadArgs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManagerReadArgs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManagerReadArgs;



/**
 * Proof that the sender knows the per-commitment secret of the previous commitment transaction.
 * This is used to convince the recipient that the channel is at a certain commitment
 * number even if they lost that data due to a local failure.  Of course, the peer may lie
 * and even later commitments may have been revoked.
 */
typedef struct MUST_USE_STRUCT LDKDataLossProtect {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDataLossProtect *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDataLossProtect;

/**
 * A trait to describe an object which can receive routing messages.
 *
 * # Implementor DoS Warnings
 *
 * For `gossip_queries` messages there are potential DoS vectors when handling
 * inbound queries. Implementors using an on-disk network graph should be aware of
 * repeated disk I/O for queries accessing different parts of the network graph.
 */
typedef struct LDKRoutingMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming node_announcement message, returning true if it should be forwarded on,
    * false or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_node_announcement)(const void *this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);
   /**
    * Handle a channel_announcement message, returning true if it should be forwarded on, false
    * or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_announcement)(const void *this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_update message, returning true if it should be forwarded on,
    * false or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_update)(const void *this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Gets a subset of the channel announcements and updates required to dump our routing table
    * to a remote node, starting at the short_channel_id indicated by starting_point and
    * including the batch_amount entries immediately higher in numerical value than starting_point.
    */
   struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ (*get_next_channel_announcements)(const void *this_arg, uint64_t starting_point, uint8_t batch_amount);
   /**
    * Gets a subset of the node announcements required to dump our routing table to a remote node,
    * starting at the node *after* the provided publickey and including batch_amount entries
    * immediately higher (as defined by <PublicKey as Ord>::cmp) than starting_point.
    * If None is provided for starting_point, we start at the first node.
    *
    * Note that starting_point (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCVec_NodeAnnouncementZ (*get_next_node_announcements)(const void *this_arg, struct LDKPublicKey starting_point, uint8_t batch_amount);
   /**
    * Called when a connection is established with a peer. This can be used to
    * perform routing table synchronization using a strategy defined by the
    * implementor.
    */
   void (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init);
   /**
    * Handles the reply of a query we initiated to learn about channels
    * for a given range of blocks. We can expect to receive one or more
    * replies to a single query.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyChannelRange msg);
   /**
    * Handles the reply of a query we initiated asking for routing gossip
    * messages for a list of channels. We should receive this message when
    * a node has completed its best effort to send us the pertaining routing
    * gossip messages.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_short_channel_ids_end)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyShortChannelIdsEnd msg);
   /**
    * Handles when a peer asks us to send a list of short_channel_ids
    * for the requested range of blocks.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryChannelRange msg);
   /**
    * Handles when a peer asks us to send routing gossip messages for a
    * list of short_channel_ids.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_short_channel_ids)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryShortChannelIds msg);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKRoutingMessageHandler;

/**
 * Trait to be implemented by custom message (unrelated to the channel/gossip LN layers)
 * decoders.
 */
typedef struct LDKCustomMessageReader {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Decodes a custom message to `CustomMessageType`. If the given message type is known to the
    * implementation and the message could be decoded, must return `Ok(Some(message))`. If the
    * message type is unknown to the implementation, must return `Ok(None)`. If a decoding error
    * occur, must return `Err(DecodeError::X)` where `X` details the encountered error.
    */
   struct LDKCResult_COption_TypeZDecodeErrorZ (*read)(const void *this_arg, uint16_t message_type, struct LDKu8slice buffer);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomMessageReader;

/**
 * Handler for BOLT1-compliant messages.
 */
typedef struct LDKCustomMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Called with the message type that was received and the buffer to be read.
    * Can return a `MessageHandlingError` if the message could not be handled.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_custom_message)(const void *this_arg, struct LDKType msg, struct LDKPublicKey sender_node_id);
   /**
    * Gets the list of pending messages which were generated by the custom message
    * handler, clearing the list in the process. The first tuple element must
    * correspond to the intended recipients node ids. If no connection to one of the
    * specified node does not exist, the message is simply not sent to it.
    */
   struct LDKCVec_C2Tuple_PublicKeyTypeZZ (*get_and_clear_pending_msg)(const void *this_arg);
   /**
    * Implementation of CustomMessageReader for this object.
    */
   struct LDKCustomMessageReader CustomMessageReader;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomMessageHandler;



/**
 * A dummy struct which implements `RoutingMessageHandler` without storing any routing information
 * or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKIgnoringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeIgnoringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKIgnoringMessageHandler;



/**
 * A dummy struct which implements `ChannelMessageHandler` without having any channels.
 * You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKErroringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErroringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErroringMessageHandler;



/**
 * Provides references to trait impls which handle different types of messages.
 */
typedef struct MUST_USE_STRUCT LDKMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMessageHandler;

/**
 * Provides an object which can be used to send data to and which uniquely identifies a connection
 * to a remote host. You will need to be able to generate multiple of these which meet Eq and
 * implement Hash to meet the PeerManager API.
 *
 * For efficiency, Clone should be relatively cheap for this type.
 *
 * Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
 * has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
 * having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
 * further calls to the [`PeerManager`] related to the original socket occur. This allows you to
 * use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
 * to simply use another value which is guaranteed to be globally unique instead.
 */
typedef struct LDKSocketDescriptor {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Attempts to send some data from the given slice to the peer.
    *
    * Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
    * Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
    * called and further write attempts may occur until that time.
    *
    * If the returned size is smaller than `data.len()`, a
    * [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
    * written. Additionally, until a `send_data` event completes fully, no further
    * [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
    * prevent denial-of-service issues, you should not read or buffer any data from the socket
    * until then.
    *
    * If a [`PeerManager::read_event`] call on this descriptor had previously returned true
    * (indicating that read events should be paused to prevent DoS in the send buffer),
    * `resume_read` may be set indicating that read events on this descriptor should resume. A
    * `resume_read` of false carries no meaning, and should not cause any action.
    */
   uintptr_t (*send_data)(void *this_arg, struct LDKu8slice data, bool resume_read);
   /**
    * Disconnect the socket pointed to by this SocketDescriptor.
    *
    * You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
    * call (doing so is a noop).
    */
   void (*disconnect_socket)(void *this_arg);
   /**
    * Checks if two objects are equal given this object's this_arg pointer and another object.
    */
   bool (*eq)(const void *this_arg, const struct LDKSocketDescriptor *NONNULL_PTR other_arg);
   /**
    * Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
    * This is used, for example, for inclusion of this object in a hash map.
    */
   uint64_t (*hash)(const void *this_arg);
   /**
    * Called, if set, after this SocketDescriptor has been cloned into a duplicate object.
    * The new SocketDescriptor is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKSocketDescriptor *NONNULL_PTR new_SocketDescriptor);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSocketDescriptor;



/**
 * A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
 * socket events into messages which it passes on to its [`MessageHandler`].
 *
 * Locks are taken internally, so you must never assume that reentrancy from a
 * [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
 *
 * Calls to [`read_event`] will decode relevant messages and pass them to the
 * [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
 * parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
 * [`PeerManager`] functions related to the same connection must occur only in serial, making new
 * calls only after previous ones have returned.
 *
 * Rather than using a plain PeerManager, it is preferable to use either a SimpleArcPeerManager
 * a SimpleRefPeerManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefPeerManager, and use a
 * SimpleArcPeerManager when you require a PeerManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 *
 * [`read_event`]: PeerManager::read_event
 */
typedef struct MUST_USE_STRUCT LDKPeerManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerManager;



/**
 * Static channel fields used to build transactions given per-commitment fields, organized by
 * broadcaster/countersignatory.
 *
 * This is derived from the holder/counterparty-organized ChannelTransactionParameters via the
 * as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKDirectedChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectedChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectedChannelTransactionParameters;



/**
 * A read-only view of [`NetworkGraph`].
 */
typedef struct MUST_USE_STRUCT LDKReadOnlyNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReadOnlyNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReadOnlyNetworkGraph;



/**
 * Receives and validates network updates from peers,
 * stores authentic and relevant data as a network graph.
 * This network graph is then used for routing payments.
 * Provides interface to help with initial routing sync by
 * serving historical announcements.
 *
 * Serves as an [`EventHandler`] for applying updates from [`Event::PaymentPathFailed`] to the
 * [`NetworkGraph`].
 */
typedef struct MUST_USE_STRUCT LDKNetGraphMsgHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNetGraphMsgHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNetGraphMsgHandler;



/**
 * A wrapper around [`ChannelInfo`] representing information about the channel as directed from a
 * source node to a target node.
 */
typedef struct MUST_USE_STRUCT LDKDirectedChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectedChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectedChannelInfo;

/**
 * The effective capacity of a channel for routing purposes.
 *
 * While this may be smaller than the actual channel capacity, amounts greater than
 * [`Self::as_msat`] should not be routed through the channel.
 */
typedef enum LDKEffectiveCapacity_Tag {
   /**
    * The available liquidity in the channel known from being a channel counterparty, and thus a
    * direct hop.
    */
   LDKEffectiveCapacity_ExactLiquidity,
   /**
    * The maximum HTLC amount in one direction as advertised on the gossip network.
    */
   LDKEffectiveCapacity_MaximumHTLC,
   /**
    * The total capacity of the channel as determined by the funding transaction.
    */
   LDKEffectiveCapacity_Total,
   /**
    * A capacity sufficient to route any payment, typically used for private channels provided by
    * an invoice.
    */
   LDKEffectiveCapacity_Infinite,
   /**
    * A capacity that is unknown possibly because either the chain state is unavailable to know
    * the total capacity or the `htlc_maximum_msat` was not advertised on the gossip network.
    */
   LDKEffectiveCapacity_Unknown,
   /**
    * Must be last for serialization purposes
    */
   LDKEffectiveCapacity_Sentinel,
} LDKEffectiveCapacity_Tag;

typedef struct LDKEffectiveCapacity_LDKExactLiquidity_Body {
   /**
    * Either the inbound or outbound liquidity depending on the direction, denominated in
    * millisatoshi.
    */
   uint64_t liquidity_msat;
} LDKEffectiveCapacity_LDKExactLiquidity_Body;

typedef struct LDKEffectiveCapacity_LDKMaximumHTLC_Body {
   /**
    * The maximum HTLC amount denominated in millisatoshi.
    */
   uint64_t amount_msat;
} LDKEffectiveCapacity_LDKMaximumHTLC_Body;

typedef struct LDKEffectiveCapacity_LDKTotal_Body {
   /**
    * The funding amount denominated in millisatoshi.
    */
   uint64_t capacity_msat;
} LDKEffectiveCapacity_LDKTotal_Body;

typedef struct MUST_USE_STRUCT LDKEffectiveCapacity {
   LDKEffectiveCapacity_Tag tag;
   union {
      LDKEffectiveCapacity_LDKExactLiquidity_Body exact_liquidity;
      LDKEffectiveCapacity_LDKMaximumHTLC_Body maximum_htlc;
      LDKEffectiveCapacity_LDKTotal_Body total;
   };
} LDKEffectiveCapacity;

/**
 * An interface used to score payment channels for path finding.
 *
 *\tScoring is in terms of fees willing to be paid in order to avoid routing through a channel.
 */
typedef struct LDKScore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the fee in msats willing to be paid to avoid routing `send_amt_msat` through the
    * given channel in the direction from `source` to `target`.
    *
    * The channel's capacity (less any other MPP parts that are also being considered for use in
    * the same payment) is given by `capacity_msat`. It may be determined from various sources
    * such as a chain data, network gossip, or invoice hints. For invoice hints, a capacity near
    * [`u64::max_value`] is given to indicate sufficient capacity for the invoice's full amount.
    * Thus, implementations should be overflow-safe.
    */
   uint64_t (*channel_penalty_msat)(const void *this_arg, uint64_t short_channel_id, uint64_t send_amt_msat, uint64_t capacity_msat, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target);
   /**
    * Handles updating channel penalties after failing to route through a channel.
    */
   void (*payment_path_failed)(void *this_arg, struct LDKCVec_RouteHopZ path, uint64_t short_channel_id);
   /**
    * Handles updating channel penalties after successfully routing along a path.
    */
   void (*payment_path_successful)(void *this_arg, struct LDKCVec_RouteHopZ path);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKScore;

/**
 * A scorer that is accessed under a lock.
 *
 * Needed so that calls to [`Score::channel_penalty_msat`] in [`find_route`] can be made while
 * having shared ownership of a scorer but without requiring internal locking in [`Score`]
 * implementations. Internal locking would be detrimental to route finding performance and could
 * result in [`Score::channel_penalty_msat`] returning a different value for the same channel.
 *
 * [`find_route`]: crate::routing::router::find_route
 */
typedef struct LDKLockableScore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the locked scorer.
    */
   struct LDKScore (*lock)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKLockableScore;



/**
 * A concrete implementation of [`LockableScore`] which supports multi-threading.
 */
typedef struct MUST_USE_STRUCT LDKMultiThreadedLockableScore {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMultiThreadedLockableScore *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMultiThreadedLockableScore;



/**
 * Parameters for configuring [`ProbabilisticScorer`].
 *
 * Used to configure base, liquidity, and amount penalties, the sum of which comprises the channel
 * penalty (i.e., the amount in msats willing to be paid to avoid routing through the channel).
 */
typedef struct MUST_USE_STRUCT LDKProbabilisticScoringParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeProbabilisticScoringParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKProbabilisticScoringParameters;



/**
 * FilesystemPersister persists channel data on disk, where each channel's
 * data is stored in a file named after its funding outpoint.
 *
 * Warning: this module does the best it can with calls to persist data, but it
 * can only guarantee that the data is passed to the drive. It is up to the
 * drive manufacturers to do the actual persistence properly, which they often
 * don't (especially on consumer-grade hardware). Therefore, it is up to the
 * user to validate their entire storage stack, to ensure the writes are
 * persistent.
 * Corollary: especially when dealing with larger amounts of money, it is best
 * practice to have multiple channel data backups and not rely only on one
 * FilesystemPersister.
 */
typedef struct MUST_USE_STRUCT LDKFilesystemPersister {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFilesystemPersister *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFilesystemPersister;



/**
 * `BackgroundProcessor` takes care of tasks that (1) need to happen periodically to keep
 * Rust-Lightning running properly, and (2) either can or should be run in the background. Its
 * responsibilities are:
 * * Processing [`Event`]s with a user-provided [`EventHandler`].
 * * Monitoring whether the [`ChannelManager`] needs to be re-persisted to disk, and if so,
 *   writing it to disk/backups by invoking the callback given to it at startup.
 *   [`ChannelManager`] persistence should be done in the background.
 * * Calling [`ChannelManager::timer_tick_occurred`] and [`PeerManager::timer_tick_occurred`]
 *   at the appropriate intervals.
 * * Calling [`NetworkGraph::remove_stale_channels`] (if a [`NetGraphMsgHandler`] is provided to
 *   [`BackgroundProcessor::start`]).
 *
 * It will also call [`PeerManager::process_events`] periodically though this shouldn't be relied
 * upon as doing so may result in high latency.
 *
 * # Note
 *
 * If [`ChannelManager`] persistence fails and the persisted manager becomes out-of-date, then
 * there is a risk of channels force-closing on startup when the manager realizes it's outdated.
 * However, as long as [`ChannelMonitor`] backups are sound, no funds besides those used for
 * unilateral chain closure fees are at risk.
 *
 * [`ChannelMonitor`]: lightning::chain::channelmonitor::ChannelMonitor
 * [`Event`]: lightning::util::events::Event
 *BackgroundProcessor will immediately stop on drop. It should be stored until shutdown.
 */
typedef struct MUST_USE_STRUCT LDKBackgroundProcessor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBackgroundProcessor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBackgroundProcessor;

/**
 * Trait that handles persisting a [`ChannelManager`] and [`NetworkGraph`] to disk.
 */
typedef struct LDKPersister {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist the given [`ChannelManager`] to disk, returning an error if persistence failed
    * (which will cause the [`BackgroundProcessor`] which called this method to exit).
    */
   struct LDKCResult_NoneErrorZ (*persist_manager)(const void *this_arg, const struct LDKChannelManager *NONNULL_PTR channel_manager);
   /**
    * Persist the given [`NetworkGraph`] to disk, returning an error if persistence failed.
    */
   struct LDKCResult_NoneErrorZ (*persist_graph)(const void *this_arg, const struct LDKNetworkGraph *NONNULL_PTR network_graph);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPersister;



/**
 * Data of the `RawInvoice` that is encoded in the data part
 */
typedef struct MUST_USE_STRUCT LDKRawDataPart {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRawDataPart *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRawDataPart;



/**
 * SHA-256 hash
 */
typedef struct MUST_USE_STRUCT LDKSha256 {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSha256 *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSha256;



/**
 * Positive duration that defines when (relatively to the timestamp) in the future the invoice
 * expires
 */
typedef struct MUST_USE_STRUCT LDKExpiryTime {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeExpiryTime *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKExpiryTime;



/**
 * `min_final_cltv_expiry` to use for the last HTLC in the route
 */
typedef struct MUST_USE_STRUCT LDKMinFinalCltvExpiry {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMinFinalCltvExpiry *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMinFinalCltvExpiry;

/**
 * A 20-byte byte array.
 */
typedef struct LDKTwentyBytes {
   /**
    * The twenty bytes
    */
   uint8_t data[20];
} LDKTwentyBytes;

/**
 * Fallback address in case no LN payment is possible
 */
typedef enum LDKFallback_Tag {
   LDKFallback_SegWitProgram,
   LDKFallback_PubKeyHash,
   LDKFallback_ScriptHash,
   /**
    * Must be last for serialization purposes
    */
   LDKFallback_Sentinel,
} LDKFallback_Tag;

typedef struct LDKFallback_LDKSegWitProgram_Body {
   struct LDKu5 version;
   struct LDKCVec_u8Z program;
} LDKFallback_LDKSegWitProgram_Body;

typedef struct MUST_USE_STRUCT LDKFallback {
   LDKFallback_Tag tag;
   union {
      LDKFallback_LDKSegWitProgram_Body seg_wit_program;
      struct {
         struct LDKTwentyBytes pub_key_hash;
      };
      struct {
         struct LDKTwentyBytes script_hash;
      };
   };
} LDKFallback;

/**
 * A trait defining behavior of an [`Invoice`] payer.
 */
typedef struct LDKPayer {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the payer's node id.
    */
   struct LDKPublicKey (*node_id)(const void *this_arg);
   /**
    * Returns the payer's channels.
    */
   struct LDKCVec_ChannelDetailsZ (*first_hops)(const void *this_arg);
   /**
    * Sends a payment over the Lightning Network using the given [`Route`].
    *
    * Note that payment_secret (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCResult_PaymentIdPaymentSendFailureZ (*send_payment)(const void *this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);
   /**
    * Sends a spontaneous payment over the Lightning Network using the given [`Route`].
    */
   struct LDKCResult_PaymentIdPaymentSendFailureZ (*send_spontaneous_payment)(const void *this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_preimage);
   /**
    * Retries a failed payment path for the [`PaymentId`] using the given [`Route`].
    */
   struct LDKCResult_NonePaymentSendFailureZ (*retry_payment)(const void *this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_id);
   /**
    * Signals that no further retries for the given payment will occur.
    */
   void (*abandon_payment)(const void *this_arg, struct LDKThirtyTwoBytes payment_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPayer;

/**
 * A trait defining behavior for routing an [`Invoice`] payment.
 */
typedef struct LDKRouter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Finds a [`Route`] between `payer` and `payee` for a payment with the given values.
    *
    * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCResult_RouteLightningErrorZ (*find_route)(const void *this_arg, struct LDKPublicKey payer, const struct LDKRouteParameters *NONNULL_PTR route_params, const uint8_t (*payment_hash)[32], struct LDKCVec_ChannelDetailsZ *first_hops, const struct LDKScore *NONNULL_PTR scorer);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKRouter;



/**
 * A utility for paying [`Invoice`]s and sending spontaneous payments.
 *
 * See [module-level documentation] for details.
 *
 * [module-level documentation]: crate::payment
 */
typedef struct MUST_USE_STRUCT LDKInvoicePayer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoicePayer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoicePayer;



/**
 * Number of attempts to retry payment path failures for an [`Invoice`].
 *
 * Note that this is the number of *path* failures, not full payment retries. For multi-path
 * payments, if this is less than the total number of paths, we will never even retry all of the
 * payment's paths.
 */
typedef struct MUST_USE_STRUCT LDKRetryAttempts {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRetryAttempts *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRetryAttempts;



/**
 * A [`Router`] implemented using [`find_route`].
 */
typedef struct MUST_USE_STRUCT LDKDefaultRouter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDefaultRouter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDefaultRouter;

extern const uintptr_t MAX_BUF_SIZE;

extern const uint64_t MIN_RELAY_FEE_SAT_PER_1000_WEIGHT;

extern const uint64_t CLOSED_CHANNEL_UPDATE_ID;

extern const uint32_t ANTI_REORG_DELAY;

extern const uint16_t BREAKDOWN_TIMEOUT;

extern const uint16_t MIN_CLTV_EXPIRY_DELTA;

extern const uint32_t MIN_FINAL_CLTV_EXPIRY;

extern const uintptr_t REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH;

extern const uint64_t UNKNOWN_CHANNEL_CAPACITY_MSAT;

extern const uint32_t DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA;

extern const uint64_t MAX_TIMESTAMP;

extern const uint64_t DEFAULT_EXPIRY_TIME;

extern const uint64_t DEFAULT_MIN_FINAL_CLTV_EXPIRY;

extern const uint8_t TAG_PAYMENT_HASH;

extern const uint8_t TAG_DESCRIPTION;

extern const uint8_t TAG_PAYEE_PUB_KEY;

extern const uint8_t TAG_DESCRIPTION_HASH;

extern const uint8_t TAG_EXPIRY_TIME;

extern const uint8_t TAG_MIN_FINAL_CLTV_EXPIRY;

extern const uint8_t TAG_FALLBACK;

extern const uint8_t TAG_PRIVATE_ROUTE;

extern const uint8_t TAG_PAYMENT_SECRET;

extern const uint8_t TAG_FEATURES;

struct LDKStr _ldk_get_compiled_version(void);

struct LDKStr _ldk_c_bindings_get_compiled_version(void);

/**
 * Creates a new Bech32Error which has the same data as `orig`
 */
struct LDKBech32Error Bech32Error_clone(const struct LDKBech32Error *NONNULL_PTR orig);

/**
 * Releases any memory held by the given `Bech32Error` (which is currently none)
 */
void Bech32Error_free(struct LDKBech32Error o);

/**
 * Frees the data buffer, if data_is_owned is set and datalen > 0.
 */
void Transaction_free(struct LDKTransaction _res);

/**
 * Convenience function for constructing a new TxOut
 */
struct LDKTxOut TxOut_new(struct LDKCVec_u8Z script_pubkey, uint64_t value);

/**
 * Frees the data pointed to by script_pubkey.
 */
void TxOut_free(struct LDKTxOut _res);

/**
 * Creates a new TxOut which has the same data as `orig` but with a new script buffer.
 */
struct LDKTxOut TxOut_clone(const struct LDKTxOut *NONNULL_PTR orig);

/**
 * Frees the data buffer, if chars_is_owned is set and len > 0.
 */
void Str_free(struct LDKStr _res);

#if defined(LDK_DEBUG_BUILD)
/**
 * This function exists for memory safety testing purposes. It should never be used in production
 * code
 */
const void *__unmangle_inner_ptr(const void *ptr);
#endif

/**
 * Creates a new CResult_NoneNoneZ in the success state.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_ok(void);

/**
 * Creates a new CResult_NoneNoneZ in the error state.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneNoneZ_is_ok(const struct LDKCResult_NoneNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneNoneZ.
 */
void CResult_NoneNoneZ_free(struct LDKCResult_NoneNoneZ _res);

/**
 * Creates a new CResult_NoneNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_clone(const struct LDKCResult_NoneNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(struct LDKCounterpartyCommitmentSecrets o);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyCommitmentSecretsDecodeErrorZ.
 */
void CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SecretKeyErrorZ in the success state.
 */
struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_ok(struct LDKSecretKey o);

/**
 * Creates a new CResult_SecretKeyErrorZ in the error state.
 */
struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SecretKeyErrorZ_is_ok(const struct LDKCResult_SecretKeyErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SecretKeyErrorZ.
 */
void CResult_SecretKeyErrorZ_free(struct LDKCResult_SecretKeyErrorZ _res);

/**
 * Creates a new CResult_SecretKeyErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_clone(const struct LDKCResult_SecretKeyErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PublicKeyErrorZ in the success state.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_ok(struct LDKPublicKey o);

/**
 * Creates a new CResult_PublicKeyErrorZ in the error state.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PublicKeyErrorZ_is_ok(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PublicKeyErrorZ.
 */
void CResult_PublicKeyErrorZ_free(struct LDKCResult_PublicKeyErrorZ _res);

/**
 * Creates a new CResult_PublicKeyErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_clone(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ in the success state.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(struct LDKTxCreationKeys o);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ in the error state.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxCreationKeysDecodeErrorZ_is_ok(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxCreationKeysDecodeErrorZ.
 */
void CResult_TxCreationKeysDecodeErrorZ_free(struct LDKCResult_TxCreationKeysDecodeErrorZ _res);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_clone(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_ok(struct LDKChannelPublicKeys o);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelPublicKeysDecodeErrorZ_is_ok(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelPublicKeysDecodeErrorZ.
 */
void CResult_ChannelPublicKeysDecodeErrorZ_free(struct LDKCResult_ChannelPublicKeysDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_clone(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxCreationKeysErrorZ in the success state.
 */
struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_ok(struct LDKTxCreationKeys o);

/**
 * Creates a new CResult_TxCreationKeysErrorZ in the error state.
 */
struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxCreationKeysErrorZ_is_ok(const struct LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxCreationKeysErrorZ.
 */
void CResult_TxCreationKeysErrorZ_free(struct LDKCResult_TxCreationKeysErrorZ _res);

/**
 * Creates a new CResult_TxCreationKeysErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_clone(const struct LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_u32Z containing a u32
 */
struct LDKCOption_u32Z COption_u32Z_some(uint32_t o);

/**
 * Constructs a new COption_u32Z containing nothing
 */
struct LDKCOption_u32Z COption_u32Z_none(void);

/**
 * Frees any resources associated with the u32, if we are in the Some state
 */
void COption_u32Z_free(struct LDKCOption_u32Z _res);

/**
 * Creates a new COption_u32Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u32Z COption_u32Z_clone(const struct LDKCOption_u32Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(struct LDKHTLCOutputInCommitment o);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HTLCOutputInCommitmentDecodeErrorZ.
 */
void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_NoneZ containing a
 */
enum LDKCOption_NoneZ COption_NoneZ_some(void);

/**
 * Constructs a new COption_NoneZ containing nothing
 */
enum LDKCOption_NoneZ COption_NoneZ_none(void);

/**
 * Frees any resources associated with the , if we are in the Some state
 */
void COption_NoneZ_free(enum LDKCOption_NoneZ _res);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(struct LDKCounterpartyChannelTransactionParameters o);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyChannelTransactionParametersDecodeErrorZ.
 */
void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_ok(struct LDKChannelTransactionParameters o);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelTransactionParametersDecodeErrorZ.
 */
void CResult_ChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_ChannelTransactionParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_SignatureZ_free(struct LDKCVec_SignatureZ _res);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_ok(struct LDKHolderCommitmentTransaction o);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HolderCommitmentTransactionDecodeErrorZ.
 */
void CResult_HolderCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(struct LDKBuiltCommitmentTransaction o);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BuiltCommitmentTransactionDecodeErrorZ.
 */
void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TrustedClosingTransactionNoneZ in the success state.
 */
struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_ok(struct LDKTrustedClosingTransaction o);

/**
 * Creates a new CResult_TrustedClosingTransactionNoneZ in the error state.
 */
struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TrustedClosingTransactionNoneZ_is_ok(const struct LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TrustedClosingTransactionNoneZ.
 */
void CResult_TrustedClosingTransactionNoneZ_free(struct LDKCResult_TrustedClosingTransactionNoneZ _res);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_ok(struct LDKCommitmentTransaction o);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CommitmentTransactionDecodeErrorZ.
 */
void CResult_CommitmentTransactionDecodeErrorZ_free(struct LDKCResult_CommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the success state.
 */
struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_ok(struct LDKTrustedCommitmentTransaction o);

/**
 * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the error state.
 */
struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TrustedCommitmentTransactionNoneZ_is_ok(const struct LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TrustedCommitmentTransactionNoneZ.
 */
void CResult_TrustedCommitmentTransactionNoneZ_free(struct LDKCResult_TrustedCommitmentTransactionNoneZ _res);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ in the success state.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_ok(struct LDKCVec_SignatureZ o);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ in the error state.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_SignatureZNoneZ_is_ok(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_SignatureZNoneZ.
 */
void CResult_CVec_SignatureZNoneZ_free(struct LDKCResult_CVec_SignatureZNoneZ _res);

/**
 * Creates a new CResult_CVec_SignatureZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_clone(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ in the success state.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_ok(struct LDKShutdownScript o);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ in the error state.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownScriptDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownScriptDecodeErrorZ.
 */
void CResult_ShutdownScriptDecodeErrorZ_free(struct LDKCResult_ShutdownScriptDecodeErrorZ _res);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_clone(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the success state.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_ok(struct LDKShutdownScript o);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the error state.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_err(struct LDKInvalidShutdownScript e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownScriptInvalidShutdownScriptZ.
 */
void CResult_ShutdownScriptInvalidShutdownScriptZ_free(struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ _res);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_clone(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneErrorZ in the success state.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_ok(void);

/**
 * Creates a new CResult_NoneErrorZ in the error state.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneErrorZ_is_ok(const struct LDKCResult_NoneErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneErrorZ.
 */
void CResult_NoneErrorZ_free(struct LDKCResult_NoneErrorZ _res);

/**
 * Creates a new CResult_NoneErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneErrorZ CResult_NoneErrorZ_clone(const struct LDKCResult_NoneErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_ok(struct LDKRouteHop o);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHopDecodeErrorZ.
 */
void CResult_RouteHopDecodeErrorZ_free(struct LDKCResult_RouteHopDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_clone(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHopZ_free(struct LDKCVec_RouteHopZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CVec_RouteHopZZ_free(struct LDKCVec_CVec_RouteHopZZ _res);

/**
 * Creates a new CResult_RouteDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(struct LDKRoute o);

/**
 * Creates a new CResult_RouteDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteDecodeErrorZ_is_ok(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteDecodeErrorZ.
 */
void CResult_RouteDecodeErrorZ_free(struct LDKCResult_RouteDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_ok(struct LDKRouteParameters o);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteParametersDecodeErrorZ_is_ok(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteParametersDecodeErrorZ.
 */
void CResult_RouteParametersDecodeErrorZ_free(struct LDKCResult_RouteParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_clone(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHintZ_free(struct LDKCVec_RouteHintZ _res);

/**
 * Constructs a new COption_u64Z containing a u64
 */
struct LDKCOption_u64Z COption_u64Z_some(uint64_t o);

/**
 * Constructs a new COption_u64Z containing nothing
 */
struct LDKCOption_u64Z COption_u64Z_none(void);

/**
 * Frees any resources associated with the u64, if we are in the Some state
 */
void COption_u64Z_free(struct LDKCOption_u64Z _res);

/**
 * Creates a new COption_u64Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u64Z COption_u64Z_clone(const struct LDKCOption_u64Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_ok(struct LDKPaymentParameters o);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentParametersDecodeErrorZ_is_ok(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentParametersDecodeErrorZ.
 */
void CResult_PaymentParametersDecodeErrorZ_free(struct LDKCResult_PaymentParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_clone(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHintHopZ_free(struct LDKCVec_RouteHintHopZ _res);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_ok(struct LDKRouteHint o);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHintDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHintDecodeErrorZ.
 */
void CResult_RouteHintDecodeErrorZ_free(struct LDKCResult_RouteHintDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_clone(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_ok(struct LDKRouteHintHop o);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHintHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHintHopDecodeErrorZ.
 */
void CResult_RouteHintHopDecodeErrorZ_free(struct LDKCResult_RouteHintHopDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_clone(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ChannelDetailsZ_free(struct LDKCVec_ChannelDetailsZ _res);

/**
 * Creates a new CResult_RouteLightningErrorZ in the success state.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(struct LDKRoute o);

/**
 * Creates a new CResult_RouteLightningErrorZ in the error state.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteLightningErrorZ_is_ok(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteLightningErrorZ.
 */
void CResult_RouteLightningErrorZ_free(struct LDKCResult_RouteLightningErrorZ _res);

/**
 * Creates a new CResult_RouteLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxOutAccessErrorZ in the success state.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_ok(struct LDKTxOut o);

/**
 * Creates a new CResult_TxOutAccessErrorZ in the error state.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_err(enum LDKAccessError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxOutAccessErrorZ_is_ok(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxOutAccessErrorZ.
 */
void CResult_TxOutAccessErrorZ_free(struct LDKCResult_TxOutAccessErrorZ _res);

/**
 * Creates a new CResult_TxOutAccessErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_clone(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_clone(const struct LDKC2Tuple_usizeTransactionZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_usizeTransactionZ from the contained elements.
 */
struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(uintptr_t a, struct LDKTransaction b);

/**
 * Frees any resources used by the C2Tuple_usizeTransactionZ.
 */
void C2Tuple_usizeTransactionZ_free(struct LDKC2Tuple_usizeTransactionZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_usizeTransactionZZ_free(struct LDKCVec_C2Tuple_usizeTransactionZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TxidZ_free(struct LDKCVec_TxidZ _res);

/**
 * Creates a new CResult_NoneChannelMonitorUpdateErrZ in the success state.
 */
struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_ok(void);

/**
 * Creates a new CResult_NoneChannelMonitorUpdateErrZ in the error state.
 */
struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_err(enum LDKChannelMonitorUpdateErr e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneChannelMonitorUpdateErrZ_is_ok(const struct LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneChannelMonitorUpdateErrZ.
 */
void CResult_NoneChannelMonitorUpdateErrZ_free(struct LDKCResult_NoneChannelMonitorUpdateErrZ _res);

/**
 * Creates a new CResult_NoneChannelMonitorUpdateErrZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_clone(const struct LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MonitorEventZ_free(struct LDKCVec_MonitorEventZ _res);

/**
 * Constructs a new COption_C2Tuple_usizeTransactionZZ containing a crate::c_types::derived::C2Tuple_usizeTransactionZ
 */
struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_some(struct LDKC2Tuple_usizeTransactionZ o);

/**
 * Constructs a new COption_C2Tuple_usizeTransactionZZ containing nothing
 */
struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::C2Tuple_usizeTransactionZ, if we are in the Some state
 */
void COption_C2Tuple_usizeTransactionZZ_free(struct LDKCOption_C2Tuple_usizeTransactionZZ _res);

/**
 * Creates a new COption_C2Tuple_usizeTransactionZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_clone(const struct LDKCOption_C2Tuple_usizeTransactionZZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_ClosureReasonZ containing a crate::lightning::util::events::ClosureReason
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_some(struct LDKClosureReason o);

/**
 * Constructs a new COption_ClosureReasonZ containing nothing
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::util::events::ClosureReason, if we are in the Some state
 */
void COption_ClosureReasonZ_free(struct LDKCOption_ClosureReasonZ _res);

/**
 * Creates a new COption_ClosureReasonZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_clone(const struct LDKCOption_ClosureReasonZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_ok(struct LDKCOption_ClosureReasonZ o);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_ClosureReasonZDecodeErrorZ.
 */
void CResult_COption_ClosureReasonZDecodeErrorZ_free(struct LDKCResult_COption_ClosureReasonZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_clone(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_NetworkUpdateZ containing a crate::lightning::routing::network_graph::NetworkUpdate
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_some(struct LDKNetworkUpdate o);

/**
 * Constructs a new COption_NetworkUpdateZ containing nothing
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::routing::network_graph::NetworkUpdate, if we are in the Some state
 */
void COption_NetworkUpdateZ_free(struct LDKCOption_NetworkUpdateZ _res);

/**
 * Creates a new COption_NetworkUpdateZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_clone(const struct LDKCOption_NetworkUpdateZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_SpendableOutputDescriptorZ_free(struct LDKCVec_SpendableOutputDescriptorZ _res);

/**
 * Constructs a new COption_EventZ containing a crate::lightning::util::events::Event
 */
struct LDKCOption_EventZ COption_EventZ_some(struct LDKEvent o);

/**
 * Constructs a new COption_EventZ containing nothing
 */
struct LDKCOption_EventZ COption_EventZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::util::events::Event, if we are in the Some state
 */
void COption_EventZ_free(struct LDKCOption_EventZ _res);

/**
 * Creates a new COption_EventZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_EventZ COption_EventZ_clone(const struct LDKCOption_EventZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_ok(struct LDKCOption_EventZ o);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_EventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_EventZDecodeErrorZ.
 */
void CResult_COption_EventZDecodeErrorZ_free(struct LDKCResult_COption_EventZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_clone(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MessageSendEventZ_free(struct LDKCVec_MessageSendEventZ _res);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the success state.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_ok(struct LDKFixedPenaltyScorer o);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the error state.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FixedPenaltyScorerDecodeErrorZ.
 */
void CResult_FixedPenaltyScorerDecodeErrorZ_free(struct LDKCResult_FixedPenaltyScorerDecodeErrorZ _res);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_clone(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ScoringParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_ScoringParametersDecodeErrorZ CResult_ScoringParametersDecodeErrorZ_ok(struct LDKScoringParameters o);

/**
 * Creates a new CResult_ScoringParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_ScoringParametersDecodeErrorZ CResult_ScoringParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ScoringParametersDecodeErrorZ_is_ok(const struct LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ScoringParametersDecodeErrorZ.
 */
void CResult_ScoringParametersDecodeErrorZ_free(struct LDKCResult_ScoringParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_ScoringParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ScoringParametersDecodeErrorZ CResult_ScoringParametersDecodeErrorZ_clone(const struct LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ScorerDecodeErrorZ in the success state.
 */
struct LDKCResult_ScorerDecodeErrorZ CResult_ScorerDecodeErrorZ_ok(struct LDKScorer o);

/**
 * Creates a new CResult_ScorerDecodeErrorZ in the error state.
 */
struct LDKCResult_ScorerDecodeErrorZ CResult_ScorerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ScorerDecodeErrorZ_is_ok(const struct LDKCResult_ScorerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ScorerDecodeErrorZ.
 */
void CResult_ScorerDecodeErrorZ_free(struct LDKCResult_ScorerDecodeErrorZ _res);

/**
 * Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the success state.
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_ok(struct LDKProbabilisticScorer o);

/**
 * Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the error state.
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ProbabilisticScorerDecodeErrorZ_is_ok(const struct LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ProbabilisticScorerDecodeErrorZ.
 */
void CResult_ProbabilisticScorerDecodeErrorZ_free(struct LDKCResult_ProbabilisticScorerDecodeErrorZ _res);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(struct LDKInitFeatures o);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InitFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InitFeaturesDecodeErrorZ.
 */
void CResult_InitFeaturesDecodeErrorZ_free(struct LDKCResult_InitFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(struct LDKChannelFeatures o);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelFeaturesDecodeErrorZ.
 */
void CResult_ChannelFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(struct LDKNodeFeatures o);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeFeaturesDecodeErrorZ.
 */
void CResult_NodeFeaturesDecodeErrorZ_free(struct LDKCResult_NodeFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_ok(struct LDKInvoiceFeatures o);

/**
 * Creates a new CResult_InvoiceFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceFeaturesDecodeErrorZ.
 */
void CResult_InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_InvoiceFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_ok(struct LDKChannelTypeFeatures o);

/**
 * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelTypeFeaturesDecodeErrorZ.
 */
void CResult_ChannelTypeFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKDelayedPaymentOutputDescriptor o);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_DelayedPaymentOutputDescriptorDecodeErrorZ.
 */
void CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKStaticPaymentOutputDescriptor o);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_StaticPaymentOutputDescriptorDecodeErrorZ.
 */
void CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_ok(struct LDKSpendableOutputDescriptor o);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SpendableOutputDescriptorDecodeErrorZ.
 */
void CResult_SpendableOutputDescriptorDecodeErrorZ_free(struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PaymentPreimageZ_free(struct LDKCVec_PaymentPreimageZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_clone(const struct LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_SignatureCVec_SignatureZZ from the contained elements.
 */
struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_new(struct LDKSignature a, struct LDKCVec_SignatureZ b);

/**
 * Frees any resources used by the C2Tuple_SignatureCVec_SignatureZZ.
 */
void C2Tuple_SignatureCVec_SignatureZZ_free(struct LDKC2Tuple_SignatureCVec_SignatureZZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(struct LDKC2Tuple_SignatureCVec_SignatureZZ o);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ.
 */
void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignatureNoneZ in the success state.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_ok(struct LDKSignature o);

/**
 * Creates a new CResult_SignatureNoneZ in the error state.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SignatureNoneZ_is_ok(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SignatureNoneZ.
 */
void CResult_SignatureNoneZ_free(struct LDKCResult_SignatureNoneZ _res);

/**
 * Creates a new CResult_SignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_clone(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_SignatureSignatureZ C2Tuple_SignatureSignatureZ_clone(const struct LDKC2Tuple_SignatureSignatureZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_SignatureSignatureZ from the contained elements.
 */
struct LDKC2Tuple_SignatureSignatureZ C2Tuple_SignatureSignatureZ_new(struct LDKSignature a, struct LDKSignature b);

/**
 * Frees any resources used by the C2Tuple_SignatureSignatureZ.
 */
void C2Tuple_SignatureSignatureZ_free(struct LDKC2Tuple_SignatureSignatureZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_ok(struct LDKC2Tuple_SignatureSignatureZ o);

/**
 * Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok(const struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_SignatureSignatureZNoneZ.
 */
void CResult_C2Tuple_SignatureSignatureZNoneZ_free(struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_SignatureSignatureZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SecretKeyNoneZ in the success state.
 */
struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_ok(struct LDKSecretKey o);

/**
 * Creates a new CResult_SecretKeyNoneZ in the error state.
 */
struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SecretKeyNoneZ_is_ok(const struct LDKCResult_SecretKeyNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SecretKeyNoneZ.
 */
void CResult_SecretKeyNoneZ_free(struct LDKCResult_SecretKeyNoneZ _res);

/**
 * Creates a new CResult_SecretKeyNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_clone(const struct LDKCResult_SecretKeyNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignDecodeErrorZ in the success state.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_ok(struct LDKSign o);

/**
 * Creates a new CResult_SignDecodeErrorZ in the error state.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SignDecodeErrorZ_is_ok(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SignDecodeErrorZ.
 */
void CResult_SignDecodeErrorZ_free(struct LDKCResult_SignDecodeErrorZ _res);

/**
 * Creates a new CResult_SignDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_clone(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u5Z_free(struct LDKCVec_u5Z _res);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ in the success state.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_ok(struct LDKRecoverableSignature o);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ in the error state.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RecoverableSignatureNoneZ_is_ok(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RecoverableSignatureNoneZ.
 */
void CResult_RecoverableSignatureNoneZ_free(struct LDKCResult_RecoverableSignatureNoneZ _res);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_clone(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u8Z_free(struct LDKCVec_u8Z _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CVec_u8ZZ_free(struct LDKCVec_CVec_u8ZZ _res);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the success state.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(struct LDKCVec_CVec_u8ZZ o);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the error state.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_CVec_u8ZZNoneZ_is_ok(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_CVec_u8ZZNoneZ.
 */
void CResult_CVec_CVec_u8ZZNoneZ_free(struct LDKCResult_CVec_CVec_u8ZZNoneZ _res);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ in the success state.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(struct LDKInMemorySigner o);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ in the error state.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InMemorySignerDecodeErrorZ_is_ok(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InMemorySignerDecodeErrorZ.
 */
void CResult_InMemorySignerDecodeErrorZ_free(struct LDKCResult_InMemorySignerDecodeErrorZ _res);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_clone(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TxOutZ_free(struct LDKCVec_TxOutZ _res);

/**
 * Creates a new CResult_TransactionNoneZ in the success state.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(struct LDKTransaction o);

/**
 * Creates a new CResult_TransactionNoneZ in the error state.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TransactionNoneZ_is_ok(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TransactionNoneZ.
 */
void CResult_TransactionNoneZ_free(struct LDKCResult_TransactionNoneZ _res);

/**
 * Creates a new CResult_TransactionNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_clone(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_clone(const struct LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_BlockHashChannelMonitorZ from the contained elements.
 */
struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelMonitor b);

/**
 * Frees any resources used by the C2Tuple_BlockHashChannelMonitorZ.
 */
void C2Tuple_BlockHashChannelMonitorZ_free(struct LDKC2Tuple_BlockHashChannelMonitorZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_BlockHashChannelMonitorZZ_free(struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ in the success state.
 */
struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_ok(struct LDKCVec_C2Tuple_BlockHashChannelMonitorZZ o);

/**
 * Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ in the error state.
 */
struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_is_ok(const struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ.
 */
void CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_free(struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clone(const struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_u16Z containing a u16
 */
struct LDKCOption_u16Z COption_u16Z_some(uint16_t o);

/**
 * Constructs a new COption_u16Z containing nothing
 */
struct LDKCOption_u16Z COption_u16Z_none(void);

/**
 * Frees any resources associated with the u16, if we are in the Some state
 */
void COption_u16Z_free(struct LDKCOption_u16Z _res);

/**
 * Creates a new COption_u16Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u16Z COption_u16Z_clone(const struct LDKCOption_u16Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneAPIErrorZ in the success state.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok(void);

/**
 * Creates a new CResult_NoneAPIErrorZ in the error state.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneAPIErrorZ_is_ok(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneAPIErrorZ.
 */
void CResult_NoneAPIErrorZ_free(struct LDKCResult_NoneAPIErrorZ _res);

/**
 * Creates a new CResult_NoneAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CResult_NoneAPIErrorZZ_free(struct LDKCVec_CResult_NoneAPIErrorZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_APIErrorZ_free(struct LDKCVec_APIErrorZ _res);

/**
 * Creates a new CResult__u832APIErrorZ in the success state.
 */
struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult__u832APIErrorZ in the error state.
 */
struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult__u832APIErrorZ_is_ok(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult__u832APIErrorZ.
 */
void CResult__u832APIErrorZ_free(struct LDKCResult__u832APIErrorZ _res);

/**
 * Creates a new CResult__u832APIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_clone(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentIdPaymentSendFailureZ in the success state.
 */
struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentIdPaymentSendFailureZ in the error state.
 */
struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentIdPaymentSendFailureZ_is_ok(const struct LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentIdPaymentSendFailureZ.
 */
void CResult_PaymentIdPaymentSendFailureZ_free(struct LDKCResult_PaymentIdPaymentSendFailureZ _res);

/**
 * Creates a new CResult_PaymentIdPaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_clone(const struct LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NonePaymentSendFailureZ in the success state.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok(void);

/**
 * Creates a new CResult_NonePaymentSendFailureZ in the error state.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NonePaymentSendFailureZ_is_ok(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NonePaymentSendFailureZ.
 */
void CResult_NonePaymentSendFailureZ_free(struct LDKCResult_NonePaymentSendFailureZ _res);

/**
 * Creates a new CResult_NonePaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_clone(const struct LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PaymentHashPaymentIdZ from the contained elements.
 */
struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);

/**
 * Frees any resources used by the C2Tuple_PaymentHashPaymentIdZ.
 */
void C2Tuple_PaymentHashPaymentIdZ_free(struct LDKC2Tuple_PaymentHashPaymentIdZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ in the success state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(struct LDKC2Tuple_PaymentHashPaymentIdZ o);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ in the error state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ.
 */
void CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_NetAddressZ_free(struct LDKCVec_NetAddressZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_clone(const struct LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PaymentHashPaymentSecretZ from the contained elements.
 */
struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);

/**
 * Frees any resources used by the C2Tuple_PaymentHashPaymentSecretZ.
 */
void C2Tuple_PaymentHashPaymentSecretZ_free(struct LDKC2Tuple_PaymentHashPaymentSecretZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ.
 */
void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ.
 */
void CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ _res);

/**
 * Creates a new CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentSecretNoneZ in the success state.
 */
struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentSecretNoneZ in the error state.
 */
struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentSecretNoneZ_is_ok(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentSecretNoneZ.
 */
void CResult_PaymentSecretNoneZ_free(struct LDKCResult_PaymentSecretNoneZ _res);

/**
 * Creates a new CResult_PaymentSecretNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_clone(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ in the success state.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ in the error state.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentSecretAPIErrorZ_is_ok(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentSecretAPIErrorZ.
 */
void CResult_PaymentSecretAPIErrorZ_free(struct LDKCResult_PaymentSecretAPIErrorZ _res);

/**
 * Creates a new CResult_PaymentSecretAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_clone(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentPreimageAPIErrorZ in the success state.
 */
struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentPreimageAPIErrorZ in the error state.
 */
struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentPreimageAPIErrorZ_is_ok(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentPreimageAPIErrorZ.
 */
void CResult_PaymentPreimageAPIErrorZ_free(struct LDKCResult_PaymentPreimageAPIErrorZ _res);

/**
 * Creates a new CResult_PaymentPreimageAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_clone(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(struct LDKCounterpartyForwardingInfo o);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyForwardingInfoDecodeErrorZ.
 */
void CResult_CounterpartyForwardingInfoDecodeErrorZ_free(struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_ok(struct LDKChannelCounterparty o);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelCounterpartyDecodeErrorZ_is_ok(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelCounterpartyDecodeErrorZ.
 */
void CResult_ChannelCounterpartyDecodeErrorZ_free(struct LDKCResult_ChannelCounterpartyDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_clone(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_ok(struct LDKChannelDetails o);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelDetailsDecodeErrorZ_is_ok(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelDetailsDecodeErrorZ.
 */
void CResult_ChannelDetailsDecodeErrorZ_free(struct LDKCResult_ChannelDetailsDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_clone(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the success state.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_ok(struct LDKPhantomRouteHints o);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the error state.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PhantomRouteHintsDecodeErrorZ_is_ok(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PhantomRouteHintsDecodeErrorZ.
 */
void CResult_PhantomRouteHintsDecodeErrorZ_free(struct LDKCResult_PhantomRouteHintsDecodeErrorZ _res);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_clone(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ChannelMonitorZ_free(struct LDKCVec_ChannelMonitorZ _res);

/**
 * Creates a new C2Tuple_BlockHashChannelManagerZ from the contained elements.
 */
struct LDKC2Tuple_BlockHashChannelManagerZ C2Tuple_BlockHashChannelManagerZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelManager b);

/**
 * Frees any resources used by the C2Tuple_BlockHashChannelManagerZ.
 */
void C2Tuple_BlockHashChannelManagerZ_free(struct LDKC2Tuple_BlockHashChannelManagerZ _res);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelManagerZ o);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ.
 */
void CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(struct LDKChannelConfig o);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelConfigDecodeErrorZ_is_ok(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelConfigDecodeErrorZ.
 */
void CResult_ChannelConfigDecodeErrorZ_free(struct LDKCResult_ChannelConfigDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OutPointDecodeErrorZ in the success state.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(struct LDKOutPoint o);

/**
 * Creates a new CResult_OutPointDecodeErrorZ in the error state.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OutPointDecodeErrorZ_is_ok(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OutPointDecodeErrorZ.
 */
void CResult_OutPointDecodeErrorZ_free(struct LDKCResult_OutPointDecodeErrorZ _res);

/**
 * Creates a new CResult_OutPointDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_TypeZ containing a crate::lightning::ln::wire::Type
 */
struct LDKCOption_TypeZ COption_TypeZ_some(struct LDKType o);

/**
 * Constructs a new COption_TypeZ containing nothing
 */
struct LDKCOption_TypeZ COption_TypeZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::wire::Type, if we are in the Some state
 */
void COption_TypeZ_free(struct LDKCOption_TypeZ _res);

/**
 * Creates a new COption_TypeZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_TypeZ COption_TypeZ_clone(const struct LDKCOption_TypeZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_ok(struct LDKCOption_TypeZ o);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_TypeZDecodeErrorZ_is_ok(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_TypeZDecodeErrorZ.
 */
void CResult_COption_TypeZDecodeErrorZ_free(struct LDKCResult_COption_TypeZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_clone(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentIdPaymentErrorZ in the success state.
 */
struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_PaymentIdPaymentErrorZ in the error state.
 */
struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_err(struct LDKPaymentError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentIdPaymentErrorZ_is_ok(const struct LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentIdPaymentErrorZ.
 */
void CResult_PaymentIdPaymentErrorZ_free(struct LDKCResult_PaymentIdPaymentErrorZ _res);

/**
 * Creates a new CResult_PaymentIdPaymentErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_clone(const struct LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SiPrefixParseErrorZ in the success state.
 */
struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_ok(enum LDKSiPrefix o);

/**
 * Creates a new CResult_SiPrefixParseErrorZ in the error state.
 */
struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_err(struct LDKParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SiPrefixParseErrorZ_is_ok(const struct LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SiPrefixParseErrorZ.
 */
void CResult_SiPrefixParseErrorZ_free(struct LDKCResult_SiPrefixParseErrorZ _res);

/**
 * Creates a new CResult_SiPrefixParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_clone(const struct LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceParseOrSemanticErrorZ in the success state.
 */
struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceParseOrSemanticErrorZ in the error state.
 */
struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_err(struct LDKParseOrSemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceParseOrSemanticErrorZ_is_ok(const struct LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceParseOrSemanticErrorZ.
 */
void CResult_InvoiceParseOrSemanticErrorZ_free(struct LDKCResult_InvoiceParseOrSemanticErrorZ _res);

/**
 * Creates a new CResult_InvoiceParseOrSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_clone(const struct LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignedRawInvoiceParseErrorZ in the success state.
 */
struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_ok(struct LDKSignedRawInvoice o);

/**
 * Creates a new CResult_SignedRawInvoiceParseErrorZ in the error state.
 */
struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_err(struct LDKParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SignedRawInvoiceParseErrorZ_is_ok(const struct LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SignedRawInvoiceParseErrorZ.
 */
void CResult_SignedRawInvoiceParseErrorZ_free(struct LDKCResult_SignedRawInvoiceParseErrorZ _res);

/**
 * Creates a new CResult_SignedRawInvoiceParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_clone(const struct LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(const struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_RawInvoice_u832InvoiceSignatureZ from the contained elements.
 */
struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(struct LDKRawInvoice a, struct LDKThirtyTwoBytes b, struct LDKInvoiceSignature c);

/**
 * Frees any resources used by the C3Tuple_RawInvoice_u832InvoiceSignatureZ.
 */
void C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ _res);

/**
 * Creates a new CResult_PayeePubKeyErrorZ in the success state.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_ok(struct LDKPayeePubKey o);

/**
 * Creates a new CResult_PayeePubKeyErrorZ in the error state.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PayeePubKeyErrorZ_is_ok(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PayeePubKeyErrorZ.
 */
void CResult_PayeePubKeyErrorZ_free(struct LDKCResult_PayeePubKeyErrorZ _res);

/**
 * Creates a new CResult_PayeePubKeyErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_clone(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PrivateRouteZ_free(struct LDKCVec_PrivateRouteZ _res);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ in the success state.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_ok(struct LDKPositiveTimestamp o);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ in the error state.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PositiveTimestampCreationErrorZ_is_ok(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PositiveTimestampCreationErrorZ.
 */
void CResult_PositiveTimestampCreationErrorZ_free(struct LDKCResult_PositiveTimestampCreationErrorZ _res);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_clone(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneSemanticErrorZ in the success state.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_ok(void);

/**
 * Creates a new CResult_NoneSemanticErrorZ in the error state.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_err(enum LDKSemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneSemanticErrorZ_is_ok(const struct LDKCResult_NoneSemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneSemanticErrorZ.
 */
void CResult_NoneSemanticErrorZ_free(struct LDKCResult_NoneSemanticErrorZ _res);

/**
 * Creates a new CResult_NoneSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_clone(const struct LDKCResult_NoneSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ in the success state.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ in the error state.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_err(enum LDKSemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceSemanticErrorZ_is_ok(const struct LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceSemanticErrorZ.
 */
void CResult_InvoiceSemanticErrorZ_free(struct LDKCResult_InvoiceSemanticErrorZ _res);

/**
 * Creates a new CResult_InvoiceSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_clone(const struct LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_DescriptionCreationErrorZ in the success state.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_ok(struct LDKDescription o);

/**
 * Creates a new CResult_DescriptionCreationErrorZ in the error state.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_DescriptionCreationErrorZ_is_ok(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_DescriptionCreationErrorZ.
 */
void CResult_DescriptionCreationErrorZ_free(struct LDKCResult_DescriptionCreationErrorZ _res);

/**
 * Creates a new CResult_DescriptionCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_clone(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ in the success state.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_ok(struct LDKPrivateRoute o);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ in the error state.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PrivateRouteCreationErrorZ_is_ok(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PrivateRouteCreationErrorZ.
 */
void CResult_PrivateRouteCreationErrorZ_free(struct LDKCResult_PrivateRouteCreationErrorZ _res);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_clone(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_StringErrorZ in the success state.
 */
struct LDKCResult_StringErrorZ CResult_StringErrorZ_ok(struct LDKStr o);

/**
 * Creates a new CResult_StringErrorZ in the error state.
 */
struct LDKCResult_StringErrorZ CResult_StringErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_StringErrorZ_is_ok(const struct LDKCResult_StringErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_StringErrorZ.
 */
void CResult_StringErrorZ_free(struct LDKCResult_StringErrorZ _res);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_ok(struct LDKChannelMonitorUpdate o);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelMonitorUpdateDecodeErrorZ.
 */
void CResult_ChannelMonitorUpdateDecodeErrorZ_free(struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_MonitorEventZ containing a crate::lightning::chain::channelmonitor::MonitorEvent
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_some(struct LDKMonitorEvent o);

/**
 * Constructs a new COption_MonitorEventZ containing nothing
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::chain::channelmonitor::MonitorEvent, if we are in the Some state
 */
void COption_MonitorEventZ_free(struct LDKCOption_MonitorEventZ _res);

/**
 * Creates a new COption_MonitorEventZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_clone(const struct LDKCOption_MonitorEventZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_ok(struct LDKCOption_MonitorEventZ o);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_MonitorEventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_MonitorEventZDecodeErrorZ.
 */
void CResult_COption_MonitorEventZDecodeErrorZ_free(struct LDKCResult_COption_MonitorEventZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_clone(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(struct LDKHTLCUpdate o);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HTLCUpdateDecodeErrorZ_is_ok(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HTLCUpdateDecodeErrorZ.
 */
void CResult_HTLCUpdateDecodeErrorZ_free(struct LDKCResult_HTLCUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_clone(const struct LDKC2Tuple_OutPointScriptZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_OutPointScriptZ from the contained elements.
 */
struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_new(struct LDKOutPoint a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_OutPointScriptZ.
 */
void C2Tuple_OutPointScriptZ_free(struct LDKC2Tuple_OutPointScriptZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_clone(const struct LDKC2Tuple_u32ScriptZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u32ScriptZ from the contained elements.
 */
struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_new(uint32_t a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_u32ScriptZ.
 */
void C2Tuple_u32ScriptZ_free(struct LDKC2Tuple_u32ScriptZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u32ScriptZZ_free(struct LDKCVec_C2Tuple_u32ScriptZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ from the contained elements.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32ScriptZZ b);

/**
 * Frees any resources used by the C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ.
 */
void C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_EventZ_free(struct LDKCVec_EventZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TransactionZ_free(struct LDKCVec_TransactionZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(const struct LDKC2Tuple_u32TxOutZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u32TxOutZ from the contained elements.
 */
struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(uint32_t a, struct LDKTxOut b);

/**
 * Frees any resources used by the C2Tuple_u32TxOutZ.
 */
void C2Tuple_u32TxOutZ_free(struct LDKC2Tuple_u32TxOutZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u32TxOutZZ_free(struct LDKCVec_C2Tuple_u32TxOutZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ from the contained elements.
 */
struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32TxOutZZ b);

/**
 * Frees any resources used by the C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ.
 */
void C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TransactionOutputsZ_free(struct LDKCVec_TransactionOutputsZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_BalanceZ_free(struct LDKCVec_BalanceZ _res);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelMonitorZ o);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ.
 */
void CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res);

/**
 * Creates a new CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneLightningErrorZ in the success state.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok(void);

/**
 * Creates a new CResult_NoneLightningErrorZ in the error state.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneLightningErrorZ_is_ok(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneLightningErrorZ.
 */
void CResult_NoneLightningErrorZ_free(struct LDKCResult_NoneLightningErrorZ _res);

/**
 * Creates a new CResult_NoneLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_clone(const struct LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PublicKeyTypeZ from the contained elements.
 */
struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_new(struct LDKPublicKey a, struct LDKType b);

/**
 * Frees any resources used by the C2Tuple_PublicKeyTypeZ.
 */
void C2Tuple_PublicKeyTypeZ_free(struct LDKC2Tuple_PublicKeyTypeZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_PublicKeyTypeZZ_free(struct LDKCVec_C2Tuple_PublicKeyTypeZZ _res);

/**
 * Creates a new CResult_boolLightningErrorZ in the success state.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(bool o);

/**
 * Creates a new CResult_boolLightningErrorZ in the error state.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_boolLightningErrorZ_is_ok(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_boolLightningErrorZ.
 */
void CResult_boolLightningErrorZ_free(struct LDKCResult_boolLightningErrorZ _res);

/**
 * Creates a new CResult_boolLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(const struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ from the contained elements.
 */
struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(struct LDKChannelAnnouncement a, struct LDKChannelUpdate b, struct LDKChannelUpdate c);

/**
 * Frees any resources used by the C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.
 */
void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_NodeAnnouncementZ_free(struct LDKCVec_NodeAnnouncementZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PublicKeyZ_free(struct LDKCVec_PublicKeyZ _res);

/**
 * Constructs a new COption_NetAddressZ containing a crate::lightning::ln::msgs::NetAddress
 */
struct LDKCOption_NetAddressZ COption_NetAddressZ_some(struct LDKNetAddress o);

/**
 * Constructs a new COption_NetAddressZ containing nothing
 */
struct LDKCOption_NetAddressZ COption_NetAddressZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::msgs::NetAddress, if we are in the Some state
 */
void COption_NetAddressZ_free(struct LDKCOption_NetAddressZ _res);

/**
 * Creates a new COption_NetAddressZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_NetAddressZ COption_NetAddressZ_clone(const struct LDKCOption_NetAddressZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the success state.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(struct LDKCVec_u8Z o);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the error state.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_u8ZPeerHandleErrorZ_is_ok(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_u8ZPeerHandleErrorZ.
 */
void CResult_CVec_u8ZPeerHandleErrorZ_free(struct LDKCResult_CVec_u8ZPeerHandleErrorZ _res);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NonePeerHandleErrorZ in the success state.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok(void);

/**
 * Creates a new CResult_NonePeerHandleErrorZ in the error state.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NonePeerHandleErrorZ_is_ok(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NonePeerHandleErrorZ.
 */
void CResult_NonePeerHandleErrorZ_free(struct LDKCResult_NonePeerHandleErrorZ _res);

/**
 * Creates a new CResult_NonePeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_boolPeerHandleErrorZ in the success state.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(bool o);

/**
 * Creates a new CResult_boolPeerHandleErrorZ in the error state.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_boolPeerHandleErrorZ_is_ok(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_boolPeerHandleErrorZ.
 */
void CResult_boolPeerHandleErrorZ_free(struct LDKCResult_boolPeerHandleErrorZ _res);

/**
 * Creates a new CResult_boolPeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_ok(struct LDKNodeId o);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeIdDecodeErrorZ_is_ok(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeIdDecodeErrorZ.
 */
void CResult_NodeIdDecodeErrorZ_free(struct LDKCResult_NodeIdDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_clone(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_ok(struct LDKCOption_NetworkUpdateZ o);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_NetworkUpdateZDecodeErrorZ.
 */
void CResult_COption_NetworkUpdateZDecodeErrorZ_free(struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_clone(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_AccessZ containing a crate::lightning::chain::Access
 */
struct LDKCOption_AccessZ COption_AccessZ_some(struct LDKAccess o);

/**
 * Constructs a new COption_AccessZ containing nothing
 */
struct LDKCOption_AccessZ COption_AccessZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::chain::Access, if we are in the Some state
 */
void COption_AccessZ_free(struct LDKCOption_AccessZ _res);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_ok(struct LDKChannelUpdateInfo o);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelUpdateInfoDecodeErrorZ.
 */
void CResult_ChannelUpdateInfoDecodeErrorZ_free(struct LDKCResult_ChannelUpdateInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(struct LDKChannelInfo o);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelInfoDecodeErrorZ.
 */
void CResult_ChannelInfoDecodeErrorZ_free(struct LDKCResult_ChannelInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ in the success state.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(struct LDKRoutingFees o);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ in the error state.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RoutingFeesDecodeErrorZ_is_ok(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RoutingFeesDecodeErrorZ.
 */
void CResult_RoutingFeesDecodeErrorZ_free(struct LDKCResult_RoutingFeesDecodeErrorZ _res);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_ok(struct LDKNodeAnnouncementInfo o);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeAnnouncementInfoDecodeErrorZ.
 */
void CResult_NodeAnnouncementInfoDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u64Z_free(struct LDKCVec_u64Z _res);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(struct LDKNodeInfo o);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeInfoDecodeErrorZ.
 */
void CResult_NodeInfoDecodeErrorZ_free(struct LDKCResult_NodeInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ in the success state.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(struct LDKNetworkGraph o);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ in the error state.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NetworkGraphDecodeErrorZ_is_ok(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NetworkGraphDecodeErrorZ.
 */
void CResult_NetworkGraphDecodeErrorZ_free(struct LDKCResult_NetworkGraphDecodeErrorZ _res);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_clone(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_CVec_NetAddressZZ containing a crate::c_types::derived::CVec_NetAddressZ
 */
struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_some(struct LDKCVec_NetAddressZ o);

/**
 * Constructs a new COption_CVec_NetAddressZZ containing nothing
 */
struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::CVec_NetAddressZ, if we are in the Some state
 */
void COption_CVec_NetAddressZZ_free(struct LDKCOption_CVec_NetAddressZZ _res);

/**
 * Creates a new COption_CVec_NetAddressZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_clone(const struct LDKCOption_CVec_NetAddressZZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ in the success state.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_ok(struct LDKNetAddress o);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ in the error state.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NetAddressDecodeErrorZ_is_ok(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NetAddressDecodeErrorZ.
 */
void CResult_NetAddressDecodeErrorZ_free(struct LDKCResult_NetAddressDecodeErrorZ _res);

/**
 * Creates a new CResult_NetAddressDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_clone(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateAddHTLCZ_free(struct LDKCVec_UpdateAddHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFulfillHTLCZ_free(struct LDKCVec_UpdateFulfillHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFailHTLCZ_free(struct LDKCVec_UpdateFailHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFailMalformedHTLCZ_free(struct LDKCVec_UpdateFailMalformedHTLCZ _res);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ in the success state.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(struct LDKAcceptChannel o);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ in the error state.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_AcceptChannelDecodeErrorZ_is_ok(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_AcceptChannelDecodeErrorZ.
 */
void CResult_AcceptChannelDecodeErrorZ_free(struct LDKCResult_AcceptChannelDecodeErrorZ _res);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_ok(struct LDKAnnouncementSignatures o);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_AnnouncementSignaturesDecodeErrorZ.
 */
void CResult_AnnouncementSignaturesDecodeErrorZ_free(struct LDKCResult_AnnouncementSignaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_clone(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_ok(struct LDKChannelReestablish o);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelReestablishDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelReestablishDecodeErrorZ.
 */
void CResult_ChannelReestablishDecodeErrorZ_free(struct LDKCResult_ChannelReestablishDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_clone(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(struct LDKClosingSigned o);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ClosingSignedDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ClosingSignedDecodeErrorZ.
 */
void CResult_ClosingSignedDecodeErrorZ_free(struct LDKCResult_ClosingSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(struct LDKClosingSignedFeeRange o);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ClosingSignedFeeRangeDecodeErrorZ.
 */
void CResult_ClosingSignedFeeRangeDecodeErrorZ_free(struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_ok(struct LDKCommitmentSigned o);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CommitmentSignedDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CommitmentSignedDecodeErrorZ.
 */
void CResult_CommitmentSignedDecodeErrorZ_free(struct LDKCResult_CommitmentSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_clone(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(struct LDKFundingCreated o);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FundingCreatedDecodeErrorZ_is_ok(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FundingCreatedDecodeErrorZ.
 */
void CResult_FundingCreatedDecodeErrorZ_free(struct LDKCResult_FundingCreatedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_clone(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(struct LDKFundingSigned o);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FundingSignedDecodeErrorZ_is_ok(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FundingSignedDecodeErrorZ.
 */
void CResult_FundingSignedDecodeErrorZ_free(struct LDKCResult_FundingSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingLockedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_ok(struct LDKFundingLocked o);

/**
 * Creates a new CResult_FundingLockedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FundingLockedDecodeErrorZ_is_ok(const struct LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FundingLockedDecodeErrorZ.
 */
void CResult_FundingLockedDecodeErrorZ_free(struct LDKCResult_FundingLockedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingLockedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_clone(const struct LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InitDecodeErrorZ in the success state.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(struct LDKInit o);

/**
 * Creates a new CResult_InitDecodeErrorZ in the error state.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InitDecodeErrorZ_is_ok(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InitDecodeErrorZ.
 */
void CResult_InitDecodeErrorZ_free(struct LDKCResult_InitDecodeErrorZ _res);

/**
 * Creates a new CResult_InitDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ in the success state.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(struct LDKOpenChannel o);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ in the error state.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OpenChannelDecodeErrorZ_is_ok(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OpenChannelDecodeErrorZ.
 */
void CResult_OpenChannelDecodeErrorZ_free(struct LDKCResult_OpenChannelDecodeErrorZ _res);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ in the success state.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(struct LDKRevokeAndACK o);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ in the error state.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RevokeAndACKDecodeErrorZ_is_ok(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RevokeAndACKDecodeErrorZ.
 */
void CResult_RevokeAndACKDecodeErrorZ_free(struct LDKCResult_RevokeAndACKDecodeErrorZ _res);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ in the success state.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(struct LDKShutdown o);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ in the error state.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownDecodeErrorZ.
 */
void CResult_ShutdownDecodeErrorZ_free(struct LDKCResult_ShutdownDecodeErrorZ _res);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(struct LDKUpdateFailHTLC o);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFailHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFailHTLCDecodeErrorZ.
 */
void CResult_UpdateFailHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(struct LDKUpdateFailMalformedHTLC o);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFailMalformedHTLCDecodeErrorZ.
 */
void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(struct LDKUpdateFee o);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFeeDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFeeDecodeErrorZ.
 */
void CResult_UpdateFeeDecodeErrorZ_free(struct LDKCResult_UpdateFeeDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_ok(struct LDKUpdateFulfillHTLC o);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFulfillHTLCDecodeErrorZ.
 */
void CResult_UpdateFulfillHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(struct LDKUpdateAddHTLC o);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateAddHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateAddHTLCDecodeErrorZ.
 */
void CResult_UpdateAddHTLCDecodeErrorZ_free(struct LDKCResult_UpdateAddHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PingDecodeErrorZ in the success state.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(struct LDKPing o);

/**
 * Creates a new CResult_PingDecodeErrorZ in the error state.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PingDecodeErrorZ_is_ok(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PingDecodeErrorZ.
 */
void CResult_PingDecodeErrorZ_free(struct LDKCResult_PingDecodeErrorZ _res);

/**
 * Creates a new CResult_PingDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PongDecodeErrorZ in the success state.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(struct LDKPong o);

/**
 * Creates a new CResult_PongDecodeErrorZ in the error state.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PongDecodeErrorZ_is_ok(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PongDecodeErrorZ.
 */
void CResult_PongDecodeErrorZ_free(struct LDKCResult_PongDecodeErrorZ _res);

/**
 * Creates a new CResult_PongDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(struct LDKUnsignedChannelAnnouncement o);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedChannelAnnouncementDecodeErrorZ.
 */
void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_ok(struct LDKChannelAnnouncement o);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelAnnouncementDecodeErrorZ.
 */
void CResult_ChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_ChannelAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_ok(struct LDKUnsignedChannelUpdate o);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedChannelUpdateDecodeErrorZ.
 */
void CResult_UnsignedChannelUpdateDecodeErrorZ_free(struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(struct LDKChannelUpdate o);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelUpdateDecodeErrorZ.
 */
void CResult_ChannelUpdateDecodeErrorZ_free(struct LDKCResult_ChannelUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(struct LDKErrorMessage o);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ErrorMessageDecodeErrorZ_is_ok(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ErrorMessageDecodeErrorZ.
 */
void CResult_ErrorMessageDecodeErrorZ_free(struct LDKCResult_ErrorMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_ok(struct LDKWarningMessage o);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_WarningMessageDecodeErrorZ_is_ok(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_WarningMessageDecodeErrorZ.
 */
void CResult_WarningMessageDecodeErrorZ_free(struct LDKCResult_WarningMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_clone(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(struct LDKUnsignedNodeAnnouncement o);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedNodeAnnouncementDecodeErrorZ.
 */
void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_ok(struct LDKNodeAnnouncement o);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeAnnouncementDecodeErrorZ.
 */
void CResult_NodeAnnouncementDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the success state.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_ok(struct LDKQueryShortChannelIds o);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the error state.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_QueryShortChannelIdsDecodeErrorZ.
 */
void CResult_QueryShortChannelIdsDecodeErrorZ_free(struct LDKCResult_QueryShortChannelIdsDecodeErrorZ _res);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_clone(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the success state.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(struct LDKReplyShortChannelIdsEnd o);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the error state.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ReplyShortChannelIdsEndDecodeErrorZ.
 */
void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_ok(struct LDKQueryChannelRange o);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_QueryChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_QueryChannelRangeDecodeErrorZ.
 */
void CResult_QueryChannelRangeDecodeErrorZ_free(struct LDKCResult_QueryChannelRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_clone(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_ok(struct LDKReplyChannelRange o);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ReplyChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ReplyChannelRangeDecodeErrorZ.
 */
void CResult_ReplyChannelRangeDecodeErrorZ_free(struct LDKCResult_ReplyChannelRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_clone(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the success state.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_ok(struct LDKGossipTimestampFilter o);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the error state.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_GossipTimestampFilterDecodeErrorZ_is_ok(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_GossipTimestampFilterDecodeErrorZ.
 */
void CResult_GossipTimestampFilterDecodeErrorZ_free(struct LDKCResult_GossipTimestampFilterDecodeErrorZ _res);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_clone(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PhantomRouteHintsZ_free(struct LDKCVec_PhantomRouteHintsZ _res);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ in the success state.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_ok(struct LDKInvoice o);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ in the error state.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_err(struct LDKSignOrCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceSignOrCreationErrorZ_is_ok(const struct LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceSignOrCreationErrorZ.
 */
void CResult_InvoiceSignOrCreationErrorZ_free(struct LDKCResult_InvoiceSignOrCreationErrorZ _res);

/**
 * Creates a new CResult_InvoiceSignOrCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_clone(const struct LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_FilterZ containing a crate::lightning::chain::Filter
 */
struct LDKCOption_FilterZ COption_FilterZ_some(struct LDKFilter o);

/**
 * Constructs a new COption_FilterZ containing nothing
 */
struct LDKCOption_FilterZ COption_FilterZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::chain::Filter, if we are in the Some state
 */
void COption_FilterZ_free(struct LDKCOption_FilterZ _res);

/**
 * Creates a new CResult_LockedChannelMonitorNoneZ in the success state.
 */
struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_ok(struct LDKLockedChannelMonitor o);

/**
 * Creates a new CResult_LockedChannelMonitorNoneZ in the error state.
 */
struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_LockedChannelMonitorNoneZ_is_ok(const struct LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_LockedChannelMonitorNoneZ.
 */
void CResult_LockedChannelMonitorNoneZ_free(struct LDKCResult_LockedChannelMonitorNoneZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_OutPointZ_free(struct LDKCVec_OutPointZ _res);

/**
 * Frees any resources used by the PaymentPurpose
 */
void PaymentPurpose_free(struct LDKPaymentPurpose this_ptr);

/**
 * Creates a copy of the PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_clone(const struct LDKPaymentPurpose *NONNULL_PTR orig);

/**
 * Utility method to constructs a new InvoicePayment-variant PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_invoice_payment(struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_secret);

/**
 * Utility method to constructs a new SpontaneousPayment-variant PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_spontaneous_payment(struct LDKThirtyTwoBytes a);

/**
 * Frees any resources used by the ClosureReason
 */
void ClosureReason_free(struct LDKClosureReason this_ptr);

/**
 * Creates a copy of the ClosureReason
 */
struct LDKClosureReason ClosureReason_clone(const struct LDKClosureReason *NONNULL_PTR orig);

/**
 * Utility method to constructs a new CounterpartyForceClosed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_counterparty_force_closed(struct LDKStr peer_msg);

/**
 * Utility method to constructs a new HolderForceClosed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_holder_force_closed(void);

/**
 * Utility method to constructs a new CooperativeClosure-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_cooperative_closure(void);

/**
 * Utility method to constructs a new CommitmentTxConfirmed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_commitment_tx_confirmed(void);

/**
 * Utility method to constructs a new FundingTimedOut-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_funding_timed_out(void);

/**
 * Utility method to constructs a new ProcessingError-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_processing_error(struct LDKStr err);

/**
 * Utility method to constructs a new DisconnectedPeer-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_disconnected_peer(void);

/**
 * Utility method to constructs a new OutdatedChannelManager-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_outdated_channel_manager(void);

/**
 * Serialize the ClosureReason object into a byte array which can be read by ClosureReason_read
 */
struct LDKCVec_u8Z ClosureReason_write(const struct LDKClosureReason *NONNULL_PTR obj);

/**
 * Read a ClosureReason from a byte array, created by ClosureReason_write
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ ClosureReason_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Event
 */
void Event_free(struct LDKEvent this_ptr);

/**
 * Creates a copy of the Event
 */
struct LDKEvent Event_clone(const struct LDKEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new FundingGenerationReady-variant Event
 */
struct LDKEvent Event_funding_generation_ready(struct LDKThirtyTwoBytes temporary_channel_id, uint64_t channel_value_satoshis, struct LDKCVec_u8Z output_script, uint64_t user_channel_id);

/**
 * Utility method to constructs a new PaymentReceived-variant Event
 */
struct LDKEvent Event_payment_received(struct LDKThirtyTwoBytes payment_hash, uint64_t amt, struct LDKPaymentPurpose purpose);

/**
 * Utility method to constructs a new PaymentSent-variant Event
 */
struct LDKEvent Event_payment_sent(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z fee_paid_msat);

/**
 * Utility method to constructs a new PaymentPathFailed-variant Event
 */
struct LDKEvent Event_payment_path_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, bool rejected_by_dest, struct LDKCOption_NetworkUpdateZ network_update, bool all_paths_failed, struct LDKCVec_RouteHopZ path, struct LDKCOption_u64Z short_channel_id, struct LDKRouteParameters retry);

/**
 * Utility method to constructs a new PaymentFailed-variant Event
 */
struct LDKEvent Event_payment_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash);

/**
 * Utility method to constructs a new PendingHTLCsForwardable-variant Event
 */
struct LDKEvent Event_pending_htlcs_forwardable(uint64_t time_forwardable);

/**
 * Utility method to constructs a new SpendableOutputs-variant Event
 */
struct LDKEvent Event_spendable_outputs(struct LDKCVec_SpendableOutputDescriptorZ outputs);

/**
 * Utility method to constructs a new PaymentForwarded-variant Event
 */
struct LDKEvent Event_payment_forwarded(struct LDKCOption_u64Z fee_earned_msat, bool claim_from_onchain_tx);

/**
 * Utility method to constructs a new ChannelClosed-variant Event
 */
struct LDKEvent Event_channel_closed(struct LDKThirtyTwoBytes channel_id, uint64_t user_channel_id, struct LDKClosureReason reason);

/**
 * Utility method to constructs a new DiscardFunding-variant Event
 */
struct LDKEvent Event_discard_funding(struct LDKThirtyTwoBytes channel_id, struct LDKTransaction transaction);

/**
 * Utility method to constructs a new PaymentPathSuccessful-variant Event
 */
struct LDKEvent Event_payment_path_successful(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKCVec_RouteHopZ path);

/**
 * Utility method to constructs a new OpenChannelRequest-variant Event
 */
struct LDKEvent Event_open_channel_request(struct LDKThirtyTwoBytes temporary_channel_id, struct LDKPublicKey counterparty_node_id, uint64_t funding_satoshis, uint64_t push_msat, struct LDKChannelTypeFeatures channel_type);

/**
 * Serialize the Event object into a byte array which can be read by Event_read
 */
struct LDKCVec_u8Z Event_write(const struct LDKEvent *NONNULL_PTR obj);

/**
 * Read a Event from a byte array, created by Event_write
 */
struct LDKCResult_COption_EventZDecodeErrorZ Event_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the MessageSendEvent
 */
void MessageSendEvent_free(struct LDKMessageSendEvent this_ptr);

/**
 * Creates a copy of the MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_clone(const struct LDKMessageSendEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SendAcceptChannel-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_accept_channel(struct LDKPublicKey node_id, struct LDKAcceptChannel msg);

/**
 * Utility method to constructs a new SendOpenChannel-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_open_channel(struct LDKPublicKey node_id, struct LDKOpenChannel msg);

/**
 * Utility method to constructs a new SendFundingCreated-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_funding_created(struct LDKPublicKey node_id, struct LDKFundingCreated msg);

/**
 * Utility method to constructs a new SendFundingSigned-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_funding_signed(struct LDKPublicKey node_id, struct LDKFundingSigned msg);

/**
 * Utility method to constructs a new SendFundingLocked-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_funding_locked(struct LDKPublicKey node_id, struct LDKFundingLocked msg);

/**
 * Utility method to constructs a new SendAnnouncementSignatures-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_announcement_signatures(struct LDKPublicKey node_id, struct LDKAnnouncementSignatures msg);

/**
 * Utility method to constructs a new UpdateHTLCs-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_update_htlcs(struct LDKPublicKey node_id, struct LDKCommitmentUpdate updates);

/**
 * Utility method to constructs a new SendRevokeAndACK-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_revoke_and_ack(struct LDKPublicKey node_id, struct LDKRevokeAndACK msg);

/**
 * Utility method to constructs a new SendClosingSigned-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_closing_signed(struct LDKPublicKey node_id, struct LDKClosingSigned msg);

/**
 * Utility method to constructs a new SendShutdown-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_shutdown(struct LDKPublicKey node_id, struct LDKShutdown msg);

/**
 * Utility method to constructs a new SendChannelReestablish-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_reestablish(struct LDKPublicKey node_id, struct LDKChannelReestablish msg);

/**
 * Utility method to constructs a new BroadcastChannelAnnouncement-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_announcement(struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);

/**
 * Utility method to constructs a new BroadcastNodeAnnouncement-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_broadcast_node_announcement(struct LDKNodeAnnouncement msg);

/**
 * Utility method to constructs a new BroadcastChannelUpdate-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_update(struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new SendChannelUpdate-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_update(struct LDKPublicKey node_id, struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new HandleError-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_handle_error(struct LDKPublicKey node_id, struct LDKErrorAction action);

/**
 * Utility method to constructs a new SendChannelRangeQuery-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_range_query(struct LDKPublicKey node_id, struct LDKQueryChannelRange msg);

/**
 * Utility method to constructs a new SendShortIdsQuery-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_short_ids_query(struct LDKPublicKey node_id, struct LDKQueryShortChannelIds msg);

/**
 * Utility method to constructs a new SendReplyChannelRange-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_reply_channel_range(struct LDKPublicKey node_id, struct LDKReplyChannelRange msg);

/**
 * Utility method to constructs a new SendGossipTimestampFilter-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_gossip_timestamp_filter(struct LDKPublicKey node_id, struct LDKGossipTimestampFilter msg);

/**
 * Calls the free function if one is set
 */
void MessageSendEventsProvider_free(struct LDKMessageSendEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventsProvider_free(struct LDKEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventHandler_free(struct LDKEventHandler this_ptr);

/**
 * Frees any resources used by the APIError
 */
void APIError_free(struct LDKAPIError this_ptr);

/**
 * Creates a copy of the APIError
 */
struct LDKAPIError APIError_clone(const struct LDKAPIError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new APIMisuseError-variant APIError
 */
struct LDKAPIError APIError_apimisuse_error(struct LDKStr err);

/**
 * Utility method to constructs a new FeeRateTooHigh-variant APIError
 */
struct LDKAPIError APIError_fee_rate_too_high(struct LDKStr err, uint32_t feerate);

/**
 * Utility method to constructs a new RouteError-variant APIError
 */
struct LDKAPIError APIError_route_error(struct LDKStr err);

/**
 * Utility method to constructs a new ChannelUnavailable-variant APIError
 */
struct LDKAPIError APIError_channel_unavailable(struct LDKStr err);

/**
 * Utility method to constructs a new MonitorUpdateFailed-variant APIError
 */
struct LDKAPIError APIError_monitor_update_failed(void);

/**
 * Utility method to constructs a new IncompatibleShutdownScript-variant APIError
 */
struct LDKAPIError APIError_incompatible_shutdown_script(struct LDKShutdownScript script);

/**
 * Creates a digital signature of a message given a SecretKey, like the node's secret.
 * A receiver knowing the PublicKey (e.g. the node's id) and the message can be sure that the signature was generated by the caller.
 * Signatures are EC recoverable, meaning that given the message and the signature the PublicKey of the signer can be extracted.
 */
struct LDKCResult_StringErrorZ sign(struct LDKu8slice msg, const uint8_t (*sk)[32]);

/**
 * Recovers the PublicKey of the signer of the message given the message and the signature.
 */
struct LDKCResult_PublicKeyErrorZ recover_pk(struct LDKu8slice msg, struct LDKStr sig);

/**
 * Verifies a message was signed by a PrivateKey that derives to a given PublicKey, given a message, a signature,
 * and the PublicKey.
 */
bool verify(struct LDKu8slice msg, struct LDKStr sig, struct LDKPublicKey pk);

/**
 * Construct the invoice's HRP and signatureless data into a preimage to be hashed.
 */
struct LDKCVec_u8Z construct_invoice_preimage(struct LDKu8slice hrp_bytes, struct LDKCVec_u5Z data_without_signature);

/**
 * Creates a copy of the Level
 */
enum LDKLevel Level_clone(const enum LDKLevel *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Gossip-variant Level
 */
enum LDKLevel Level_gossip(void);

/**
 * Utility method to constructs a new Trace-variant Level
 */
enum LDKLevel Level_trace(void);

/**
 * Utility method to constructs a new Debug-variant Level
 */
enum LDKLevel Level_debug(void);

/**
 * Utility method to constructs a new Info-variant Level
 */
enum LDKLevel Level_info(void);

/**
 * Utility method to constructs a new Warn-variant Level
 */
enum LDKLevel Level_warn(void);

/**
 * Utility method to constructs a new Error-variant Level
 */
enum LDKLevel Level_error(void);

/**
 * Checks if two Levels contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Level_eq(const enum LDKLevel *NONNULL_PTR a, const enum LDKLevel *NONNULL_PTR b);

/**
 * Checks if two Levels contain equal inner contents.
 */
uint64_t Level_hash(const enum LDKLevel *NONNULL_PTR o);

/**
 * Returns the most verbose logging level.
 */
MUST_USE_RES enum LDKLevel Level_max(void);

/**
 * Frees any resources used by the Record, if is_owned is set and inner is non-NULL.
 */
void Record_free(struct LDKRecord this_obj);

/**
 * The verbosity level of the message.
 */
enum LDKLevel Record_get_level(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The verbosity level of the message.
 */
void Record_set_level(struct LDKRecord *NONNULL_PTR this_ptr, enum LDKLevel val);

/**
 * The message body.
 */
struct LDKStr Record_get_args(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The message body.
 */
void Record_set_args(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The module path of the message.
 */
struct LDKStr Record_get_module_path(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The module path of the message.
 */
void Record_set_module_path(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The source file containing the message.
 */
struct LDKStr Record_get_file(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The source file containing the message.
 */
void Record_set_file(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The line containing the message.
 */
uint32_t Record_get_line(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The line containing the message.
 */
void Record_set_line(struct LDKRecord *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the Record
 */
struct LDKRecord Record_clone(const struct LDKRecord *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Logger_free(struct LDKLogger this_ptr);

/**
 * Frees any resources used by the ChannelHandshakeConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeConfig_free(struct LDKChannelHandshakeConfig this_obj);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * Default value: 6.
 */
uint32_t ChannelHandshakeConfig_get_minimum_depth(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * Default value: 6.
 */
void ChannelHandshakeConfig_set_minimum_depth(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to the number of blocks we require our counterparty to wait to claim their money (ie
 * the number of blocks we have to punish our counterparty if they broadcast a revoked
 * transaction).
 *
 * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
 * be online to check for revoked transactions on-chain at least once every our_to_self_delay
 * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
 * possibly with time in between to RBF the spending transaction).
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
 * can tweak config to ask for more security, not less.
 */
uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the number of blocks we require our counterparty to wait to claim their money (ie
 * the number of blocks we have to punish our counterparty if they broadcast a revoked
 * transaction).
 *
 * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
 * be online to check for revoked transactions on-chain at least once every our_to_self_delay
 * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
 * possibly with time in between to RBF the spending transaction).
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
 * can tweak config to ask for more security, not less.
 */
void ChannelHandshakeConfig_set_our_to_self_delay(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
void ChannelHandshakeConfig_set_our_htlc_minimum_msat(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * If set, we attempt to negotiate the `scid_privacy` (referred to as `scid_alias` in the
 * BOLTs) option for outbound private channels. This provides better privacy by not including
 * our real on-chain channel UTXO in each invoice and requiring that our counterparty only
 * relay HTLCs to us using the channel's SCID alias.
 *
 * If this option is set, channels may be created that will not be readable by LDK versions
 * prior to 0.0.106, causing [`ChannelManager`]'s read method to return a
 * [`DecodeError:InvalidValue`].
 *
 * Note that setting this to true does *not* prevent us from opening channels with
 * counterparties that do not support the `scid_alias` option; we will simply fall back to a
 * private channel without that option.
 *
 * Ignored if the channel is negotiated to be announced, see
 * [`ChannelConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`] for more.
 *
 * Default value: false. This value is likely to change to true in the future.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`DecodeError:InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
 */
bool ChannelHandshakeConfig_get_negotiate_scid_privacy(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * If set, we attempt to negotiate the `scid_privacy` (referred to as `scid_alias` in the
 * BOLTs) option for outbound private channels. This provides better privacy by not including
 * our real on-chain channel UTXO in each invoice and requiring that our counterparty only
 * relay HTLCs to us using the channel's SCID alias.
 *
 * If this option is set, channels may be created that will not be readable by LDK versions
 * prior to 0.0.106, causing [`ChannelManager`]'s read method to return a
 * [`DecodeError:InvalidValue`].
 *
 * Note that setting this to true does *not* prevent us from opening channels with
 * counterparties that do not support the `scid_alias` option; we will simply fall back to a
 * private channel without that option.
 *
 * Ignored if the channel is negotiated to be announced, see
 * [`ChannelConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`] for more.
 *
 * Default value: false. This value is likely to change to true in the future.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`DecodeError:InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
 */
void ChannelHandshakeConfig_set_negotiate_scid_privacy(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ChannelHandshakeConfig given each field
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg, bool negotiate_scid_privacy_arg);

/**
 * Creates a copy of the ChannelHandshakeConfig
 */
struct LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(const struct LDKChannelHandshakeConfig *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);

/**
 * Frees any resources used by the ChannelHandshakeLimits, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeLimits_free(struct LDKChannelHandshakeLimits this_obj);

/**
 * Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_htlc_minimum_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_accepted_htlcs(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
void ChannelHandshakeLimits_set_max_minimum_depth(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to force an incoming channel to match our announced channel preference in
 * [`ChannelConfig::announced_channel`].
 *
 * For a node which is not online reliably, this should be set to true and
 * [`ChannelConfig::announced_channel`] set to false, ensuring that no announced (aka public)
 * channels will ever be opened.
 *
 * Default value: true.
 */
bool ChannelHandshakeLimits_get_force_announced_channel_preference(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to force an incoming channel to match our announced channel preference in
 * [`ChannelConfig::announced_channel`].
 *
 * For a node which is not online reliably, this should be set to true and
 * [`ChannelConfig::announced_channel`] set to false, ensuring that no announced (aka public)
 * channels will ever be opened.
 *
 * Default value: true.
 */
void ChannelHandshakeLimits_set_force_announced_channel_preference(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
void ChannelHandshakeLimits_set_their_to_self_delay(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new ChannelHandshakeLimits given each field
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint32_t max_minimum_depth_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);

/**
 * Creates a copy of the ChannelHandshakeLimits
 */
struct LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(const struct LDKChannelHandshakeLimits *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeLimits. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);

/**
 * Frees any resources used by the ChannelConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelConfig_free(struct LDKChannelConfig this_obj);

/**
 * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
 * over the channel.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
uint32_t ChannelConfig_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
 * over the channel.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
void ChannelConfig_set_forwarding_fee_proportional_millionths(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
 * excess of [`forwarding_fee_proportional_millionths`].
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * The default value of a single satoshi roughly matches the market rate on many routing nodes
 * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
 * this node.
 *
 * Default value: 1000.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 */
uint32_t ChannelConfig_get_forwarding_fee_base_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
 * excess of [`forwarding_fee_proportional_millionths`].
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * The default value of a single satoshi roughly matches the market rate on many routing nodes
 * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
 * this node.
 *
 * Default value: 1000.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 */
void ChannelConfig_set_forwarding_fee_base_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
 * the channel this config applies to.
 *
 * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
 * HTLC balance when a channel appears on-chain whereas
 * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
 * (non-HTLC-encumbered) balance.
 *
 * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
 * we (or one of our watchtowers) MUST be online to check for broadcast of the current
 * commitment transaction at least once per this many blocks (minus some margin to allow us
 * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
 * the spending transaction).
 *
 * Default value: 72 (12 hours at an average of 6 blocks/hour).
 * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
 *                [`MIN_CLTV_EXPIRY_DELTA`] instead.
 *
 * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
 */
uint16_t ChannelConfig_get_cltv_expiry_delta(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
 * the channel this config applies to.
 *
 * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
 * HTLC balance when a channel appears on-chain whereas
 * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
 * (non-HTLC-encumbered) balance.
 *
 * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
 * we (or one of our watchtowers) MUST be online to check for broadcast of the current
 * commitment transaction at least once per this many blocks (minus some margin to allow us
 * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
 * the spending transaction).
 *
 * Default value: 72 (12 hours at an average of 6 blocks/hour).
 * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
 *                [`MIN_CLTV_EXPIRY_DELTA`] instead.
 *
 * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
 */
void ChannelConfig_set_cltv_expiry_delta(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
 *
 * This cannot be changed after the initial channel handshake.
 *
 * Default value: false.
 */
bool ChannelConfig_get_announced_channel(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
 *
 * This cannot be changed after the initial channel handshake.
 *
 * Default value: false.
 */
void ChannelConfig_set_announced_channel(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * This cannot be changed after a channel has been initialized.
 *
 * Default value: true.
 */
bool ChannelConfig_get_commit_upfront_shutdown_pubkey(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * This cannot be changed after a channel has been initialized.
 *
 * Default value: true.
 */
void ChannelConfig_set_commit_upfront_shutdown_pubkey(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
 * small to claim on-chain.
 *
 * When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
 * not be claimable on-chain, instead being turned into additional miner fees if either
 * party force-closes the channel. Because the threshold is per-HTLC, our total exposure
 * to such payments may be sustantial if there are many dust HTLCs present when the
 * channel is force-closed.
 *
 * This limit is applied for sent, forwarded, and received HTLCs and limits the total
 * exposure across all three types per-channel. Setting this too low may prevent the
 * sending or receipt of low-value HTLCs on high-traffic nodes, and this limit is very
 * important to prevent stealing of dust HTLCs by miners.
 *
 * Default value: 5_000_000 msat.
 */
uint64_t ChannelConfig_get_max_dust_htlc_exposure_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
 * small to claim on-chain.
 *
 * When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
 * not be claimable on-chain, instead being turned into additional miner fees if either
 * party force-closes the channel. Because the threshold is per-HTLC, our total exposure
 * to such payments may be sustantial if there are many dust HTLCs present when the
 * channel is force-closed.
 *
 * This limit is applied for sent, forwarded, and received HTLCs and limits the total
 * exposure across all three types per-channel. Setting this too low may prevent the
 * sending or receipt of low-value HTLCs on high-traffic nodes, and this limit is very
 * important to prevent stealing of dust HTLCs by miners.
 *
 * Default value: 5_000_000 msat.
 */
void ChannelConfig_set_max_dust_htlc_exposure_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The additional fee we're willing to pay to avoid waiting for the counterparty's
 * `to_self_delay` to reclaim funds.
 *
 * When we close a channel cooperatively with our counterparty, we negotiate a fee for the
 * closing transaction which both sides find acceptable, ultimately paid by the channel
 * funder/initiator.
 *
 * When we are the funder, because we have to pay the channel closing fee, we bound the
 * acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
 * this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
 * [`Normal`] feerate during normal operation, this value represents the additional fee we're
 * willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
 * funds.
 *
 * When we are not the funder, we require the closing transaction fee pay at least our
 * [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
 * Thus, this value is ignored when we are not the funder.
 *
 * Default value: 1000 satoshis.
 *
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 */
uint64_t ChannelConfig_get_force_close_avoidance_max_fee_satoshis(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * The additional fee we're willing to pay to avoid waiting for the counterparty's
 * `to_self_delay` to reclaim funds.
 *
 * When we close a channel cooperatively with our counterparty, we negotiate a fee for the
 * closing transaction which both sides find acceptable, ultimately paid by the channel
 * funder/initiator.
 *
 * When we are the funder, because we have to pay the channel closing fee, we bound the
 * acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
 * this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
 * [`Normal`] feerate during normal operation, this value represents the additional fee we're
 * willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
 * funds.
 *
 * When we are not the funder, we require the closing transaction fee pay at least our
 * [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
 * Thus, this value is ignored when we are not the funder.
 *
 * Default value: 1000 satoshis.
 *
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 */
void ChannelConfig_set_force_close_avoidance_max_fee_satoshis(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ChannelConfig given each field
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_new(uint32_t forwarding_fee_proportional_millionths_arg, uint32_t forwarding_fee_base_msat_arg, uint16_t cltv_expiry_delta_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg, uint64_t max_dust_htlc_exposure_msat_arg, uint64_t force_close_avoidance_max_fee_satoshis_arg);

/**
 * Creates a copy of the ChannelConfig
 */
struct LDKChannelConfig ChannelConfig_clone(const struct LDKChannelConfig *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_default(void);

/**
 * Serialize the ChannelConfig object into a byte array which can be read by ChannelConfig_read
 */
struct LDKCVec_u8Z ChannelConfig_write(const struct LDKChannelConfig *NONNULL_PTR obj);

/**
 * Read a ChannelConfig from a byte array, created by ChannelConfig_write
 */
struct LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UserConfig, if is_owned is set and inner is non-NULL.
 */
void UserConfig_free(struct LDKUserConfig this_obj);

/**
 * Channel config that we propose to our counterparty.
 */
struct LDKChannelHandshakeConfig UserConfig_get_own_channel_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel config that we propose to our counterparty.
 */
void UserConfig_set_own_channel_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeConfig val);

/**
 * Limits applied to our counterparty's proposed channel config settings.
 */
struct LDKChannelHandshakeLimits UserConfig_get_peer_channel_config_limits(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Limits applied to our counterparty's proposed channel config settings.
 */
void UserConfig_set_peer_channel_config_limits(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeLimits val);

/**
 * Channel config which affects behavior during channel lifetime.
 */
struct LDKChannelConfig UserConfig_get_channel_options(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel config which affects behavior during channel lifetime.
 */
void UserConfig_set_channel_options(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelConfig val);

/**
 * If this is set to false, we will reject any HTLCs which were to be forwarded over private
 * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
 * node which is not online reliably.
 *
 * For nodes which are not online reliably, you should set all channels to *not* be announced
 * (using [`ChannelConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
 * ensure you are not exposed to any forwarding risk.
 *
 * Note that because you cannot change a channel's announced state after creation, there is no
 * way to disable forwarding on public channels retroactively. Thus, in order to change a node
 * from a publicly-announced forwarding node to a private non-forwarding node you must close
 * all your channels and open new ones. For privacy, you should also change your node_id
 * (swapping all private and public key material for new ones) at that time.
 *
 * Default value: false.
 */
bool UserConfig_get_accept_forwards_to_priv_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to false, we will reject any HTLCs which were to be forwarded over private
 * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
 * node which is not online reliably.
 *
 * For nodes which are not online reliably, you should set all channels to *not* be announced
 * (using [`ChannelConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
 * ensure you are not exposed to any forwarding risk.
 *
 * Note that because you cannot change a channel's announced state after creation, there is no
 * way to disable forwarding on public channels retroactively. Thus, in order to change a node
 * from a publicly-announced forwarding node to a private non-forwarding node you must close
 * all your channels and open new ones. For privacy, you should also change your node_id
 * (swapping all private and public key material for new ones) at that time.
 *
 * Default value: false.
 */
void UserConfig_set_accept_forwards_to_priv_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * If this is set to false, we do not accept inbound requests to open a new channel.
 * Default value: true.
 */
bool UserConfig_get_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to false, we do not accept inbound requests to open a new channel.
 * Default value: true.
 */
void UserConfig_set_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * If this is set to true, the user needs to manually accept inbound requests to open a new
 * channel.
 *
 * When set to true, [`Event::OpenChannelRequest`] will be triggered once a request to open a
 * new inbound channel is received through a [`msgs::OpenChannel`] message. In that case, a
 * [`msgs::AcceptChannel`] message will not be sent back to the counterparty node unless the
 * user explicitly chooses to accept the request.
 *
 * Default value: false.
 *
 * [`Event::OpenChannelRequest`]: crate::util::events::Event::OpenChannelRequest
 * [`msgs::OpenChannel`]: crate::ln::msgs::OpenChannel
 * [`msgs::AcceptChannel`]: crate::ln::msgs::AcceptChannel
 */
bool UserConfig_get_manually_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to true, the user needs to manually accept inbound requests to open a new
 * channel.
 *
 * When set to true, [`Event::OpenChannelRequest`] will be triggered once a request to open a
 * new inbound channel is received through a [`msgs::OpenChannel`] message. In that case, a
 * [`msgs::AcceptChannel`] message will not be sent back to the counterparty node unless the
 * user explicitly chooses to accept the request.
 *
 * Default value: false.
 *
 * [`Event::OpenChannelRequest`]: crate::util::events::Event::OpenChannelRequest
 * [`msgs::OpenChannel`]: crate::ln::msgs::OpenChannel
 * [`msgs::AcceptChannel`]: crate::ln::msgs::AcceptChannel
 */
void UserConfig_set_manually_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new UserConfig given each field
 */
MUST_USE_RES struct LDKUserConfig UserConfig_new(struct LDKChannelHandshakeConfig own_channel_config_arg, struct LDKChannelHandshakeLimits peer_channel_config_limits_arg, struct LDKChannelConfig channel_options_arg, bool accept_forwards_to_priv_channels_arg, bool accept_inbound_channels_arg, bool manually_accept_inbound_channels_arg);

/**
 * Creates a copy of the UserConfig
 */
struct LDKUserConfig UserConfig_clone(const struct LDKUserConfig *NONNULL_PTR orig);

/**
 * Creates a "default" UserConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKUserConfig UserConfig_default(void);

/**
 * Frees any resources used by the BestBlock, if is_owned is set and inner is non-NULL.
 */
void BestBlock_free(struct LDKBestBlock this_obj);

/**
 * Creates a copy of the BestBlock
 */
struct LDKBestBlock BestBlock_clone(const struct LDKBestBlock *NONNULL_PTR orig);

/**
 * Constructs a `BestBlock` that represents the genesis block at height 0 of the given
 * network.
 */
MUST_USE_RES struct LDKBestBlock BestBlock_from_genesis(enum LDKNetwork network);

/**
 * Returns a `BestBlock` as identified by the given block hash and height.
 */
MUST_USE_RES struct LDKBestBlock BestBlock_new(struct LDKThirtyTwoBytes block_hash, uint32_t height);

/**
 * Returns the best block hash.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BestBlock_block_hash(const struct LDKBestBlock *NONNULL_PTR this_arg);

/**
 * Returns the best block height.
 */
MUST_USE_RES uint32_t BestBlock_height(const struct LDKBestBlock *NONNULL_PTR this_arg);

/**
 * Creates a copy of the AccessError
 */
enum LDKAccessError AccessError_clone(const enum LDKAccessError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new UnknownChain-variant AccessError
 */
enum LDKAccessError AccessError_unknown_chain(void);

/**
 * Utility method to constructs a new UnknownTx-variant AccessError
 */
enum LDKAccessError AccessError_unknown_tx(void);

/**
 * Calls the free function if one is set
 */
void Access_free(struct LDKAccess this_ptr);

/**
 * Calls the free function if one is set
 */
void Listen_free(struct LDKListen this_ptr);

/**
 * Calls the free function if one is set
 */
void Confirm_free(struct LDKConfirm this_ptr);

/**
 * Creates a copy of the ChannelMonitorUpdateErr
 */
enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_clone(const enum LDKChannelMonitorUpdateErr *NONNULL_PTR orig);

/**
 * Utility method to constructs a new TemporaryFailure-variant ChannelMonitorUpdateErr
 */
enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_temporary_failure(void);

/**
 * Utility method to constructs a new PermanentFailure-variant ChannelMonitorUpdateErr
 */
enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_permanent_failure(void);

/**
 * Calls the free function if one is set
 */
void Watch_free(struct LDKWatch this_ptr);

/**
 * Calls the free function if one is set
 */
void Filter_free(struct LDKFilter this_ptr);

/**
 * Frees any resources used by the WatchedOutput, if is_owned is set and inner is non-NULL.
 */
void WatchedOutput_free(struct LDKWatchedOutput this_obj);

/**
 * First block where the transaction output may have been spent.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKThirtyTwoBytes WatchedOutput_get_block_hash(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * First block where the transaction output may have been spent.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void WatchedOutput_set_block_hash(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Outpoint identifying the transaction output.
 */
struct LDKOutPoint WatchedOutput_get_outpoint(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * Outpoint identifying the transaction output.
 */
void WatchedOutput_set_outpoint(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Spending condition of the transaction output.
 */
struct LDKu8slice WatchedOutput_get_script_pubkey(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * Spending condition of the transaction output.
 */
void WatchedOutput_set_script_pubkey(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new WatchedOutput given each field
 */
MUST_USE_RES struct LDKWatchedOutput WatchedOutput_new(struct LDKThirtyTwoBytes block_hash_arg, struct LDKOutPoint outpoint_arg, struct LDKCVec_u8Z script_pubkey_arg);

/**
 * Creates a copy of the WatchedOutput
 */
struct LDKWatchedOutput WatchedOutput_clone(const struct LDKWatchedOutput *NONNULL_PTR orig);

/**
 * Checks if two WatchedOutputs contain equal inner contents.
 */
uint64_t WatchedOutput_hash(const struct LDKWatchedOutput *NONNULL_PTR o);

/**
 * Calls the free function if one is set
 */
void BroadcasterInterface_free(struct LDKBroadcasterInterface this_ptr);

/**
 * Creates a copy of the ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_clone(const enum LDKConfirmationTarget *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Background-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_background(void);

/**
 * Utility method to constructs a new Normal-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_normal(void);

/**
 * Utility method to constructs a new HighPriority-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_high_priority(void);

/**
 * Checks if two ConfirmationTargets contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ConfirmationTarget_eq(const enum LDKConfirmationTarget *NONNULL_PTR a, const enum LDKConfirmationTarget *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void FeeEstimator_free(struct LDKFeeEstimator this_ptr);

/**
 * Frees any resources used by the MonitorUpdateId, if is_owned is set and inner is non-NULL.
 */
void MonitorUpdateId_free(struct LDKMonitorUpdateId this_obj);

/**
 * Creates a copy of the MonitorUpdateId
 */
struct LDKMonitorUpdateId MonitorUpdateId_clone(const struct LDKMonitorUpdateId *NONNULL_PTR orig);

/**
 * Checks if two MonitorUpdateIds contain equal inner contents.
 */
uint64_t MonitorUpdateId_hash(const struct LDKMonitorUpdateId *NONNULL_PTR o);

/**
 * Checks if two MonitorUpdateIds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool MonitorUpdateId_eq(const struct LDKMonitorUpdateId *NONNULL_PTR a, const struct LDKMonitorUpdateId *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void Persist_free(struct LDKPersist this_ptr);

/**
 * Frees any resources used by the LockedChannelMonitor, if is_owned is set and inner is non-NULL.
 */
void LockedChannelMonitor_free(struct LDKLockedChannelMonitor this_obj);

/**
 * Frees any resources used by the ChainMonitor, if is_owned is set and inner is non-NULL.
 */
void ChainMonitor_free(struct LDKChainMonitor this_obj);

/**
 * Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
 *
 * When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
 * will call back to it indicating transactions and outputs of interest. This allows clients to
 * pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
 * always need to fetch full blocks absent another means for determining which blocks contain
 * transactions relevant to the watched channels.
 */
MUST_USE_RES struct LDKChainMonitor ChainMonitor_new(struct LDKCOption_FilterZ chain_source, struct LDKBroadcasterInterface broadcaster, struct LDKLogger logger, struct LDKFeeEstimator feeest, struct LDKPersist persister);

/**
 * Gets the balances in the contained [`ChannelMonitor`]s which are claimable on-chain or
 * claims which are awaiting confirmation.
 *
 * Includes the balances from each [`ChannelMonitor`] *except* those included in
 * `ignored_channels`, allowing you to filter out balances from channels which are still open
 * (and whose balance should likely be pulled from the [`ChannelDetails`]).
 *
 * See [`ChannelMonitor::get_claimable_balances`] for more details on the exact criteria for
 * inclusion in the return value.
 */
MUST_USE_RES struct LDKCVec_BalanceZ ChainMonitor_get_claimable_balances(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKCVec_ChannelDetailsZ ignored_channels);

/**
 * Gets the [`LockedChannelMonitor`] for a given funding outpoint, returning an `Err` if no
 * such [`ChannelMonitor`] is currently being monitored for.
 *
 * Note that the result holds a mutex over our monitor set, and should not be held
 * indefinitely.
 */
MUST_USE_RES struct LDKCResult_LockedChannelMonitorNoneZ ChainMonitor_get_monitor(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo);

/**
 * Lists the funding outpoint of each [`ChannelMonitor`] being monitored.
 *
 * Note that [`ChannelMonitor`]s are not removed when a channel is closed as they are always
 * monitoring for on-chain state resolutions.
 */
MUST_USE_RES struct LDKCVec_OutPointZ ChainMonitor_list_monitors(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Indicates the persistence of a [`ChannelMonitor`] has completed after
 * [`ChannelMonitorUpdateErr::TemporaryFailure`] was returned from an update operation.
 *
 * Thus, the anticipated use is, at a high level:
 *  1) This [`ChainMonitor`] calls [`Persist::update_persisted_channel`] which stores the
 *     update to disk and begins updating any remote (e.g. watchtower/backup) copies,
 *     returning [`ChannelMonitorUpdateErr::TemporaryFailure`],
 *  2) once all remote copies are updated, you call this function with the
 *     `completed_update_id` that completed, and once all pending updates have completed the
 *     channel will be re-enabled.
 *
 * Returns an [`APIError::APIMisuseError`] if `funding_txo` does not match any currently
 * registered [`ChannelMonitor`]s.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChainMonitor_channel_monitor_updated(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKMonitorUpdateId completed_update_id);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChainMonitor_as_Listen(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Confirm which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
 */
struct LDKConfirm ChainMonitor_as_Confirm(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Watch which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
 */
struct LDKWatch ChainMonitor_as_Watch(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChainMonitor_as_EventsProvider(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelMonitorUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitorUpdate_free(struct LDKChannelMonitorUpdate this_obj);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with one exception specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instance where update_id values are not strictly increasing is the case where we
 * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
 * its docs for more details.
 */
uint64_t ChannelMonitorUpdate_get_update_id(const struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with one exception specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instance where update_id values are not strictly increasing is the case where we
 * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
 * its docs for more details.
 */
void ChannelMonitorUpdate_set_update_id(struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelMonitorUpdate
 */
struct LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(const struct LDKChannelMonitorUpdate *NONNULL_PTR orig);

/**
 * Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
 */
struct LDKCVec_u8Z ChannelMonitorUpdate_write(const struct LDKChannelMonitorUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the MonitorEvent
 */
void MonitorEvent_free(struct LDKMonitorEvent this_ptr);

/**
 * Creates a copy of the MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_clone(const struct LDKMonitorEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new HTLCEvent-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_htlcevent(struct LDKHTLCUpdate a);

/**
 * Utility method to constructs a new CommitmentTxConfirmed-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_commitment_tx_confirmed(struct LDKOutPoint a);

/**
 * Utility method to constructs a new UpdateCompleted-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_update_completed(struct LDKOutPoint funding_txo, uint64_t monitor_update_id);

/**
 * Utility method to constructs a new UpdateFailed-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_update_failed(struct LDKOutPoint a);

/**
 * Serialize the MonitorEvent object into a byte array which can be read by MonitorEvent_read
 */
struct LDKCVec_u8Z MonitorEvent_write(const struct LDKMonitorEvent *NONNULL_PTR obj);

/**
 * Read a MonitorEvent from a byte array, created by MonitorEvent_write
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ MonitorEvent_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the HTLCUpdate, if is_owned is set and inner is non-NULL.
 */
void HTLCUpdate_free(struct LDKHTLCUpdate this_obj);

/**
 * Creates a copy of the HTLCUpdate
 */
struct LDKHTLCUpdate HTLCUpdate_clone(const struct LDKHTLCUpdate *NONNULL_PTR orig);

/**
 * Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
 */
struct LDKCVec_u8Z HTLCUpdate_write(const struct LDKHTLCUpdate *NONNULL_PTR obj);

/**
 * Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Balance
 */
void Balance_free(struct LDKBalance this_ptr);

/**
 * Creates a copy of the Balance
 */
struct LDKBalance Balance_clone(const struct LDKBalance *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ClaimableOnChannelClose-variant Balance
 */
struct LDKBalance Balance_claimable_on_channel_close(uint64_t claimable_amount_satoshis);

/**
 * Utility method to constructs a new ClaimableAwaitingConfirmations-variant Balance
 */
struct LDKBalance Balance_claimable_awaiting_confirmations(uint64_t claimable_amount_satoshis, uint32_t confirmation_height);

/**
 * Utility method to constructs a new ContentiousClaimable-variant Balance
 */
struct LDKBalance Balance_contentious_claimable(uint64_t claimable_amount_satoshis, uint32_t timeout_height);

/**
 * Utility method to constructs a new MaybeClaimableHTLCAwaitingTimeout-variant Balance
 */
struct LDKBalance Balance_maybe_claimable_htlcawaiting_timeout(uint64_t claimable_amount_satoshis, uint32_t claimable_height);

/**
 * Checks if two Balances contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Balance_eq(const struct LDKBalance *NONNULL_PTR a, const struct LDKBalance *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelMonitor, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitor_free(struct LDKChannelMonitor this_obj);

/**
 * Creates a copy of the ChannelMonitor
 */
struct LDKChannelMonitor ChannelMonitor_clone(const struct LDKChannelMonitor *NONNULL_PTR orig);

/**
 * Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
 */
struct LDKCVec_u8Z ChannelMonitor_write(const struct LDKChannelMonitor *NONNULL_PTR obj);

/**
 * Updates a ChannelMonitor on the basis of some new information provided by the Channel
 * itself.
 *
 * panics if the given update is not the next update by update_id.
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelMonitor_update_monitor(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR updates, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, const struct LDKFeeEstimator *NONNULL_PTR fee_estimator, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
 * ChannelMonitor.
 */
MUST_USE_RES uint64_t ChannelMonitor_get_latest_update_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
 */
MUST_USE_RES struct LDKC2Tuple_OutPointScriptZ ChannelMonitor_get_funding_txo(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets a list of txids, with their output scripts (in the order they appear in the
 * transaction), which we must learn about spends of via block_connected().
 */
MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ChannelMonitor_get_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
 * calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
 * have been registered.
 */
void ChannelMonitor_load_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKFilter *NONNULL_PTR filter);

/**
 * Get the list of HTLCs who's status has been updated on chain. This should be called by
 * ChannelManager via [`chain::Watch::release_pending_monitor_events`].
 */
MUST_USE_RES struct LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the list of pending events which were generated by previous actions, clearing the list
 * in the process.
 *
 * This is called by ChainMonitor::get_and_clear_pending_events() and is equivalent to
 * EventsProvider::get_and_clear_pending_events() except that it requires &mut self as we do
 * no internal locking in ChannelMonitors.
 */
MUST_USE_RES struct LDKCVec_EventZ ChannelMonitor_get_and_clear_pending_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Used by ChannelManager deserialization to broadcast the latest holder state if its copy of
 * the Channel was out-of-date. You may use it to get a broadcastable holder toxic tx in case of
 * fallen-behind, i.e when receiving a channel_reestablish with a proof that our counterparty side knows
 * a higher revocation secret than the holder commitment number we are aware of. Broadcasting these
 * transactions are UNSAFE, as they allow counterparty side to punish you. Nevertheless you may want to
 * broadcast them if counterparty don't close channel with his higher commitment transaction after a
 * substantial amount of time (a month or even a year) to get back funds. Best may be to contact
 * out-of-band the other node operator to coordinate with him if option is available to you.
 * In any-case, choice is up to the user.
 */
MUST_USE_RES struct LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Processes transactions in a newly connected block, which may result in any of the following:
 * - update the monitor's state against resolved HTLCs
 * - punish the counterparty in the case of seeing a revoked commitment transaction
 * - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
 * - detect settled outputs for later spending
 * - schedule and bump any in-flight claims
 *
 * Returns any new outputs to watch from `txdata`; after called, these are also included in
 * [`get_outputs_to_watch`].
 *
 * [`get_outputs_to_watch`]: #method.get_outputs_to_watch
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_block_connected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Determines if the disconnected block contained any transactions of interest and updates
 * appropriately.
 */
void ChannelMonitor_block_disconnected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Processes transactions confirmed in a block with the given header and height, returning new
 * outputs to watch. See [`block_connected`] for details.
 *
 * Used instead of [`block_connected`] by clients that are notified of transactions rather than
 * blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_connected`]: Self::block_connected
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_transactions_confirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Processes a transaction that was reorganized out of the chain.
 *
 * Used instead of [`block_disconnected`] by clients that are notified of transactions rather
 * than blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_disconnected`]: Self::block_disconnected
 */
void ChannelMonitor_transaction_unconfirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Updates the monitor with the current best chain tip, returning new outputs to watch. See
 * [`block_connected`] for details.
 *
 * Used instead of [`block_connected`] by clients that are notified of transactions rather than
 * blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_connected`]: Self::block_connected
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_best_block_updated(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Returns the set of txids that should be monitored for re-organization out of the chain.
 */
MUST_USE_RES struct LDKCVec_TxidZ ChannelMonitor_get_relevant_txids(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the latest best block which was connected either via the [`chain::Listen`] or
 * [`chain::Confirm`] interfaces.
 */
MUST_USE_RES struct LDKBestBlock ChannelMonitor_current_best_block(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the balances in this channel which are either claimable by us if we were to
 * force-close the channel now or which are claimable on-chain (possibly awaiting
 * confirmation).
 *
 * Any balances in the channel which are available on-chain (excluding on-chain fees) are
 * included here until an [`Event::SpendableOutputs`] event has been generated for the
 * balance, or until our counterparty has claimed the balance and accrued several
 * confirmations on the claim transaction.
 *
 * Note that the balances available when you or your counterparty have broadcasted revoked
 * state(s) may not be fully captured here.
 *
 * See [`Balance`] for additional details on the types of claimable balances which
 * may be returned here and their meanings.
 */
MUST_USE_RES struct LDKCVec_BalanceZ ChannelMonitor_get_claimable_balances(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Read a C2Tuple_BlockHashChannelMonitorZ from a byte array, created by C2Tuple_BlockHashChannelMonitorZ_write
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ C2Tuple_BlockHashChannelMonitorZ_read(struct LDKu8slice ser, const struct LDKKeysInterface *NONNULL_PTR arg);

/**
 * Frees any resources used by the OutPoint, if is_owned is set and inner is non-NULL.
 */
void OutPoint_free(struct LDKOutPoint this_obj);

/**
 * The referenced transaction's txid.
 */
const uint8_t (*OutPoint_get_txid(const struct LDKOutPoint *NONNULL_PTR this_ptr))[32];

/**
 * The referenced transaction's txid.
 */
void OutPoint_set_txid(struct LDKOutPoint *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The index of the referenced output in its transaction's vout.
 */
uint16_t OutPoint_get_index(const struct LDKOutPoint *NONNULL_PTR this_ptr);

/**
 * The index of the referenced output in its transaction's vout.
 */
void OutPoint_set_index(struct LDKOutPoint *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new OutPoint given each field
 */
MUST_USE_RES struct LDKOutPoint OutPoint_new(struct LDKThirtyTwoBytes txid_arg, uint16_t index_arg);

/**
 * Creates a copy of the OutPoint
 */
struct LDKOutPoint OutPoint_clone(const struct LDKOutPoint *NONNULL_PTR orig);

/**
 * Checks if two OutPoints contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OutPoint_eq(const struct LDKOutPoint *NONNULL_PTR a, const struct LDKOutPoint *NONNULL_PTR b);

/**
 * Checks if two OutPoints contain equal inner contents.
 */
uint64_t OutPoint_hash(const struct LDKOutPoint *NONNULL_PTR o);

/**
 * Convert an `OutPoint` to a lightning channel id.
 */
MUST_USE_RES struct LDKThirtyTwoBytes OutPoint_to_channel_id(const struct LDKOutPoint *NONNULL_PTR this_arg);

/**
 * Serialize the OutPoint object into a byte array which can be read by OutPoint_read
 */
struct LDKCVec_u8Z OutPoint_write(const struct LDKOutPoint *NONNULL_PTR obj);

/**
 * Read a OutPoint from a byte array, created by OutPoint_write
 */
struct LDKCResult_OutPointDecodeErrorZ OutPoint_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DelayedPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void DelayedPaymentOutputDescriptor_free(struct LDKDelayedPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable
 */
struct LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable
 */
void DelayedPaymentOutputDescriptor_set_outpoint(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Per commitment point to derive delayed_payment_key by key holder
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * Per commitment point to derive delayed_payment_key by key holder
 */
void DelayedPaymentOutputDescriptor_set_per_commitment_point(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The nSequence value which must be set in the spending input to satisfy the OP_CSV in
 * the witness_script.
 */
uint16_t DelayedPaymentOutputDescriptor_get_to_self_delay(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The nSequence value which must be set in the spending input to satisfy the OP_CSV in
 * the witness_script.
 */
void DelayedPaymentOutputDescriptor_set_to_self_delay(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The output which is referenced by the given outpoint
 */
void DelayedPaymentOutputDescriptor_set_output(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
void DelayedPaymentOutputDescriptor_set_revocation_pubkey(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
const uint8_t (*DelayedPaymentOutputDescriptor_get_channel_keys_id(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
void DelayedPaymentOutputDescriptor_set_channel_keys_id(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
uint64_t DelayedPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new DelayedPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKPublicKey per_commitment_point_arg, uint16_t to_self_delay_arg, struct LDKTxOut output_arg, struct LDKPublicKey revocation_pubkey_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the DelayedPaymentOutputDescriptor
 */
struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Serialize the DelayedPaymentOutputDescriptor object into a byte array which can be read by DelayedPaymentOutputDescriptor_read
 */
struct LDKCVec_u8Z DelayedPaymentOutputDescriptor_write(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a DelayedPaymentOutputDescriptor from a byte array, created by DelayedPaymentOutputDescriptor_write
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ DelayedPaymentOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the StaticPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void StaticPaymentOutputDescriptor_free(struct LDKStaticPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable
 */
struct LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable
 */
void StaticPaymentOutputDescriptor_set_outpoint(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The output which is referenced by the given outpoint
 */
void StaticPaymentOutputDescriptor_set_output(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
const uint8_t (*StaticPaymentOutputDescriptor_get_channel_keys_id(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
void StaticPaymentOutputDescriptor_set_channel_keys_id(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this transactions spends.
 */
uint64_t StaticPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this transactions spends.
 */
void StaticPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new StaticPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the StaticPaymentOutputDescriptor
 */
struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Serialize the StaticPaymentOutputDescriptor object into a byte array which can be read by StaticPaymentOutputDescriptor_read
 */
struct LDKCVec_u8Z StaticPaymentOutputDescriptor_write(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a StaticPaymentOutputDescriptor from a byte array, created by StaticPaymentOutputDescriptor_write
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ StaticPaymentOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the SpendableOutputDescriptor
 */
void SpendableOutputDescriptor_free(struct LDKSpendableOutputDescriptor this_ptr);

/**
 * Creates a copy of the SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(const struct LDKSpendableOutputDescriptor *NONNULL_PTR orig);

/**
 * Utility method to constructs a new StaticOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_output(struct LDKOutPoint outpoint, struct LDKTxOut output);

/**
 * Utility method to constructs a new DelayedPaymentOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_delayed_payment_output(struct LDKDelayedPaymentOutputDescriptor a);

/**
 * Utility method to constructs a new StaticPaymentOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_payment_output(struct LDKStaticPaymentOutputDescriptor a);

/**
 * Serialize the SpendableOutputDescriptor object into a byte array which can be read by SpendableOutputDescriptor_read
 */
struct LDKCVec_u8Z SpendableOutputDescriptor_write(const struct LDKSpendableOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a SpendableOutputDescriptor from a byte array, created by SpendableOutputDescriptor_write
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ SpendableOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Calls the free function if one is set
 */
void BaseSign_free(struct LDKBaseSign this_ptr);

/**
 * Creates a copy of a Sign
 */
struct LDKSign Sign_clone(const struct LDKSign *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Sign_free(struct LDKSign this_ptr);

/**
 * Creates a copy of the Recipient
 */
enum LDKRecipient Recipient_clone(const enum LDKRecipient *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Node-variant Recipient
 */
enum LDKRecipient Recipient_node(void);

/**
 * Utility method to constructs a new PhantomNode-variant Recipient
 */
enum LDKRecipient Recipient_phantom_node(void);

/**
 * Calls the free function if one is set
 */
void KeysInterface_free(struct LDKKeysInterface this_ptr);

/**
 * Frees any resources used by the InMemorySigner, if is_owned is set and inner is non-NULL.
 */
void InMemorySigner_free(struct LDKInMemorySigner this_obj);

/**
 * Private key of anchor tx
 */
const uint8_t (*InMemorySigner_get_funding_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Private key of anchor tx
 */
void InMemorySigner_set_funding_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key for blinded revocation pubkey
 */
const uint8_t (*InMemorySigner_get_revocation_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key for blinded revocation pubkey
 */
void InMemorySigner_set_revocation_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions
 */
const uint8_t (*InMemorySigner_get_payment_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions
 */
void InMemorySigner_set_payment_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used in HTLC tx
 */
const uint8_t (*InMemorySigner_get_delayed_payment_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used in HTLC tx
 */
void InMemorySigner_set_delayed_payment_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder htlc secret key used in commitment tx htlc outputs
 */
const uint8_t (*InMemorySigner_get_htlc_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder htlc secret key used in commitment tx htlc outputs
 */
void InMemorySigner_set_htlc_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Commitment seed
 */
const uint8_t (*InMemorySigner_get_commitment_seed(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Commitment seed
 */
void InMemorySigner_set_commitment_seed(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Creates a copy of the InMemorySigner
 */
struct LDKInMemorySigner InMemorySigner_clone(const struct LDKInMemorySigner *NONNULL_PTR orig);

/**
 * Create a new InMemorySigner
 */
MUST_USE_RES struct LDKInMemorySigner InMemorySigner_new(struct LDKSecretKey node_secret, struct LDKSecretKey funding_key, struct LDKSecretKey revocation_base_key, struct LDKSecretKey payment_key, struct LDKSecretKey delayed_payment_base_key, struct LDKSecretKey htlc_base_key, struct LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id);

/**
 * Counterparty pubkeys.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * The contest_delay value specified by our counterparty and applied on holder-broadcastable
 * transactions, ie the amount of time that we have to wait to recover our funds if we
 * broadcast a transaction.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES uint16_t InMemorySigner_counterparty_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * The contest_delay value specified by us and applied on transactions broadcastable
 * by our counterparty, ie the amount of time that they have to wait to recover their funds
 * if they broadcast a transaction.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES uint16_t InMemorySigner_holder_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Whether the holder is the initiator
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES bool InMemorySigner_is_outbound(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Funding outpoint
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKOutPoint InMemorySigner_funding_outpoint(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Obtain a ChannelTransactionParameters for this channel, to be used when verifying or
 * building transactions.
 *
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Whether anchors should be used.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES bool InMemorySigner_opt_anchors(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Sign the single input of spend_tx at index `input_idx` which spends the output
 * described by descriptor, returning the witness stack for the input.
 *
 * Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
 * is not spending the outpoint described by `descriptor.outpoint`,
 * or if an output descriptor script_pubkey does not match the one we can spend.
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Sign the single input of spend_tx at index `input_idx` which spends the output
 * described by descriptor, returning the witness stack for the input.
 *
 * Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
 * is not spending the outpoint described by `descriptor.outpoint`, does not have a
 * sequence set to `descriptor.to_self_delay`, or if an output descriptor
 * script_pubkey does not match the one we can spend.
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Constructs a new BaseSign which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned BaseSign must be freed before this_arg is
 */
struct LDKBaseSign InMemorySigner_as_BaseSign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Constructs a new Sign which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Sign must be freed before this_arg is
 */
struct LDKSign InMemorySigner_as_Sign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Serialize the InMemorySigner object into a byte array which can be read by InMemorySigner_read
 */
struct LDKCVec_u8Z InMemorySigner_write(const struct LDKInMemorySigner *NONNULL_PTR obj);

/**
 * Read a InMemorySigner from a byte array, created by InMemorySigner_write
 */
struct LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(struct LDKu8slice ser, struct LDKSecretKey arg);

/**
 * Frees any resources used by the KeysManager, if is_owned is set and inner is non-NULL.
 */
void KeysManager_free(struct LDKKeysManager this_obj);

/**
 * Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your
 * CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
 * starting_time isn't strictly required to actually be a time, but it must absolutely,
 * without a doubt, be unique to this instance. ie if you start multiple times with the same
 * seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to
 * simply use the current time (with very high precision).
 *
 * The seed MUST be backed up safely prior to use so that the keys can be re-created, however,
 * obviously, starting_time should be unique every time you reload the library - it is only
 * used to generate new ephemeral key data (which will be stored by the individual channel if
 * necessary).
 *
 * Note that the seed is required to recover certain on-chain funds independent of
 * ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any
 * channel, and some on-chain during-closing funds.
 *
 * Note that until the 0.1 release there is no guarantee of backward compatibility between
 * versions. Once the library is more fully supported, the docs will be updated to include a
 * detailed description of the guarantee.
 */
MUST_USE_RES struct LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos);

/**
 * Derive an old Sign containing per-channel secrets based on a key derivation parameters.
 *
 * Key derivation parameters are accessible through a per-channel secrets
 * Sign::channel_keys_id and is provided inside DynamicOuputP2WSH in case of
 * onchain output detection for which a corresponding delayed_payment_key must be derived.
 */
MUST_USE_RES struct LDKInMemorySigner KeysManager_derive_channel_keys(const struct LDKKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);

/**
 * Creates a Transaction which spends the given descriptors to the given outputs, plus an
 * output to the given change destination (if sufficient change value remains). The
 * transaction will have a feerate, at least, of the given value.
 *
 * Returns `Err(())` if the output value is greater than the input value minus required fee,
 * if a descriptor was duplicated, or if an output descriptor `script_pubkey`
 * does not match the one we can spend.
 *
 * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
 *
 * May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
 * this KeysManager or one of the `InMemorySigner` created by this KeysManager.
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);

/**
 * Constructs a new KeysInterface which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
 */
struct LDKKeysInterface KeysManager_as_KeysInterface(const struct LDKKeysManager *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the PhantomKeysManager, if is_owned is set and inner is non-NULL.
 */
void PhantomKeysManager_free(struct LDKPhantomKeysManager this_obj);

/**
 * Constructs a new KeysInterface which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
 */
struct LDKKeysInterface PhantomKeysManager_as_KeysInterface(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);

/**
 * Constructs a `PhantomKeysManager` given a 32-byte seed and an additional `cross_node_seed`
 * that is shared across all nodes that intend to participate in [phantom node payments] together.
 *
 * See [`KeysManager::new`] for more information on `seed`, `starting_time_secs`, and
 * `starting_time_nanos`.
 *
 * `cross_node_seed` must be the same across all phantom payment-receiving nodes and also the
 * same across restarts, or else inbound payments may fail.
 *
 * [phantom node payments]: PhantomKeysManager
 */
MUST_USE_RES struct LDKPhantomKeysManager PhantomKeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos, const uint8_t (*cross_node_seed)[32]);

/**
 * See [`KeysManager::spend_spendable_outputs`] for documentation on this method.
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ PhantomKeysManager_spend_spendable_outputs(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);

/**
 * See [`KeysManager::derive_channel_keys`] for documentation on this method.
 */
MUST_USE_RES struct LDKInMemorySigner PhantomKeysManager_derive_channel_keys(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);

/**
 * Frees any resources used by the ChannelManager, if is_owned is set and inner is non-NULL.
 */
void ChannelManager_free(struct LDKChannelManager this_obj);

/**
 * Frees any resources used by the ChainParameters, if is_owned is set and inner is non-NULL.
 */
void ChainParameters_free(struct LDKChainParameters this_obj);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
enum LDKNetwork ChainParameters_get_network(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
void ChainParameters_set_network(struct LDKChainParameters *NONNULL_PTR this_ptr, enum LDKNetwork val);

/**
 * The hash and height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
struct LDKBestBlock ChainParameters_get_best_block(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The hash and height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
void ChainParameters_set_best_block(struct LDKChainParameters *NONNULL_PTR this_ptr, struct LDKBestBlock val);

/**
 * Constructs a new ChainParameters given each field
 */
MUST_USE_RES struct LDKChainParameters ChainParameters_new(enum LDKNetwork network_arg, struct LDKBestBlock best_block_arg);

/**
 * Creates a copy of the ChainParameters
 */
struct LDKChainParameters ChainParameters_clone(const struct LDKChainParameters *NONNULL_PTR orig);

/**
 * Frees any resources used by the CounterpartyForwardingInfo, if is_owned is set and inner is non-NULL.
 */
void CounterpartyForwardingInfo_free(struct LDKCounterpartyForwardingInfo this_obj);

/**
 * Base routing fee in millisatoshis.
 */
uint32_t CounterpartyForwardingInfo_get_fee_base_msat(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * Base routing fee in millisatoshis.
 */
void CounterpartyForwardingInfo_set_fee_base_msat(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Amount in millionths of a satoshi the channel will charge per transferred satoshi.
 */
uint32_t CounterpartyForwardingInfo_get_fee_proportional_millionths(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * Amount in millionths of a satoshi the channel will charge per transferred satoshi.
 */
void CounterpartyForwardingInfo_set_fee_proportional_millionths(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
 * such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
 * `cltv_expiry_delta` for more details.
 */
uint16_t CounterpartyForwardingInfo_get_cltv_expiry_delta(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
 * such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
 * `cltv_expiry_delta` for more details.
 */
void CounterpartyForwardingInfo_set_cltv_expiry_delta(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new CounterpartyForwardingInfo given each field
 */
MUST_USE_RES struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_new(uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, uint16_t cltv_expiry_delta_arg);

/**
 * Creates a copy of the CounterpartyForwardingInfo
 */
struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_clone(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelCounterparty, if is_owned is set and inner is non-NULL.
 */
void ChannelCounterparty_free(struct LDKChannelCounterparty this_obj);

/**
 * The node_id of our counterparty
 */
struct LDKPublicKey ChannelCounterparty_get_node_id(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The node_id of our counterparty
 */
void ChannelCounterparty_set_node_id(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
struct LDKInitFeatures ChannelCounterparty_get_features(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
void ChannelCounterparty_set_features(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * The value, in satoshis, that must always be held in the channel for our counterparty. This
 * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
 *
 * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
 */
uint64_t ChannelCounterparty_get_unspendable_punishment_reserve(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, that must always be held in the channel for our counterparty. This
 * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
 *
 * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
 */
void ChannelCounterparty_set_unspendable_punishment_reserve(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Information on the fees and requirements that the counterparty requires when forwarding
 * payments to us through this channel.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCounterpartyForwardingInfo ChannelCounterparty_get_forwarding_info(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * Information on the fees and requirements that the counterparty requires when forwarding
 * payments to us through this channel.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelCounterparty_set_forwarding_info(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCounterpartyForwardingInfo val);

/**
 * Constructs a new ChannelCounterparty given each field
 */
MUST_USE_RES struct LDKChannelCounterparty ChannelCounterparty_new(struct LDKPublicKey node_id_arg, struct LDKInitFeatures features_arg, uint64_t unspendable_punishment_reserve_arg, struct LDKCounterpartyForwardingInfo forwarding_info_arg);

/**
 * Creates a copy of the ChannelCounterparty
 */
struct LDKChannelCounterparty ChannelCounterparty_clone(const struct LDKChannelCounterparty *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelDetails, if is_owned is set and inner is non-NULL.
 */
void ChannelDetails_free(struct LDKChannelDetails this_obj);

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
const uint8_t (*ChannelDetails_get_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr))[32];

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
void ChannelDetails_set_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Parameters which apply to our counterparty. See individual fields for more information.
 */
struct LDKChannelCounterparty ChannelDetails_get_counterparty(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Parameters which apply to our counterparty. See individual fields for more information.
 */
void ChannelDetails_set_counterparty(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelCounterparty val);

/**
 * The Channel's funding transaction output, if we've negotiated the funding transaction with
 * our counterparty already.
 *
 * Note that, if this has been set, `channel_id` will be equivalent to
 * `funding_txo.unwrap().to_channel_id()`.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKOutPoint ChannelDetails_get_funding_txo(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The Channel's funding transaction output, if we've negotiated the funding transaction with
 * our counterparty already.
 *
 * Note that, if this has been set, `channel_id` will be equivalent to
 * `funding_txo.unwrap().to_channel_id()`.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelDetails_set_funding_txo(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The features which this channel operates with. See individual features for more info.
 *
 * `None` until negotiation completes and the channel type is finalized.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures ChannelDetails_get_channel_type(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The features which this channel operates with. See individual features for more info.
 *
 * `None` until negotiation completes and the channel type is finalized.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelDetails_set_channel_type(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * The position of the funding transaction in the chain. None if the funding transaction has
 * not yet been confirmed and the channel fully opened.
 *
 * Note that if [`inbound_scid_alias`] is set, it must be used for invoices and inbound
 * payments instead of this. See [`get_inbound_payment_scid`].
 *
 * [`inbound_scid_alias`]: Self::inbound_scid_alias
 * [`get_inbound_payment_scid`]: Self::get_inbound_payment_scid
 */
struct LDKCOption_u64Z ChannelDetails_get_short_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The position of the funding transaction in the chain. None if the funding transaction has
 * not yet been confirmed and the channel fully opened.
 *
 * Note that if [`inbound_scid_alias`] is set, it must be used for invoices and inbound
 * payments instead of this. See [`get_inbound_payment_scid`].
 *
 * [`inbound_scid_alias`]: Self::inbound_scid_alias
 * [`get_inbound_payment_scid`]: Self::get_inbound_payment_scid
 */
void ChannelDetails_set_short_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by our
 * counterparty and usable in place of [`short_channel_id`] in invoice route hints. Our
 * counterparty will recognize the alias provided here in place of the [`short_channel_id`]
 * when they see a payment to be routed to us.
 *
 * Our counterparty may choose to rotate this value at any time, though will always recognize
 * previous values for inbound payment forwarding.
 *
 * [`short_channel_id`]: Self::short_channel_id
 */
struct LDKCOption_u64Z ChannelDetails_get_inbound_scid_alias(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by our
 * counterparty and usable in place of [`short_channel_id`] in invoice route hints. Our
 * counterparty will recognize the alias provided here in place of the [`short_channel_id`]
 * when they see a payment to be routed to us.
 *
 * Our counterparty may choose to rotate this value at any time, though will always recognize
 * previous values for inbound payment forwarding.
 *
 * [`short_channel_id`]: Self::short_channel_id
 */
void ChannelDetails_set_inbound_scid_alias(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
uint64_t ChannelDetails_get_channel_value_satoshis(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
void ChannelDetails_set_channel_value_satoshis(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The value, in satoshis, that must always be held in the channel for us. This value ensures
 * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
 * this value on chain.
 *
 * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
 */
struct LDKCOption_u64Z ChannelDetails_get_unspendable_punishment_reserve(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, that must always be held in the channel for us. This value ensures
 * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
 * this value on chain.
 *
 * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
 */
void ChannelDetails_set_unspendable_punishment_reserve(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The `user_channel_id` passed in to create_channel, or 0 if the channel was inbound.
 */
uint64_t ChannelDetails_get_user_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The `user_channel_id` passed in to create_channel, or 0 if the channel was inbound.
 */
void ChannelDetails_set_user_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Our total balance.  This is the amount we would get if we close the channel.
 * This value is not exact. Due to various in-flight changes and feerate changes, exactly this
 * amount is not likely to be recoverable on close.
 *
 * This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
 * balance is not available for inclusion in new outbound HTLCs). This further does not include
 * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
 * This does not consider any on-chain fees.
 *
 * See also [`ChannelDetails::outbound_capacity_msat`]
 */
uint64_t ChannelDetails_get_balance_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Our total balance.  This is the amount we would get if we close the channel.
 * This value is not exact. Due to various in-flight changes and feerate changes, exactly this
 * amount is not likely to be recoverable on close.
 *
 * This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
 * balance is not available for inclusion in new outbound HTLCs). This further does not include
 * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
 * This does not consider any on-chain fees.
 *
 * See also [`ChannelDetails::outbound_capacity_msat`]
 */
void ChannelDetails_set_balance_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 *
 * See also [`ChannelDetails::balance_msat`]
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
 * should be able to spend nearly this amount.
 */
uint64_t ChannelDetails_get_outbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 *
 * See also [`ChannelDetails::balance_msat`]
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
 * should be able to spend nearly this amount.
 */
void ChannelDetails_set_outbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
 * However, our counterparty should be able to spend nearly this amount.
 */
uint64_t ChannelDetails_get_inbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
 * However, our counterparty should be able to spend nearly this amount.
 */
void ChannelDetails_set_inbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The number of required confirmations on the funding transaction before the funding will be
 * considered \"locked\". This number is selected by the channel fundee (i.e. us if
 * [`is_outbound`] is *not* set), and can be selected for inbound channels with
 * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
 * [`ChannelHandshakeLimits::max_minimum_depth`].
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`is_outbound`]: ChannelDetails::is_outbound
 * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
 * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
 */
struct LDKCOption_u32Z ChannelDetails_get_confirmations_required(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The number of required confirmations on the funding transaction before the funding will be
 * considered \"locked\". This number is selected by the channel fundee (i.e. us if
 * [`is_outbound`] is *not* set), and can be selected for inbound channels with
 * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
 * [`ChannelHandshakeLimits::max_minimum_depth`].
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`is_outbound`]: ChannelDetails::is_outbound
 * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
 * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
 */
void ChannelDetails_set_confirmations_required(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * The number of blocks (after our commitment transaction confirms) that we will need to wait
 * until we can claim our funds after we force-close the channel. During this time our
 * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
 * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
 * time to claim our non-HTLC-encumbered funds.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 */
struct LDKCOption_u16Z ChannelDetails_get_force_close_spend_delay(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The number of blocks (after our commitment transaction confirms) that we will need to wait
 * until we can claim our funds after we force-close the channel. During this time our
 * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
 * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
 * time to claim our non-HTLC-encumbered funds.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 */
void ChannelDetails_set_force_close_spend_delay(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);

/**
 * True if the channel was initiated (and thus funded) by us.
 */
bool ChannelDetails_get_is_outbound(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel was initiated (and thus funded) by us.
 */
void ChannelDetails_set_is_outbound(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if the channel is confirmed, funding_locked messages have been exchanged, and the
 * channel is not currently being shut down. `funding_locked` message exchange implies the
 * required confirmation count has been reached (and we were connected to the peer at some
 * point after the funding transaction received enough confirmations). The required
 * confirmation count is provided in [`confirmations_required`].
 *
 * [`confirmations_required`]: ChannelDetails::confirmations_required
 */
bool ChannelDetails_get_is_funding_locked(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is confirmed, funding_locked messages have been exchanged, and the
 * channel is not currently being shut down. `funding_locked` message exchange implies the
 * required confirmation count has been reached (and we were connected to the peer at some
 * point after the funding transaction received enough confirmations). The required
 * confirmation count is provided in [`confirmations_required`].
 *
 * [`confirmations_required`]: ChannelDetails::confirmations_required
 */
void ChannelDetails_set_is_funding_locked(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)
 * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
 *
 * This is a strict superset of `is_funding_locked`.
 */
bool ChannelDetails_get_is_usable(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)
 * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
 *
 * This is a strict superset of `is_funding_locked`.
 */
void ChannelDetails_set_is_usable(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if this channel is (or will be) publicly-announced.
 */
bool ChannelDetails_get_is_public(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if this channel is (or will be) publicly-announced.
 */
void ChannelDetails_set_is_public(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ChannelDetails given each field
 */
MUST_USE_RES struct LDKChannelDetails ChannelDetails_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKChannelCounterparty counterparty_arg, struct LDKOutPoint funding_txo_arg, struct LDKChannelTypeFeatures channel_type_arg, struct LDKCOption_u64Z short_channel_id_arg, struct LDKCOption_u64Z inbound_scid_alias_arg, uint64_t channel_value_satoshis_arg, struct LDKCOption_u64Z unspendable_punishment_reserve_arg, uint64_t user_channel_id_arg, uint64_t balance_msat_arg, uint64_t outbound_capacity_msat_arg, uint64_t inbound_capacity_msat_arg, struct LDKCOption_u32Z confirmations_required_arg, struct LDKCOption_u16Z force_close_spend_delay_arg, bool is_outbound_arg, bool is_funding_locked_arg, bool is_usable_arg, bool is_public_arg);

/**
 * Creates a copy of the ChannelDetails
 */
struct LDKChannelDetails ChannelDetails_clone(const struct LDKChannelDetails *NONNULL_PTR orig);

/**
 * Gets the current SCID which should be used to identify this channel for inbound payments.
 * This should be used for providing invoice hints or in any other context where our
 * counterparty will forward a payment to us.
 *
 * This is either the [`ChannelDetails::inbound_scid_alias`], if set, or the
 * [`ChannelDetails::short_channel_id`]. See those for more information.
 */
MUST_USE_RES struct LDKCOption_u64Z ChannelDetails_get_inbound_payment_scid(const struct LDKChannelDetails *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the PaymentSendFailure
 */
void PaymentSendFailure_free(struct LDKPaymentSendFailure this_ptr);

/**
 * Creates a copy of the PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_clone(const struct LDKPaymentSendFailure *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ParameterError-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_parameter_error(struct LDKAPIError a);

/**
 * Utility method to constructs a new PathParameterError-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_path_parameter_error(struct LDKCVec_CResult_NoneAPIErrorZZ a);

/**
 * Utility method to constructs a new AllFailedRetrySafe-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_all_failed_retry_safe(struct LDKCVec_APIErrorZ a);

/**
 * Utility method to constructs a new PartialFailure-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_partial_failure(struct LDKCVec_CResult_NoneAPIErrorZZ results, struct LDKRouteParameters failed_paths_retry, struct LDKThirtyTwoBytes payment_id);

/**
 * Frees any resources used by the PhantomRouteHints, if is_owned is set and inner is non-NULL.
 */
void PhantomRouteHints_free(struct LDKPhantomRouteHints this_obj);

/**
 * The list of channels to be included in the invoice route hints.
 */
struct LDKCVec_ChannelDetailsZ PhantomRouteHints_get_channels(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * The list of channels to be included in the invoice route hints.
 */
void PhantomRouteHints_set_channels(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKCVec_ChannelDetailsZ val);

/**
 * A fake scid used for representing the phantom node's fake channel in generating the invoice
 * route hints.
 */
uint64_t PhantomRouteHints_get_phantom_scid(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * A fake scid used for representing the phantom node's fake channel in generating the invoice
 * route hints.
 */
void PhantomRouteHints_set_phantom_scid(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The pubkey of the real backing node that would ultimately receive the payment.
 */
struct LDKPublicKey PhantomRouteHints_get_real_node_pubkey(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * The pubkey of the real backing node that would ultimately receive the payment.
 */
void PhantomRouteHints_set_real_node_pubkey(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new PhantomRouteHints given each field
 */
MUST_USE_RES struct LDKPhantomRouteHints PhantomRouteHints_new(struct LDKCVec_ChannelDetailsZ channels_arg, uint64_t phantom_scid_arg, struct LDKPublicKey real_node_pubkey_arg);

/**
 * Creates a copy of the PhantomRouteHints
 */
struct LDKPhantomRouteHints PhantomRouteHints_clone(const struct LDKPhantomRouteHints *NONNULL_PTR orig);

/**
 * Constructs a new ChannelManager to hold several channels and route between them.
 *
 * This is the main \"logic hub\" for all channel-related actions, and implements
 * ChannelMessageHandler.
 *
 * Non-proportional fees are fixed according to our risk using the provided fee estimator.
 *
 * panics if channel_value_satoshis is >= `MAX_FUNDING_SATOSHIS`!
 *
 * Users need to notify the new ChannelManager when a new block is connected or
 * disconnected using its `block_connected` and `block_disconnected` methods, starting
 * from after `params.latest_hash`.
 */
MUST_USE_RES struct LDKChannelManager ChannelManager_new(struct LDKFeeEstimator fee_est, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKKeysInterface keys_manager, struct LDKUserConfig config, struct LDKChainParameters params);

/**
 * Gets the current configuration applied to all new channels,  as
 */
MUST_USE_RES struct LDKUserConfig ChannelManager_get_current_default_configuration(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Creates a new outbound channel to the given remote node and with the given value.
 *
 * `user_channel_id` will be provided back as in
 * [`Event::FundingGenerationReady::user_channel_id`] to allow tracking of which events
 * correspond with which `create_channel` call. Note that the `user_channel_id` defaults to 0
 * for inbound channels, so you may wish to avoid using 0 for `user_channel_id` here.
 * `user_channel_id` has no meaning inside of LDK, it is simply copied to events and otherwise
 * ignored.
 *
 * Raises [`APIError::APIMisuseError`] when `channel_value_satoshis` > 2**24 or `push_msat` is
 * greater than `channel_value_satoshis * 1k` or `channel_value_satoshis < 1000`.
 *
 * Note that we do not check if you are currently connected to the given peer. If no
 * connection is available, the outbound `open_channel` message may fail to send, resulting in
 * the channel eventually being silently forgotten (dropped on reload).
 *
 * Returns the new Channel's temporary `channel_id`. This ID will appear as
 * [`Event::FundingGenerationReady::temporary_channel_id`] and in
 * [`ChannelDetails::channel_id`] until after
 * [`ChannelManager::funding_transaction_generated`] is called, swapping the Channel's ID for
 * one derived from the funding transaction's TXID. If the counterparty rejects the channel
 * immediately, this temporary ID will appear in [`Event::ChannelClosed::channel_id`].
 *
 * [`Event::FundingGenerationReady::user_channel_id`]: events::Event::FundingGenerationReady::user_channel_id
 * [`Event::FundingGenerationReady::temporary_channel_id`]: events::Event::FundingGenerationReady::temporary_channel_id
 * [`Event::ChannelClosed::channel_id`]: events::Event::ChannelClosed::channel_id
 *
 * Note that override_config (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult__u832APIErrorZ ChannelManager_create_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, uint64_t user_channel_id, struct LDKUserConfig override_config);

/**
 * Gets the list of open channels, in random order. See ChannelDetail field documentation for
 * more information.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the list of usable channels, in random order. Useful as an argument to
 * get_route to ensure non-announced channels are used.
 *
 * These are guaranteed to have their [`ChannelDetails::is_usable`] value set to true, see the
 * documentation for [`ChannelDetails::is_usable`] for more info on exactly what the criteria
 * are.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
 * will be accepted on the given channel, and after additional timeout/the closing of all
 * pending HTLCs, the channel will be closed on chain.
 *
 *  * If we are the channel initiator, we will pay between our [`Background`] and
 *    [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
 *    estimate.
 *  * If our counterparty is the channel initiator, we will require a channel closing
 *    transaction feerate of at least our [`Background`] feerate or the feerate which
 *    would appear on a force-closure transaction, whichever is lower. We will allow our
 *    counterparty to pay as much fee as they'd like, however.
 *
 * May generate a SendShutdown message event on success, which should be relayed.
 *
 * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);

/**
 * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
 * will be accepted on the given channel, and after additional timeout/the closing of all
 * pending HTLCs, the channel will be closed on chain.
 *
 * `target_feerate_sat_per_1000_weight` has different meanings depending on if we initiated
 * the channel being closed or not:
 *  * If we are the channel initiator, we will pay at least this feerate on the closing
 *    transaction. The upper-bound is set by
 *    [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
 *    estimate (or `target_feerate_sat_per_1000_weight`, if it is greater).
 *  * If our counterparty is the channel initiator, we will refuse to accept a channel closure
 *    transaction feerate below `target_feerate_sat_per_1000_weight` (or the feerate which
 *    will appear on a force-closure transaction, whichever is lower).
 *
 * May generate a SendShutdown message event on success, which should be relayed.
 *
 * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel_with_target_feerate(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], uint32_t target_feerate_sats_per_1000_weight);

/**
 * Force closes a channel, immediately broadcasting the latest local commitment transaction to
 * the chain and rejecting new HTLCs on the given channel. Fails if channel_id is unknown to the manager.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);

/**
 * Force close all channels, immediately broadcasting the latest local commitment transaction
 * for each to the chain and rejecting new HTLCs on each.
 */
void ChannelManager_force_close_all_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Sends a payment along a given route.
 *
 * Value parameters are provided via the last hop in route, see documentation for RouteHop
 * fields for more info.
 *
 * Note that if the payment_hash already exists elsewhere (eg you're sending a duplicative
 * payment), we don't do anything to stop you! We always try to ensure that if the provided
 * next hop knows the preimage to payment_hash they can claim an additional amount as
 * specified in the last hop in the route! Thus, you should probably do your own
 * payment_preimage tracking (which you should already be doing as they represent \"proof of
 * payment\") and prevent double-sends yourself.
 *
 * May generate SendHTLCs message(s) event on success, which should be relayed.
 *
 * Each path may have a different return value, and PaymentSendValue may return a Vec with
 * each entry matching the corresponding-index entry in the route paths, see
 * PaymentSendFailure for more info.
 *
 * In general, a path may raise:
 *  * APIError::RouteError when an invalid route or forwarding parameter (cltv_delta, fee,
 *    node public key) is specified.
 *  * APIError::ChannelUnavailable if the next-hop channel is not available for updates
 *    (including due to previous monitor update failure or new permanent monitor update
 *    failure).
 *  * APIError::MonitorUpdateFailed if a new monitor update failure prevented sending the
 *    relevant updates.
 *
 * Note that depending on the type of the PaymentSendFailure the HTLC may have been
 * irrevocably committed to on our end. In such a case, do NOT retry the payment with a
 * different route unless you intend to pay twice!
 *
 * payment_secret is unrelated to payment_hash (or PaymentPreimage) and exists to authenticate
 * the sender to the recipient and prevent payment-probing (deanonymization) attacks. For
 * newer nodes, it will be provided to you in the invoice. If you do not have one, the Route
 * must not contain multiple paths as multi-path payments require a recipient-provided
 * payment_secret.
 * If a payment_secret *is* provided, we assume that the invoice had the payment_secret feature
 * bit set (either as required or as available). If multiple paths are present in the Route,
 * we assume the invoice had the basic_mpp feature set.
 *
 * Note that payment_secret (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult_PaymentIdPaymentSendFailureZ ChannelManager_send_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);

/**
 * Retries a payment along the given [`Route`].
 *
 * Errors returned are a superset of those returned from [`send_payment`], so see
 * [`send_payment`] documentation for more details on errors. This method will also error if the
 * retry amount puts the payment more than 10% over the payment's total amount, if the payment
 * for the given `payment_id` cannot be found (likely due to timeout or success), or if
 * further retries have been disabled with [`abandon_payment`].
 *
 * [`send_payment`]: [`ChannelManager::send_payment`]
 * [`abandon_payment`]: [`ChannelManager::abandon_payment`]
 */
MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_retry_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_id);

/**
 * Signals that no further retries for the given payment will occur.
 *
 * After this method returns, any future calls to [`retry_payment`] for the given `payment_id`
 * will fail with [`PaymentSendFailure::ParameterError`]. If no such event has been generated,
 * an [`Event::PaymentFailed`] event will be generated as soon as there are no remaining
 * pending HTLCs for this payment.
 *
 * Note that calling this method does *not* prevent a payment from succeeding. You must still
 * wait until you receive either a [`Event::PaymentFailed`] or [`Event::PaymentSent`] event to
 * determine the ultimate status of a payment.
 *
 * [`retry_payment`]: Self::retry_payment
 * [`Event::PaymentFailed`]: events::Event::PaymentFailed
 * [`Event::PaymentSent`]: events::Event::PaymentSent
 */
void ChannelManager_abandon_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_id);

/**
 * Send a spontaneous payment, which is a payment that does not require the recipient to have
 * generated an invoice. Optionally, you may specify the preimage. If you do choose to specify
 * the preimage, it must be a cryptographically secure random value that no intermediate node
 * would be able to guess -- otherwise, an intermediate node may claim the payment and it will
 * never reach the recipient.
 *
 * See [`send_payment`] documentation for more details on the return value of this function.
 *
 * Similar to regular payments, you MUST NOT reuse a `payment_preimage` value. See
 * [`send_payment`] for more information about the risks of duplicate preimage usage.
 *
 * Note that `route` must have exactly one path.
 *
 * [`send_payment`]: Self::send_payment
 *
 * Note that payment_preimage (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ ChannelManager_send_spontaneous_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_preimage);

/**
 * Call this upon creation of a funding transaction for the given channel.
 *
 * Returns an [`APIError::APIMisuseError`] if the funding_transaction spent non-SegWit outputs
 * or if no output was found which matches the parameters in [`Event::FundingGenerationReady`].
 *
 * Returns [`APIError::ChannelUnavailable`] if a funding transaction has already been provided
 * for the channel or if the channel has been closed as indicated by [`Event::ChannelClosed`].
 *
 * May panic if the output found in the funding transaction is duplicative with some other
 * channel (note that this should be trivially prevented by using unique funding transaction
 * keys per-channel).
 *
 * Do NOT broadcast the funding transaction yourself. When we have safely received our
 * counterparty's signature the funding transaction will automatically be broadcast via the
 * [`BroadcasterInterface`] provided when this `ChannelManager` was constructed.
 *
 * Note that this includes RBF or similar transaction replacement strategies - lightning does
 * not currently support replacing a funding transaction on an existing channel. Instead,
 * create a new channel with a conflicting funding transaction.
 *
 * [`Event::FundingGenerationReady`]: crate::util::events::Event::FundingGenerationReady
 * [`Event::ChannelClosed`]: crate::util::events::Event::ChannelClosed
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKTransaction funding_transaction);

/**
 * Regenerates channel_announcements and generates a signed node_announcement from the given
 * arguments, providing them in corresponding events via
 * [`get_and_clear_pending_msg_events`], if at least one public channel has been confirmed
 * on-chain. This effectively re-broadcasts all channel announcements and sends our node
 * announcement to ensure that the lightning P2P network is aware of the channels we have and
 * our network addresses.
 *
 * `rgb` is a node \"color\" and `alias` is a printable human-readable string to describe this
 * node to humans. They carry no in-protocol meaning.
 *
 * `addresses` represent the set (possibly empty) of socket addresses on which this node
 * accepts incoming connections. These will be included in the node_announcement, publicly
 * tying these addresses together and to this node. If you wish to preserve user privacy,
 * addresses should likely contain only Tor Onion addresses.
 *
 * Panics if `addresses` is absurdly large (more than 500).
 *
 * [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
 */
void ChannelManager_broadcast_node_announcement(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThreeBytes rgb, struct LDKThirtyTwoBytes alias, struct LDKCVec_NetAddressZ addresses);

/**
 * Processes HTLCs which are pending waiting on random forward delay.
 *
 * Should only really ever be called in response to a PendingHTLCsForwardable event.
 * Will likely generate further events.
 */
void ChannelManager_process_pending_htlc_forwards(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Performs actions which should happen on startup and roughly once per minute thereafter.
 *
 * This currently includes:
 *  * Increasing or decreasing the on-chain feerate estimates for our outbound channels,
 *  * Broadcasting `ChannelUpdate` messages if we've been disconnected from our peer for more
 *    than a minute, informing the network that they should no longer attempt to route over
 *    the channel.
 *
 * Note that this may cause reentrancy through `chain::Watch::update_channel` calls or feerate
 * estimate fetches.
 */
void ChannelManager_timer_tick_occurred(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Indicates that the preimage for payment_hash is unknown or the received amount is incorrect
 * after a PaymentReceived event, failing the HTLC back to its origin and freeing resources
 * along the path (including in our own channel on which we received it).
 * Returns false if no payment was found to fail backwards, true if the process of failing the
 * HTLC backwards has been started.
 */
MUST_USE_RES bool ChannelManager_fail_htlc_backwards(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);

/**
 * Provides a payment preimage in response to [`Event::PaymentReceived`], generating any
 * [`MessageSendEvent`]s needed to claim the payment.
 *
 * Note that if you did not set an `amount_msat` when calling [`create_inbound_payment`] or
 * [`create_inbound_payment_for_hash`] you must check that the amount in the `PaymentReceived`
 * event matches your expectation. If you fail to do so and call this method, you may provide
 * the sender \"proof-of-payment\" when they did not fulfill the full expected payment.
 *
 * Returns whether any HTLCs were claimed, and thus if any new [`MessageSendEvent`]s are now
 * pending for processing via [`get_and_clear_pending_msg_events`].
 *
 * [`Event::PaymentReceived`]: crate::util::events::Event::PaymentReceived
 * [`create_inbound_payment`]: Self::create_inbound_payment
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 * [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
 */
MUST_USE_RES bool ChannelManager_claim_funds(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage);

/**
 * Gets the node_id held by this ChannelManager
 */
MUST_USE_RES struct LDKPublicKey ChannelManager_get_our_node_id(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Called to accept a request to open a channel after [`Event::OpenChannelRequest`] has been
 * triggered.
 *
 * The `temporary_channel_id` parameter indicates which inbound channel should be accepted.
 *
 * For inbound channels, the `user_channel_id` parameter will be provided back in
 * [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
 * with which `accept_inbound_channel` call.
 *
 * [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
 * [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], uint64_t user_channel_id);

/**
 * Gets a payment secret and payment hash for use in an invoice given to a third party wishing
 * to pay us.
 *
 * This differs from [`create_inbound_payment_for_hash`] only in that it generates the
 * [`PaymentHash`] and [`PaymentPreimage`] for you.
 *
 * The [`PaymentPreimage`] will ultimately be returned to you in the [`PaymentReceived`], which
 * will have the [`PaymentReceived::payment_preimage`] field filled in. That should then be
 * passed directly to [`claim_funds`].
 *
 * See [`create_inbound_payment_for_hash`] for detailed documentation on behavior and requirements.
 *
 * Note that a malicious eavesdropper can intuit whether an inbound payment was created by
 * `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
 *
 * # Note
 *
 * If you register an inbound payment with this method, then serialize the `ChannelManager`, then
 * deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
 *
 * Errors if `min_value_msat` is greater than total bitcoin supply.
 *
 * [`claim_funds`]: Self::claim_funds
 * [`PaymentReceived`]: events::Event::PaymentReceived
 * [`PaymentReceived::payment_preimage`]: events::Event::PaymentReceived::payment_preimage
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 */
MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ ChannelManager_create_inbound_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);

/**
 * Legacy version of [`create_inbound_payment`]. Use this method if you wish to share
 * serialized state with LDK node(s) running 0.0.103 and earlier.
 *
 * May panic if `invoice_expiry_delta_secs` is greater than one year.
 *
 * # Note
 * This method is deprecated and will be removed soon.
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 */
MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ ChannelManager_create_inbound_payment_legacy(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);

/**
 * Gets a [`PaymentSecret`] for a given [`PaymentHash`], for which the payment preimage is
 * stored external to LDK.
 *
 * A [`PaymentReceived`] event will only be generated if the [`PaymentSecret`] matches a
 * payment secret fetched via this method or [`create_inbound_payment`], and which is at least
 * the `min_value_msat` provided here, if one is provided.
 *
 * The [`PaymentHash`] (and corresponding [`PaymentPreimage`]) should be globally unique, though
 * note that LDK will not stop you from registering duplicate payment hashes for inbound
 * payments.
 *
 * `min_value_msat` should be set if the invoice being generated contains a value. Any payment
 * received for the returned [`PaymentHash`] will be required to be at least `min_value_msat`
 * before a [`PaymentReceived`] event will be generated, ensuring that we do not provide the
 * sender \"proof-of-payment\" unless they have paid the required amount.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time. This should roughly match the expiry time set in the invoice.
 * After this many seconds, we will remove the inbound payment, resulting in any attempts to
 * pay the invoice failing. The BOLT spec suggests 3,600 secs as a default validity time for
 * invoices when no timeout is set.
 *
 * Note that we use block header time to time-out pending inbound payments (with some margin
 * to compensate for the inaccuracy of block header timestamps). Thus, in practice we will
 * accept a payment and generate a [`PaymentReceived`] event for some time after the expiry.
 * If you need exact expiry semantics, you should enforce them upon receipt of
 * [`PaymentReceived`].
 *
 * Note that invoices generated for inbound payments should have their `min_final_cltv_expiry`
 * set to at least [`MIN_FINAL_CLTV_EXPIRY`].
 *
 * Note that a malicious eavesdropper can intuit whether an inbound payment was created by
 * `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
 *
 * # Note
 *
 * If you register an inbound payment with this method, then serialize the `ChannelManager`, then
 * deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
 *
 * Errors if `min_value_msat` is greater than total bitcoin supply.
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 * [`PaymentReceived`]: events::Event::PaymentReceived
 */
MUST_USE_RES struct LDKCResult_PaymentSecretNoneZ ChannelManager_create_inbound_payment_for_hash(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);

/**
 * Legacy version of [`create_inbound_payment_for_hash`]. Use this method if you wish to share
 * serialized state with LDK node(s) running 0.0.103 and earlier.
 *
 * May panic if `invoice_expiry_delta_secs` is greater than one year.
 *
 * # Note
 * This method is deprecated and will be removed soon.
 *
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 */
MUST_USE_RES struct LDKCResult_PaymentSecretAPIErrorZ ChannelManager_create_inbound_payment_for_hash_legacy(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);

/**
 * Gets an LDK-generated payment preimage from a payment hash and payment secret that were
 * previously returned from [`create_inbound_payment`].
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 */
MUST_USE_RES struct LDKCResult_PaymentPreimageAPIErrorZ ChannelManager_get_payment_preimage(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);

/**
 * Gets a fake short channel id for use in receiving [phantom node payments]. These fake scids
 * are used when constructing the phantom invoice's route hints.
 *
 * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
 */
MUST_USE_RES uint64_t ChannelManager_get_phantom_scid(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets route hints for use in receiving [phantom node payments].
 *
 * [phantom node payments]: crate::chain::keysinterface::PhantomKeysManager
 */
MUST_USE_RES struct LDKPhantomRouteHints ChannelManager_get_phantom_route_hints(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChannelManager_as_EventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChannelManager_as_Listen(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Confirm which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
 */
struct LDKConfirm ChannelManager_as_Confirm(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Blocks until ChannelManager needs to be persisted or a timeout is reached. It returns a bool
 * indicating whether persistence is necessary. Only one listener on
 * `await_persistable_update` or `await_persistable_update_timeout` is guaranteed to be woken
 * up.
 *
 * Note that this method is not available with the `no-std` feature.
 */
MUST_USE_RES bool ChannelManager_await_persistable_update_timeout(const struct LDKChannelManager *NONNULL_PTR this_arg, uint64_t max_wait);

/**
 * Blocks until ChannelManager needs to be persisted. Only one listener on
 * `await_persistable_update` or `await_persistable_update_timeout` is guaranteed to be woken
 * up.
 */
void ChannelManager_await_persistable_update(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the latest best block which was connected either via the [`chain::Listen`] or
 * [`chain::Confirm`] interfaces.
 */
MUST_USE_RES struct LDKBestBlock ChannelManager_current_best_block(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Serialize the CounterpartyForwardingInfo object into a byte array which can be read by CounterpartyForwardingInfo_read
 */
struct LDKCVec_u8Z CounterpartyForwardingInfo_write(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR obj);

/**
 * Read a CounterpartyForwardingInfo from a byte array, created by CounterpartyForwardingInfo_write
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CounterpartyForwardingInfo_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelCounterparty object into a byte array which can be read by ChannelCounterparty_read
 */
struct LDKCVec_u8Z ChannelCounterparty_write(const struct LDKChannelCounterparty *NONNULL_PTR obj);

/**
 * Read a ChannelCounterparty from a byte array, created by ChannelCounterparty_write
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ ChannelCounterparty_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelDetails object into a byte array which can be read by ChannelDetails_read
 */
struct LDKCVec_u8Z ChannelDetails_write(const struct LDKChannelDetails *NONNULL_PTR obj);

/**
 * Read a ChannelDetails from a byte array, created by ChannelDetails_write
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ ChannelDetails_read(struct LDKu8slice ser);

/**
 * Serialize the PhantomRouteHints object into a byte array which can be read by PhantomRouteHints_read
 */
struct LDKCVec_u8Z PhantomRouteHints_write(const struct LDKPhantomRouteHints *NONNULL_PTR obj);

/**
 * Read a PhantomRouteHints from a byte array, created by PhantomRouteHints_write
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ PhantomRouteHints_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelManager object into a byte array which can be read by ChannelManager_read
 */
struct LDKCVec_u8Z ChannelManager_write(const struct LDKChannelManager *NONNULL_PTR obj);

/**
 * Frees any resources used by the ChannelManagerReadArgs, if is_owned is set and inner is non-NULL.
 */
void ChannelManagerReadArgs_free(struct LDKChannelManagerReadArgs this_obj);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
const struct LDKKeysInterface *ChannelManagerReadArgs_get_keys_manager(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
void ChannelManagerReadArgs_set_keys_manager(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKKeysInterface val);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
const struct LDKFeeEstimator *ChannelManagerReadArgs_get_fee_estimator(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
void ChannelManagerReadArgs_set_fee_estimator(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKFeeEstimator val);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
const struct LDKWatch *ChannelManagerReadArgs_get_chain_monitor(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
void ChannelManagerReadArgs_set_chain_monitor(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKWatch val);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
const struct LDKBroadcasterInterface *ChannelManagerReadArgs_get_tx_broadcaster(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
void ChannelManagerReadArgs_set_tx_broadcaster(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKBroadcasterInterface val);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
const struct LDKLogger *ChannelManagerReadArgs_get_logger(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
void ChannelManagerReadArgs_set_logger(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKLogger val);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
struct LDKUserConfig ChannelManagerReadArgs_get_default_config(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
void ChannelManagerReadArgs_set_default_config(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKUserConfig val);

/**
 * Simple utility function to create a ChannelManagerReadArgs which creates the monitor
 * HashMap for you. This is primarily useful for C bindings where it is not practical to
 * populate a HashMap directly from C.
 */
MUST_USE_RES struct LDKChannelManagerReadArgs ChannelManagerReadArgs_new(struct LDKKeysInterface keys_manager, struct LDKFeeEstimator fee_estimator, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKUserConfig default_config, struct LDKCVec_ChannelMonitorZ channel_monitors);

/**
 * Read a C2Tuple_BlockHashChannelManagerZ from a byte array, created by C2Tuple_BlockHashChannelManagerZ_write
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ C2Tuple_BlockHashChannelManagerZ_read(struct LDKu8slice ser, struct LDKChannelManagerReadArgs arg);

/**
 * Frees any resources used by the DecodeError, if is_owned is set and inner is non-NULL.
 */
void DecodeError_free(struct LDKDecodeError this_obj);

/**
 * Creates a copy of the DecodeError
 */
struct LDKDecodeError DecodeError_clone(const struct LDKDecodeError *NONNULL_PTR orig);

/**
 * Frees any resources used by the Init, if is_owned is set and inner is non-NULL.
 */
void Init_free(struct LDKInit this_obj);

/**
 * The relevant features which the sender supports
 */
struct LDKInitFeatures Init_get_features(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * The relevant features which the sender supports
 */
void Init_set_features(struct LDKInit *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * The receipient's network address. This adds the option to report a remote IP address
 * back to a connecting peer using the init message. A node can decide to use that information
 * to discover a potential update to its public IPv4 address (NAT) and use
 * that for a node_announcement update message containing the new address.
 */
struct LDKCOption_NetAddressZ Init_get_remote_network_address(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * The receipient's network address. This adds the option to report a remote IP address
 * back to a connecting peer using the init message. A node can decide to use that information
 * to discover a potential update to its public IPv4 address (NAT) and use
 * that for a node_announcement update message containing the new address.
 */
void Init_set_remote_network_address(struct LDKInit *NONNULL_PTR this_ptr, struct LDKCOption_NetAddressZ val);

/**
 * Constructs a new Init given each field
 */
MUST_USE_RES struct LDKInit Init_new(struct LDKInitFeatures features_arg, struct LDKCOption_NetAddressZ remote_network_address_arg);

/**
 * Creates a copy of the Init
 */
struct LDKInit Init_clone(const struct LDKInit *NONNULL_PTR orig);

/**
 * Frees any resources used by the ErrorMessage, if is_owned is set and inner is non-NULL.
 */
void ErrorMessage_free(struct LDKErrorMessage this_obj);

/**
 * The channel ID involved in the error.
 *
 * All-0s indicates a general error unrelated to a specific channel, after which all channels
 * with the sending peer should be closed.
 */
const uint8_t (*ErrorMessage_get_channel_id(const struct LDKErrorMessage *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID involved in the error.
 *
 * All-0s indicates a general error unrelated to a specific channel, after which all channels
 * with the sending peer should be closed.
 */
void ErrorMessage_set_channel_id(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A possibly human-readable error description.
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
struct LDKStr ErrorMessage_get_data(const struct LDKErrorMessage *NONNULL_PTR this_ptr);

/**
 * A possibly human-readable error description.
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
void ErrorMessage_set_data(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new ErrorMessage given each field
 */
MUST_USE_RES struct LDKErrorMessage ErrorMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);

/**
 * Creates a copy of the ErrorMessage
 */
struct LDKErrorMessage ErrorMessage_clone(const struct LDKErrorMessage *NONNULL_PTR orig);

/**
 * Frees any resources used by the WarningMessage, if is_owned is set and inner is non-NULL.
 */
void WarningMessage_free(struct LDKWarningMessage this_obj);

/**
 * The channel ID involved in the warning.
 *
 * All-0s indicates a warning unrelated to a specific channel.
 */
const uint8_t (*WarningMessage_get_channel_id(const struct LDKWarningMessage *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID involved in the warning.
 *
 * All-0s indicates a warning unrelated to a specific channel.
 */
void WarningMessage_set_channel_id(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A possibly human-readable warning description.
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
struct LDKStr WarningMessage_get_data(const struct LDKWarningMessage *NONNULL_PTR this_ptr);

/**
 * A possibly human-readable warning description.
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
void WarningMessage_set_data(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new WarningMessage given each field
 */
MUST_USE_RES struct LDKWarningMessage WarningMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);

/**
 * Creates a copy of the WarningMessage
 */
struct LDKWarningMessage WarningMessage_clone(const struct LDKWarningMessage *NONNULL_PTR orig);

/**
 * Frees any resources used by the Ping, if is_owned is set and inner is non-NULL.
 */
void Ping_free(struct LDKPing this_obj);

/**
 * The desired response length
 */
uint16_t Ping_get_ponglen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The desired response length
 */
void Ping_set_ponglen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The ping packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Ping_get_byteslen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The ping packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Ping_set_byteslen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Ping given each field
 */
MUST_USE_RES struct LDKPing Ping_new(uint16_t ponglen_arg, uint16_t byteslen_arg);

/**
 * Creates a copy of the Ping
 */
struct LDKPing Ping_clone(const struct LDKPing *NONNULL_PTR orig);

/**
 * Frees any resources used by the Pong, if is_owned is set and inner is non-NULL.
 */
void Pong_free(struct LDKPong this_obj);

/**
 * The pong packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Pong_get_byteslen(const struct LDKPong *NONNULL_PTR this_ptr);

/**
 * The pong packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Pong_set_byteslen(struct LDKPong *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Pong given each field
 */
MUST_USE_RES struct LDKPong Pong_new(uint16_t byteslen_arg);

/**
 * Creates a copy of the Pong
 */
struct LDKPong Pong_clone(const struct LDKPong *NONNULL_PTR orig);

/**
 * Frees any resources used by the OpenChannel, if is_owned is set and inner is non-NULL.
 */
void OpenChannel_free(struct LDKOpenChannel this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*OpenChannel_get_chain_hash(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void OpenChannel_set_chain_hash(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*OpenChannel_get_temporary_channel_id(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void OpenChannel_set_temporary_channel_id(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The channel value
 */
uint64_t OpenChannel_get_funding_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel value
 */
void OpenChannel_set_funding_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
uint64_t OpenChannel_get_push_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
void OpenChannel_set_push_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t OpenChannel_get_dust_limit_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void OpenChannel_set_dust_limit_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t OpenChannel_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void OpenChannel_set_max_htlc_value_in_flight_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t OpenChannel_get_channel_reserve_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void OpenChannel_set_channel_reserve_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t OpenChannel_get_htlc_minimum_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void OpenChannel_set_htlc_minimum_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
 */
uint32_t OpenChannel_get_feerate_per_kw(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
 */
void OpenChannel_set_feerate_per_kw(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t OpenChannel_get_to_self_delay(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void OpenChannel_set_to_self_delay(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t OpenChannel_get_max_accepted_htlcs(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void OpenChannel_set_max_accepted_htlcs(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey OpenChannel_get_funding_pubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void OpenChannel_set_funding_pubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_revocation_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void OpenChannel_set_revocation_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_payment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void OpenChannel_set_payment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey OpenChannel_get_delayed_payment_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void OpenChannel_set_delayed_payment_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender
 */
struct LDKPublicKey OpenChannel_get_htlc_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender
 */
void OpenChannel_set_htlc_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey OpenChannel_get_first_per_commitment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void OpenChannel_set_first_per_commitment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Channel flags
 */
uint8_t OpenChannel_get_channel_flags(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void OpenChannel_set_channel_flags(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint8_t val);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures OpenChannel_get_channel_type(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void OpenChannel_set_channel_type(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Creates a copy of the OpenChannel
 */
struct LDKOpenChannel OpenChannel_clone(const struct LDKOpenChannel *NONNULL_PTR orig);

/**
 * Frees any resources used by the AcceptChannel, if is_owned is set and inner is non-NULL.
 */
void AcceptChannel_free(struct LDKAcceptChannel this_obj);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*AcceptChannel_get_temporary_channel_id(const struct LDKAcceptChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void AcceptChannel_set_temporary_channel_id(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t AcceptChannel_get_dust_limit_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void AcceptChannel_set_dust_limit_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void AcceptChannel_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t AcceptChannel_get_channel_reserve_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void AcceptChannel_set_channel_reserve_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_htlc_minimum_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void AcceptChannel_set_htlc_minimum_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
uint32_t AcceptChannel_get_minimum_depth(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
void AcceptChannel_set_minimum_depth(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t AcceptChannel_get_to_self_delay(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void AcceptChannel_set_to_self_delay(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t AcceptChannel_get_max_accepted_htlcs(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void AcceptChannel_set_max_accepted_htlcs(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey AcceptChannel_get_funding_pubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void AcceptChannel_set_funding_pubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_revocation_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void AcceptChannel_set_revocation_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_payment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_payment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void AcceptChannel_set_delayed_payment_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_htlc_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_htlc_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey AcceptChannel_get_first_per_commitment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void AcceptChannel_set_first_per_commitment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * This is required to match the equivalent field in [`OpenChannel::channel_type`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures AcceptChannel_get_channel_type(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * This is required to match the equivalent field in [`OpenChannel::channel_type`].
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void AcceptChannel_set_channel_type(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Creates a copy of the AcceptChannel
 */
struct LDKAcceptChannel AcceptChannel_clone(const struct LDKAcceptChannel *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingCreated, if is_owned is set and inner is non-NULL.
 */
void FundingCreated_free(struct LDKFundingCreated this_obj);

/**
 * A temporary channel ID, until the funding is established
 */
const uint8_t (*FundingCreated_get_temporary_channel_id(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding is established
 */
void FundingCreated_set_temporary_channel_id(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The funding transaction ID
 */
const uint8_t (*FundingCreated_get_funding_txid(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * The funding transaction ID
 */
void FundingCreated_set_funding_txid(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The specific output index funding this channel
 */
uint16_t FundingCreated_get_funding_output_index(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The specific output index funding this channel
 */
void FundingCreated_set_funding_output_index(struct LDKFundingCreated *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The signature of the channel initiator (funder) on the initial commitment transaction
 */
struct LDKSignature FundingCreated_get_signature(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The signature of the channel initiator (funder) on the initial commitment transaction
 */
void FundingCreated_set_signature(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new FundingCreated given each field
 */
MUST_USE_RES struct LDKFundingCreated FundingCreated_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, struct LDKThirtyTwoBytes funding_txid_arg, uint16_t funding_output_index_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the FundingCreated
 */
struct LDKFundingCreated FundingCreated_clone(const struct LDKFundingCreated *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingSigned, if is_owned is set and inner is non-NULL.
 */
void FundingSigned_free(struct LDKFundingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*FundingSigned_get_channel_id(const struct LDKFundingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void FundingSigned_set_channel_id(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The signature of the channel acceptor (fundee) on the initial commitment transaction
 */
struct LDKSignature FundingSigned_get_signature(const struct LDKFundingSigned *NONNULL_PTR this_ptr);

/**
 * The signature of the channel acceptor (fundee) on the initial commitment transaction
 */
void FundingSigned_set_signature(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new FundingSigned given each field
 */
MUST_USE_RES struct LDKFundingSigned FundingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the FundingSigned
 */
struct LDKFundingSigned FundingSigned_clone(const struct LDKFundingSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingLocked, if is_owned is set and inner is non-NULL.
 */
void FundingLocked_free(struct LDKFundingLocked this_obj);

/**
 * The channel ID
 */
const uint8_t (*FundingLocked_get_channel_id(const struct LDKFundingLocked *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void FundingLocked_set_channel_id(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The per-commitment point of the second commitment transaction
 */
struct LDKPublicKey FundingLocked_get_next_per_commitment_point(const struct LDKFundingLocked *NONNULL_PTR this_ptr);

/**
 * The per-commitment point of the second commitment transaction
 */
void FundingLocked_set_next_per_commitment_point(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * If set, provides a short_channel_id alias for this channel. The sender will accept payments
 * to be forwarded over this SCID and forward them to this messages' recipient.
 */
struct LDKCOption_u64Z FundingLocked_get_short_channel_id_alias(const struct LDKFundingLocked *NONNULL_PTR this_ptr);

/**
 * If set, provides a short_channel_id alias for this channel. The sender will accept payments
 * to be forwarded over this SCID and forward them to this messages' recipient.
 */
void FundingLocked_set_short_channel_id_alias(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new FundingLocked given each field
 */
MUST_USE_RES struct LDKFundingLocked FundingLocked_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKPublicKey next_per_commitment_point_arg, struct LDKCOption_u64Z short_channel_id_alias_arg);

/**
 * Creates a copy of the FundingLocked
 */
struct LDKFundingLocked FundingLocked_clone(const struct LDKFundingLocked *NONNULL_PTR orig);

/**
 * Frees any resources used by the Shutdown, if is_owned is set and inner is non-NULL.
 */
void Shutdown_free(struct LDKShutdown this_obj);

/**
 * The channel ID
 */
const uint8_t (*Shutdown_get_channel_id(const struct LDKShutdown *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void Shutdown_set_channel_id(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The destination of this peer's funds on closing.
 * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
 */
struct LDKu8slice Shutdown_get_scriptpubkey(const struct LDKShutdown *NONNULL_PTR this_ptr);

/**
 * The destination of this peer's funds on closing.
 * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
 */
void Shutdown_set_scriptpubkey(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new Shutdown given each field
 */
MUST_USE_RES struct LDKShutdown Shutdown_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z scriptpubkey_arg);

/**
 * Creates a copy of the Shutdown
 */
struct LDKShutdown Shutdown_clone(const struct LDKShutdown *NONNULL_PTR orig);

/**
 * Frees any resources used by the ClosingSignedFeeRange, if is_owned is set and inner is non-NULL.
 */
void ClosingSignedFeeRange_free(struct LDKClosingSignedFeeRange this_obj);

/**
 * The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
uint64_t ClosingSignedFeeRange_get_min_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);

/**
 * The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
void ClosingSignedFeeRange_set_min_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
uint64_t ClosingSignedFeeRange_get_max_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);

/**
 * The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
void ClosingSignedFeeRange_set_max_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ClosingSignedFeeRange given each field
 */
MUST_USE_RES struct LDKClosingSignedFeeRange ClosingSignedFeeRange_new(uint64_t min_fee_satoshis_arg, uint64_t max_fee_satoshis_arg);

/**
 * Creates a copy of the ClosingSignedFeeRange
 */
struct LDKClosingSignedFeeRange ClosingSignedFeeRange_clone(const struct LDKClosingSignedFeeRange *NONNULL_PTR orig);

/**
 * Frees any resources used by the ClosingSigned, if is_owned is set and inner is non-NULL.
 */
void ClosingSigned_free(struct LDKClosingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*ClosingSigned_get_channel_id(const struct LDKClosingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ClosingSigned_set_channel_id(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The proposed total fee for the closing transaction
 */
uint64_t ClosingSigned_get_fee_satoshis(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * The proposed total fee for the closing transaction
 */
void ClosingSigned_set_fee_satoshis(struct LDKClosingSigned *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature on the closing transaction
 */
struct LDKSignature ClosingSigned_get_signature(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the closing transaction
 */
void ClosingSigned_set_signature(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The minimum and maximum fees which the sender is willing to accept, provided only by new
 * nodes.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKClosingSignedFeeRange ClosingSigned_get_fee_range(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * The minimum and maximum fees which the sender is willing to accept, provided only by new
 * nodes.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ClosingSigned_set_fee_range(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKClosingSignedFeeRange val);

/**
 * Constructs a new ClosingSigned given each field
 */
MUST_USE_RES struct LDKClosingSigned ClosingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t fee_satoshis_arg, struct LDKSignature signature_arg, struct LDKClosingSignedFeeRange fee_range_arg);

/**
 * Creates a copy of the ClosingSigned
 */
struct LDKClosingSigned ClosingSigned_clone(const struct LDKClosingSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateAddHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateAddHTLC_free(struct LDKUpdateAddHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateAddHTLC_get_channel_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateAddHTLC_set_channel_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateAddHTLC_get_htlc_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateAddHTLC_set_htlc_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The HTLC value in milli-satoshi
 */
uint64_t UpdateAddHTLC_get_amount_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC value in milli-satoshi
 */
void UpdateAddHTLC_set_amount_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
const uint8_t (*UpdateAddHTLC_get_payment_hash(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
void UpdateAddHTLC_set_payment_hash(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The expiry height of the HTLC
 */
uint32_t UpdateAddHTLC_get_cltv_expiry(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The expiry height of the HTLC
 */
void UpdateAddHTLC_set_cltv_expiry(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the UpdateAddHTLC
 */
struct LDKUpdateAddHTLC UpdateAddHTLC_clone(const struct LDKUpdateAddHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFulfillHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFulfillHTLC_free(struct LDKUpdateFulfillHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFulfillHTLC_get_channel_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFulfillHTLC_set_channel_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFulfillHTLC_get_htlc_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFulfillHTLC_set_htlc_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
const uint8_t (*UpdateFulfillHTLC_get_payment_preimage(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
void UpdateFulfillHTLC_set_payment_preimage(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new UpdateFulfillHTLC given each field
 */
MUST_USE_RES struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t htlc_id_arg, struct LDKThirtyTwoBytes payment_preimage_arg);

/**
 * Creates a copy of the UpdateFulfillHTLC
 */
struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(const struct LDKUpdateFulfillHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFailHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailHTLC_free(struct LDKUpdateFailHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailHTLC_get_channel_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailHTLC_set_channel_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailHTLC_get_htlc_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailHTLC_set_htlc_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the UpdateFailHTLC
 */
struct LDKUpdateFailHTLC UpdateFailHTLC_clone(const struct LDKUpdateFailHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFailMalformedHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailMalformedHTLC_free(struct LDKUpdateFailMalformedHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailMalformedHTLC_get_channel_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailMalformedHTLC_set_channel_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailMalformedHTLC_get_htlc_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailMalformedHTLC_set_htlc_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The failure code
 */
uint16_t UpdateFailMalformedHTLC_get_failure_code(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The failure code
 */
void UpdateFailMalformedHTLC_set_failure_code(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Creates a copy of the UpdateFailMalformedHTLC
 */
struct LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the CommitmentSigned, if is_owned is set and inner is non-NULL.
 */
void CommitmentSigned_free(struct LDKCommitmentSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*CommitmentSigned_get_channel_id(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void CommitmentSigned_set_channel_id(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A signature on the commitment transaction
 */
struct LDKSignature CommitmentSigned_get_signature(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the commitment transaction
 */
void CommitmentSigned_set_signature(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Signatures on the HTLC transactions
 */
void CommitmentSigned_set_htlc_signatures(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);

/**
 * Constructs a new CommitmentSigned given each field
 */
MUST_USE_RES struct LDKCommitmentSigned CommitmentSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg, struct LDKCVec_SignatureZ htlc_signatures_arg);

/**
 * Creates a copy of the CommitmentSigned
 */
struct LDKCommitmentSigned CommitmentSigned_clone(const struct LDKCommitmentSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the RevokeAndACK, if is_owned is set and inner is non-NULL.
 */
void RevokeAndACK_free(struct LDKRevokeAndACK this_obj);

/**
 * The channel ID
 */
const uint8_t (*RevokeAndACK_get_channel_id(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void RevokeAndACK_set_channel_id(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The secret corresponding to the per-commitment point
 */
const uint8_t (*RevokeAndACK_get_per_commitment_secret(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The secret corresponding to the per-commitment point
 */
void RevokeAndACK_set_per_commitment_secret(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
struct LDKPublicKey RevokeAndACK_get_next_per_commitment_point(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
void RevokeAndACK_set_next_per_commitment_point(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new RevokeAndACK given each field
 */
MUST_USE_RES struct LDKRevokeAndACK RevokeAndACK_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes per_commitment_secret_arg, struct LDKPublicKey next_per_commitment_point_arg);

/**
 * Creates a copy of the RevokeAndACK
 */
struct LDKRevokeAndACK RevokeAndACK_clone(const struct LDKRevokeAndACK *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFee, if is_owned is set and inner is non-NULL.
 */
void UpdateFee_free(struct LDKUpdateFee this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFee_get_channel_id(const struct LDKUpdateFee *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFee_set_channel_id(struct LDKUpdateFee *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Fee rate per 1000-weight of the transaction
 */
uint32_t UpdateFee_get_feerate_per_kw(const struct LDKUpdateFee *NONNULL_PTR this_ptr);

/**
 * Fee rate per 1000-weight of the transaction
 */
void UpdateFee_set_feerate_per_kw(struct LDKUpdateFee *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new UpdateFee given each field
 */
MUST_USE_RES struct LDKUpdateFee UpdateFee_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t feerate_per_kw_arg);

/**
 * Creates a copy of the UpdateFee
 */
struct LDKUpdateFee UpdateFee_clone(const struct LDKUpdateFee *NONNULL_PTR orig);

/**
 * Frees any resources used by the DataLossProtect, if is_owned is set and inner is non-NULL.
 */
void DataLossProtect_free(struct LDKDataLossProtect this_obj);

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
const uint8_t (*DataLossProtect_get_your_last_per_commitment_secret(const struct LDKDataLossProtect *NONNULL_PTR this_ptr))[32];

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
void DataLossProtect_set_your_last_per_commitment_secret(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
struct LDKPublicKey DataLossProtect_get_my_current_per_commitment_point(const struct LDKDataLossProtect *NONNULL_PTR this_ptr);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
void DataLossProtect_set_my_current_per_commitment_point(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new DataLossProtect given each field
 */
MUST_USE_RES struct LDKDataLossProtect DataLossProtect_new(struct LDKThirtyTwoBytes your_last_per_commitment_secret_arg, struct LDKPublicKey my_current_per_commitment_point_arg);

/**
 * Creates a copy of the DataLossProtect
 */
struct LDKDataLossProtect DataLossProtect_clone(const struct LDKDataLossProtect *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelReestablish, if is_owned is set and inner is non-NULL.
 */
void ChannelReestablish_free(struct LDKChannelReestablish this_obj);

/**
 * The channel ID
 */
const uint8_t (*ChannelReestablish_get_channel_id(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ChannelReestablish_set_channel_id(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next commitment number for the sender
 */
uint64_t ChannelReestablish_get_next_local_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the sender
 */
void ChannelReestablish_set_next_local_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The next commitment number for the recipient
 */
uint64_t ChannelReestablish_get_next_remote_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the recipient
 */
void ChannelReestablish_set_next_remote_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelReestablish
 */
struct LDKChannelReestablish ChannelReestablish_clone(const struct LDKChannelReestablish *NONNULL_PTR orig);

/**
 * Frees any resources used by the AnnouncementSignatures, if is_owned is set and inner is non-NULL.
 */
void AnnouncementSignatures_free(struct LDKAnnouncementSignatures this_obj);

/**
 * The channel ID
 */
const uint8_t (*AnnouncementSignatures_get_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void AnnouncementSignatures_set_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t AnnouncementSignatures_get_short_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void AnnouncementSignatures_set_short_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature by the node key
 */
struct LDKSignature AnnouncementSignatures_get_node_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the node key
 */
void AnnouncementSignatures_set_node_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * A signature by the funding key
 */
struct LDKSignature AnnouncementSignatures_get_bitcoin_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the funding key
 */
void AnnouncementSignatures_set_bitcoin_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new AnnouncementSignatures given each field
 */
MUST_USE_RES struct LDKAnnouncementSignatures AnnouncementSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t short_channel_id_arg, struct LDKSignature node_signature_arg, struct LDKSignature bitcoin_signature_arg);

/**
 * Creates a copy of the AnnouncementSignatures
 */
struct LDKAnnouncementSignatures AnnouncementSignatures_clone(const struct LDKAnnouncementSignatures *NONNULL_PTR orig);

/**
 * Frees any resources used by the NetAddress
 */
void NetAddress_free(struct LDKNetAddress this_ptr);

/**
 * Creates a copy of the NetAddress
 */
struct LDKNetAddress NetAddress_clone(const struct LDKNetAddress *NONNULL_PTR orig);

/**
 * Utility method to constructs a new IPv4-variant NetAddress
 */
struct LDKNetAddress NetAddress_ipv4(struct LDKFourBytes addr, uint16_t port);

/**
 * Utility method to constructs a new IPv6-variant NetAddress
 */
struct LDKNetAddress NetAddress_ipv6(struct LDKSixteenBytes addr, uint16_t port);

/**
 * Utility method to constructs a new OnionV2-variant NetAddress
 */
struct LDKNetAddress NetAddress_onion_v2(struct LDKTwelveBytes a);

/**
 * Utility method to constructs a new OnionV3-variant NetAddress
 */
struct LDKNetAddress NetAddress_onion_v3(struct LDKThirtyTwoBytes ed25519_pubkey, uint16_t checksum, uint8_t version, uint16_t port);

/**
 * Serialize the NetAddress object into a byte array which can be read by NetAddress_read
 */
struct LDKCVec_u8Z NetAddress_write(const struct LDKNetAddress *NONNULL_PTR obj);

/**
 * Read a NetAddress from a byte array, created by NetAddress_write
 */
struct LDKCResult_NetAddressDecodeErrorZ NetAddress_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UnsignedNodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedNodeAnnouncement_free(struct LDKUnsignedNodeAnnouncement this_obj);

/**
 * The advertised features
 */
struct LDKNodeFeatures UnsignedNodeAnnouncement_get_features(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised features
 */
void UnsignedNodeAnnouncement_set_features(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
uint32_t UnsignedNodeAnnouncement_get_timestamp(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
void UnsignedNodeAnnouncement_set_timestamp(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The node_id this announcement originated from (don't rebroadcast the node_announcement back
 * to this node).
 */
struct LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The node_id this announcement originated from (don't rebroadcast the node_announcement back
 * to this node).
 */
void UnsignedNodeAnnouncement_set_node_id(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * An RGB color for UI purposes
 */
const uint8_t (*UnsignedNodeAnnouncement_get_rgb(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[3];

/**
 * An RGB color for UI purposes
 */
void UnsignedNodeAnnouncement_set_rgb(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
 * of uniqueness.
 */
const uint8_t (*UnsignedNodeAnnouncement_get_alias(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
 * of uniqueness.
 */
void UnsignedNodeAnnouncement_set_alias(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * List of addresses on which this node is reachable
 */
void UnsignedNodeAnnouncement_set_addresses(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);

/**
 * Creates a copy of the UnsignedNodeAnnouncement
 */
struct LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the NodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncement_free(struct LDKNodeAnnouncement this_obj);

/**
 * The signature by the node key
 */
struct LDKSignature NodeAnnouncement_get_signature(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The signature by the node key
 */
void NodeAnnouncement_set_signature(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual content of the announcement
 */
struct LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual content of the announcement
 */
void NodeAnnouncement_set_contents(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncement given each field
 */
MUST_USE_RES struct LDKNodeAnnouncement NodeAnnouncement_new(struct LDKSignature signature_arg, struct LDKUnsignedNodeAnnouncement contents_arg);

/**
 * Creates a copy of the NodeAnnouncement
 */
struct LDKNodeAnnouncement NodeAnnouncement_clone(const struct LDKNodeAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the UnsignedChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelAnnouncement_free(struct LDKUnsignedChannelAnnouncement this_obj);

/**
 * The advertised channel features
 */
struct LDKChannelFeatures UnsignedChannelAnnouncement_get_features(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised channel features
 */
void UnsignedChannelAnnouncement_set_features(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelAnnouncement_get_chain_hash(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelAnnouncement_set_chain_hash(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelAnnouncement_get_short_channel_id(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelAnnouncement_set_short_channel_id(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, uint64_t val);

/**
 * One of the two node_ids which are endpoints of this channel
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * One of the two node_ids which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The other of the two node_ids which are endpoints of this channel
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The other of the two node_ids which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The funding key for the first node
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the first node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The funding key for the second node
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the second node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Creates a copy of the UnsignedChannelAnnouncement
 */
struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void ChannelAnnouncement_free(struct LDKChannelAnnouncement this_obj);

/**
 * Authentication of the announcement by the first public node
 */
struct LDKSignature ChannelAnnouncement_get_node_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the first public node
 */
void ChannelAnnouncement_set_node_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Authentication of the announcement by the second public node
 */
struct LDKSignature ChannelAnnouncement_get_node_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the second public node
 */
void ChannelAnnouncement_set_node_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Proof of funding UTXO ownership by the first public node
 */
struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the first public node
 */
void ChannelAnnouncement_set_bitcoin_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Proof of funding UTXO ownership by the second public node
 */
struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the second public node
 */
void ChannelAnnouncement_set_bitcoin_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual announcement
 */
struct LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual announcement
 */
void ChannelAnnouncement_set_contents(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedChannelAnnouncement val);

/**
 * Constructs a new ChannelAnnouncement given each field
 */
MUST_USE_RES struct LDKChannelAnnouncement ChannelAnnouncement_new(struct LDKSignature node_signature_1_arg, struct LDKSignature node_signature_2_arg, struct LDKSignature bitcoin_signature_1_arg, struct LDKSignature bitcoin_signature_2_arg, struct LDKUnsignedChannelAnnouncement contents_arg);

/**
 * Creates a copy of the ChannelAnnouncement
 */
struct LDKChannelAnnouncement ChannelAnnouncement_clone(const struct LDKChannelAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the UnsignedChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelUpdate_free(struct LDKUnsignedChannelUpdate this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelUpdate_get_chain_hash(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelUpdate_set_chain_hash(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelUpdate_get_short_channel_id(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelUpdate_set_short_channel_id(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
uint32_t UnsignedChannelUpdate_get_timestamp(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
void UnsignedChannelUpdate_set_timestamp(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Channel flags
 */
uint8_t UnsignedChannelUpdate_get_flags(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void UnsignedChannelUpdate_set_flags(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint8_t val);

/**
 * The number of blocks such that if:
 * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
 * then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
 * the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
 * cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
 * then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
 * forwarding. Note that the HTLC sender is the one who originally sets this value when
 * constructing the route.
 */
uint16_t UnsignedChannelUpdate_get_cltv_expiry_delta(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The number of blocks such that if:
 * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
 * then we need to fail the HTLC backwards. When forwarding an HTLC, cltv_expiry_delta determines
 * the outgoing HTLC's minimum cltv_expiry value -- so, if an incoming HTLC comes in with a
 * cltv_expiry of 100000, and the node we're forwarding to has a cltv_expiry_delta value of 10,
 * then we'll check that the outgoing HTLC's cltv_expiry value is at least 100010 before
 * forwarding. Note that the HTLC sender is the one who originally sets this value when
 * constructing the route.
 */
void UnsignedChannelUpdate_set_cltv_expiry_delta(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t UnsignedChannelUpdate_get_htlc_minimum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_htlc_minimum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_base_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_fee_base_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_proportional_millionths(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
void UnsignedChannelUpdate_set_fee_proportional_millionths(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the UnsignedChannelUpdate
 */
struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(const struct LDKUnsignedChannelUpdate *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelUpdate_free(struct LDKChannelUpdate this_obj);

/**
 * A signature of the channel update
 */
struct LDKSignature ChannelUpdate_get_signature(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A signature of the channel update
 */
void ChannelUpdate_set_signature(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual channel update
 */
struct LDKUnsignedChannelUpdate ChannelUpdate_get_contents(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The actual channel update
 */
void ChannelUpdate_set_contents(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKUnsignedChannelUpdate val);

/**
 * Constructs a new ChannelUpdate given each field
 */
MUST_USE_RES struct LDKChannelUpdate ChannelUpdate_new(struct LDKSignature signature_arg, struct LDKUnsignedChannelUpdate contents_arg);

/**
 * Creates a copy of the ChannelUpdate
 */
struct LDKChannelUpdate ChannelUpdate_clone(const struct LDKChannelUpdate *NONNULL_PTR orig);

/**
 * Frees any resources used by the QueryChannelRange, if is_owned is set and inner is non-NULL.
 */
void QueryChannelRange_free(struct LDKQueryChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryChannelRange_get_chain_hash(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryChannelRange_set_chain_hash(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block for the channel UTXOs being queried
 */
uint32_t QueryChannelRange_get_first_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block for the channel UTXOs being queried
 */
void QueryChannelRange_set_first_blocknum(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks to include in the query results
 */
uint32_t QueryChannelRange_get_number_of_blocks(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks to include in the query results
 */
void QueryChannelRange_set_number_of_blocks(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new QueryChannelRange given each field
 */
MUST_USE_RES struct LDKQueryChannelRange QueryChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg);

/**
 * Creates a copy of the QueryChannelRange
 */
struct LDKQueryChannelRange QueryChannelRange_clone(const struct LDKQueryChannelRange *NONNULL_PTR orig);

/**
 * Frees any resources used by the ReplyChannelRange, if is_owned is set and inner is non-NULL.
 */
void ReplyChannelRange_free(struct LDKReplyChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*ReplyChannelRange_get_chain_hash(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void ReplyChannelRange_set_chain_hash(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block in the range of the reply
 */
uint32_t ReplyChannelRange_get_first_blocknum(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block in the range of the reply
 */
void ReplyChannelRange_set_first_blocknum(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks included in the range of the reply
 */
uint32_t ReplyChannelRange_get_number_of_blocks(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks included in the range of the reply
 */
void ReplyChannelRange_set_number_of_blocks(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * True when this is the final reply for a query
 */
bool ReplyChannelRange_get_sync_complete(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * True when this is the final reply for a query
 */
void ReplyChannelRange_set_sync_complete(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, bool val);

/**
 * The short_channel_ids in the channel range
 */
void ReplyChannelRange_set_short_channel_ids(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new ReplyChannelRange given each field
 */
MUST_USE_RES struct LDKReplyChannelRange ReplyChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg, bool sync_complete_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the ReplyChannelRange
 */
struct LDKReplyChannelRange ReplyChannelRange_clone(const struct LDKReplyChannelRange *NONNULL_PTR orig);

/**
 * Frees any resources used by the QueryShortChannelIds, if is_owned is set and inner is non-NULL.
 */
void QueryShortChannelIds_free(struct LDKQueryShortChannelIds this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryShortChannelIds_get_chain_hash(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryShortChannelIds_set_chain_hash(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short_channel_ids that are being queried
 */
void QueryShortChannelIds_set_short_channel_ids(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new QueryShortChannelIds given each field
 */
MUST_USE_RES struct LDKQueryShortChannelIds QueryShortChannelIds_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the QueryShortChannelIds
 */
struct LDKQueryShortChannelIds QueryShortChannelIds_clone(const struct LDKQueryShortChannelIds *NONNULL_PTR orig);

/**
 * Frees any resources used by the ReplyShortChannelIdsEnd, if is_owned is set and inner is non-NULL.
 */
void ReplyShortChannelIdsEnd_free(struct LDKReplyShortChannelIdsEnd this_obj);

/**
 * The genesis hash of the blockchain that was queried
 */
const uint8_t (*ReplyShortChannelIdsEnd_get_chain_hash(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain that was queried
 */
void ReplyShortChannelIdsEnd_set_chain_hash(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the chain_hash
 */
bool ReplyShortChannelIdsEnd_get_full_information(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the chain_hash
 */
void ReplyShortChannelIdsEnd_set_full_information(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ReplyShortChannelIdsEnd given each field
 */
MUST_USE_RES struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(struct LDKThirtyTwoBytes chain_hash_arg, bool full_information_arg);

/**
 * Creates a copy of the ReplyShortChannelIdsEnd
 */
struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR orig);

/**
 * Frees any resources used by the GossipTimestampFilter, if is_owned is set and inner is non-NULL.
 */
void GossipTimestampFilter_free(struct LDKGossipTimestampFilter this_obj);

/**
 * The genesis hash of the blockchain for channel and node information
 */
const uint8_t (*GossipTimestampFilter_get_chain_hash(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain for channel and node information
 */
void GossipTimestampFilter_set_chain_hash(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The starting unix timestamp
 */
uint32_t GossipTimestampFilter_get_first_timestamp(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The starting unix timestamp
 */
void GossipTimestampFilter_set_first_timestamp(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The range of information in seconds
 */
uint32_t GossipTimestampFilter_get_timestamp_range(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The range of information in seconds
 */
void GossipTimestampFilter_set_timestamp_range(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new GossipTimestampFilter given each field
 */
MUST_USE_RES struct LDKGossipTimestampFilter GossipTimestampFilter_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_timestamp_arg, uint32_t timestamp_range_arg);

/**
 * Creates a copy of the GossipTimestampFilter
 */
struct LDKGossipTimestampFilter GossipTimestampFilter_clone(const struct LDKGossipTimestampFilter *NONNULL_PTR orig);

/**
 * Frees any resources used by the ErrorAction
 */
void ErrorAction_free(struct LDKErrorAction this_ptr);

/**
 * Creates a copy of the ErrorAction
 */
struct LDKErrorAction ErrorAction_clone(const struct LDKErrorAction *NONNULL_PTR orig);

/**
 * Utility method to constructs a new DisconnectPeer-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_disconnect_peer(struct LDKErrorMessage msg);

/**
 * Utility method to constructs a new IgnoreError-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_error(void);

/**
 * Utility method to constructs a new IgnoreAndLog-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_and_log(enum LDKLevel a);

/**
 * Utility method to constructs a new IgnoreDuplicateGossip-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_duplicate_gossip(void);

/**
 * Utility method to constructs a new SendErrorMessage-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_send_error_message(struct LDKErrorMessage msg);

/**
 * Utility method to constructs a new SendWarningMessage-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_send_warning_message(struct LDKWarningMessage msg, enum LDKLevel log_level);

/**
 * Frees any resources used by the LightningError, if is_owned is set and inner is non-NULL.
 */
void LightningError_free(struct LDKLightningError this_obj);

/**
 * A human-readable message describing the error
 */
struct LDKStr LightningError_get_err(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * A human-readable message describing the error
 */
void LightningError_set_err(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The action which should be taken against the offending peer.
 */
struct LDKErrorAction LightningError_get_action(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * The action which should be taken against the offending peer.
 */
void LightningError_set_action(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKErrorAction val);

/**
 * Constructs a new LightningError given each field
 */
MUST_USE_RES struct LDKLightningError LightningError_new(struct LDKStr err_arg, struct LDKErrorAction action_arg);

/**
 * Creates a copy of the LightningError
 */
struct LDKLightningError LightningError_clone(const struct LDKLightningError *NONNULL_PTR orig);

/**
 * Frees any resources used by the CommitmentUpdate, if is_owned is set and inner is non-NULL.
 */
void CommitmentUpdate_free(struct LDKCommitmentUpdate this_obj);

/**
 * update_add_htlc messages which should be sent
 */
struct LDKCVec_UpdateAddHTLCZ CommitmentUpdate_get_update_add_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * update_add_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_add_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateAddHTLCZ val);

/**
 * update_fulfill_htlc messages which should be sent
 */
struct LDKCVec_UpdateFulfillHTLCZ CommitmentUpdate_get_update_fulfill_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * update_fulfill_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fulfill_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFulfillHTLCZ val);

/**
 * update_fail_htlc messages which should be sent
 */
struct LDKCVec_UpdateFailHTLCZ CommitmentUpdate_get_update_fail_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * update_fail_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fail_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailHTLCZ val);

/**
 * update_fail_malformed_htlc messages which should be sent
 */
struct LDKCVec_UpdateFailMalformedHTLCZ CommitmentUpdate_get_update_fail_malformed_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * update_fail_malformed_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fail_malformed_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailMalformedHTLCZ val);

/**
 * An update_fee message which should be sent
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKUpdateFee CommitmentUpdate_get_update_fee(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * An update_fee message which should be sent
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void CommitmentUpdate_set_update_fee(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKUpdateFee val);

/**
 * Finally, the commitment_signed message which should be sent
 */
struct LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * Finally, the commitment_signed message which should be sent
 */
void CommitmentUpdate_set_commitment_signed(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCommitmentSigned val);

/**
 * Constructs a new CommitmentUpdate given each field
 */
MUST_USE_RES struct LDKCommitmentUpdate CommitmentUpdate_new(struct LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, struct LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, struct LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, struct LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, struct LDKUpdateFee update_fee_arg, struct LDKCommitmentSigned commitment_signed_arg);

/**
 * Creates a copy of the CommitmentUpdate
 */
struct LDKCommitmentUpdate CommitmentUpdate_clone(const struct LDKCommitmentUpdate *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void ChannelMessageHandler_free(struct LDKChannelMessageHandler this_ptr);

/**
 * Calls the free function if one is set
 */
void RoutingMessageHandler_free(struct LDKRoutingMessageHandler this_ptr);

/**
 * Serialize the AcceptChannel object into a byte array which can be read by AcceptChannel_read
 */
struct LDKCVec_u8Z AcceptChannel_write(const struct LDKAcceptChannel *NONNULL_PTR obj);

/**
 * Read a AcceptChannel from a byte array, created by AcceptChannel_write
 */
struct LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(struct LDKu8slice ser);

/**
 * Serialize the AnnouncementSignatures object into a byte array which can be read by AnnouncementSignatures_read
 */
struct LDKCVec_u8Z AnnouncementSignatures_write(const struct LDKAnnouncementSignatures *NONNULL_PTR obj);

/**
 * Read a AnnouncementSignatures from a byte array, created by AnnouncementSignatures_write
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelReestablish object into a byte array which can be read by ChannelReestablish_read
 */
struct LDKCVec_u8Z ChannelReestablish_write(const struct LDKChannelReestablish *NONNULL_PTR obj);

/**
 * Read a ChannelReestablish from a byte array, created by ChannelReestablish_write
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(struct LDKu8slice ser);

/**
 * Serialize the ClosingSigned object into a byte array which can be read by ClosingSigned_read
 */
struct LDKCVec_u8Z ClosingSigned_write(const struct LDKClosingSigned *NONNULL_PTR obj);

/**
 * Read a ClosingSigned from a byte array, created by ClosingSigned_write
 */
struct LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the ClosingSignedFeeRange object into a byte array which can be read by ClosingSignedFeeRange_read
 */
struct LDKCVec_u8Z ClosingSignedFeeRange_write(const struct LDKClosingSignedFeeRange *NONNULL_PTR obj);

/**
 * Read a ClosingSignedFeeRange from a byte array, created by ClosingSignedFeeRange_write
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ ClosingSignedFeeRange_read(struct LDKu8slice ser);

/**
 * Serialize the CommitmentSigned object into a byte array which can be read by CommitmentSigned_read
 */
struct LDKCVec_u8Z CommitmentSigned_write(const struct LDKCommitmentSigned *NONNULL_PTR obj);

/**
 * Read a CommitmentSigned from a byte array, created by CommitmentSigned_write
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(struct LDKu8slice ser);

/**
 * Serialize the FundingCreated object into a byte array which can be read by FundingCreated_read
 */
struct LDKCVec_u8Z FundingCreated_write(const struct LDKFundingCreated *NONNULL_PTR obj);

/**
 * Read a FundingCreated from a byte array, created by FundingCreated_write
 */
struct LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(struct LDKu8slice ser);

/**
 * Serialize the FundingSigned object into a byte array which can be read by FundingSigned_read
 */
struct LDKCVec_u8Z FundingSigned_write(const struct LDKFundingSigned *NONNULL_PTR obj);

/**
 * Read a FundingSigned from a byte array, created by FundingSigned_write
 */
struct LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the FundingLocked object into a byte array which can be read by FundingLocked_read
 */
struct LDKCVec_u8Z FundingLocked_write(const struct LDKFundingLocked *NONNULL_PTR obj);

/**
 * Read a FundingLocked from a byte array, created by FundingLocked_write
 */
struct LDKCResult_FundingLockedDecodeErrorZ FundingLocked_read(struct LDKu8slice ser);

/**
 * Serialize the Init object into a byte array which can be read by Init_read
 */
struct LDKCVec_u8Z Init_write(const struct LDKInit *NONNULL_PTR obj);

/**
 * Read a Init from a byte array, created by Init_write
 */
struct LDKCResult_InitDecodeErrorZ Init_read(struct LDKu8slice ser);

/**
 * Serialize the OpenChannel object into a byte array which can be read by OpenChannel_read
 */
struct LDKCVec_u8Z OpenChannel_write(const struct LDKOpenChannel *NONNULL_PTR obj);

/**
 * Read a OpenChannel from a byte array, created by OpenChannel_write
 */
struct LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(struct LDKu8slice ser);

/**
 * Serialize the RevokeAndACK object into a byte array which can be read by RevokeAndACK_read
 */
struct LDKCVec_u8Z RevokeAndACK_write(const struct LDKRevokeAndACK *NONNULL_PTR obj);

/**
 * Read a RevokeAndACK from a byte array, created by RevokeAndACK_write
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(struct LDKu8slice ser);

/**
 * Serialize the Shutdown object into a byte array which can be read by Shutdown_read
 */
struct LDKCVec_u8Z Shutdown_write(const struct LDKShutdown *NONNULL_PTR obj);

/**
 * Read a Shutdown from a byte array, created by Shutdown_write
 */
struct LDKCResult_ShutdownDecodeErrorZ Shutdown_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailHTLC object into a byte array which can be read by UpdateFailHTLC_read
 */
struct LDKCVec_u8Z UpdateFailHTLC_write(const struct LDKUpdateFailHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailHTLC from a byte array, created by UpdateFailHTLC_write
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailMalformedHTLC object into a byte array which can be read by UpdateFailMalformedHTLC_read
 */
struct LDKCVec_u8Z UpdateFailMalformedHTLC_write(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailMalformedHTLC from a byte array, created by UpdateFailMalformedHTLC_write
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFee object into a byte array which can be read by UpdateFee_read
 */
struct LDKCVec_u8Z UpdateFee_write(const struct LDKUpdateFee *NONNULL_PTR obj);

/**
 * Read a UpdateFee from a byte array, created by UpdateFee_write
 */
struct LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFulfillHTLC object into a byte array which can be read by UpdateFulfillHTLC_read
 */
struct LDKCVec_u8Z UpdateFulfillHTLC_write(const struct LDKUpdateFulfillHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFulfillHTLC from a byte array, created by UpdateFulfillHTLC_write
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateAddHTLC object into a byte array which can be read by UpdateAddHTLC_read
 */
struct LDKCVec_u8Z UpdateAddHTLC_write(const struct LDKUpdateAddHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateAddHTLC from a byte array, created by UpdateAddHTLC_write
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the Ping object into a byte array which can be read by Ping_read
 */
struct LDKCVec_u8Z Ping_write(const struct LDKPing *NONNULL_PTR obj);

/**
 * Read a Ping from a byte array, created by Ping_write
 */
struct LDKCResult_PingDecodeErrorZ Ping_read(struct LDKu8slice ser);

/**
 * Serialize the Pong object into a byte array which can be read by Pong_read
 */
struct LDKCVec_u8Z Pong_write(const struct LDKPong *NONNULL_PTR obj);

/**
 * Read a Pong from a byte array, created by Pong_write
 */
struct LDKCResult_PongDecodeErrorZ Pong_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelAnnouncement object into a byte array which can be read by UnsignedChannelAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedChannelAnnouncement_write(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelAnnouncement from a byte array, created by UnsignedChannelAnnouncement_write
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ UnsignedChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelAnnouncement object into a byte array which can be read by ChannelAnnouncement_read
 */
struct LDKCVec_u8Z ChannelAnnouncement_write(const struct LDKChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a ChannelAnnouncement from a byte array, created by ChannelAnnouncement_write
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelUpdate object into a byte array which can be read by UnsignedChannelUpdate_read
 */
struct LDKCVec_u8Z UnsignedChannelUpdate_write(const struct LDKUnsignedChannelUpdate *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelUpdate from a byte array, created by UnsignedChannelUpdate_write
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelUpdate object into a byte array which can be read by ChannelUpdate_read
 */
struct LDKCVec_u8Z ChannelUpdate_write(const struct LDKChannelUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelUpdate from a byte array, created by ChannelUpdate_write
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ErrorMessage object into a byte array which can be read by ErrorMessage_read
 */
struct LDKCVec_u8Z ErrorMessage_write(const struct LDKErrorMessage *NONNULL_PTR obj);

/**
 * Read a ErrorMessage from a byte array, created by ErrorMessage_write
 */
struct LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(struct LDKu8slice ser);

/**
 * Serialize the WarningMessage object into a byte array which can be read by WarningMessage_read
 */
struct LDKCVec_u8Z WarningMessage_write(const struct LDKWarningMessage *NONNULL_PTR obj);

/**
 * Read a WarningMessage from a byte array, created by WarningMessage_write
 */
struct LDKCResult_WarningMessageDecodeErrorZ WarningMessage_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedNodeAnnouncement object into a byte array which can be read by UnsignedNodeAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedNodeAnnouncement_write(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedNodeAnnouncement from a byte array, created by UnsignedNodeAnnouncement_write
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the NodeAnnouncement object into a byte array which can be read by NodeAnnouncement_read
 */
struct LDKCVec_u8Z NodeAnnouncement_write(const struct LDKNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncement from a byte array, created by NodeAnnouncement_write
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Read a QueryShortChannelIds from a byte array, created by QueryShortChannelIds_write
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(struct LDKu8slice ser);

/**
 * Serialize the QueryShortChannelIds object into a byte array which can be read by QueryShortChannelIds_read
 */
struct LDKCVec_u8Z QueryShortChannelIds_write(const struct LDKQueryShortChannelIds *NONNULL_PTR obj);

/**
 * Serialize the ReplyShortChannelIdsEnd object into a byte array which can be read by ReplyShortChannelIdsEnd_read
 */
struct LDKCVec_u8Z ReplyShortChannelIdsEnd_write(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR obj);

/**
 * Read a ReplyShortChannelIdsEnd from a byte array, created by ReplyShortChannelIdsEnd_write
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(struct LDKu8slice ser);

/**
 *\n\t * Calculates the overflow safe ending block height for the query.\n\t * Overflow returns `0xffffffff`, otherwise returns `first_blocknum + number_of_blocks`\n\t
 */
MUST_USE_RES uint32_t QueryChannelRange_end_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_arg);

/**
 * Serialize the QueryChannelRange object into a byte array which can be read by QueryChannelRange_read
 */
struct LDKCVec_u8Z QueryChannelRange_write(const struct LDKQueryChannelRange *NONNULL_PTR obj);

/**
 * Read a QueryChannelRange from a byte array, created by QueryChannelRange_write
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(struct LDKu8slice ser);

/**
 * Read a ReplyChannelRange from a byte array, created by ReplyChannelRange_write
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(struct LDKu8slice ser);

/**
 * Serialize the ReplyChannelRange object into a byte array which can be read by ReplyChannelRange_read
 */
struct LDKCVec_u8Z ReplyChannelRange_write(const struct LDKReplyChannelRange *NONNULL_PTR obj);

/**
 * Serialize the GossipTimestampFilter object into a byte array which can be read by GossipTimestampFilter_read
 */
struct LDKCVec_u8Z GossipTimestampFilter_write(const struct LDKGossipTimestampFilter *NONNULL_PTR obj);

/**
 * Read a GossipTimestampFilter from a byte array, created by GossipTimestampFilter_write
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(struct LDKu8slice ser);

/**
 * Calls the free function if one is set
 */
void CustomMessageHandler_free(struct LDKCustomMessageHandler this_ptr);

/**
 * Frees any resources used by the IgnoringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void IgnoringMessageHandler_free(struct LDKIgnoringMessageHandler this_obj);

/**
 * Constructs a new IgnoringMessageHandler given each field
 */
MUST_USE_RES struct LDKIgnoringMessageHandler IgnoringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider IgnoringMessageHandler_as_MessageSendEventsProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new CustomMessageReader which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CustomMessageReader must be freed before this_arg is
 */
struct LDKCustomMessageReader IgnoringMessageHandler_as_CustomMessageReader(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new CustomMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CustomMessageHandler must be freed before this_arg is
 */
struct LDKCustomMessageHandler IgnoringMessageHandler_as_CustomMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ErroringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void ErroringMessageHandler_free(struct LDKErroringMessageHandler this_obj);

/**
 * Constructs a new ErroringMessageHandler
 */
MUST_USE_RES struct LDKErroringMessageHandler ErroringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ErroringMessageHandler_as_MessageSendEventsProvider(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the MessageHandler, if is_owned is set and inner is non-NULL.
 */
void MessageHandler_free(struct LDKMessageHandler this_obj);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * [`ChannelManager`] object or an [`ErroringMessageHandler`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
const struct LDKChannelMessageHandler *MessageHandler_get_chan_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * [`ChannelManager`] object or an [`ErroringMessageHandler`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
void MessageHandler_set_chan_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKChannelMessageHandler val);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a [`NetGraphMsgHandler`] object or an
 * [`IgnoringMessageHandler`].
 *
 * [`NetGraphMsgHandler`]: crate::routing::network_graph::NetGraphMsgHandler
 */
const struct LDKRoutingMessageHandler *MessageHandler_get_route_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a [`NetGraphMsgHandler`] object or an
 * [`IgnoringMessageHandler`].
 *
 * [`NetGraphMsgHandler`]: crate::routing::network_graph::NetGraphMsgHandler
 */
void MessageHandler_set_route_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKRoutingMessageHandler val);

/**
 * Constructs a new MessageHandler given each field
 */
MUST_USE_RES struct LDKMessageHandler MessageHandler_new(struct LDKChannelMessageHandler chan_handler_arg, struct LDKRoutingMessageHandler route_handler_arg);

/**
 * Creates a copy of a SocketDescriptor
 */
struct LDKSocketDescriptor SocketDescriptor_clone(const struct LDKSocketDescriptor *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void SocketDescriptor_free(struct LDKSocketDescriptor this_ptr);

/**
 * Frees any resources used by the PeerHandleError, if is_owned is set and inner is non-NULL.
 */
void PeerHandleError_free(struct LDKPeerHandleError this_obj);

/**
 * Used to indicate that we probably can't make any future connections to this peer, implying
 * we should go ahead and force-close any channels we have with it.
 */
bool PeerHandleError_get_no_connection_possible(const struct LDKPeerHandleError *NONNULL_PTR this_ptr);

/**
 * Used to indicate that we probably can't make any future connections to this peer, implying
 * we should go ahead and force-close any channels we have with it.
 */
void PeerHandleError_set_no_connection_possible(struct LDKPeerHandleError *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new PeerHandleError given each field
 */
MUST_USE_RES struct LDKPeerHandleError PeerHandleError_new(bool no_connection_possible_arg);

/**
 * Creates a copy of the PeerHandleError
 */
struct LDKPeerHandleError PeerHandleError_clone(const struct LDKPeerHandleError *NONNULL_PTR orig);

/**
 * Frees any resources used by the PeerManager, if is_owned is set and inner is non-NULL.
 */
void PeerManager_free(struct LDKPeerManager this_obj);

/**
 * Constructs a new PeerManager with the given message handlers and node_id secret key
 * ephemeral_random_data is used to derive per-connection ephemeral keys and must be
 * cryptographically secure random bytes.
 */
MUST_USE_RES struct LDKPeerManager PeerManager_new(struct LDKMessageHandler message_handler, struct LDKSecretKey our_node_secret, const uint8_t (*ephemeral_random_data)[32], struct LDKLogger logger, struct LDKCustomMessageHandler custom_message_handler);

/**
 * Get the list of node ids for peers which have completed the initial handshake.
 *
 * For outbound connections, this will be the same as the their_node_id parameter passed in to
 * new_outbound_connection, however entries will only appear once the initial handshake has
 * completed and we are sure the remote peer has the private key for the given node_id.
 */
MUST_USE_RES struct LDKCVec_PublicKeyZ PeerManager_get_peer_node_ids(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates a new outbound connection has been established to a node with the given node_id
 * and an optional remote network address.
 *
 * The remote network address adds the option to report a remote IP address back to a connecting
 * peer using the init message.
 * The user should pass the remote network address of the host they are connected to.
 *
 * Note that if an Err is returned here you MUST NOT call socket_disconnected for the new
 * descriptor but must disconnect the connection immediately.
 *
 * Returns a small number of bytes to send to the remote node (currently always 50).
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet been
 * [`socket_disconnected()`].
 *
 * [`socket_disconnected()`]: PeerManager::socket_disconnected
 */
MUST_USE_RES struct LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKSocketDescriptor descriptor, struct LDKCOption_NetAddressZ remote_network_address);

/**
 * Indicates a new inbound connection has been established to a node with an optional remote
 * network address.
 *
 * The remote network address adds the option to report a remote IP address back to a connecting
 * peer using the init message.
 * The user should pass the remote network address of the host they are connected to.
 *
 * May refuse the connection by returning an Err, but will never write bytes to the remote end
 * (outbound connector always speaks first). Note that if an Err is returned here you MUST NOT
 * call socket_disconnected for the new descriptor but must disconnect the connection
 * immediately.
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet been
 * [`socket_disconnected()`].
 *
 * [`socket_disconnected()`]: PeerManager::socket_disconnected
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor descriptor, struct LDKCOption_NetAddressZ remote_network_address);

/**
 * Indicates that there is room to write data to the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
 * returning. Thus, be very careful with reentrancy issues! The invariants around calling
 * [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
 * ready to call `[write_buffer_space_avail`] again if a write call generated here isn't
 * sufficient!
 *
 * [`send_data`]: SocketDescriptor::send_data
 * [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Indicates that data was read from the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
 * Thus, however, you should call [`process_events`] after any `read_event` to generate
 * [`send_data`] calls to handle responses.
 *
 * If `Ok(true)` is returned, further read_events should not be triggered until a
 * [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
 * send buffer).
 *
 * [`send_data`]: SocketDescriptor::send_data
 * [`process_events`]: PeerManager::process_events
 */
MUST_USE_RES struct LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR peer_descriptor, struct LDKu8slice data);

/**
 * Checks for any events generated by our handlers and processes them. Includes sending most
 * response messages as well as messages generated by calls to handler functions directly (eg
 * functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
 *
 * May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
 * issues!
 *
 * You don't have to call this function explicitly if you are using [`lightning-net-tokio`]
 * or one of the other clients provided in our language bindings.
 *
 * [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
 * [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
 * [`send_data`]: SocketDescriptor::send_data
 */
void PeerManager_process_events(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates that the given socket descriptor's connection is now closed.
 */
void PeerManager_socket_disconnected(const struct LDKPeerManager *NONNULL_PTR this_arg, const struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Disconnect a peer given its node id.
 *
 * Set `no_connection_possible` to true to prevent any further connection with this peer,
 * force-closing any channels we have with it.
 *
 * If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
 * peer. Thus, be very careful about reentrancy issues.
 *
 * [`disconnect_socket`]: SocketDescriptor::disconnect_socket
 */
void PeerManager_disconnect_by_node_id(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id, bool no_connection_possible);

/**
 * Disconnects all currently-connected peers. This is useful on platforms where there may be
 * an indication that TCP sockets have stalled even if we weren't around to time them out
 * using regular ping/pongs.
 */
void PeerManager_disconnect_all_peers(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Send pings to each peer and disconnect those which did not respond to the last round of
 * pings.
 *
 * This may be called on any timescale you want, however, roughly once every ten seconds is
 * preferred. The call rate determines both how often we send a ping to our peers and how much
 * time they have to respond before we disconnect them.
 *
 * May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
 * issues!
 *
 * [`send_data`]: SocketDescriptor::send_data
 */
void PeerManager_timer_tick_occurred(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Gets the weight for an HTLC-Success transaction.
 */
uint64_t htlc_success_tx_weight(bool opt_anchors);

/**
 * Gets the weight for an HTLC-Timeout transaction.
 */
uint64_t htlc_timeout_tx_weight(bool opt_anchors);

/**
 * Build the commitment secret from the seed and the commitment number
 */
struct LDKThirtyTwoBytes build_commitment_secret(const uint8_t (*commitment_seed)[32], uint64_t idx);

/**
 * Build a closing transaction
 */
struct LDKTransaction build_closing_transaction(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);

/**
 * Frees any resources used by the CounterpartyCommitmentSecrets, if is_owned is set and inner is non-NULL.
 */
void CounterpartyCommitmentSecrets_free(struct LDKCounterpartyCommitmentSecrets this_obj);

/**
 * Creates a copy of the CounterpartyCommitmentSecrets
 */
struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_clone(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR orig);

/**
 * Creates a new empty `CounterpartyCommitmentSecrets` structure.
 */
MUST_USE_RES struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_new(void);

/**
 * Returns the minimum index of all stored secrets. Note that indexes start
 * at 1 << 48 and get decremented by one for each new secret.
 */
MUST_USE_RES uint64_t CounterpartyCommitmentSecrets_get_min_seen_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg);

/**
 * Inserts the `secret` at `idx`. Returns `Ok(())` if the secret
 * was generated in accordance with BOLT 3 and is consistent with previous secrets.
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ CounterpartyCommitmentSecrets_provide_secret(struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx, struct LDKThirtyTwoBytes secret);

/**
 * Returns the secret at `idx`.
 * Returns `None` if `idx` is < [`CounterpartyCommitmentSecrets::get_min_seen_secret`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKThirtyTwoBytes CounterpartyCommitmentSecrets_get_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx);

/**
 * Serialize the CounterpartyCommitmentSecrets object into a byte array which can be read by CounterpartyCommitmentSecrets_read
 */
struct LDKCVec_u8Z CounterpartyCommitmentSecrets_write(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR obj);

/**
 * Read a CounterpartyCommitmentSecrets from a byte array, created by CounterpartyCommitmentSecrets_write
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CounterpartyCommitmentSecrets_read(struct LDKu8slice ser);

/**
 * Derives a per-commitment-transaction private key (eg an htlc key or delayed_payment key)
 * from the base secret and the per_commitment_point.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_SecretKeyErrorZ derive_private_key(struct LDKPublicKey per_commitment_point, const uint8_t (*base_secret)[32]);

/**
 * Derives a per-commitment-transaction public key (eg an htlc key or a delayed_payment key)
 * from the base point and the per_commitment_key. This is the public equivalent of
 * derive_private_key - using only public keys to derive a public key instead of private keys.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_PublicKeyErrorZ derive_public_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey base_point);

/**
 * Derives a per-commitment-transaction revocation key from its constituent parts.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_secret always come from cheater
 * and revocation_base_secret always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_SecretKeyErrorZ derive_private_revocation_key(const uint8_t (*per_commitment_secret)[32], const uint8_t (*countersignatory_revocation_base_secret)[32]);

/**
 * Derives a per-commitment-transaction revocation public key from its constituent parts. This is
 * the public equivalend of derive_private_revocation_key - using only public keys to derive a
 * public key instead of private keys.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_point always come from cheater
 * and revocation_base_point always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_PublicKeyErrorZ derive_public_revocation_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey countersignatory_revocation_base_point);

/**
 * Frees any resources used by the TxCreationKeys, if is_owned is set and inner is non-NULL.
 */
void TxCreationKeys_free(struct LDKTxCreationKeys this_obj);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
struct LDKPublicKey TxCreationKeys_get_per_commitment_point(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
void TxCreationKeys_set_per_commitment_point(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
struct LDKPublicKey TxCreationKeys_get_revocation_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
void TxCreationKeys_set_revocation_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's HTLC Key
 */
void TxCreationKeys_set_broadcaster_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Countersignatory's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Countersignatory's HTLC Key
 */
void TxCreationKeys_set_countersignatory_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
void TxCreationKeys_set_broadcaster_delayed_payment_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new TxCreationKeys given each field
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_new(struct LDKPublicKey per_commitment_point_arg, struct LDKPublicKey revocation_key_arg, struct LDKPublicKey broadcaster_htlc_key_arg, struct LDKPublicKey countersignatory_htlc_key_arg, struct LDKPublicKey broadcaster_delayed_payment_key_arg);

/**
 * Creates a copy of the TxCreationKeys
 */
struct LDKTxCreationKeys TxCreationKeys_clone(const struct LDKTxCreationKeys *NONNULL_PTR orig);

/**
 * Serialize the TxCreationKeys object into a byte array which can be read by TxCreationKeys_read
 */
struct LDKCVec_u8Z TxCreationKeys_write(const struct LDKTxCreationKeys *NONNULL_PTR obj);

/**
 * Read a TxCreationKeys from a byte array, created by TxCreationKeys_write
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelPublicKeys, if is_owned is set and inner is non-NULL.
 */
void ChannelPublicKeys_free(struct LDKChannelPublicKeys this_obj);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
struct LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
void ChannelPublicKeys_set_funding_pubkey(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
struct LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
void ChannelPublicKeys_set_revocation_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
struct LDKPublicKey ChannelPublicKeys_get_payment_point(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
void ChannelPublicKeys_set_payment_point(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
struct LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
void ChannelPublicKeys_set_delayed_payment_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
struct LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
void ChannelPublicKeys_set_htlc_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new ChannelPublicKeys given each field
 */
MUST_USE_RES struct LDKChannelPublicKeys ChannelPublicKeys_new(struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg);

/**
 * Creates a copy of the ChannelPublicKeys
 */
struct LDKChannelPublicKeys ChannelPublicKeys_clone(const struct LDKChannelPublicKeys *NONNULL_PTR orig);

/**
 * Serialize the ChannelPublicKeys object into a byte array which can be read by ChannelPublicKeys_read
 */
struct LDKCVec_u8Z ChannelPublicKeys_write(const struct LDKChannelPublicKeys *NONNULL_PTR obj);

/**
 * Read a ChannelPublicKeys from a byte array, created by ChannelPublicKeys_write
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(struct LDKu8slice ser);

/**
 * Create per-state keys from channel base points and the per-commitment point.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_derive_new(struct LDKPublicKey per_commitment_point, struct LDKPublicKey broadcaster_delayed_payment_base, struct LDKPublicKey broadcaster_htlc_base, struct LDKPublicKey countersignatory_revocation_base, struct LDKPublicKey countersignatory_htlc_base);

/**
 * Generate per-state keys from channel static keys.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_from_channel_static_keys(struct LDKPublicKey per_commitment_point, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * A script either spendable by the revocation
 * key or the broadcaster_delayed_payment_key and satisfying the relative-locktime OP_CSV constrain.
 * Encumbering a `to_holder` output on a commitment transaction or 2nd-stage HTLC transactions.
 */
struct LDKCVec_u8Z get_revokeable_redeemscript(struct LDKPublicKey revocation_key, uint16_t contest_delay, struct LDKPublicKey broadcaster_delayed_payment_key);

/**
 * Frees any resources used by the HTLCOutputInCommitment, if is_owned is set and inner is non-NULL.
 */
void HTLCOutputInCommitment_free(struct LDKHTLCOutputInCommitment this_obj);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
bool HTLCOutputInCommitment_get_offered(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
void HTLCOutputInCommitment_set_offered(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, bool val);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
uint64_t HTLCOutputInCommitment_get_amount_msat(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
void HTLCOutputInCommitment_set_amount_msat(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
uint32_t HTLCOutputInCommitment_get_cltv_expiry(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
void HTLCOutputInCommitment_set_cltv_expiry(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The hash of the preimage which unlocks this HTLC.
 */
const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr))[32];

/**
 * The hash of the preimage which unlocks this HTLC.
 */
void HTLCOutputInCommitment_set_payment_hash(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The position within the commitment transactions' outputs. This may be None if the value is
 * below the dust limit (in which case no output appears in the commitment transaction and the
 * value is spent to additional transaction fees).
 */
struct LDKCOption_u32Z HTLCOutputInCommitment_get_transaction_output_index(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The position within the commitment transactions' outputs. This may be None if the value is
 * below the dust limit (in which case no output appears in the commitment transaction and the
 * value is spent to additional transaction fees).
 */
void HTLCOutputInCommitment_set_transaction_output_index(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * Constructs a new HTLCOutputInCommitment given each field
 */
MUST_USE_RES struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_new(bool offered_arg, uint64_t amount_msat_arg, uint32_t cltv_expiry_arg, struct LDKThirtyTwoBytes payment_hash_arg, struct LDKCOption_u32Z transaction_output_index_arg);

/**
 * Creates a copy of the HTLCOutputInCommitment
 */
struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(const struct LDKHTLCOutputInCommitment *NONNULL_PTR orig);

/**
 * Serialize the HTLCOutputInCommitment object into a byte array which can be read by HTLCOutputInCommitment_read
 */
struct LDKCVec_u8Z HTLCOutputInCommitment_write(const struct LDKHTLCOutputInCommitment *NONNULL_PTR obj);

/**
 * Read a HTLCOutputInCommitment from a byte array, created by HTLCOutputInCommitment_write
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(struct LDKu8slice ser);

/**
 * Gets the witness redeemscript for an HTLC output in a commitment transaction. Note that htlc
 * does not need to have its previous_output_index filled.
 */
struct LDKCVec_u8Z get_htlc_redeemscript(const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, bool opt_anchors, const struct LDKTxCreationKeys *NONNULL_PTR keys);

/**
 * Gets the redeemscript for a funding output from the two funding public keys.
 * Note that the order of funding public keys does not matter.
 */
struct LDKCVec_u8Z make_funding_redeemscript(struct LDKPublicKey broadcaster, struct LDKPublicKey countersignatory);

/**
 * Builds an unsigned HTLC-Success or HTLC-Timeout transaction from the given channel and HTLC
 * parameters. This is used by [`TrustedCommitmentTransaction::get_htlc_sigs`] to fetch the
 * transaction which needs signing, and can be used to construct an HTLC transaction which is
 * broadcastable given a counterparty HTLC signature.
 *
 * Panics if htlc.transaction_output_index.is_none() (as such HTLCs do not appear in the
 * commitment transaction).
 */
struct LDKTransaction build_htlc_transaction(const uint8_t (*commitment_txid)[32], uint32_t feerate_per_kw, uint16_t contest_delay, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, bool opt_anchors, struct LDKPublicKey broadcaster_delayed_payment_key, struct LDKPublicKey revocation_key);

/**
 * Gets the witnessScript for an anchor output from the funding public key.
 * The witness in the spending input must be:
 * <BIP 143 funding_signature>
 * After 16 blocks of confirmation, an alternative satisfying witness could be:
 * <>
 * (empty vector required to satisfy compliance with MINIMALIF-standard rule)
 */
struct LDKCVec_u8Z get_anchor_redeemscript(struct LDKPublicKey funding_pubkey);

/**
 * Frees any resources used by the ChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void ChannelTransactionParameters_free(struct LDKChannelTransactionParameters this_obj);

/**
 * Holder public keys
 */
struct LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Holder public keys
 */
void ChannelTransactionParameters_set_holder_pubkeys(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
uint16_t ChannelTransactionParameters_get_holder_selected_contest_delay(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
void ChannelTransactionParameters_set_holder_selected_contest_delay(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
bool ChannelTransactionParameters_get_is_outbound_from_holder(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
void ChannelTransactionParameters_set_is_outbound_from_holder(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, bool val);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCounterpartyChannelTransactionParameters ChannelTransactionParameters_get_counterparty_parameters(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelTransactionParameters_set_counterparty_parameters(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKCounterpartyChannelTransactionParameters val);

/**
 * The late-bound funding outpoint
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound funding outpoint
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelTransactionParameters_set_funding_outpoint(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Are anchors used for this channel.  Boolean is serialization backwards-compatible
 */
enum LDKCOption_NoneZ ChannelTransactionParameters_get_opt_anchors(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Are anchors used for this channel.  Boolean is serialization backwards-compatible
 */
void ChannelTransactionParameters_set_opt_anchors(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);

/**
 * Constructs a new ChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKChannelTransactionParameters ChannelTransactionParameters_new(struct LDKChannelPublicKeys holder_pubkeys_arg, uint16_t holder_selected_contest_delay_arg, bool is_outbound_from_holder_arg, struct LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg, struct LDKOutPoint funding_outpoint_arg, enum LDKCOption_NoneZ opt_anchors_arg);

/**
 * Creates a copy of the ChannelTransactionParameters
 */
struct LDKChannelTransactionParameters ChannelTransactionParameters_clone(const struct LDKChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Frees any resources used by the CounterpartyChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void CounterpartyChannelTransactionParameters_free(struct LDKCounterpartyChannelTransactionParameters this_obj);

/**
 * Counter-party public keys
 */
struct LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Counter-party public keys
 */
void CounterpartyChannelTransactionParameters_set_pubkeys(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
uint16_t CounterpartyChannelTransactionParameters_get_selected_contest_delay(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
void CounterpartyChannelTransactionParameters_set_selected_contest_delay(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new CounterpartyChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_new(struct LDKChannelPublicKeys pubkeys_arg, uint16_t selected_contest_delay_arg);

/**
 * Creates a copy of the CounterpartyChannelTransactionParameters
 */
struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_clone(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Whether the late bound parameters are populated.
 */
MUST_USE_RES bool ChannelTransactionParameters_is_populated(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the holder is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_holder_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the counterparty is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_counterparty_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Serialize the CounterpartyChannelTransactionParameters object into a byte array which can be read by CounterpartyChannelTransactionParameters_read
 */
struct LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a CounterpartyChannelTransactionParameters from a byte array, created by CounterpartyChannelTransactionParameters_write
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CounterpartyChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelTransactionParameters object into a byte array which can be read by ChannelTransactionParameters_read
 */
struct LDKCVec_u8Z ChannelTransactionParameters_write(const struct LDKChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a ChannelTransactionParameters from a byte array, created by ChannelTransactionParameters_write
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ ChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DirectedChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void DirectedChannelTransactionParameters_free(struct LDKDirectedChannelTransactionParameters this_obj);

/**
 * Get the channel pubkeys for the broadcaster
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the channel pubkeys for the countersignatory
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_countersignatory_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the contest delay applicable to the transactions.
 * Note that the contest delay was selected by the countersignatory.
 */
MUST_USE_RES uint16_t DirectedChannelTransactionParameters_contest_delay(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Whether the channel is outbound from the broadcaster.
 *
 * The boolean representing the side that initiated the channel is
 * an input to the commitment number obscure factor computation.
 */
MUST_USE_RES bool DirectedChannelTransactionParameters_is_outbound(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * The funding outpoint
 */
MUST_USE_RES struct LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Whether to use anchors for this channel
 */
MUST_USE_RES bool DirectedChannelTransactionParameters_opt_anchors(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the HolderCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void HolderCommitmentTransaction_free(struct LDKHolderCommitmentTransaction this_obj);

/**
 * Our counterparty's signature for the transaction
 */
struct LDKSignature HolderCommitmentTransaction_get_counterparty_sig(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * Our counterparty's signature for the transaction
 */
void HolderCommitmentTransaction_set_counterparty_sig(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * All non-dust counterparty HTLC signatures, in the order they appear in the transaction
 */
void HolderCommitmentTransaction_set_counterparty_htlc_sigs(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);

/**
 * Creates a copy of the HolderCommitmentTransaction
 */
struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(const struct LDKHolderCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the HolderCommitmentTransaction object into a byte array which can be read by HolderCommitmentTransaction_read
 */
struct LDKCVec_u8Z HolderCommitmentTransaction_write(const struct LDKHolderCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a HolderCommitmentTransaction from a byte array, created by HolderCommitmentTransaction_write
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ HolderCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Create a new holder transaction with the given counterparty signatures.
 * The funding keys are used to figure out which signature should go first when building the transaction for broadcast.
 */
MUST_USE_RES struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(struct LDKCommitmentTransaction commitment_tx, struct LDKSignature counterparty_sig, struct LDKCVec_SignatureZ counterparty_htlc_sigs, struct LDKPublicKey holder_funding_key, struct LDKPublicKey counterparty_funding_key);

/**
 * Frees any resources used by the BuiltCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void BuiltCommitmentTransaction_free(struct LDKBuiltCommitmentTransaction this_obj);

/**
 * The commitment transaction
 */
struct LDKTransaction BuiltCommitmentTransaction_get_transaction(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * The commitment transaction
 */
void BuiltCommitmentTransaction_set_transaction(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKTransaction val);

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
const uint8_t (*BuiltCommitmentTransaction_get_txid(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr))[32];

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
void BuiltCommitmentTransaction_set_txid(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new BuiltCommitmentTransaction given each field
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(struct LDKTransaction transaction_arg, struct LDKThirtyTwoBytes txid_arg);

/**
 * Creates a copy of the BuiltCommitmentTransaction
 */
struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the BuiltCommitmentTransaction object into a byte array which can be read by BuiltCommitmentTransaction_read
 */
struct LDKCVec_u8Z BuiltCommitmentTransaction_write(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a BuiltCommitmentTransaction from a byte array, created by BuiltCommitmentTransaction_write
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ BuiltCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Get the SIGHASH_ALL sighash value of the transaction.
 *
 * This can be used to verify a signature.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Sign a transaction, either because we are counter-signing the counterparty's transaction or
 * because we are about to broadcast a holder transaction.
 */
MUST_USE_RES struct LDKSignature BuiltCommitmentTransaction_sign(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Frees any resources used by the ClosingTransaction, if is_owned is set and inner is non-NULL.
 */
void ClosingTransaction_free(struct LDKClosingTransaction this_obj);

/**
 * Creates a copy of the ClosingTransaction
 */
struct LDKClosingTransaction ClosingTransaction_clone(const struct LDKClosingTransaction *NONNULL_PTR orig);

/**
 * Checks if two ClosingTransactions contain equal inner contents.
 */
uint64_t ClosingTransaction_hash(const struct LDKClosingTransaction *NONNULL_PTR o);

/**
 * Construct an object of the class
 */
MUST_USE_RES struct LDKClosingTransaction ClosingTransaction_new(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);

/**
 * Trust our pre-built transaction.
 *
 * Applies a wrapper which allows access to the transaction.
 *
 * This should only be used if you fully trust the builder of this object. It should not
 * be used by an external signer - instead use the verify function.
 */
MUST_USE_RES struct LDKTrustedClosingTransaction ClosingTransaction_trust(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * Verify our pre-built transaction.
 *
 * Applies a wrapper which allows access to the transaction.
 *
 * An external validating signer must call this method before signing
 * or using the built transaction.
 */
MUST_USE_RES struct LDKCResult_TrustedClosingTransactionNoneZ ClosingTransaction_verify(const struct LDKClosingTransaction *NONNULL_PTR this_arg, struct LDKOutPoint funding_outpoint);

/**
 * The value to be sent to the holder, or zero if the output will be omitted
 */
MUST_USE_RES uint64_t ClosingTransaction_to_holder_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the counterparty, or zero if the output will be omitted
 */
MUST_USE_RES uint64_t ClosingTransaction_to_counterparty_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The destination of the holder's output
 */
MUST_USE_RES struct LDKu8slice ClosingTransaction_to_holder_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The destination of the counterparty's output
 */
MUST_USE_RES struct LDKu8slice ClosingTransaction_to_counterparty_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the TrustedClosingTransaction, if is_owned is set and inner is non-NULL.
 */
void TrustedClosingTransaction_free(struct LDKTrustedClosingTransaction this_obj);

/**
 * The pre-built Bitcoin commitment transaction
 */
MUST_USE_RES struct LDKTransaction TrustedClosingTransaction_built_transaction(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg);

/**
 * Get the SIGHASH_ALL sighash value of the transaction.
 *
 * This can be used to verify a signature.
 */
MUST_USE_RES struct LDKThirtyTwoBytes TrustedClosingTransaction_get_sighash_all(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Sign a transaction, either because we are counter-signing the counterparty's transaction or
 * because we are about to broadcast a holder transaction.
 */
MUST_USE_RES struct LDKSignature TrustedClosingTransaction_sign(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Frees any resources used by the CommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void CommitmentTransaction_free(struct LDKCommitmentTransaction this_obj);

/**
 * Creates a copy of the CommitmentTransaction
 */
struct LDKCommitmentTransaction CommitmentTransaction_clone(const struct LDKCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the CommitmentTransaction object into a byte array which can be read by CommitmentTransaction_read
 */
struct LDKCVec_u8Z CommitmentTransaction_write(const struct LDKCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a CommitmentTransaction from a byte array, created by CommitmentTransaction_write
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(struct LDKu8slice ser);

/**
 * The backwards-counting commitment number
 */
MUST_USE_RES uint64_t CommitmentTransaction_commitment_number(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the broadcaster
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_broadcaster_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the counterparty
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_countersignatory_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The feerate paid per 1000-weight-unit in this commitment transaction.
 */
MUST_USE_RES uint32_t CommitmentTransaction_feerate_per_kw(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Trust our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * This should only be used if you fully trust the builder of this object.  It should not
 * be used by an external signer - instead use the verify function.
 */
MUST_USE_RES struct LDKTrustedCommitmentTransaction CommitmentTransaction_trust(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Verify our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * An external validating signer must call this method before signing
 * or using the built transaction.
 */
MUST_USE_RES struct LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg, const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * Frees any resources used by the TrustedCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void TrustedCommitmentTransaction_free(struct LDKTrustedCommitmentTransaction this_obj);

/**
 * The transaction ID of the built Bitcoin transaction
 */
MUST_USE_RES struct LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-built Bitcoin commitment transaction
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-calculated transaction creation public keys.
 */
MUST_USE_RES struct LDKTxCreationKeys TrustedCommitmentTransaction_keys(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Should anchors be used.
 */
MUST_USE_RES bool TrustedCommitmentTransaction_opt_anchors(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Get a signature for each HTLC which was included in the commitment transaction (ie for
 * which HTLCOutputInCommitment::transaction_output_index.is_some()).
 *
 * The returned Vec has one entry for each HTLC, and in the same order.
 *
 * This function is only valid in the holder commitment context, it always uses SigHashType::All.
 */
MUST_USE_RES struct LDKCResult_CVec_SignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*htlc_base_key)[32], const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters);

/**
 * Commitment transaction numbers which appear in the transactions themselves are XOR'd with a
 * shared secret first. This prevents on-chain observers from discovering how many commitment
 * transactions occurred in a channel before it was closed.
 *
 * This function gets the shared secret from relevant channel public keys and can be used to
 * \"decrypt\" the commitment transaction number given a commitment transaction on-chain.
 */
uint64_t get_commitment_transaction_number_obscure_factor(struct LDKPublicKey broadcaster_payment_basepoint, struct LDKPublicKey countersignatory_payment_basepoint, bool outbound_from_broadcaster);

/**
 * Checks if two InitFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InitFeatures_eq(const struct LDKInitFeatures *NONNULL_PTR a, const struct LDKInitFeatures *NONNULL_PTR b);

/**
 * Checks if two NodeFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeFeatures_eq(const struct LDKNodeFeatures *NONNULL_PTR a, const struct LDKNodeFeatures *NONNULL_PTR b);

/**
 * Checks if two ChannelFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelFeatures_eq(const struct LDKChannelFeatures *NONNULL_PTR a, const struct LDKChannelFeatures *NONNULL_PTR b);

/**
 * Checks if two InvoiceFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InvoiceFeatures_eq(const struct LDKInvoiceFeatures *NONNULL_PTR a, const struct LDKInvoiceFeatures *NONNULL_PTR b);

/**
 * Checks if two ChannelTypeFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelTypeFeatures_eq(const struct LDKChannelTypeFeatures *NONNULL_PTR a, const struct LDKChannelTypeFeatures *NONNULL_PTR b);

/**
 * Creates a copy of the InitFeatures
 */
struct LDKInitFeatures InitFeatures_clone(const struct LDKInitFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the NodeFeatures
 */
struct LDKNodeFeatures NodeFeatures_clone(const struct LDKNodeFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the ChannelFeatures
 */
struct LDKChannelFeatures ChannelFeatures_clone(const struct LDKChannelFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the InvoiceFeatures
 */
struct LDKInvoiceFeatures InvoiceFeatures_clone(const struct LDKInvoiceFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the ChannelTypeFeatures
 */
struct LDKChannelTypeFeatures ChannelTypeFeatures_clone(const struct LDKChannelTypeFeatures *NONNULL_PTR orig);

/**
 * Frees any resources used by the InitFeatures, if is_owned is set and inner is non-NULL.
 */
void InitFeatures_free(struct LDKInitFeatures this_obj);

/**
 * Frees any resources used by the NodeFeatures, if is_owned is set and inner is non-NULL.
 */
void NodeFeatures_free(struct LDKNodeFeatures this_obj);

/**
 * Frees any resources used by the ChannelFeatures, if is_owned is set and inner is non-NULL.
 */
void ChannelFeatures_free(struct LDKChannelFeatures this_obj);

/**
 * Frees any resources used by the InvoiceFeatures, if is_owned is set and inner is non-NULL.
 */
void InvoiceFeatures_free(struct LDKInvoiceFeatures this_obj);

/**
 * Frees any resources used by the ChannelTypeFeatures, if is_owned is set and inner is non-NULL.
 */
void ChannelTypeFeatures_free(struct LDKChannelTypeFeatures this_obj);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInitFeatures InitFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKInitFeatures InitFeatures_known(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool InitFeatures_requires_unknown_bits(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKNodeFeatures NodeFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKNodeFeatures NodeFeatures_known(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool NodeFeatures_requires_unknown_bits(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_known(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool ChannelFeatures_requires_unknown_bits(const struct LDKChannelFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_known(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool InvoiceFeatures_requires_unknown_bits(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_empty(void);

/**
 * Creates a Features with the bits set which are known by the implementation
 */
MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_known(void);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_unknown_bits(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Serialize the InitFeatures object into a byte array which can be read by InitFeatures_read
 */
struct LDKCVec_u8Z InitFeatures_write(const struct LDKInitFeatures *NONNULL_PTR obj);

/**
 * Read a InitFeatures from a byte array, created by InitFeatures_write
 */
struct LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelFeatures object into a byte array which can be read by ChannelFeatures_read
 */
struct LDKCVec_u8Z ChannelFeatures_write(const struct LDKChannelFeatures *NONNULL_PTR obj);

/**
 * Read a ChannelFeatures from a byte array, created by ChannelFeatures_write
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the NodeFeatures object into a byte array which can be read by NodeFeatures_read
 */
struct LDKCVec_u8Z NodeFeatures_write(const struct LDKNodeFeatures *NONNULL_PTR obj);

/**
 * Read a NodeFeatures from a byte array, created by NodeFeatures_write
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the InvoiceFeatures object into a byte array which can be read by InvoiceFeatures_read
 */
struct LDKCVec_u8Z InvoiceFeatures_write(const struct LDKInvoiceFeatures *NONNULL_PTR obj);

/**
 * Read a InvoiceFeatures from a byte array, created by InvoiceFeatures_write
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ InvoiceFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelTypeFeatures object into a byte array which can be read by ChannelTypeFeatures_read
 */
struct LDKCVec_u8Z ChannelTypeFeatures_write(const struct LDKChannelTypeFeatures *NONNULL_PTR obj);

/**
 * Read a ChannelTypeFeatures from a byte array, created by ChannelTypeFeatures_write
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ ChannelTypeFeatures_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ShutdownScript, if is_owned is set and inner is non-NULL.
 */
void ShutdownScript_free(struct LDKShutdownScript this_obj);

/**
 * Creates a copy of the ShutdownScript
 */
struct LDKShutdownScript ShutdownScript_clone(const struct LDKShutdownScript *NONNULL_PTR orig);

/**
 * Frees any resources used by the InvalidShutdownScript, if is_owned is set and inner is non-NULL.
 */
void InvalidShutdownScript_free(struct LDKInvalidShutdownScript this_obj);

/**
 * The script that did not meet the requirements from [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md
 */
struct LDKu8slice InvalidShutdownScript_get_script(const struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr);

/**
 * The script that did not meet the requirements from [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightningnetwork/lightning-rfc/blob/master/02-peer-protocol.md
 */
void InvalidShutdownScript_set_script(struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new InvalidShutdownScript given each field
 */
MUST_USE_RES struct LDKInvalidShutdownScript InvalidShutdownScript_new(struct LDKCVec_u8Z script_arg);

/**
 * Creates a copy of the InvalidShutdownScript
 */
struct LDKInvalidShutdownScript InvalidShutdownScript_clone(const struct LDKInvalidShutdownScript *NONNULL_PTR orig);

/**
 * Serialize the ShutdownScript object into a byte array which can be read by ShutdownScript_read
 */
struct LDKCVec_u8Z ShutdownScript_write(const struct LDKShutdownScript *NONNULL_PTR obj);

/**
 * Read a ShutdownScript from a byte array, created by ShutdownScript_write
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ ShutdownScript_read(struct LDKu8slice ser);

/**
 * Generates a P2WPKH script pubkey from the given [`WPubkeyHash`].
 */
MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wpkh(const uint8_t (*pubkey_hash)[20]);

/**
 * Generates a P2WSH script pubkey from the given [`WScriptHash`].
 */
MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wsh(const uint8_t (*script_hash)[32]);

/**
 * Generates a witness script pubkey from the given segwit version and program.
 *
 * Note for version-zero witness scripts you must use [`ShutdownScript::new_p2wpkh`] or
 * [`ShutdownScript::new_p2wsh`] instead.
 *
 * # Errors
 *
 * This function may return an error if `program` is invalid for the segwit `version`.
 */
MUST_USE_RES struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ ShutdownScript_new_witness_program(uint8_t version, struct LDKu8slice program);

/**
 * Converts the shutdown script into the underlying [`Script`].
 */
MUST_USE_RES struct LDKCVec_u8Z ShutdownScript_into_inner(struct LDKShutdownScript this_arg);

/**
 * Returns the [`PublicKey`] used for a P2WPKH shutdown script if constructed directly from it.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPublicKey ShutdownScript_as_legacy_pubkey(const struct LDKShutdownScript *NONNULL_PTR this_arg);

/**
 * Returns whether the shutdown script is compatible with the features as defined by BOLT #2.
 *
 * Specifically, checks for compliance with feature `option_shutdown_anysegwit`.
 */
MUST_USE_RES bool ShutdownScript_is_compatible(const struct LDKShutdownScript *NONNULL_PTR this_arg, const struct LDKInitFeatures *NONNULL_PTR features);

/**
 * Calls the free function if one is set
 */
void CustomMessageReader_free(struct LDKCustomMessageReader this_ptr);

/**
 * Creates a copy of a Type
 */
struct LDKType Type_clone(const struct LDKType *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Type_free(struct LDKType this_ptr);

/**
 * Frees any resources used by the NodeId, if is_owned is set and inner is non-NULL.
 */
void NodeId_free(struct LDKNodeId this_obj);

/**
 * Creates a copy of the NodeId
 */
struct LDKNodeId NodeId_clone(const struct LDKNodeId *NONNULL_PTR orig);

/**
 * Create a new NodeId from a public key
 */
MUST_USE_RES struct LDKNodeId NodeId_from_pubkey(struct LDKPublicKey pubkey);

/**
 * Get the public key slice from this NodeId
 */
MUST_USE_RES struct LDKu8slice NodeId_as_slice(const struct LDKNodeId *NONNULL_PTR this_arg);

/**
 * Checks if two NodeIds contain equal inner contents.
 */
uint64_t NodeId_hash(const struct LDKNodeId *NONNULL_PTR o);

/**
 * Serialize the NodeId object into a byte array which can be read by NodeId_read
 */
struct LDKCVec_u8Z NodeId_write(const struct LDKNodeId *NONNULL_PTR obj);

/**
 * Read a NodeId from a byte array, created by NodeId_write
 */
struct LDKCResult_NodeIdDecodeErrorZ NodeId_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NetworkGraph, if is_owned is set and inner is non-NULL.
 */
void NetworkGraph_free(struct LDKNetworkGraph this_obj);

/**
 * Creates a copy of the NetworkGraph
 */
struct LDKNetworkGraph NetworkGraph_clone(const struct LDKNetworkGraph *NONNULL_PTR orig);

/**
 * Frees any resources used by the ReadOnlyNetworkGraph, if is_owned is set and inner is non-NULL.
 */
void ReadOnlyNetworkGraph_free(struct LDKReadOnlyNetworkGraph this_obj);

/**
 * Frees any resources used by the NetworkUpdate
 */
void NetworkUpdate_free(struct LDKNetworkUpdate this_ptr);

/**
 * Creates a copy of the NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_clone(const struct LDKNetworkUpdate *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ChannelUpdateMessage-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_channel_update_message(struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new ChannelClosed-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_channel_closed(uint64_t short_channel_id, bool is_permanent);

/**
 * Utility method to constructs a new NodeFailure-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_node_failure(struct LDKPublicKey node_id, bool is_permanent);

/**
 * Serialize the NetworkUpdate object into a byte array which can be read by NetworkUpdate_read
 */
struct LDKCVec_u8Z NetworkUpdate_write(const struct LDKNetworkUpdate *NONNULL_PTR obj);

/**
 * Read a NetworkUpdate from a byte array, created by NetworkUpdate_write
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ NetworkUpdate_read(struct LDKu8slice ser);

/**
 * Constructs a new EventHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventHandler must be freed before this_arg is
 */
struct LDKEventHandler NetGraphMsgHandler_as_EventHandler(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the NetGraphMsgHandler, if is_owned is set and inner is non-NULL.
 */
void NetGraphMsgHandler_free(struct LDKNetGraphMsgHandler this_obj);

/**
 * Creates a new tracker of the actual state of the network of channels and nodes,
 * assuming an existing Network Graph.
 * Chain monitor is used to make sure announced channels exist on-chain,
 * channel data is correct, and that the announcement is signed with
 * channel owners' keys.
 */
MUST_USE_RES struct LDKNetGraphMsgHandler NetGraphMsgHandler_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCOption_AccessZ chain_access, struct LDKLogger logger);

/**
 * Adds a provider used to check new announcements. Does not affect
 * existing announcements unless they are updated.
 * Add, update or remove the provider would replace the current one.
 */
void NetGraphMsgHandler_add_chain_access(struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg, struct LDKCOption_AccessZ chain_access);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler NetGraphMsgHandler_as_RoutingMessageHandler(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider NetGraphMsgHandler_as_MessageSendEventsProvider(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelUpdateInfo, if is_owned is set and inner is non-NULL.
 */
void ChannelUpdateInfo_free(struct LDKChannelUpdateInfo this_obj);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t ChannelUpdateInfo_get_last_update(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
void ChannelUpdateInfo_set_last_update(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
bool ChannelUpdateInfo_get_enabled(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
void ChannelUpdateInfo_set_enabled(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, bool val);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
uint16_t ChannelUpdateInfo_get_cltv_expiry_delta(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
void ChannelUpdateInfo_set_cltv_expiry_delta(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
uint64_t ChannelUpdateInfo_get_htlc_minimum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
void ChannelUpdateInfo_set_htlc_minimum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum value which may be relayed to the next hop via the channel.
 */
struct LDKCOption_u64Z ChannelUpdateInfo_get_htlc_maximum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The maximum value which may be relayed to the next hop via the channel.
 */
void ChannelUpdateInfo_set_htlc_maximum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Fees charged when the channel is used for routing
 */
struct LDKRoutingFees ChannelUpdateInfo_get_fees(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Fees charged when the channel is used for routing
 */
void ChannelUpdateInfo_set_fees(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdate ChannelUpdateInfo_get_last_update_message(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelUpdateInfo_set_last_update_message(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdate val);

/**
 * Constructs a new ChannelUpdateInfo given each field
 */
MUST_USE_RES struct LDKChannelUpdateInfo ChannelUpdateInfo_new(uint32_t last_update_arg, bool enabled_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg, struct LDKRoutingFees fees_arg, struct LDKChannelUpdate last_update_message_arg);

/**
 * Creates a copy of the ChannelUpdateInfo
 */
struct LDKChannelUpdateInfo ChannelUpdateInfo_clone(const struct LDKChannelUpdateInfo *NONNULL_PTR orig);

/**
 * Serialize the ChannelUpdateInfo object into a byte array which can be read by ChannelUpdateInfo_read
 */
struct LDKCVec_u8Z ChannelUpdateInfo_write(const struct LDKChannelUpdateInfo *NONNULL_PTR obj);

/**
 * Read a ChannelUpdateInfo from a byte array, created by ChannelUpdateInfo_write
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ ChannelUpdateInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelInfo, if is_owned is set and inner is non-NULL.
 */
void ChannelInfo_free(struct LDKChannelInfo this_obj);

/**
 * Protocol features of a channel communicated during its announcement
 */
struct LDKChannelFeatures ChannelInfo_get_features(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features of a channel communicated during its announcement
 */
void ChannelInfo_set_features(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * Source node of the first direction of a channel
 */
struct LDKNodeId ChannelInfo_get_node_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the first direction of a channel
 */
void ChannelInfo_set_node_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * Details about the first direction of a channel
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdateInfo ChannelInfo_get_one_to_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the first direction of a channel
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_one_to_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);

/**
 * Source node of the second direction of a channel
 */
struct LDKNodeId ChannelInfo_get_node_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the second direction of a channel
 */
void ChannelInfo_set_node_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * Details about the second direction of a channel
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdateInfo ChannelInfo_get_two_to_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the second direction of a channel
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_two_to_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);

/**
 * The channel capacity as seen on-chain, if chain lookup is available.
 */
struct LDKCOption_u64Z ChannelInfo_get_capacity_sats(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * The channel capacity as seen on-chain, if chain lookup is available.
 */
void ChannelInfo_set_capacity_sats(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelAnnouncement ChannelInfo_get_announcement_message(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_announcement_message(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelAnnouncement val);

/**
 * Creates a copy of the ChannelInfo
 */
struct LDKChannelInfo ChannelInfo_clone(const struct LDKChannelInfo *NONNULL_PTR orig);

/**
 * Serialize the ChannelInfo object into a byte array which can be read by ChannelInfo_read
 */
struct LDKCVec_u8Z ChannelInfo_write(const struct LDKChannelInfo *NONNULL_PTR obj);

/**
 * Read a ChannelInfo from a byte array, created by ChannelInfo_write
 */
struct LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DirectedChannelInfo, if is_owned is set and inner is non-NULL.
 */
void DirectedChannelInfo_free(struct LDKDirectedChannelInfo this_obj);

/**
 * Creates a copy of the DirectedChannelInfo
 */
struct LDKDirectedChannelInfo DirectedChannelInfo_clone(const struct LDKDirectedChannelInfo *NONNULL_PTR orig);

/**
 * Returns information for the channel.
 */
MUST_USE_RES struct LDKChannelInfo DirectedChannelInfo_channel(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Returns information for the direction.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelUpdateInfo DirectedChannelInfo_direction(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Returns the [`EffectiveCapacity`] of the channel in the direction.
 *
 * This is either the total capacity from the funding transaction, if known, or the
 * `htlc_maximum_msat` for the direction as advertised by the gossip network, if known,
 * whichever is smaller.
 */
MUST_USE_RES struct LDKEffectiveCapacity DirectedChannelInfo_effective_capacity(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the EffectiveCapacity
 */
void EffectiveCapacity_free(struct LDKEffectiveCapacity this_ptr);

/**
 * Creates a copy of the EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_clone(const struct LDKEffectiveCapacity *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ExactLiquidity-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_exact_liquidity(uint64_t liquidity_msat);

/**
 * Utility method to constructs a new MaximumHTLC-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_maximum_htlc(uint64_t amount_msat);

/**
 * Utility method to constructs a new Total-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_total(uint64_t capacity_msat);

/**
 * Utility method to constructs a new Infinite-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_infinite(void);

/**
 * Utility method to constructs a new Unknown-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_unknown(void);

/**
 * Returns the effective capacity denominated in millisatoshi.
 */
MUST_USE_RES uint64_t EffectiveCapacity_as_msat(const struct LDKEffectiveCapacity *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the RoutingFees, if is_owned is set and inner is non-NULL.
 */
void RoutingFees_free(struct LDKRoutingFees this_obj);

/**
 * Flat routing fee in satoshis
 */
uint32_t RoutingFees_get_base_msat(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Flat routing fee in satoshis
 */
void RoutingFees_set_base_msat(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
uint32_t RoutingFees_get_proportional_millionths(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
void RoutingFees_set_proportional_millionths(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RoutingFees given each field
 */
MUST_USE_RES struct LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);

/**
 * Checks if two RoutingFeess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RoutingFees_eq(const struct LDKRoutingFees *NONNULL_PTR a, const struct LDKRoutingFees *NONNULL_PTR b);

/**
 * Creates a copy of the RoutingFees
 */
struct LDKRoutingFees RoutingFees_clone(const struct LDKRoutingFees *NONNULL_PTR orig);

/**
 * Checks if two RoutingFeess contain equal inner contents.
 */
uint64_t RoutingFees_hash(const struct LDKRoutingFees *NONNULL_PTR o);

/**
 * Serialize the RoutingFees object into a byte array which can be read by RoutingFees_read
 */
struct LDKCVec_u8Z RoutingFees_write(const struct LDKRoutingFees *NONNULL_PTR obj);

/**
 * Read a RoutingFees from a byte array, created by RoutingFees_write
 */
struct LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeAnnouncementInfo, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncementInfo_free(struct LDKNodeAnnouncementInfo this_obj);

/**
 * Protocol features the node announced support for
 */
struct LDKNodeFeatures NodeAnnouncementInfo_get_features(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features the node announced support for
 */
void NodeAnnouncementInfo_set_features(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t NodeAnnouncementInfo_get_last_update(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
void NodeAnnouncementInfo_set_last_update(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Color assigned to the node
 */
const uint8_t (*NodeAnnouncementInfo_get_rgb(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[3];

/**
 * Color assigned to the node
 */
void NodeAnnouncementInfo_set_rgb(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
const uint8_t (*NodeAnnouncementInfo_get_alias(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[32];

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
void NodeAnnouncementInfo_set_alias(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Internet-level addresses via which one can connect to the node
 */
void NodeAnnouncementInfo_set_addresses(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void NodeAnnouncementInfo_set_announcement_message(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncementInfo given each field
 */
MUST_USE_RES struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(struct LDKNodeFeatures features_arg, uint32_t last_update_arg, struct LDKThreeBytes rgb_arg, struct LDKThirtyTwoBytes alias_arg, struct LDKCVec_NetAddressZ addresses_arg, struct LDKNodeAnnouncement announcement_message_arg);

/**
 * Creates a copy of the NodeAnnouncementInfo
 */
struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(const struct LDKNodeAnnouncementInfo *NONNULL_PTR orig);

/**
 * Serialize the NodeAnnouncementInfo object into a byte array which can be read by NodeAnnouncementInfo_read
 */
struct LDKCVec_u8Z NodeAnnouncementInfo_write(const struct LDKNodeAnnouncementInfo *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncementInfo from a byte array, created by NodeAnnouncementInfo_write
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeInfo, if is_owned is set and inner is non-NULL.
 */
void NodeInfo_free(struct LDKNodeInfo this_obj);

/**
 * All valid channels a node has announced
 */
void NodeInfo_set_channels(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Lowest fees enabling routing via any of the enabled, known channels to a node.
 * The two fields (flat and proportional fee) are independent,
 * meaning they don't have to refer to the same channel.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKRoutingFees NodeInfo_get_lowest_inbound_channel_fees(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * Lowest fees enabling routing via any of the enabled, known channels to a node.
 * The two fields (flat and proportional fee) are independent,
 * meaning they don't have to refer to the same channel.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void NodeInfo_set_lowest_inbound_channel_fees(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void NodeInfo_set_announcement_info(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncementInfo val);

/**
 * Constructs a new NodeInfo given each field
 */
MUST_USE_RES struct LDKNodeInfo NodeInfo_new(struct LDKCVec_u64Z channels_arg, struct LDKRoutingFees lowest_inbound_channel_fees_arg, struct LDKNodeAnnouncementInfo announcement_info_arg);

/**
 * Creates a copy of the NodeInfo
 */
struct LDKNodeInfo NodeInfo_clone(const struct LDKNodeInfo *NONNULL_PTR orig);

/**
 * Serialize the NodeInfo object into a byte array which can be read by NodeInfo_read
 */
struct LDKCVec_u8Z NodeInfo_write(const struct LDKNodeInfo *NONNULL_PTR obj);

/**
 * Read a NodeInfo from a byte array, created by NodeInfo_write
 */
struct LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(struct LDKu8slice ser);

/**
 * Serialize the NetworkGraph object into a byte array which can be read by NetworkGraph_read
 */
struct LDKCVec_u8Z NetworkGraph_write(const struct LDKNetworkGraph *NONNULL_PTR obj);

/**
 * Read a NetworkGraph from a byte array, created by NetworkGraph_write
 */
struct LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(struct LDKu8slice ser);

/**
 * Creates a new, empty, network graph.
 */
MUST_USE_RES struct LDKNetworkGraph NetworkGraph_new(struct LDKThirtyTwoBytes genesis_hash);

/**
 * Returns a read-only view of the network graph.
 */
MUST_USE_RES struct LDKReadOnlyNetworkGraph NetworkGraph_read_only(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement without verifying the associated signatures. Because we aren't
 * given the associated signatures here we cannot relay the node announcement to any of our
 * peers.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR msg);

/**
 * Store or update channel info from a channel announcement.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_AccessZ chain_access);

/**
 * Store or update channel info from a channel announcement without verifying the associated
 * signatures. Because we aren't given the associated signatures here we cannot relay the
 * channel announcement to any of our peers.
 *
 * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_AccessZ chain_access);

/**
 * Close a channel if a corresponding HTLC fail was sent.
 * If permanent, removes a channel from the local storage.
 * May cause the removal of nodes too, if this was their last channel.
 * If not permanent, makes channels unavailable for routing.
 */
void NetworkGraph_close_channel_from_update(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, bool is_permanent);

/**
 * Marks a node in the graph as failed.
 */
void NetworkGraph_fail_node(const struct LDKNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey _node_id, bool is_permanent);

/**
 * Removes information about channels that we haven't heard any updates about in some time.
 * This can be used regularly to prune the network graph of channels that likely no longer
 * exist.
 *
 * While there is no formal requirement that nodes regularly re-broadcast their channel
 * updates every two weeks, the non-normative section of BOLT 7 currently suggests that
 * pruning occur for updates which are at least two weeks old, which we implement here.
 *
 * Note that for users of the `lightning-background-processor` crate this method may be
 * automatically called regularly for you.
 *
 * This method is only available with the `std` feature. See
 * [`NetworkGraph::remove_stale_channels_with_time`] for `no-std` use.
 */
void NetworkGraph_remove_stale_channels(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * Removes information about channels that we haven't heard any updates about in some time.
 * This can be used regularly to prune the network graph of channels that likely no longer
 * exist.
 *
 * While there is no formal requirement that nodes regularly re-broadcast their channel
 * updates every two weeks, the non-normative section of BOLT 7 currently suggests that
 * pruning occur for updates which are at least two weeks old, which we implement here.
 *
 * This function takes the current unix time as an argument. For users with the `std` feature
 * enabled, [`NetworkGraph::remove_stale_channels`] may be preferable.
 */
void NetworkGraph_remove_stale_channels_with_time(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t current_time_unix);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * If built with `no-std`, any updates with a timestamp more than two weeks in the past or
 * materially in the future will be rejected.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel without verifying the associated signatures. Because we aren't given the
 * associated signatures here we cannot relay the channel update to any of our peers.
 *
 * If built with `no-std`, any updates with a timestamp more than two weeks in the past or
 * materially in the future will be rejected.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelUpdate *NONNULL_PTR msg);

/**
 * Get network addresses by node id.
 * Returns None if the requested node is completely unknown,
 * or if node announcement for the node was never received.
 */
MUST_USE_RES struct LDKCOption_CVec_NetAddressZZ ReadOnlyNetworkGraph_get_addresses(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey pubkey);

/**
 * Frees any resources used by the RouteHop, if is_owned is set and inner is non-NULL.
 */
void RouteHop_free(struct LDKRouteHop this_obj);

/**
 * The node_id of the node at this hop.
 */
struct LDKPublicKey RouteHop_get_pubkey(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the node at this hop.
 */
void RouteHop_set_pubkey(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
struct LDKNodeFeatures RouteHop_get_node_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
void RouteHop_set_node_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
uint64_t RouteHop_get_short_channel_id(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
void RouteHop_set_short_channel_id(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
struct LDKChannelFeatures RouteHop_get_channel_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
void RouteHop_set_channel_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * For the last hop, this should be the full value of the payment (might be more than
 * requested if we had to match htlc_minimum_msat).
 */
uint64_t RouteHop_get_fee_msat(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * For the last hop, this should be the full value of the payment (might be more than
 * requested if we had to match htlc_minimum_msat).
 */
void RouteHop_set_fee_msat(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
 * expected at the destination, in excess of the current block height.
 */
uint32_t RouteHop_get_cltv_expiry_delta(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
 * expected at the destination, in excess of the current block height.
 */
void RouteHop_set_cltv_expiry_delta(struct LDKRouteHop *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RouteHop given each field
 */
MUST_USE_RES struct LDKRouteHop RouteHop_new(struct LDKPublicKey pubkey_arg, struct LDKNodeFeatures node_features_arg, uint64_t short_channel_id_arg, struct LDKChannelFeatures channel_features_arg, uint64_t fee_msat_arg, uint32_t cltv_expiry_delta_arg);

/**
 * Creates a copy of the RouteHop
 */
struct LDKRouteHop RouteHop_clone(const struct LDKRouteHop *NONNULL_PTR orig);

/**
 * Checks if two RouteHops contain equal inner contents.
 */
uint64_t RouteHop_hash(const struct LDKRouteHop *NONNULL_PTR o);

/**
 * Checks if two RouteHops contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHop_eq(const struct LDKRouteHop *NONNULL_PTR a, const struct LDKRouteHop *NONNULL_PTR b);

/**
 * Serialize the RouteHop object into a byte array which can be read by RouteHop_read
 */
struct LDKCVec_u8Z RouteHop_write(const struct LDKRouteHop *NONNULL_PTR obj);

/**
 * Read a RouteHop from a byte array, created by RouteHop_write
 */
struct LDKCResult_RouteHopDecodeErrorZ RouteHop_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Route, if is_owned is set and inner is non-NULL.
 */
void Route_free(struct LDKRoute this_obj);

/**
 * The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
 * last RouteHop in each path must be the same.
 * Each entry represents a list of hops, NOT INCLUDING our own, where the last hop is the
 * destination. Thus, this must always be at least length one. While the maximum length of any
 * given path is variable, keeping the length of any path to less than 20 should currently
 * ensure it is viable.
 */
struct LDKCVec_CVec_RouteHopZZ Route_get_paths(const struct LDKRoute *NONNULL_PTR this_ptr);

/**
 * The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
 * last RouteHop in each path must be the same.
 * Each entry represents a list of hops, NOT INCLUDING our own, where the last hop is the
 * destination. Thus, this must always be at least length one. While the maximum length of any
 * given path is variable, keeping the length of any path to less than 20 should currently
 * ensure it is viable.
 */
void Route_set_paths(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKCVec_CVec_RouteHopZZ val);

/**
 * The `payment_params` parameter passed to [`find_route`].
 * This is used by `ChannelManager` to track information which may be required for retries,
 * provided back to you via [`Event::PaymentPathFailed`].
 *
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKPaymentParameters Route_get_payment_params(const struct LDKRoute *NONNULL_PTR this_ptr);

/**
 * The `payment_params` parameter passed to [`find_route`].
 * This is used by `ChannelManager` to track information which may be required for retries,
 * provided back to you via [`Event::PaymentPathFailed`].
 *
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void Route_set_payment_params(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);

/**
 * Constructs a new Route given each field
 */
MUST_USE_RES struct LDKRoute Route_new(struct LDKCVec_CVec_RouteHopZZ paths_arg, struct LDKPaymentParameters payment_params_arg);

/**
 * Creates a copy of the Route
 */
struct LDKRoute Route_clone(const struct LDKRoute *NONNULL_PTR orig);

/**
 * Checks if two Routes contain equal inner contents.
 */
uint64_t Route_hash(const struct LDKRoute *NONNULL_PTR o);

/**
 * Checks if two Routes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Route_eq(const struct LDKRoute *NONNULL_PTR a, const struct LDKRoute *NONNULL_PTR b);

/**
 * Returns the total amount of fees paid on this [`Route`].
 *
 * This doesn't include any extra payment made to the recipient, which can happen in excess of
 * the amount passed to [`find_route`]'s `params.final_value_msat`.
 */
MUST_USE_RES uint64_t Route_get_total_fees(const struct LDKRoute *NONNULL_PTR this_arg);

/**
 * Returns the total amount paid on this [`Route`], excluding the fees.
 */
MUST_USE_RES uint64_t Route_get_total_amount(const struct LDKRoute *NONNULL_PTR this_arg);

/**
 * Serialize the Route object into a byte array which can be read by Route_read
 */
struct LDKCVec_u8Z Route_write(const struct LDKRoute *NONNULL_PTR obj);

/**
 * Read a Route from a byte array, created by Route_write
 */
struct LDKCResult_RouteDecodeErrorZ Route_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteParameters, if is_owned is set and inner is non-NULL.
 */
void RouteParameters_free(struct LDKRouteParameters this_obj);

/**
 * The parameters of the failed payment path.
 */
struct LDKPaymentParameters RouteParameters_get_payment_params(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The parameters of the failed payment path.
 */
void RouteParameters_set_payment_params(struct LDKRouteParameters *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);

/**
 * The amount in msats sent on the failed payment path.
 */
uint64_t RouteParameters_get_final_value_msat(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The amount in msats sent on the failed payment path.
 */
void RouteParameters_set_final_value_msat(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV on the final hop of the failed payment path.
 */
uint32_t RouteParameters_get_final_cltv_expiry_delta(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The CLTV on the final hop of the failed payment path.
 */
void RouteParameters_set_final_cltv_expiry_delta(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RouteParameters given each field
 */
MUST_USE_RES struct LDKRouteParameters RouteParameters_new(struct LDKPaymentParameters payment_params_arg, uint64_t final_value_msat_arg, uint32_t final_cltv_expiry_delta_arg);

/**
 * Creates a copy of the RouteParameters
 */
struct LDKRouteParameters RouteParameters_clone(const struct LDKRouteParameters *NONNULL_PTR orig);

/**
 * Serialize the RouteParameters object into a byte array which can be read by RouteParameters_read
 */
struct LDKCVec_u8Z RouteParameters_write(const struct LDKRouteParameters *NONNULL_PTR obj);

/**
 * Read a RouteParameters from a byte array, created by RouteParameters_write
 */
struct LDKCResult_RouteParametersDecodeErrorZ RouteParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the PaymentParameters, if is_owned is set and inner is non-NULL.
 */
void PaymentParameters_free(struct LDKPaymentParameters this_obj);

/**
 * The node id of the payee.
 */
struct LDKPublicKey PaymentParameters_get_payee_pubkey(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * The node id of the payee.
 */
void PaymentParameters_set_payee_pubkey(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Features supported by the payee.
 *
 * May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
 * does not contain any features.
 *
 * [`for_keysend`]: Self::for_keysend
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKInvoiceFeatures PaymentParameters_get_features(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Features supported by the payee.
 *
 * May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
 * does not contain any features.
 *
 * [`for_keysend`]: Self::for_keysend
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void PaymentParameters_set_features(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKInvoiceFeatures val);

/**
 * Hints for routing to the payee, containing channels connecting the payee to public nodes.
 */
struct LDKCVec_RouteHintZ PaymentParameters_get_route_hints(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Hints for routing to the payee, containing channels connecting the payee to public nodes.
 */
void PaymentParameters_set_route_hints(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintZ val);

/**
 * Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
 */
struct LDKCOption_u64Z PaymentParameters_get_expiry_time(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
 */
void PaymentParameters_set_expiry_time(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The maximum total CLTV delta we accept for the route.
 */
uint32_t PaymentParameters_get_max_total_cltv_expiry_delta(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * The maximum total CLTV delta we accept for the route.
 */
void PaymentParameters_set_max_total_cltv_expiry_delta(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new PaymentParameters given each field
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_new(struct LDKPublicKey payee_pubkey_arg, struct LDKInvoiceFeatures features_arg, struct LDKCVec_RouteHintZ route_hints_arg, struct LDKCOption_u64Z expiry_time_arg, uint32_t max_total_cltv_expiry_delta_arg);

/**
 * Creates a copy of the PaymentParameters
 */
struct LDKPaymentParameters PaymentParameters_clone(const struct LDKPaymentParameters *NONNULL_PTR orig);

/**
 * Checks if two PaymentParameterss contain equal inner contents.
 */
uint64_t PaymentParameters_hash(const struct LDKPaymentParameters *NONNULL_PTR o);

/**
 * Checks if two PaymentParameterss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PaymentParameters_eq(const struct LDKPaymentParameters *NONNULL_PTR a, const struct LDKPaymentParameters *NONNULL_PTR b);

/**
 * Serialize the PaymentParameters object into a byte array which can be read by PaymentParameters_read
 */
struct LDKCVec_u8Z PaymentParameters_write(const struct LDKPaymentParameters *NONNULL_PTR obj);

/**
 * Read a PaymentParameters from a byte array, created by PaymentParameters_write
 */
struct LDKCResult_PaymentParametersDecodeErrorZ PaymentParameters_read(struct LDKu8slice ser);

/**
 * Creates a payee with the node id of the given `pubkey`.
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_from_node_id(struct LDKPublicKey payee_pubkey);

/**
 * Creates a payee with the node id of the given `pubkey` to use for keysend payments.
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_for_keysend(struct LDKPublicKey payee_pubkey);

/**
 * Frees any resources used by the RouteHint, if is_owned is set and inner is non-NULL.
 */
void RouteHint_free(struct LDKRouteHint this_obj);

struct LDKCVec_RouteHintHopZ RouteHint_get_a(const struct LDKRouteHint *NONNULL_PTR this_ptr);

void RouteHint_set_a(struct LDKRouteHint *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintHopZ val);

/**
 * Constructs a new RouteHint given each field
 */
MUST_USE_RES struct LDKRouteHint RouteHint_new(struct LDKCVec_RouteHintHopZ a_arg);

/**
 * Creates a copy of the RouteHint
 */
struct LDKRouteHint RouteHint_clone(const struct LDKRouteHint *NONNULL_PTR orig);

/**
 * Checks if two RouteHints contain equal inner contents.
 */
uint64_t RouteHint_hash(const struct LDKRouteHint *NONNULL_PTR o);

/**
 * Checks if two RouteHints contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHint_eq(const struct LDKRouteHint *NONNULL_PTR a, const struct LDKRouteHint *NONNULL_PTR b);

/**
 * Serialize the RouteHint object into a byte array which can be read by RouteHint_read
 */
struct LDKCVec_u8Z RouteHint_write(const struct LDKRouteHint *NONNULL_PTR obj);

/**
 * Read a RouteHint from a byte array, created by RouteHint_write
 */
struct LDKCResult_RouteHintDecodeErrorZ RouteHint_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHintHop, if is_owned is set and inner is non-NULL.
 */
void RouteHintHop_free(struct LDKRouteHintHop this_obj);

/**
 * The node_id of the non-target end of the route
 */
struct LDKPublicKey RouteHintHop_get_src_node_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the non-target end of the route
 */
void RouteHintHop_set_src_node_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The short_channel_id of this channel
 */
uint64_t RouteHintHop_get_short_channel_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The short_channel_id of this channel
 */
void RouteHintHop_set_short_channel_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The fees which must be paid to use this channel
 */
struct LDKRoutingFees RouteHintHop_get_fees(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The fees which must be paid to use this channel
 */
void RouteHintHop_set_fees(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * The difference in CLTV values between this node and the next node.
 */
uint16_t RouteHintHop_get_cltv_expiry_delta(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values between this node and the next node.
 */
void RouteHintHop_set_cltv_expiry_delta(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, in msat, which must be relayed to the next hop.
 */
struct LDKCOption_u64Z RouteHintHop_get_htlc_minimum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The minimum value, in msat, which must be relayed to the next hop.
 */
void RouteHintHop_set_htlc_minimum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The maximum value in msat available for routing with a single HTLC.
 */
struct LDKCOption_u64Z RouteHintHop_get_htlc_maximum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The maximum value in msat available for routing with a single HTLC.
 */
void RouteHintHop_set_htlc_maximum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new RouteHintHop given each field
 */
MUST_USE_RES struct LDKRouteHintHop RouteHintHop_new(struct LDKPublicKey src_node_id_arg, uint64_t short_channel_id_arg, struct LDKRoutingFees fees_arg, uint16_t cltv_expiry_delta_arg, struct LDKCOption_u64Z htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg);

/**
 * Creates a copy of the RouteHintHop
 */
struct LDKRouteHintHop RouteHintHop_clone(const struct LDKRouteHintHop *NONNULL_PTR orig);

/**
 * Checks if two RouteHintHops contain equal inner contents.
 */
uint64_t RouteHintHop_hash(const struct LDKRouteHintHop *NONNULL_PTR o);

/**
 * Checks if two RouteHintHops contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHintHop_eq(const struct LDKRouteHintHop *NONNULL_PTR a, const struct LDKRouteHintHop *NONNULL_PTR b);

/**
 * Serialize the RouteHintHop object into a byte array which can be read by RouteHintHop_read
 */
struct LDKCVec_u8Z RouteHintHop_write(const struct LDKRouteHintHop *NONNULL_PTR obj);

/**
 * Read a RouteHintHop from a byte array, created by RouteHintHop_write
 */
struct LDKCResult_RouteHintHopDecodeErrorZ RouteHintHop_read(struct LDKu8slice ser);

/**
 * Finds a route from us (payer) to the given target node (payee).
 *
 * If the payee provided features in their invoice, they should be provided via `params.payee`.
 * Without this, MPP will only be used if the payee's features are available in the network graph.
 *
 * Private routing paths between a public node and the target may be included in `params.payee`.
 *
 * If some channels aren't announced, it may be useful to fill in `first_hops` with the results
 * from [`ChannelManager::list_usable_channels`]. If it is filled in, the view of our local
 * channels from [`NetworkGraph`] will be ignored, and only those in `first_hops` will be used.
 *
 * The fees on channels from us to the next hop are ignored as they are assumed to all be equal.
 * However, the enabled/disabled bit on such channels as well as the `htlc_minimum_msat` /
 * `htlc_maximum_msat` *are* checked as they may change based on the receiving node.
 *
 * # Note
 *
 * May be used to re-compute a [`Route`] when handling a [`Event::PaymentPathFailed`]. Any
 * adjustments to the [`NetworkGraph`] and channel scores should be made prior to calling this
 * function.
 *
 * # Panics
 *
 * Panics if first_hops contains channels without short_channel_ids;
 * [`ChannelManager::list_usable_channels`] will never include such channels.
 *
 * [`ChannelManager::list_usable_channels`]: crate::ln::channelmanager::ChannelManager::list_usable_channels
 * [`Event::PaymentPathFailed`]: crate::util::events::Event::PaymentPathFailed
 *
 * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCResult_RouteLightningErrorZ find_route(struct LDKPublicKey our_node_pubkey, const struct LDKRouteParameters *NONNULL_PTR route_params, const struct LDKNetworkGraph *NONNULL_PTR network, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKLogger logger, const struct LDKScore *NONNULL_PTR scorer, const uint8_t (*random_seed_bytes)[32]);

/**
 * Calls the free function if one is set
 */
void Score_free(struct LDKScore this_ptr);

/**
 * Calls the free function if one is set
 */
void LockableScore_free(struct LDKLockableScore this_ptr);

/**
 * Frees any resources used by the MultiThreadedLockableScore, if is_owned is set and inner is non-NULL.
 */
void MultiThreadedLockableScore_free(struct LDKMultiThreadedLockableScore this_obj);

/**
 * Creates a new [`MultiThreadedLockableScore`] given an underlying [`Score`].
 */
MUST_USE_RES struct LDKMultiThreadedLockableScore MultiThreadedLockableScore_new(struct LDKScore score);

/**
 * Frees any resources used by the FixedPenaltyScorer, if is_owned is set and inner is non-NULL.
 */
void FixedPenaltyScorer_free(struct LDKFixedPenaltyScorer this_obj);

/**
 * Creates a copy of the FixedPenaltyScorer
 */
struct LDKFixedPenaltyScorer FixedPenaltyScorer_clone(const struct LDKFixedPenaltyScorer *NONNULL_PTR orig);

/**
 * Creates a new scorer using `penalty_msat`.
 */
MUST_USE_RES struct LDKFixedPenaltyScorer FixedPenaltyScorer_with_penalty(uint64_t penalty_msat);

/**
 * Constructs a new Score which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
 */
struct LDKScore FixedPenaltyScorer_as_Score(const struct LDKFixedPenaltyScorer *NONNULL_PTR this_arg);

/**
 * Serialize the FixedPenaltyScorer object into a byte array which can be read by FixedPenaltyScorer_read
 */
struct LDKCVec_u8Z FixedPenaltyScorer_write(const struct LDKFixedPenaltyScorer *NONNULL_PTR obj);

/**
 * Read a FixedPenaltyScorer from a byte array, created by FixedPenaltyScorer_write
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ FixedPenaltyScorer_read(struct LDKu8slice ser, uint64_t arg);

/**
 * Frees any resources used by the Scorer, if is_owned is set and inner is non-NULL.
 */
void Scorer_free(struct LDKScorer this_obj);

/**
 * Frees any resources used by the ScoringParameters, if is_owned is set and inner is non-NULL.
 */
void ScoringParameters_free(struct LDKScoringParameters this_obj);

/**
 * A fixed penalty in msats to apply to each channel.
 *
 * Default value: 500 msat
 */
uint64_t ScoringParameters_get_base_penalty_msat(const struct LDKScoringParameters *NONNULL_PTR this_ptr);

/**
 * A fixed penalty in msats to apply to each channel.
 *
 * Default value: 500 msat
 */
void ScoringParameters_set_base_penalty_msat(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A penalty in msats to apply to a channel upon failing to relay a payment.
 *
 * This accumulates for each failure but may be reduced over time based on
 * [`failure_penalty_half_life`] or when successfully routing through a channel.
 *
 * Default value: 1,024,000 msat
 *
 * [`failure_penalty_half_life`]: Self::failure_penalty_half_life
 */
uint64_t ScoringParameters_get_failure_penalty_msat(const struct LDKScoringParameters *NONNULL_PTR this_ptr);

/**
 * A penalty in msats to apply to a channel upon failing to relay a payment.
 *
 * This accumulates for each failure but may be reduced over time based on
 * [`failure_penalty_half_life`] or when successfully routing through a channel.
 *
 * Default value: 1,024,000 msat
 *
 * [`failure_penalty_half_life`]: Self::failure_penalty_half_life
 */
void ScoringParameters_set_failure_penalty_msat(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * When the amount being sent over a channel is this many 1024ths of the total channel
 * capacity, we begin applying [`overuse_penalty_msat_per_1024th`].
 *
 * Default value: 128 1024ths (i.e. begin penalizing when an HTLC uses 1/8th of a channel)
 *
 * [`overuse_penalty_msat_per_1024th`]: Self::overuse_penalty_msat_per_1024th
 */
uint16_t ScoringParameters_get_overuse_penalty_start_1024th(const struct LDKScoringParameters *NONNULL_PTR this_ptr);

/**
 * When the amount being sent over a channel is this many 1024ths of the total channel
 * capacity, we begin applying [`overuse_penalty_msat_per_1024th`].
 *
 * Default value: 128 1024ths (i.e. begin penalizing when an HTLC uses 1/8th of a channel)
 *
 * [`overuse_penalty_msat_per_1024th`]: Self::overuse_penalty_msat_per_1024th
 */
void ScoringParameters_set_overuse_penalty_start_1024th(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * A penalty applied, per whole 1024ths of the channel capacity which the amount being sent
 * over the channel exceeds [`overuse_penalty_start_1024th`] by.
 *
 * Default value: 20 msat (i.e. 2560 msat penalty to use 1/4th of a channel, 7680 msat penalty
 *                to use half a channel, and 12,560 msat penalty to use 3/4ths of a channel)
 *
 * [`overuse_penalty_start_1024th`]: Self::overuse_penalty_start_1024th
 */
uint64_t ScoringParameters_get_overuse_penalty_msat_per_1024th(const struct LDKScoringParameters *NONNULL_PTR this_ptr);

/**
 * A penalty applied, per whole 1024ths of the channel capacity which the amount being sent
 * over the channel exceeds [`overuse_penalty_start_1024th`] by.
 *
 * Default value: 20 msat (i.e. 2560 msat penalty to use 1/4th of a channel, 7680 msat penalty
 *                to use half a channel, and 12,560 msat penalty to use 3/4ths of a channel)
 *
 * [`overuse_penalty_start_1024th`]: Self::overuse_penalty_start_1024th
 */
void ScoringParameters_set_overuse_penalty_msat_per_1024th(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The time required to elapse before any accumulated [`failure_penalty_msat`] penalties are
 * cut in half.
 *
 * Successfully routing through a channel will immediately cut the penalty in half as well.
 *
 * Default value: 1 hour
 *
 * # Note
 *
 * When built with the `no-std` feature, time will never elapse. Therefore, this penalty will
 * never decay.
 *
 * [`failure_penalty_msat`]: Self::failure_penalty_msat
 */
uint64_t ScoringParameters_get_failure_penalty_half_life(const struct LDKScoringParameters *NONNULL_PTR this_ptr);

/**
 * The time required to elapse before any accumulated [`failure_penalty_msat`] penalties are
 * cut in half.
 *
 * Successfully routing through a channel will immediately cut the penalty in half as well.
 *
 * Default value: 1 hour
 *
 * # Note
 *
 * When built with the `no-std` feature, time will never elapse. Therefore, this penalty will
 * never decay.
 *
 * [`failure_penalty_msat`]: Self::failure_penalty_msat
 */
void ScoringParameters_set_failure_penalty_half_life(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ScoringParameters given each field
 */
MUST_USE_RES struct LDKScoringParameters ScoringParameters_new(uint64_t base_penalty_msat_arg, uint64_t failure_penalty_msat_arg, uint16_t overuse_penalty_start_1024th_arg, uint64_t overuse_penalty_msat_per_1024th_arg, uint64_t failure_penalty_half_life_arg);

/**
 * Creates a copy of the ScoringParameters
 */
struct LDKScoringParameters ScoringParameters_clone(const struct LDKScoringParameters *NONNULL_PTR orig);

/**
 * Serialize the ScoringParameters object into a byte array which can be read by ScoringParameters_read
 */
struct LDKCVec_u8Z ScoringParameters_write(const struct LDKScoringParameters *NONNULL_PTR obj);

/**
 * Read a ScoringParameters from a byte array, created by ScoringParameters_write
 */
struct LDKCResult_ScoringParametersDecodeErrorZ ScoringParameters_read(struct LDKu8slice ser);

/**
 * Creates a new scorer using the given scoring parameters.
 */
MUST_USE_RES struct LDKScorer Scorer_new(struct LDKScoringParameters params);

/**
 * Creates a "default" Scorer. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKScorer Scorer_default(void);

/**
 * Creates a "default" ScoringParameters. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKScoringParameters ScoringParameters_default(void);

/**
 * Constructs a new Score which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
 */
struct LDKScore Scorer_as_Score(const struct LDKScorer *NONNULL_PTR this_arg);

/**
 * Serialize the Scorer object into a byte array which can be read by Scorer_read
 */
struct LDKCVec_u8Z Scorer_write(const struct LDKScorer *NONNULL_PTR obj);

/**
 * Read a Scorer from a byte array, created by Scorer_write
 */
struct LDKCResult_ScorerDecodeErrorZ Scorer_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ProbabilisticScorer, if is_owned is set and inner is non-NULL.
 */
void ProbabilisticScorer_free(struct LDKProbabilisticScorer this_obj);

/**
 * Frees any resources used by the ProbabilisticScoringParameters, if is_owned is set and inner is non-NULL.
 */
void ProbabilisticScoringParameters_free(struct LDKProbabilisticScoringParameters this_obj);

/**
 * A fixed penalty in msats to apply to each channel.
 *
 * Default value: 500 msat
 */
uint64_t ProbabilisticScoringParameters_get_base_penalty_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A fixed penalty in msats to apply to each channel.
 *
 * Default value: 500 msat
 */
void ProbabilisticScoringParameters_set_base_penalty_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for a payment to determine the liquidity penalty.
 *
 * The penalty is based in part on the knowledge learned from prior successful and unsuccessful
 * payments. This knowledge is decayed over time based on [`liquidity_offset_half_life`]. The
 * penalty is effectively limited to `2 * liquidity_penalty_multiplier_msat` (corresponding to
 * lower bounding the success probability to `0.01`) when the amount falls within the
 * uncertainty bounds of the channel liquidity balance. Amounts above the upper bound will
 * result in a `u64::max_value` penalty, however.
 *
 * Default value: 40,000 msat
 *
 * [`liquidity_offset_half_life`]: Self::liquidity_offset_half_life
 */
uint64_t ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for a payment to determine the liquidity penalty.
 *
 * The penalty is based in part on the knowledge learned from prior successful and unsuccessful
 * payments. This knowledge is decayed over time based on [`liquidity_offset_half_life`]. The
 * penalty is effectively limited to `2 * liquidity_penalty_multiplier_msat` (corresponding to
 * lower bounding the success probability to `0.01`) when the amount falls within the
 * uncertainty bounds of the channel liquidity balance. Amounts above the upper bound will
 * result in a `u64::max_value` penalty, however.
 *
 * Default value: 40,000 msat
 *
 * [`liquidity_offset_half_life`]: Self::liquidity_offset_half_life
 */
void ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The time required to elapse before any knowledge learned about channel liquidity balances is
 * cut in half.
 *
 * The bounds are defined in terms of offsets and are initially zero. Increasing the offsets
 * gives tighter bounds on the channel liquidity balance. Thus, halving the offsets decreases
 * the certainty of the channel liquidity balance.
 *
 * Default value: 1 hour
 *
 * # Note
 *
 * When built with the `no-std` feature, time will never elapse. Therefore, the channel
 * liquidity knowledge will never decay except when the bounds cross.
 */
uint64_t ProbabilisticScoringParameters_get_liquidity_offset_half_life(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * The time required to elapse before any knowledge learned about channel liquidity balances is
 * cut in half.
 *
 * The bounds are defined in terms of offsets and are initially zero. Increasing the offsets
 * gives tighter bounds on the channel liquidity balance. Thus, halving the offsets decreases
 * the certainty of the channel liquidity balance.
 *
 * Default value: 1 hour
 *
 * # Note
 *
 * When built with the `no-std` feature, time will never elapse. Therefore, the channel
 * liquidity knowledge will never decay except when the bounds cross.
 */
void ProbabilisticScoringParameters_set_liquidity_offset_half_life(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with a payment amount and the negative `log10` of the
 * channel's success probability for the payment to determine the amount penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^20`ths of the payment amount, weighted by the negative `log10` of the
 * success probability.
 *
 * `-log10(success_probability) * amount_penalty_multiplier_msat * amount_msat / 2^20`
 *
 * In practice, this means for 0.1 success probability (`-log10(0.1) == 1`) each `2^20`th of
 * the amount will result in a penalty of the multiplier. And, as the success probability
 * decreases, the negative `log10` weighting will increase dramatically. For higher success
 * probabilities, the multiplier will have a decreasing effect as the negative `log10` will
 * fall below `1`.
 *
 * Default value: 256 msat
 */
uint64_t ProbabilisticScoringParameters_get_amount_penalty_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with a payment amount and the negative `log10` of the
 * channel's success probability for the payment to determine the amount penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^20`ths of the payment amount, weighted by the negative `log10` of the
 * success probability.
 *
 * `-log10(success_probability) * amount_penalty_multiplier_msat * amount_msat / 2^20`
 *
 * In practice, this means for 0.1 success probability (`-log10(0.1) == 1`) each `2^20`th of
 * the amount will result in a penalty of the multiplier. And, as the success probability
 * decreases, the negative `log10` weighting will increase dramatically. For higher success
 * probabilities, the multiplier will have a decreasing effect as the negative `log10` will
 * fall below `1`.
 *
 * Default value: 256 msat
 */
void ProbabilisticScoringParameters_set_amount_penalty_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ProbabilisticScoringParameters given each field
 */
MUST_USE_RES struct LDKProbabilisticScoringParameters ProbabilisticScoringParameters_new(uint64_t base_penalty_msat_arg, uint64_t liquidity_penalty_multiplier_msat_arg, uint64_t liquidity_offset_half_life_arg, uint64_t amount_penalty_multiplier_msat_arg);

/**
 * Creates a copy of the ProbabilisticScoringParameters
 */
struct LDKProbabilisticScoringParameters ProbabilisticScoringParameters_clone(const struct LDKProbabilisticScoringParameters *NONNULL_PTR orig);

/**
 * Creates a new scorer using the given scoring parameters for sending payments from a node
 * through a network graph.
 */
MUST_USE_RES struct LDKProbabilisticScorer ProbabilisticScorer_new(struct LDKProbabilisticScoringParameters params, const struct LDKNetworkGraph *NONNULL_PTR network_graph);

/**
 * Creates a "default" ProbabilisticScoringParameters. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKProbabilisticScoringParameters ProbabilisticScoringParameters_default(void);

/**
 * Constructs a new Score which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
 */
struct LDKScore ProbabilisticScorer_as_Score(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);

/**
 * Serialize the ProbabilisticScorer object into a byte array which can be read by ProbabilisticScorer_read
 */
struct LDKCVec_u8Z ProbabilisticScorer_write(const struct LDKProbabilisticScorer *NONNULL_PTR obj);

/**
 * Read a ProbabilisticScorer from a byte array, created by ProbabilisticScorer_write
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ ProbabilisticScorer_read(struct LDKu8slice ser, struct LDKProbabilisticScoringParameters arg_a, const struct LDKNetworkGraph *NONNULL_PTR arg_b);

/**
 * Frees any resources used by the FilesystemPersister, if is_owned is set and inner is non-NULL.
 */
void FilesystemPersister_free(struct LDKFilesystemPersister this_obj);

/**
 * Initialize a new FilesystemPersister and set the path to the individual channels'
 * files.
 */
MUST_USE_RES struct LDKFilesystemPersister FilesystemPersister_new(struct LDKStr path_to_channel_data);

/**
 * Get the directory which was provided when this persister was initialized.
 */
MUST_USE_RES struct LDKStr FilesystemPersister_get_data_dir(const struct LDKFilesystemPersister *NONNULL_PTR this_arg);

/**
 * Writes the provided `ChannelManager` to the path provided at `FilesystemPersister`
 * initialization, within a file called \"manager\".
 */
MUST_USE_RES struct LDKCResult_NoneErrorZ FilesystemPersister_persist_manager(struct LDKStr data_dir, const struct LDKChannelManager *NONNULL_PTR manager);

/**
 * Write the provided `NetworkGraph` to the path provided at `FilesystemPersister`
 * initialization, within a file called \"network_graph\"
 */
MUST_USE_RES struct LDKCResult_NoneErrorZ FilesystemPersister_persist_network_graph(struct LDKStr data_dir, const struct LDKNetworkGraph *NONNULL_PTR network_graph);

/**
 * Read `ChannelMonitor`s from disk.
 */
MUST_USE_RES struct LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ FilesystemPersister_read_channelmonitors(const struct LDKFilesystemPersister *NONNULL_PTR this_arg, struct LDKKeysInterface keys_manager);

/**
 * Constructs a new Persist which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Persist must be freed before this_arg is
 */
struct LDKPersist FilesystemPersister_as_Persist(const struct LDKFilesystemPersister *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the BackgroundProcessor, if is_owned is set and inner is non-NULL.
 */
void BackgroundProcessor_free(struct LDKBackgroundProcessor this_obj);

/**
 * Calls the free function if one is set
 */
void Persister_free(struct LDKPersister this_ptr);

/**
 * Start a background thread that takes care of responsibilities enumerated in the [top-level
 * documentation].
 *
 * The thread runs indefinitely unless the object is dropped, [`stop`] is called, or
 * [`Persister::persist_manager`] returns an error. In case of an error, the error is retrieved by calling
 * either [`join`] or [`stop`].
 *
 * # Data Persistence
 *
 * [`Persister::persist_manager`] is responsible for writing out the [`ChannelManager`] to disk, and/or
 * uploading to one or more backup services. See [`ChannelManager::write`] for writing out a
 * [`ChannelManager`]. See [`FilesystemPersister::persist_manager`] for Rust-Lightning's
 * provided implementation.
 *
 * [`Persister::persist_graph`] is responsible for writing out the [`NetworkGraph`] to disk. See
 * [`NetworkGraph::write`] for writing out a [`NetworkGraph`]. See [`FilesystemPersister::persist_network_graph`]
 * for Rust-Lightning's provided implementation.
 *
 * Typically, users should either implement [`Persister::persist_manager`] to never return an
 * error or call [`join`] and handle any error that may arise. For the latter case,
 * `BackgroundProcessor` must be restarted by calling `start` again after handling the error.
 *
 * # Event Handling
 *
 * `event_handler` is responsible for handling events that users should be notified of (e.g.,
 * payment failed). [`BackgroundProcessor`] may decorate the given [`EventHandler`] with common
 * functionality implemented by other handlers.
 * * [`NetGraphMsgHandler`] if given will update the [`NetworkGraph`] based on payment failures.
 *
 * [top-level documentation]: BackgroundProcessor
 * [`join`]: Self::join
 * [`stop`]: Self::stop
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 * [`ChannelManager::write`]: lightning::ln::channelmanager::ChannelManager#impl-Writeable
 * [`FilesystemPersister::persist_manager`]: lightning_persister::FilesystemPersister::persist_manager
 * [`FilesystemPersister::persist_network_graph`]: lightning_persister::FilesystemPersister::persist_network_graph
 * [`NetworkGraph`]: lightning::routing::network_graph::NetworkGraph
 * [`NetworkGraph::write`]: lightning::routing::network_graph::NetworkGraph#impl-Writeable
 *
 * Note that net_graph_msg_handler (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKBackgroundProcessor BackgroundProcessor_start(struct LDKPersister persister, struct LDKEventHandler event_handler, const struct LDKChainMonitor *NONNULL_PTR chain_monitor, const struct LDKChannelManager *NONNULL_PTR channel_manager, struct LDKNetGraphMsgHandler net_graph_msg_handler, const struct LDKPeerManager *NONNULL_PTR peer_manager, struct LDKLogger logger);

/**
 * Join `BackgroundProcessor`'s thread, returning any error that occurred while persisting
 * [`ChannelManager`].
 *
 * # Panics
 *
 * This function panics if the background thread has panicked such as while persisting or
 * handling events.
 *
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 */
MUST_USE_RES struct LDKCResult_NoneErrorZ BackgroundProcessor_join(struct LDKBackgroundProcessor this_arg);

/**
 * Stop `BackgroundProcessor`'s thread, returning any error that occurred while persisting
 * [`ChannelManager`].
 *
 * # Panics
 *
 * This function panics if the background thread has panicked such as while persisting or
 * handling events.
 *
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 */
MUST_USE_RES struct LDKCResult_NoneErrorZ BackgroundProcessor_stop(struct LDKBackgroundProcessor this_arg);

/**
 * Frees any resources used by the ParseError
 */
void ParseError_free(struct LDKParseError this_ptr);

/**
 * Creates a copy of the ParseError
 */
struct LDKParseError ParseError_clone(const struct LDKParseError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Bech32Error-variant ParseError
 */
struct LDKParseError ParseError_bech32_error(struct LDKBech32Error a);

/**
 * Utility method to constructs a new ParseAmountError-variant ParseError
 */
struct LDKParseError ParseError_parse_amount_error(struct LDKError a);

/**
 * Utility method to constructs a new MalformedSignature-variant ParseError
 */
struct LDKParseError ParseError_malformed_signature(enum LDKSecp256k1Error a);

/**
 * Utility method to constructs a new BadPrefix-variant ParseError
 */
struct LDKParseError ParseError_bad_prefix(void);

/**
 * Utility method to constructs a new UnknownCurrency-variant ParseError
 */
struct LDKParseError ParseError_unknown_currency(void);

/**
 * Utility method to constructs a new UnknownSiPrefix-variant ParseError
 */
struct LDKParseError ParseError_unknown_si_prefix(void);

/**
 * Utility method to constructs a new MalformedHRP-variant ParseError
 */
struct LDKParseError ParseError_malformed_hrp(void);

/**
 * Utility method to constructs a new TooShortDataPart-variant ParseError
 */
struct LDKParseError ParseError_too_short_data_part(void);

/**
 * Utility method to constructs a new UnexpectedEndOfTaggedFields-variant ParseError
 */
struct LDKParseError ParseError_unexpected_end_of_tagged_fields(void);

/**
 * Utility method to constructs a new DescriptionDecodeError-variant ParseError
 */
struct LDKParseError ParseError_description_decode_error(struct LDKError a);

/**
 * Utility method to constructs a new PaddingError-variant ParseError
 */
struct LDKParseError ParseError_padding_error(void);

/**
 * Utility method to constructs a new IntegerOverflowError-variant ParseError
 */
struct LDKParseError ParseError_integer_overflow_error(void);

/**
 * Utility method to constructs a new InvalidSegWitProgramLength-variant ParseError
 */
struct LDKParseError ParseError_invalid_seg_wit_program_length(void);

/**
 * Utility method to constructs a new InvalidPubKeyHashLength-variant ParseError
 */
struct LDKParseError ParseError_invalid_pub_key_hash_length(void);

/**
 * Utility method to constructs a new InvalidScriptHashLength-variant ParseError
 */
struct LDKParseError ParseError_invalid_script_hash_length(void);

/**
 * Utility method to constructs a new InvalidRecoveryId-variant ParseError
 */
struct LDKParseError ParseError_invalid_recovery_id(void);

/**
 * Utility method to constructs a new InvalidSliceLength-variant ParseError
 */
struct LDKParseError ParseError_invalid_slice_length(struct LDKStr a);

/**
 * Utility method to constructs a new Skip-variant ParseError
 */
struct LDKParseError ParseError_skip(void);

/**
 * Frees any resources used by the ParseOrSemanticError
 */
void ParseOrSemanticError_free(struct LDKParseOrSemanticError this_ptr);

/**
 * Creates a copy of the ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_clone(const struct LDKParseOrSemanticError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ParseError-variant ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_parse_error(struct LDKParseError a);

/**
 * Utility method to constructs a new SemanticError-variant ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_semantic_error(enum LDKSemanticError a);

/**
 * Frees any resources used by the Invoice, if is_owned is set and inner is non-NULL.
 */
void Invoice_free(struct LDKInvoice this_obj);

/**
 * Checks if two Invoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Invoice_eq(const struct LDKInvoice *NONNULL_PTR a, const struct LDKInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the Invoice
 */
struct LDKInvoice Invoice_clone(const struct LDKInvoice *NONNULL_PTR orig);

/**
 * Frees any resources used by the SignedRawInvoice, if is_owned is set and inner is non-NULL.
 */
void SignedRawInvoice_free(struct LDKSignedRawInvoice this_obj);

/**
 * Checks if two SignedRawInvoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool SignedRawInvoice_eq(const struct LDKSignedRawInvoice *NONNULL_PTR a, const struct LDKSignedRawInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the SignedRawInvoice
 */
struct LDKSignedRawInvoice SignedRawInvoice_clone(const struct LDKSignedRawInvoice *NONNULL_PTR orig);

/**
 * Frees any resources used by the RawInvoice, if is_owned is set and inner is non-NULL.
 */
void RawInvoice_free(struct LDKRawInvoice this_obj);

/**
 * data part
 */
struct LDKRawDataPart RawInvoice_get_data(const struct LDKRawInvoice *NONNULL_PTR this_ptr);

/**
 * data part
 */
void RawInvoice_set_data(struct LDKRawInvoice *NONNULL_PTR this_ptr, struct LDKRawDataPart val);

/**
 * Checks if two RawInvoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RawInvoice_eq(const struct LDKRawInvoice *NONNULL_PTR a, const struct LDKRawInvoice *NONNULL_PTR b);

/**
 * Creates a copy of the RawInvoice
 */
struct LDKRawInvoice RawInvoice_clone(const struct LDKRawInvoice *NONNULL_PTR orig);

/**
 * Frees any resources used by the RawDataPart, if is_owned is set and inner is non-NULL.
 */
void RawDataPart_free(struct LDKRawDataPart this_obj);

/**
 * generation time of the invoice
 */
struct LDKPositiveTimestamp RawDataPart_get_timestamp(const struct LDKRawDataPart *NONNULL_PTR this_ptr);

/**
 * generation time of the invoice
 */
void RawDataPart_set_timestamp(struct LDKRawDataPart *NONNULL_PTR this_ptr, struct LDKPositiveTimestamp val);

/**
 * Checks if two RawDataParts contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RawDataPart_eq(const struct LDKRawDataPart *NONNULL_PTR a, const struct LDKRawDataPart *NONNULL_PTR b);

/**
 * Creates a copy of the RawDataPart
 */
struct LDKRawDataPart RawDataPart_clone(const struct LDKRawDataPart *NONNULL_PTR orig);

/**
 * Frees any resources used by the PositiveTimestamp, if is_owned is set and inner is non-NULL.
 */
void PositiveTimestamp_free(struct LDKPositiveTimestamp this_obj);

/**
 * Checks if two PositiveTimestamps contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PositiveTimestamp_eq(const struct LDKPositiveTimestamp *NONNULL_PTR a, const struct LDKPositiveTimestamp *NONNULL_PTR b);

/**
 * Creates a copy of the PositiveTimestamp
 */
struct LDKPositiveTimestamp PositiveTimestamp_clone(const struct LDKPositiveTimestamp *NONNULL_PTR orig);

/**
 * Creates a copy of the SiPrefix
 */
enum LDKSiPrefix SiPrefix_clone(const enum LDKSiPrefix *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Milli-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_milli(void);

/**
 * Utility method to constructs a new Micro-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_micro(void);

/**
 * Utility method to constructs a new Nano-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_nano(void);

/**
 * Utility method to constructs a new Pico-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_pico(void);

/**
 * Checks if two SiPrefixs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SiPrefix_eq(const enum LDKSiPrefix *NONNULL_PTR a, const enum LDKSiPrefix *NONNULL_PTR b);

/**
 * Returns the multiplier to go from a BTC value to picoBTC implied by this SiPrefix.
 * This is effectively 10^12 * the prefix multiplier
 */
MUST_USE_RES uint64_t SiPrefix_multiplier(const enum LDKSiPrefix *NONNULL_PTR this_arg);

/**
 * Creates a copy of the Currency
 */
enum LDKCurrency Currency_clone(const enum LDKCurrency *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Bitcoin-variant Currency
 */
enum LDKCurrency Currency_bitcoin(void);

/**
 * Utility method to constructs a new BitcoinTestnet-variant Currency
 */
enum LDKCurrency Currency_bitcoin_testnet(void);

/**
 * Utility method to constructs a new Regtest-variant Currency
 */
enum LDKCurrency Currency_regtest(void);

/**
 * Utility method to constructs a new Simnet-variant Currency
 */
enum LDKCurrency Currency_simnet(void);

/**
 * Utility method to constructs a new Signet-variant Currency
 */
enum LDKCurrency Currency_signet(void);

/**
 * Checks if two Currencys contain equal inner contents.
 */
uint64_t Currency_hash(const enum LDKCurrency *NONNULL_PTR o);

/**
 * Checks if two Currencys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Currency_eq(const enum LDKCurrency *NONNULL_PTR a, const enum LDKCurrency *NONNULL_PTR b);

/**
 * Frees any resources used by the Sha256, if is_owned is set and inner is non-NULL.
 */
void Sha256_free(struct LDKSha256 this_obj);

/**
 * Creates a copy of the Sha256
 */
struct LDKSha256 Sha256_clone(const struct LDKSha256 *NONNULL_PTR orig);

/**
 * Checks if two Sha256s contain equal inner contents.
 */
uint64_t Sha256_hash(const struct LDKSha256 *NONNULL_PTR o);

/**
 * Checks if two Sha256s contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Sha256_eq(const struct LDKSha256 *NONNULL_PTR a, const struct LDKSha256 *NONNULL_PTR b);

/**
 * Frees any resources used by the Description, if is_owned is set and inner is non-NULL.
 */
void Description_free(struct LDKDescription this_obj);

/**
 * Creates a copy of the Description
 */
struct LDKDescription Description_clone(const struct LDKDescription *NONNULL_PTR orig);

/**
 * Checks if two Descriptions contain equal inner contents.
 */
uint64_t Description_hash(const struct LDKDescription *NONNULL_PTR o);

/**
 * Checks if two Descriptions contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Description_eq(const struct LDKDescription *NONNULL_PTR a, const struct LDKDescription *NONNULL_PTR b);

/**
 * Frees any resources used by the PayeePubKey, if is_owned is set and inner is non-NULL.
 */
void PayeePubKey_free(struct LDKPayeePubKey this_obj);

struct LDKPublicKey PayeePubKey_get_a(const struct LDKPayeePubKey *NONNULL_PTR this_ptr);

void PayeePubKey_set_a(struct LDKPayeePubKey *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new PayeePubKey given each field
 */
MUST_USE_RES struct LDKPayeePubKey PayeePubKey_new(struct LDKPublicKey a_arg);

/**
 * Creates a copy of the PayeePubKey
 */
struct LDKPayeePubKey PayeePubKey_clone(const struct LDKPayeePubKey *NONNULL_PTR orig);

/**
 * Checks if two PayeePubKeys contain equal inner contents.
 */
uint64_t PayeePubKey_hash(const struct LDKPayeePubKey *NONNULL_PTR o);

/**
 * Checks if two PayeePubKeys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PayeePubKey_eq(const struct LDKPayeePubKey *NONNULL_PTR a, const struct LDKPayeePubKey *NONNULL_PTR b);

/**
 * Frees any resources used by the ExpiryTime, if is_owned is set and inner is non-NULL.
 */
void ExpiryTime_free(struct LDKExpiryTime this_obj);

/**
 * Creates a copy of the ExpiryTime
 */
struct LDKExpiryTime ExpiryTime_clone(const struct LDKExpiryTime *NONNULL_PTR orig);

/**
 * Checks if two ExpiryTimes contain equal inner contents.
 */
uint64_t ExpiryTime_hash(const struct LDKExpiryTime *NONNULL_PTR o);

/**
 * Checks if two ExpiryTimes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ExpiryTime_eq(const struct LDKExpiryTime *NONNULL_PTR a, const struct LDKExpiryTime *NONNULL_PTR b);

/**
 * Frees any resources used by the MinFinalCltvExpiry, if is_owned is set and inner is non-NULL.
 */
void MinFinalCltvExpiry_free(struct LDKMinFinalCltvExpiry this_obj);

uint64_t MinFinalCltvExpiry_get_a(const struct LDKMinFinalCltvExpiry *NONNULL_PTR this_ptr);

void MinFinalCltvExpiry_set_a(struct LDKMinFinalCltvExpiry *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new MinFinalCltvExpiry given each field
 */
MUST_USE_RES struct LDKMinFinalCltvExpiry MinFinalCltvExpiry_new(uint64_t a_arg);

/**
 * Creates a copy of the MinFinalCltvExpiry
 */
struct LDKMinFinalCltvExpiry MinFinalCltvExpiry_clone(const struct LDKMinFinalCltvExpiry *NONNULL_PTR orig);

/**
 * Checks if two MinFinalCltvExpirys contain equal inner contents.
 */
uint64_t MinFinalCltvExpiry_hash(const struct LDKMinFinalCltvExpiry *NONNULL_PTR o);

/**
 * Checks if two MinFinalCltvExpirys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool MinFinalCltvExpiry_eq(const struct LDKMinFinalCltvExpiry *NONNULL_PTR a, const struct LDKMinFinalCltvExpiry *NONNULL_PTR b);

/**
 * Frees any resources used by the Fallback
 */
void Fallback_free(struct LDKFallback this_ptr);

/**
 * Creates a copy of the Fallback
 */
struct LDKFallback Fallback_clone(const struct LDKFallback *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SegWitProgram-variant Fallback
 */
struct LDKFallback Fallback_seg_wit_program(struct LDKu5 version, struct LDKCVec_u8Z program);

/**
 * Utility method to constructs a new PubKeyHash-variant Fallback
 */
struct LDKFallback Fallback_pub_key_hash(struct LDKTwentyBytes a);

/**
 * Utility method to constructs a new ScriptHash-variant Fallback
 */
struct LDKFallback Fallback_script_hash(struct LDKTwentyBytes a);

/**
 * Checks if two Fallbacks contain equal inner contents.
 */
uint64_t Fallback_hash(const struct LDKFallback *NONNULL_PTR o);

/**
 * Checks if two Fallbacks contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Fallback_eq(const struct LDKFallback *NONNULL_PTR a, const struct LDKFallback *NONNULL_PTR b);

/**
 * Frees any resources used by the InvoiceSignature, if is_owned is set and inner is non-NULL.
 */
void InvoiceSignature_free(struct LDKInvoiceSignature this_obj);

/**
 * Creates a copy of the InvoiceSignature
 */
struct LDKInvoiceSignature InvoiceSignature_clone(const struct LDKInvoiceSignature *NONNULL_PTR orig);

/**
 * Checks if two InvoiceSignatures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InvoiceSignature_eq(const struct LDKInvoiceSignature *NONNULL_PTR a, const struct LDKInvoiceSignature *NONNULL_PTR b);

/**
 * Frees any resources used by the PrivateRoute, if is_owned is set and inner is non-NULL.
 */
void PrivateRoute_free(struct LDKPrivateRoute this_obj);

/**
 * Creates a copy of the PrivateRoute
 */
struct LDKPrivateRoute PrivateRoute_clone(const struct LDKPrivateRoute *NONNULL_PTR orig);

/**
 * Checks if two PrivateRoutes contain equal inner contents.
 */
uint64_t PrivateRoute_hash(const struct LDKPrivateRoute *NONNULL_PTR o);

/**
 * Checks if two PrivateRoutes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PrivateRoute_eq(const struct LDKPrivateRoute *NONNULL_PTR a, const struct LDKPrivateRoute *NONNULL_PTR b);

/**
 * Disassembles the `SignedRawInvoice` into its three parts:
 *  1. raw invoice
 *  2. hash of the raw invoice
 *  3. signature
 */
MUST_USE_RES struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ SignedRawInvoice_into_parts(struct LDKSignedRawInvoice this_arg);

/**
 * The `RawInvoice` which was signed.
 */
MUST_USE_RES struct LDKRawInvoice SignedRawInvoice_raw_invoice(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * The hash of the `RawInvoice` that was signed.
 */
MUST_USE_RES const uint8_t (*SignedRawInvoice_hash(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg))[32];

/**
 * InvoiceSignature for the invoice.
 */
MUST_USE_RES struct LDKInvoiceSignature SignedRawInvoice_signature(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Recovers the public key used for signing the invoice from the recoverable signature.
 */
MUST_USE_RES struct LDKCResult_PayeePubKeyErrorZ SignedRawInvoice_recover_payee_pub_key(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Checks if the signature is valid for the included payee public key or if none exists if it's
 * valid for the recovered signature (which should always be true?).
 */
MUST_USE_RES bool SignedRawInvoice_check_signature(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);

/**
 * Calculate the hash of the encoded `RawInvoice`
 */
MUST_USE_RES struct LDKThirtyTwoBytes RawInvoice_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKSha256 RawInvoice_payment_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKDescription RawInvoice_description(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPayeePubKey RawInvoice_payee_pub_key(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKSha256 RawInvoice_description_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKExpiryTime RawInvoice_expiry_time(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKMinFinalCltvExpiry RawInvoice_min_final_cltv_expiry(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKThirtyTwoBytes RawInvoice_payment_secret(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKInvoiceFeatures RawInvoice_features(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCVec_PrivateRouteZ RawInvoice_private_routes(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCOption_u64Z RawInvoice_amount_pico_btc(const struct LDKRawInvoice *NONNULL_PTR this_arg);

MUST_USE_RES enum LDKCurrency RawInvoice_currency(const struct LDKRawInvoice *NONNULL_PTR this_arg);

/**
 * Creates a `PositiveTimestamp` from a Unix timestamp in the range `0..=MAX_TIMESTAMP`.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_unix_timestamp(uint64_t unix_seconds);

/**
 * Creates a `PositiveTimestamp` from a [`SystemTime`] with a corresponding Unix timestamp in
 * the range `0..=MAX_TIMESTAMP`.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_system_time(uint64_t time);

/**
 * Creates a `PositiveTimestamp` from a [`Duration`] since the Unix epoch in the range
 * `0..=MAX_TIMESTAMP`.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_duration_since_epoch(uint64_t duration);

/**
 * Returns the Unix timestamp representing the stored time
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_unix_timestamp(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Returns the duration of the stored time since the Unix epoch
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_duration_since_epoch(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Returns the [`SystemTime`] representing the stored time
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_time(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Transform the `Invoice` into it's unchecked version
 */
MUST_USE_RES struct LDKSignedRawInvoice Invoice_into_signed_raw(struct LDKInvoice this_arg);

/**
 * Check that the invoice is signed correctly and that key recovery works
 */
MUST_USE_RES struct LDKCResult_NoneSemanticErrorZ Invoice_check_signature(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Constructs an `Invoice` from a `SignedRawInvoice` by checking all its invariants.
 * ```
 * use lightning_invoice::*;
 *
 * let invoice = \"lnbc100p1psj9jhxdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4q0d3p2sfluzdx45tqcs\\
 * h2pu5qc7lgq0xs578ngs6s0s68ua4h7cvspp5q6rmq35js88zp5dvwrv9m459tnk2zunwj5jalqtyxqulh0l\\
 * 5gflssp5nf55ny5gcrfl30xuhzj3nphgj27rstekmr9fw3ny5989s300gyus9qyysgqcqpcrzjqw2sxwe993\\
 * h5pcm4dxzpvttgza8zhkqxpgffcrf5v25nwpr3cmfg7z54kuqq8rgqqqqqqqq2qqqqq9qq9qrzjqd0ylaqcl\\
 * j9424x9m8h2vcukcgnm6s56xfgu3j78zyqzhgs4hlpzvznlugqq9vsqqqqqqqlgqqqqqeqq9qrzjqwldmj9d\\
 * ha74df76zhx6l9we0vjdquygcdt3kssupehe64g6yyp5yz5rhuqqwccqqyqqqqlgqqqqjcqq9qrzjqf9e58a\\
 * guqr0rcun0ajlvmzq3ek63cw2w282gv3z5uupmuwvgjtq2z55qsqqg6qqqyqqqrtnqqqzq3cqygrzjqvphms\\
 * ywntrrhqjcraumvc4y6r8v4z5v593trte429v4hredj7ms5z52usqq9ngqqqqqqqlgqqqqqqgq9qrzjq2v0v\\
 * p62g49p7569ev48cmulecsxe59lvaw3wlxm7r982zxa9zzj7z5l0cqqxusqqyqqqqlgqqqqqzsqygarl9fh3\\
 * 8s0gyuxjjgux34w75dnc6xp2l35j7es3jd4ugt3lu0xzre26yg5m7ke54n2d5sym4xcmxtl8238xxvw5h5h5\\
 * j5r6drg6k6zcqj0fcwg\";
 *
 * let signed = invoice.parse::<SignedRawInvoice>().unwrap();
 *
 * assert!(Invoice::from_signed(signed).is_ok());
 * ```
 */
MUST_USE_RES struct LDKCResult_InvoiceSemanticErrorZ Invoice_from_signed(struct LDKSignedRawInvoice signed_invoice);

/**
 * Returns the `Invoice`'s timestamp (should equal its creation time)
 */
MUST_USE_RES uint64_t Invoice_timestamp(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the `Invoice`'s timestamp as a duration since the Unix epoch
 */
MUST_USE_RES uint64_t Invoice_duration_since_epoch(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the hash to which we will receive the preimage on completion of the payment
 */
MUST_USE_RES const uint8_t (*Invoice_payment_hash(const struct LDKInvoice *NONNULL_PTR this_arg))[32];

/**
 * Get the payee's public key if one was included in the invoice
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPublicKey Invoice_payee_pub_key(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Get the payment secret if one was included in the invoice
 */
MUST_USE_RES const uint8_t (*Invoice_payment_secret(const struct LDKInvoice *NONNULL_PTR this_arg))[32];

/**
 * Get the invoice features if they were included in the invoice
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKInvoiceFeatures Invoice_features(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Recover the payee's public key (only to be used if none was included in the invoice)
 */
MUST_USE_RES struct LDKPublicKey Invoice_recover_payee_pub_key(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the invoice's expiry time, if present, otherwise [`DEFAULT_EXPIRY_TIME`].
 */
MUST_USE_RES uint64_t Invoice_expiry_time(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns whether the invoice has expired.
 */
MUST_USE_RES bool Invoice_is_expired(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns whether the expiry time would pass at the given point in time.
 * `at_time` is the timestamp as a duration since the Unix epoch.
 */
MUST_USE_RES bool Invoice_would_expire(const struct LDKInvoice *NONNULL_PTR this_arg, uint64_t at_time);

/**
 * Returns the invoice's `min_final_cltv_expiry` time, if present, otherwise
 * [`DEFAULT_MIN_FINAL_CLTV_EXPIRY`].
 */
MUST_USE_RES uint64_t Invoice_min_final_cltv_expiry(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all routes included in the invoice
 */
MUST_USE_RES struct LDKCVec_PrivateRouteZ Invoice_private_routes(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all routes included in the invoice as the underlying hints
 */
MUST_USE_RES struct LDKCVec_RouteHintZ Invoice_route_hints(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the currency for which the invoice was issued
 */
MUST_USE_RES enum LDKCurrency Invoice_currency(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Returns the amount if specified in the invoice as millisatoshis.
 */
MUST_USE_RES struct LDKCOption_u64Z Invoice_amount_milli_satoshis(const struct LDKInvoice *NONNULL_PTR this_arg);

/**
 * Creates a new `Description` if `description` is at most 1023 __bytes__ long,
 * returns `CreationError::DescriptionTooLong` otherwise
 *
 * Please note that single characters may use more than one byte due to UTF8 encoding.
 */
MUST_USE_RES struct LDKCResult_DescriptionCreationErrorZ Description_new(struct LDKStr description);

/**
 * Returns the underlying description `String`
 */
MUST_USE_RES struct LDKStr Description_into_inner(struct LDKDescription this_arg);

/**
 * Construct an `ExpiryTime` from seconds.
 */
MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_seconds(uint64_t seconds);

/**
 * Construct an `ExpiryTime` from a `Duration`.
 */
MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_duration(uint64_t duration);

/**
 * Returns the expiry time in seconds
 */
MUST_USE_RES uint64_t ExpiryTime_as_seconds(const struct LDKExpiryTime *NONNULL_PTR this_arg);

/**
 * Returns a reference to the underlying `Duration` (=expiry time)
 */
MUST_USE_RES uint64_t ExpiryTime_as_duration(const struct LDKExpiryTime *NONNULL_PTR this_arg);

/**
 * Creates a new (partial) route from a list of hops
 */
MUST_USE_RES struct LDKCResult_PrivateRouteCreationErrorZ PrivateRoute_new(struct LDKRouteHint hops);

/**
 * Returns the underlying list of hops
 */
MUST_USE_RES struct LDKRouteHint PrivateRoute_into_inner(struct LDKPrivateRoute this_arg);

/**
 * Creates a copy of the CreationError
 */
enum LDKCreationError CreationError_clone(const enum LDKCreationError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new DescriptionTooLong-variant CreationError
 */
enum LDKCreationError CreationError_description_too_long(void);

/**
 * Utility method to constructs a new RouteTooLong-variant CreationError
 */
enum LDKCreationError CreationError_route_too_long(void);

/**
 * Utility method to constructs a new TimestampOutOfBounds-variant CreationError
 */
enum LDKCreationError CreationError_timestamp_out_of_bounds(void);

/**
 * Utility method to constructs a new InvalidAmount-variant CreationError
 */
enum LDKCreationError CreationError_invalid_amount(void);

/**
 * Utility method to constructs a new MissingRouteHints-variant CreationError
 */
enum LDKCreationError CreationError_missing_route_hints(void);

/**
 * Checks if two CreationErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool CreationError_eq(const enum LDKCreationError *NONNULL_PTR a, const enum LDKCreationError *NONNULL_PTR b);

/**
 * Get the string representation of a CreationError object
 */
struct LDKStr CreationError_to_str(const enum LDKCreationError *NONNULL_PTR o);

/**
 * Creates a copy of the SemanticError
 */
enum LDKSemanticError SemanticError_clone(const enum LDKSemanticError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new NoPaymentHash-variant SemanticError
 */
enum LDKSemanticError SemanticError_no_payment_hash(void);

/**
 * Utility method to constructs a new MultiplePaymentHashes-variant SemanticError
 */
enum LDKSemanticError SemanticError_multiple_payment_hashes(void);

/**
 * Utility method to constructs a new NoDescription-variant SemanticError
 */
enum LDKSemanticError SemanticError_no_description(void);

/**
 * Utility method to constructs a new MultipleDescriptions-variant SemanticError
 */
enum LDKSemanticError SemanticError_multiple_descriptions(void);

/**
 * Utility method to constructs a new NoPaymentSecret-variant SemanticError
 */
enum LDKSemanticError SemanticError_no_payment_secret(void);

/**
 * Utility method to constructs a new MultiplePaymentSecrets-variant SemanticError
 */
enum LDKSemanticError SemanticError_multiple_payment_secrets(void);

/**
 * Utility method to constructs a new InvalidFeatures-variant SemanticError
 */
enum LDKSemanticError SemanticError_invalid_features(void);

/**
 * Utility method to constructs a new InvalidRecoveryId-variant SemanticError
 */
enum LDKSemanticError SemanticError_invalid_recovery_id(void);

/**
 * Utility method to constructs a new InvalidSignature-variant SemanticError
 */
enum LDKSemanticError SemanticError_invalid_signature(void);

/**
 * Utility method to constructs a new ImpreciseAmount-variant SemanticError
 */
enum LDKSemanticError SemanticError_imprecise_amount(void);

/**
 * Checks if two SemanticErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SemanticError_eq(const enum LDKSemanticError *NONNULL_PTR a, const enum LDKSemanticError *NONNULL_PTR b);

/**
 * Get the string representation of a SemanticError object
 */
struct LDKStr SemanticError_to_str(const enum LDKSemanticError *NONNULL_PTR o);

/**
 * Frees any resources used by the SignOrCreationError
 */
void SignOrCreationError_free(struct LDKSignOrCreationError this_ptr);

/**
 * Creates a copy of the SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_clone(const struct LDKSignOrCreationError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SignError-variant SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_sign_error(void);

/**
 * Utility method to constructs a new CreationError-variant SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_creation_error(enum LDKCreationError a);

/**
 * Checks if two SignOrCreationErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SignOrCreationError_eq(const struct LDKSignOrCreationError *NONNULL_PTR a, const struct LDKSignOrCreationError *NONNULL_PTR b);

/**
 * Get the string representation of a SignOrCreationError object
 */
struct LDKStr SignOrCreationError_to_str(const struct LDKSignOrCreationError *NONNULL_PTR o);

/**
 * Frees any resources used by the InvoicePayer, if is_owned is set and inner is non-NULL.
 */
void InvoicePayer_free(struct LDKInvoicePayer this_obj);

/**
 * Calls the free function if one is set
 */
void Payer_free(struct LDKPayer this_ptr);

/**
 * Calls the free function if one is set
 */
void Router_free(struct LDKRouter this_ptr);

/**
 * Frees any resources used by the RetryAttempts, if is_owned is set and inner is non-NULL.
 */
void RetryAttempts_free(struct LDKRetryAttempts this_obj);

uintptr_t RetryAttempts_get_a(const struct LDKRetryAttempts *NONNULL_PTR this_ptr);

void RetryAttempts_set_a(struct LDKRetryAttempts *NONNULL_PTR this_ptr, uintptr_t val);

/**
 * Constructs a new RetryAttempts given each field
 */
MUST_USE_RES struct LDKRetryAttempts RetryAttempts_new(uintptr_t a_arg);

/**
 * Creates a copy of the RetryAttempts
 */
struct LDKRetryAttempts RetryAttempts_clone(const struct LDKRetryAttempts *NONNULL_PTR orig);

/**
 * Checks if two RetryAttemptss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RetryAttempts_eq(const struct LDKRetryAttempts *NONNULL_PTR a, const struct LDKRetryAttempts *NONNULL_PTR b);

/**
 * Checks if two RetryAttemptss contain equal inner contents.
 */
uint64_t RetryAttempts_hash(const struct LDKRetryAttempts *NONNULL_PTR o);

/**
 * Frees any resources used by the PaymentError
 */
void PaymentError_free(struct LDKPaymentError this_ptr);

/**
 * Creates a copy of the PaymentError
 */
struct LDKPaymentError PaymentError_clone(const struct LDKPaymentError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Invoice-variant PaymentError
 */
struct LDKPaymentError PaymentError_invoice(struct LDKStr a);

/**
 * Utility method to constructs a new Routing-variant PaymentError
 */
struct LDKPaymentError PaymentError_routing(struct LDKLightningError a);

/**
 * Utility method to constructs a new Sending-variant PaymentError
 */
struct LDKPaymentError PaymentError_sending(struct LDKPaymentSendFailure a);

/**
 * Creates an invoice payer that retries failed payment paths.
 *
 * Will forward any [`Event::PaymentPathFailed`] events to the decorated `event_handler` once
 * `retry_attempts` has been exceeded for a given [`Invoice`].
 */
MUST_USE_RES struct LDKInvoicePayer InvoicePayer_new(struct LDKPayer payer, struct LDKRouter router, const struct LDKMultiThreadedLockableScore *NONNULL_PTR scorer, struct LDKLogger logger, struct LDKEventHandler event_handler, struct LDKRetryAttempts retry_attempts);

/**
 * Pays the given [`Invoice`], caching it for later use in case a retry is needed.
 *
 * You should ensure that the `invoice.payment_hash()` is unique and the same payment_hash has
 * never been paid before. Because [`InvoicePayer`] is stateless no effort is made to do so
 * for you.
 */
MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_invoice(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const struct LDKInvoice *NONNULL_PTR invoice);

/**
 * Pays the given zero-value [`Invoice`] using the given amount, caching it for later use in
 * case a retry is needed.
 *
 * You should ensure that the `invoice.payment_hash()` is unique and the same payment_hash has
 * never been paid before. Because [`InvoicePayer`] is stateless no effort is made to do so
 * for you.
 */
MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_zero_value_invoice(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const struct LDKInvoice *NONNULL_PTR invoice, uint64_t amount_msats);

/**
 * Pays `pubkey` an amount using the hash of the given preimage, caching it for later use in
 * case a retry is needed.
 *
 * You should ensure that `payment_preimage` is unique and that its `payment_hash` has never
 * been paid before. Because [`InvoicePayer`] is stateless no effort is made to do so for you.
 */
MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_pubkey(const struct LDKInvoicePayer *NONNULL_PTR this_arg, struct LDKPublicKey pubkey, struct LDKThirtyTwoBytes payment_preimage, uint64_t amount_msats, uint32_t final_cltv_expiry_delta);

/**
 * Removes the payment cached by the given payment hash.
 *
 * Should be called once a payment has failed or succeeded if not using [`InvoicePayer`] as an
 * [`EventHandler`]. Otherwise, calling this method is unnecessary.
 */
void InvoicePayer_remove_cached_payment(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);

/**
 * Constructs a new EventHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventHandler must be freed before this_arg is
 */
struct LDKEventHandler InvoicePayer_as_EventHandler(const struct LDKInvoicePayer *NONNULL_PTR this_arg);

/**
 * Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
 * See [`PhantomKeysManager`] for more information on phantom node payments.
 *
 * `phantom_route_hints` parameter:
 * * Contains channel info for all nodes participating in the phantom invoice
 * * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
 *   participating node
 * * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
 *   updated when a channel becomes disabled or closes
 * * Note that if too many channels are included in [`PhantomRouteHints::channels`], the invoice
 *   may be too long for QR code scanning. To fix this, `PhantomRouteHints::channels` may be pared
 *   down
 *
 * `payment_hash` and `payment_secret` come from [`ChannelManager::create_inbound_payment`] or
 * [`ChannelManager::create_inbound_payment_for_hash`]. These values can be retrieved from any
 * participating node.
 *
 * Note that the provided `keys_manager`'s `KeysInterface` implementation must support phantom
 * invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
 * requirement).
 *
 * [`PhantomKeysManager`]: lightning::chain::keysinterface::PhantomKeysManager
 * [`ChannelManager::get_phantom_route_hints`]: lightning::ln::channelmanager::ChannelManager::get_phantom_route_hints
 * [`PhantomRouteHints::channels`]: lightning::ln::channelmanager::PhantomRouteHints::channels
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_phantom_invoice(struct LDKCOption_u64Z amt_msat, struct LDKStr description, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret, struct LDKCVec_PhantomRouteHintsZ phantom_route_hints, struct LDKKeysInterface keys_manager, enum LDKCurrency network);

/**
 * Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
 * See [`PhantomKeysManager`] for more information on phantom node payments.
 *
 * `phantom_route_hints` parameter:
 * * Contains channel info for all nodes participating in the phantom invoice
 * * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
 *   participating node
 * * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
 *   updated when a channel becomes disabled or closes
 * * Note that if too many channels are included in [`PhantomRouteHints::channels`], the invoice
 *   may be too long for QR code scanning. To fix this, `PhantomRouteHints::channels` may be pared
 *   down
 *
 * `description_hash` is a SHA-256 hash of the description text
 *
 * `payment_hash` and `payment_secret` come from [`ChannelManager::create_inbound_payment`] or
 * [`ChannelManager::create_inbound_payment_for_hash`]. These values can be retrieved from any
 * participating node.
 *
 * Note that the provided `keys_manager`'s `KeysInterface` implementation must support phantom
 * invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
 * requirement).
 *
 * [`PhantomKeysManager`]: lightning::chain::keysinterface::PhantomKeysManager
 * [`ChannelManager::get_phantom_route_hints`]: lightning::ln::channelmanager::ChannelManager::get_phantom_route_hints
 * [`PhantomRouteHints::channels`]: lightning::ln::channelmanager::PhantomRouteHints::channels
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_phantom_invoice_with_description_hash(struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret, struct LDKCVec_PhantomRouteHintsZ phantom_route_hints, struct LDKKeysInterface keys_manager, enum LDKCurrency network);

/**
 * Utility to construct an invoice. Generally, unless you want to do something like a custom
 * cltv_expiry, this is what you should be using to create an invoice. The reason being, this
 * method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
 * doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
 * that the payment secret is valid when the invoice is paid.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description);

/**
 * Utility to construct an invoice. Generally, unless you want to do something like a custom
 * cltv_expiry, this is what you should be using to create an invoice. The reason being, this
 * method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
 * doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
 * that the payment secret is valid when the invoice is paid.
 * Use this variant if you want to pass the `description_hash` to the invoice.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_with_description_hash(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash);

/**
 * See [`create_invoice_from_channelmanager_with_description_hash`]
 * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
 * available and the current time is supplied by the caller.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash, uint64_t duration_since_epoch);

/**
 * See [`create_invoice_from_channelmanager`]
 * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
 * available and the current time is supplied by the caller.
 */
struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint64_t duration_since_epoch);

/**
 * Frees any resources used by the DefaultRouter, if is_owned is set and inner is non-NULL.
 */
void DefaultRouter_free(struct LDKDefaultRouter this_obj);

/**
 * Creates a new router using the given [`NetworkGraph`], a [`Logger`], and a randomness source
 * `random_seed_bytes`.
 */
MUST_USE_RES struct LDKDefaultRouter DefaultRouter_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger, struct LDKThirtyTwoBytes random_seed_bytes);

/**
 * Constructs a new Router which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Router must be freed before this_arg is
 */
struct LDKRouter DefaultRouter_as_Router(const struct LDKDefaultRouter *NONNULL_PTR this_arg);

/**
 * Constructs a new Payer which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Payer must be freed before this_arg is
 */
struct LDKPayer ChannelManager_as_Payer(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Read a SiPrefix object from a string
 */
struct LDKCResult_SiPrefixParseErrorZ SiPrefix_from_str(struct LDKStr s);

/**
 * Read a Invoice object from a string
 */
struct LDKCResult_InvoiceParseOrSemanticErrorZ Invoice_from_str(struct LDKStr s);

/**
 * Read a SignedRawInvoice object from a string
 */
struct LDKCResult_SignedRawInvoiceParseErrorZ SignedRawInvoice_from_str(struct LDKStr s);

/**
 * Get the string representation of a ParseError object
 */
struct LDKStr ParseError_to_str(const struct LDKParseError *NONNULL_PTR o);

/**
 * Get the string representation of a ParseOrSemanticError object
 */
struct LDKStr ParseOrSemanticError_to_str(const struct LDKParseOrSemanticError *NONNULL_PTR o);

/**
 * Get the string representation of a Invoice object
 */
struct LDKStr Invoice_to_str(const struct LDKInvoice *NONNULL_PTR o);

/**
 * Get the string representation of a SignedRawInvoice object
 */
struct LDKStr SignedRawInvoice_to_str(const struct LDKSignedRawInvoice *NONNULL_PTR o);

/**
 * Get the string representation of a Currency object
 */
struct LDKStr Currency_to_str(const enum LDKCurrency *NONNULL_PTR o);

/**
 * Get the string representation of a SiPrefix object
 */
struct LDKStr SiPrefix_to_str(const enum LDKSiPrefix *NONNULL_PTR o);

#endif /* LDK_C_BINDINGS_H */

#include "ldk_ver.h"
